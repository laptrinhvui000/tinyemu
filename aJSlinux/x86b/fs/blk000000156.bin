ments< foldmethod< foldexpr< foldtext<'
" }}}1

if exists('g:did_changelog_ftplugin')
  finish
endif

" Don't load another plugin (this is global)
let g:did_changelog_ftplugin = 1

" {{{1 GUI menu

" Helper functions returning various data.
" Returns full name, either from $DEBFULLNAME or debianfullname.
" TODO Is there a way to determine name from anywhere else?
function <SID>FullName()
    if exists('$DEBFULLNAME')
	return $DEBFULLNAME
    elseif exists('g:debianfullname')
	return g:debianfullname
    else
	return 'Your Name'
    endif
endfunction

" Returns email address, from $DEBEMAIL, $EMAIL or debianemail.
function <SID>Email()
    if exists('$DEBEMAIL')
	return $DEBEMAIL
    elseif exists('$EMAIL')
	return $EMAIL
    elseif exists('g:debianemail')
	return g:debianemail
    else
	return 'your@email.address'
    endif
endfunction

" Returns date in RFC822 format.
function <SID>Date()
    let savelang = v:lc_time
    execute 'language time C'
    let dateandtime = strftime('%a, %d %b %Y %X %z')
    execute 'language time ' . savelang
    return dateandtime
endfunction

function <SID>WarnIfNotUnfinalised()
    if match(getline('.'), ' -- [[:alpha:]][[:alnum:].]')!=-1
	echohl WarningMsg
	echo 'The entry has not been unfinalised before editing.'
	echohl None
	return 1
    endif
    return 0
endfunction

function <SID>Finalised()
    let savelinenum = line('.')
    1
    call search('^ -- ')
    if match(getline('.'), ' -- [[:alpha:]][[:alnum:].]')!=-1
	let returnvalue = 1
    else
	let returnvalue = 0
    endif
    execute savelinenum
    return returnvalue
endfunction

" These functions implement the menus
function NewVersion()
    " The new entry is unfinalised and shall be changed
    amenu disable Changelog.New\ Version
    amenu enable Changelog.Add\ Entry
    amenu enable Changelog.Close\ Bug
    amenu enable Changelog.Set\ Distribution
    amenu enable Changelog.Set\ Urgency
    amenu disable Changelog.Unfinalise
    amenu enable Changelog.Finalise
    call append(0, substitute(getline(1), '-\([[:digit:]]\+\))', '-$$\1)', ''))
    call append(1, '')
    call append(2, '')
    call append(3, ' -- ')
    call append(4, '')
    call Urgency('low')
    normal! 1G0
    call search(')')
    normal! h
    normal! 
    call setline(1, substitute(getline(1), '-\$\$', '-', ''))
    if exists('g:debchangelog_fold_enable')
        foldopen
    endif
    call AddEntry()
endfunction

function AddEntry()
    1
    call search('^ -- ')
    .-2
    call append('.', '  * ')
    .+3
    let warn=<SID>WarnIfNotUnfinalised()
    .-2
    if warn
	echohl MoreMsg
	call input('Hit ENTER')
	echohl None
    endif
    startinsert!
endfunction

function CloseBug()
    1
    call search('^ -- ')
    let warn=<SID>WarnIfNotUnfinalised()
    .-2
    call append('.', '  *  (closes: #' . input('Bug number to close: ') . ')')
    normal! j^ll
    startinsert
endfunction

function Distribution(dist)
    call setline(1, substitute(getline(1), ')  *\%(UNRELEASED\|\l\+\);', ') ' . a:dist . ';', ''))
endfunction

function Urgency(urg)
    call setline(1, substitute(getline(1), 'urgency=.*$', 'urgency=' . a:urg, ''))
endfunction

function <SID>UnfinaliseMenu()
    " This means the entry shall be changed
    amenu disable Changelog.New\ Version
    amenu enable Changelog.Add\ Entry
    amenu enable Changelog.Close\ Bug
    amenu enable Changelog.Set\ Distribution
    amenu enable Changelog.Set\ Urgency
    amenu disable Changelog.Unfinalise
    amenu enable Changelog.Finalise
endfunction

function Unfinalise()
    call <SID>UnfinaliseMenu()
    1
    call search('^ -- ')
    call setline('.', ' -- ')
endfunction

function <SID>FinaliseMenu()
    " This means the entry should not be changed anymore
    amenu enable Changelog.New\ Version
    amenu disable Changelog.Add\ Entry
    amenu disable Changelog.Close\ Bug
    amenu disable Changelog.Set\ Distribution
    amenu disable Changelog.Set\ Urgency
    amenu enable Changelog.Unfinalise
    amenu disable Changelog.Finalise
endfunction

function Finalise()
    call <SID>FinaliseMenu()
    1
    call search('^ -- ')
    call setline('.', ' -- ' . <SID>FullName() . ' <' . <SID>Email() . '>  ' . <SID>Date())
endfunction


function <SID>MakeMenu()
    amenu &Changelog.&New\ Version			:call NewVersion()<CR>
    amenu Changelog.&Add\ Entry				:call AddEntry()<CR>
    amenu Changelog.&Close\ Bug				:call CloseBug()<CR>
    menu Changelog.-sep-				<nul>

    amenu Changelog.Set\ &Distribution.&unstable	:call Distribution("unstable")<CR>
    amenu Changelog.Set\ Distribution.&frozen		:call Distribution("frozen")<CR>
    amenu Changelog.Set\ Distribution.&stable		:call Distribution("stable")<CR>
    menu Changelog.Set\ Distribution.-sep-		<nul>
    amenu Changelog.Set\ Distribution.frozen\ unstable	:call Distribution("frozen unstable")<CR>
    amenu Changelog.Set\ Distribution.stable\ unstable	:call Distribution("stable unstable")<CR>
    amenu Changelog.Set\ Distribution.stable\ frozen	:call Distribution("stable frozen")<CR>
    amenu Changelog.Set\ Distribution.stable\ frozen\ unstable	:call Distribution("stable frozen unstable")<CR>

    amenu Changelog.Set\ &Urgency.&low			:call Urgency("low")<CR>
    amenu Changelog.Set\ Urgency.&medium		:call Urgency("medium")<CR>
    amenu Changelog.Set\ Urgency.&high			:call Urgency("high")<CR>

    menu Changelog.-sep-				<nul>
    amenu Changelog.U&nfinalise				:call Unfinalise()<CR>
    amenu Changelog.&Finalise				:call Finalise()<CR>

    if <SID>Finalised()
	call <SID>FinaliseMenu()
    else
	call <SID>UnfinaliseMenu()
    endif
endfunction

augroup changelogMenu
au BufEnter * if &filetype == "debchangelog" | call <SID>MakeMenu() | endif
au BufLeave * if &filetype == "debchangelog" | silent! aunmenu Changelog | endif
augroup END

" }}}
" {{{1 folding

" look for an author name in the [zonestart zoneend] lines searching backward
function! s:getAuthor(zonestart, zoneend)
  let linepos = a:zoneend
  while linepos >= a:zonestart
    let line = getline(linepos)
    if line =~# '^ --'
      return substitute(line, '^ --\s*\([^<]\+\)\s*.*', '\1', '')
    endif
    let linepos -= 1
  endwhile
  return '[unknown]'
endfunction

" Look for a package source name searching backward from the givenline and
" returns it. Return the empty string if the package name can't be found
function! DebGetPkgSrcName(lineno)
  let lineidx = a:lineno
  let pkgname = ''
  while lineidx > 0
    let curline = getline(lineidx)
    if curline =~# '^\S'
      let pkgname = matchlist(curline, '^\(\S\+\).*$')[1]
      break
    endif
    let lineidx = lineidx - 1
  endwhile
  return pkgname
endfunction

function! DebChangelogFoldText()
  if v:folddashes ==# '-'  " changelog entry fold
    return foldtext() . ' -- ' . s:getAuthor(v:foldstart, v:foldend) . ' '
  endif
  return foldtext()
endfunction

function! DebGetChangelogFold(lnum)
  let line = getline(a:lnum)
  if line =~# '^\w\+'
    return '>1' " beginning of a changelog entry
  endif
  if line =~# '^\s\+\[.*\]'
    return '>2' " beginning of an author-specific chunk
  endif
  if line =~# '^ --'
    return '1'
  endif
  return '='
endfunction

if exists('g:debchangelog_fold_enable')
  silent! foldopen!   " unfold the entry the cursor is on (usually the first one)
endif

" }}}

" {{{1 omnicompletion for Closes: #

if !exists('g:debchangelog_listbugs_severities')
  let g:debchangelog_listbugs_severities = 'critical,grave,serious,important,normal,minor,wishlist'
endif

fun! DebCompleteBugs(findstart, base)
  if a:findstart
    let line = getline('.')

    " try to detect whether this is closes: or lp:
    let g:debchangelog_complete_mode = 'debbugs'
    let try_colidx = col('.') - 1
    let colidx = -1 " default to no-completion-possible

    while try_colidx > 0 && line[try_colidx - 1] =~# '\s\|\d\|#\|,\|:'
      let try_colidx = try_colidx - 1
      if line[try_colidx] ==# '#' && colidx == -1
        " found hash, where we complete from:
        let colidx = try_colidx
      elseif line[try_colidx] ==# ':'
        if try_colidx > 1 && strpart(line, try_colidx - 2, 3) =~? '\clp:'
          let g:debchangelog_complete_mode = 'lp'
        endif
        break
      endif
    endwhile
    return colidx
  else " return matches:
    let bug_lines = []
    if g:debchangelog_complete_mode ==? 'lp'
      if ! has('python')
        echoerr 'vim must be built with Python support to use LP bug completion'
        return
      endif
      let pkgsrc = DebGetPkgSrcName(line('.'))
      python << EOF
import vim
try:
    from launchpadlib.launchpad import Launchpad
    from lazr.restfulclient.errors import HTTPError
    # login anonymously
    lp = Launchpad.login_anonymously('debchangelog.vim', 'production')
    ubuntu = lp.distributions['ubuntu']
    try:
        sp = ubuntu.getSourcePackage(name=vim.eval('pkgsrc'))
        status = ('New', 'Incomplete', 'Confirmed', 'Triaged',
                  'In Progress', 'Fix Committed')
        tasklist = sp.searchTasks(status=status, order_by='id')
        liststr = '['
        for task in tasklist:
            bug = task.bug
            liststr += "'#%d - %s'," % (bug.id, bug.title.replace('\'', '\'\''))
        liststr += ']'
        vim.command('silent let bug_lines = %s' % liststr.encode('utf-8'))
    except HTTPError:
        pass
except ImportError:
    vim.command('echoerr \'python-launchpadlib >= 1.5.4 needs to be installed to use Launchpad bug completion\'')
EOF
    else
      if ! filereadable('/usr/sbin/apt-listbugs')
        echoerr 'apt-listbugs not found, you should install it to use Closes bug completion'
        return
      endif
      let pkgsrc = DebGetPkgSrcName(line('.'))
      let listbugs_output = system('/usr/sbin/apt-listbugs -s ' . g:debchangelog_listbugs_severities . ' list ' . pkgsrc . ' | grep "^ #" 2> /dev/null')
      let bug_lines = split(listbugs_output, '\n')
    endif
    let completions = []
    for line in bug_lines
      let parts = matchlist(line, '^\s*\(#\S\+\)\s*-\s*\(.*\)$')
      " filter only those which match a:base:
      if parts[1] !~ '^' . a:base
        continue
      endif
      let completion = {}
      let completion['word'] = parts[1]
      let completion['menu'] = parts[2]
      let completion['info'] = parts[0]
      let completions += [completion]
    endfor
    return completions
  endif
endfun

setlocal omnifunc=DebCompleteBugs

" }}}

" vim: set foldmethod=marker:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           " Vim filetype plugin file (GUI menu and folding)
" Language:     Debian control files
" Maintainer:   Debian Vim Maintainers
" Former Maintainer:    Pierre Habouzit <madcoder@debian.org>
" Last Change:  2018-01-28
" URL:          https://salsa.debian.org/vim-team/vim-debian/blob/master/ftplugin/debcontrol.vim

" Do these settings once per buffer
if exists('b:did_ftplugin')
  finish
endif
let b:did_ftplugin=1

" {{{1 Local settings (do on every load)
if exists('g:debcontrol_fold_enable')
  setlocal foldmethod=expr
  setlocal foldexpr=DebControlFold(v:lnum)
  setlocal foldtext=DebControlFoldText()
endif
setlocal textwidth=0

" Clean unloading
let b:undo_ftplugin = 'setlocal tw< foldmethod< foldexpr< foldtext<'

" }}}1

" {{{1 folding

function! s:getField(f, lnum)
  let line = getline(a:lnum)
  let fwdsteps = 0
  while line !~ '^'.a:f.':'
    let fwdsteps += 1
    let line = getline(a:lnum + fwdsteps)
    if line ==# ''
      return 'unknown'
    endif
  endwhile
  return substitute(line, '^'.a:f.': *', '', '')
endfunction

function! DebControlFoldText()
  if v:folddashes ==# '-'  " debcontrol entry fold
    let type = substitute(getline(v:foldstart), ':.*', '', '')
    if type ==# 'Source'
      let ftext = substitute(foldtext(), ' *Source: *', ' ', '')
      return ftext . ' -- ' . s:getField('Maintainer', v:foldstart) . ' '
    endif
    let arch  = s:getField('Architecture', v:foldstart)
    let ftext = substitute(foldtext(), ' *Package: *', ' [' . arch . '] ', '')
    return ftext . ': ' . s:getField('Description', v:foldstart) . ' '
  endif
  return foldtext()
endfunction

function! DebControlFold(l)

  " This is for not merging blank lines around folds to them
  if getline(a:l) =~# '^Source:'
    return '>1'
  endif

  if getline(a:l) =~# '^Package:'
    return '>1'
  endif

  return '='
endfunction

" }}}1
                                                                                                                                                                                                           " Vim filetype plugin file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2007-12-04

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 " Vim filetype plugin file
" Language:             dict(1) configuration file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              " Vim filetype plugin file
" Language:             dictd(8) configuration file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             " Vim filetype plugin file
" Language:	Diff
" Maintainer:	Bram Moolenaar <Bram@vim.org>
" Last Change:	2021 Nov 14

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let b:undo_ftplugin = "setl modeline< commentstring<"

" Don't use modelines in a diff, they apply to the diffed file
setlocal nomodeline

" If there are comments they start with #
let &l:commentstring = "# %s"

if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
  let b:browsefilter = "Diff Files (*.diff)\t*.diff\nPatch Files (*.patch)\t*.h\nAll Files (*.*)\t*.*\n"
  let b:undo_ftplugin ..= " | unlet! b:browsefilter"
endif
                                                                                                                                                                                                                                                                                                                                                           " Vim filetype plugin file
" Language:             dircolors(1) input file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 " Vim filetype plugin file
" Language:	    DocBook
" Maintainer:	    Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2012-04-25

if exists('b:did_ftplugin')
  finish
endif

if !exists('b:docbk_type')
  if expand('%:e') == 'sgml'
    let b:docbk_type = 'sgml'
  else
    let b:docbk_type = 'xml'
  endif
endif

if b:docbk_type == 'sgml'
  runtime! ftplugin/sgml.vim ftplugin/sgml_*.vim ftplugin/sgml/*.vim
else
  runtime! ftplugin/xml.vim ftplugin/xml_*.vim ftplugin/xml/*.vim
endif

let b:undo_ftplugin = "unlet! b:docbk_type"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              " Vim filetype plugin
" Language:	Dockerfile
" Maintainer:   Honza Pokorny <http://honza.ca>
" Last Change:	2014 Aug 29

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

let b:undo_ftplugin = "setl commentstring<"

setlocal commentstring=#\ %s
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            " Vim filetype plugin file
" Language:    MS-DOS .bat files
" Maintainer:  Mike Williams <mrw@eandem.co.uk>
" Last Change: 7th May 2020

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

" BAT comment formatting
setlocal comments=b:rem,b:@rem,b:REM,b:@REM,:::
setlocal commentstring=::\ %s
setlocal formatoptions-=t formatoptions+=rol

" Lookup DOS keywords using Windows command help.
if executable('help.exe')
  if has('terminal')
    setlocal keywordprg=:term\ help.exe
  else
    setlocal keywordprg=help.exe
  endif
endif

" Define patterns for the browse file filter
if has("gui_win32") && !exists("b:browsefilter")
  let b:browsefilter = "DOS Batch Files (*.bat, *.cmd)\t*.bat;*.cmd\nAll Files (*.*)\t*.*\n"
endif

let b:undo_ftplugin = "setlocal comments< formatoptions< keywordprg<"
    \ . "| unlet! b:browsefiler"

let &cpo = s:cpo_save
unlet s:cpo_save
             " Vim filetype plugin file
" Language:             Configuration File (ini file) for MS-DOS/MS Windows
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:; commentstring=;\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     9   dtd.vim :   
dtrace.vim  ;   dune.vim<   
eiffel.vim  =   
elinks.vim  >   elm.vim ?   
erlang.vim  @   	eruby.vim   A   	eterm.vim   B   
falcon.vim  C   fetchmail.vim   D   flexwiki.vimE   fortran.vim F   fpcmake.vim G   framescript.vim H   freebasic.vim   I   	fstab.vim   J   fvwm.vimK   gdb.vim L   git.vim M   gitcommit.vim   N   gitconfig.vim   O   gitrebase.vim   P   gitsendemail.vimQ   go.vim  R   gpg.vim S   	gprof.vim   T   
groovy.vim  U   	group.vim   V   grub.vimW   haml.vimX   hamster.vim Y   haskell.vim Z   help.vim[   hgcommit.vim\   hog.vim ]   hostconf.vim^   hostsaccess.vim _   html.vim`   htmldjango.vim  a   
indent.vim  b   
initex.vim  c   ishd.vimd   j.vim   e   java.vimf   javascript.vim  g   javascriptreact.vim h   jproperties.vim i   json.vimj   	jsonc.vim   k   jsp.vim l   	julia.vim       " Vim filetype plugin file
" Language:	dtd
" Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
" Last Changed: 20 Jan 2009
" URL:		http://dwsharp.users.sourceforge.net/vim/ftplugin

if exists("b:did_ftplugin") | finish | endif
let b:did_ftplugin = 1

" Make sure the continuation lines below do not cause problems in
" compatibility mode.
let s:save_cpo = &cpo
set cpo-=C

setlocal commentstring=<!--%s-->
setlocal comments=s:<!--,m:\ \ \ \ \ ,e:-->

setlocal formatoptions-=t
if !exists("g:ft_dtd_autocomment") || (g:ft_dtd_autocomment == 1)
    setlocal formatoptions+=croql
endif

if exists("loaded_matchit")
    let b:match_words = '<!--:-->,<!:>'
endif

" Change the :browse e filter to primarily show Java-related files.
if has("gui_win32")
    let  b:browsefilter="DTD Files (*.dtd)\t*.dtd\n" .
		\	"XML Files (*.xml)\t*.xml\n" .
		\	"All Files (*.*)\t*.*\n"
endif

" Undo the stuff we changed.
let b:undo_ftplugin = "setlocal commentstring< comments< formatoptions<" .
		\     " | unlet! b:matchwords b:browsefilter"

" Restore the saved compatibility options.
let &cpo = s:save_cpo
unlet s:save_cpo
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             " Language: D script as described in "Solaris Dynamic Tracing Guide",
"           http://docs.sun.com/app/docs/doc/817-6223
" Last Change: 2008/03/20
" Version: 1.2
" Maintainer: Nicolas Weber <nicolasweber@gmx.de>

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

" Using line continuation here.
let s:cpo_save = &cpo
set cpo-=C

let b:undo_ftplugin = "setl fo< com< cms< isk<"

" Set 'formatoptions' to break comment lines but not other lines,
" and insert the comment leader when hitting <CR> or using "o".
setlocal fo-=t fo+=croql

" Set 'comments' to format dashed lists in comments.
setlocal comments=sO:*\ -,mO:*\ \ ,exO:*/,s1:/*,mb:*,ex:*/

" dtrace uses /* */ comments. Set this explicitly, just in case the user
" changed this (/*%s*/ is the default)
setlocal commentstring=/*%s*/

setlocal iskeyword+=@,$

" When the matchit plugin is loaded, this makes the % command skip parens and
" braces in comments.
let b:match_words = &matchpairs
let b:match_skip = 's:comment\|string\|character'

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 " Language:    Dune buildsystem
" Maintainer:  Markus Mottl        <markus.mottl@gmail.com>
"              Anton Kochkov       <anton.kochkov@gmail.com>
" URL:         https://github.com/ocaml/vim-ocaml
" Last Change:
"              2018 Nov 3 - Added commentstring (Markus Mottl)
"              2017 Sep 6 - Initial version (Etienne Millon)

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin=1

set lisp

" Comment string
setl commentstring=;\ %s
setl comments=:;

setl iskeyword+=#,?,.,/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          " Vim filetype plugin
" Language:	Eiffel
" Maintainer:	Doug Kearns <dougkearns@gmail.com>
" Last Change:	2010 Aug 29

if (exists("b:did_ftplugin"))
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

setlocal comments=:--
setlocal commentstring=--\ %s

setlocal formatoptions-=t formatoptions+=croql

if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
  let b:browsefilter = "Eiffel Source Files (*.e)\t*.e\n" .
		     \ "Eiffel Control Files (*.ecf, *.ace, *.xace)\t*.ecf;*.ace;*.xace\n" .
		     \ "All Files (*.*)\t*.*\n"
endif

if exists("loaded_matchit") && !exists("b:match_words")
  let b:match_ignorecase = 0
  " Silly \%^ trick to match note at head of pair and in middle prevents
  " 'g%' wrapping from 'note' to 'end'
  let b:match_words = '\%^:' .
		  \	'\<\%(^note\|indexing\|class\|^obsolete\|inherit\|insert\|^create\|convert\|feature\|^invariant\)\>:' .
		  \   '^end\>,' .
		  \   '\<\%(do\|deferred\|external\|once\%(\s\+"\)\@!\|check\|debug\|if\|inspect\|from\|across\)\>:' .
		  \	'\%(\%(^\s\+\)\@<=\%(then\|until\|loop\)\|\%(then\|until\|loop\)\s\+[^ -]\|' .
		  \	'\<\%(ensure\%(\s\+then\)\=\|rescue\|_then\|elseif\|else\|when\|\s\@<=invariant\|_until\|_loop\|variant\|_as\|alias\)\>\):' .
		  \   '\s\@<=end\>'
  let b:match_skip = 's:\<eiffel\%(Comment\|String\|Operator\)\>'
  noremap  [% <Nop>
  noremap  ]% <Nop>
  vnoremap a% <Nop>
endif

let b:undo_ftplugin = "setl fo< com< cms<" .
  \ "| unlet! b:browsefilter b:match_ignorecase b:match_words b:match_skip"

if !exists("g:no_plugin_maps") && !exists("g:no_eiffel_maps")
  function! s:DoMotion(pattern, count, flags) abort
    normal! m'
    for i in range(a:count)
      call search(a:pattern, a:flags)
    endfor
  endfunction

  let sections = '^\%(note\|indexing\|' .
	     \	 '\%(\%(deferred\|expanded\|external\|frozen\)\s\+\)*class\|' .
	     \	 'obsolete\|inherit\|insert\|create\|convert\|feature\|' .
	     \	 'invariant\|end\)\>'

  nnoremap <silent> <buffer> ]] :<C-U>call <SID>DoMotion(sections, v:count1, 'W')<CR>
  xnoremap <silent> <buffer> ]] :<C-U>exe "normal! gv"<Bar>call <SID>DoMotion(sections, v:count1, 'W')<CR>
  nnoremap <silent> <buffer> [[ :<C-U>call <SID>DoMotion(sections, v:count1, 'Wb')<CR>
  xnoremap <silent> <buffer> [[ :<C-U>exe "normal! gv"<Bar>call <SID>DoMotion(sections, v:count1, 'Wb')<CR>

  function! s:DoFeatureMotion(count, flags)
    let view = winsaveview()
    call cursor(1, 1)
    let [features_start, _] = searchpos('^feature\>')
    call search('^\s\+\a') " find the first feature
    let spaces = indent(line('.'))
    let [features_end, _] = searchpos('^\%(invariant\|note\|end\)\>')
    call winrestview(view)
    call s:DoMotion('\%>' . features_start . 'l\%<' . features_end . 'l^\s*\%' . (spaces + 1) . 'v\zs\a', a:count, a:flags)
  endfunction

  nnoremap <silent> <buffer> ]m :<C-U>call <SID>DoFeatureMotion(v:count1, 'W')<CR>
  xnoremap <silent> <buffer> ]m :<C-U>exe "normal! gv"<Bar>call <SID>DoFeatureMotion(v:count1, 'W')<CR>
  nnoremap <silent> <buffer> [m :<C-U>call <SID>DoFeatureMotion(v:count1, 'Wb')<CR>
  xnoremap <silent> <buffer> [m :<C-U>exe "normal! gv"<Bar>call <SID>DoFeatureMotion(v:count1, 'Wb')<CR>

  let comment_block_start = '^\%(\s\+--.*\n\)\@<!\s\+--'
  let comment_block_end = '^\s\+--.*\n\%(\s\+--\)\@!'

  nnoremap <silent> <buffer> ]- :<C-U>call <SID>DoMotion(comment_block_start, 1, 'W')<CR>
  xnoremap <silent> <buffer> ]- :<C-U>exe "normal! gv"<Bar>call <SID>DoMotion(comment_block_start, 1, 'W')<CR>
  nnoremap <silent> <buffer> [- :<C-U>call <SID>DoMotion(comment_block_end, 1, 'Wb')<CR>
  xnoremap <silent> <buffer> [- :<C-U>exe "normal! gv"<Bar>call <SID>DoMotion(comment_block_end, 1, 'Wb')<CR>

  let b:undo_ftplugin = b:undo_ftplugin .
    \ "| silent! execute 'unmap <buffer> [[' | silent! execute 'unmap <buffer> ]]'" .
    \ "| silent! execute 'unmap <buffer> [m' | silent! execute 'unmap <buffer> ]m'" .
    \ "| silent! execute 'unmap <buffer> [-' | silent! execute 'unmap <buffer> ]-'"
endif

let &cpo = s:cpo_save
unlet s:cpo_save

" vim: nowrap sw=2 sts=2 ts=8
        " Vim filetype plugin file
" Language:             elinks(1) configuration file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            " Elm filetype plugin file
" Language: Elm
" Maintainer: Andreas Scharf <as@99n.de>
" Latest Revision: 2020-05-29

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

setlocal comments=s1fl:{-,mb:\ ,ex:-},:--
setlocal commentstring=--\ %s

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       " Vim ftplugin file
" Language:     Erlang (http://www.erlang.org)
" Maintainer:   Csaba Hoch <csaba.hoch@gmail.com>
" Author:       Oscar Hellstr√∂m <oscar@oscarh.net>
" Contributors: Ricardo Catalinas Jim√©nez <jimenezrick@gmail.com>
"               Eduardo Lopez (http://github.com/tapichu)
"               Arvid Bjurklint (http://github.com/slarwise)
" Last Update:  2021-Jan-08
" License:      Vim license
" URL:          https://github.com/vim-erlang/vim-erlang-runtime

if exists('b:did_ftplugin')
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let &l:keywordprg = get(g:, 'erlang_keywordprg', 'erl -man')

if get(g:, 'erlang_folding', 0)
  setlocal foldmethod=expr
  setlocal foldexpr=GetErlangFold(v:lnum)
  setlocal foldtext=ErlangFoldText()
endif

setlocal comments=:%%%,:%%,:%
setlocal commentstring=%%s

setlocal formatoptions+=ro

setlocal suffixesadd=.erl,.hrl

let &l:include = '^\s*-\%(include\|include_lib\)\s*("\zs\f*\ze")'
let &l:define  = '^\s*-\%(define\|record\|type\|opaque\)'

let s:erlang_fun_begin = '^\a\w*(.*$'
let s:erlang_fun_end   = '^[^%]*\.\s*\(%.*\)\?$'

if !exists('*GetErlangFold')
  function GetErlangFold(lnum)
    let lnum = a:lnum
    let line = getline(lnum)

    if line =~ s:erlang_fun_end
      return '<1'
    endif

    if line =~ s:erlang_fun_begin && foldlevel(lnum - 1) == 1
      return '1'
    endif

    if line =~ s:erlang_fun_begin
      return '>1'
    endif

    return '='
  endfunction
endif

if !exists('*ErlangFoldText')
  function ErlangFoldText()
    let line    = getline(v:foldstart)
    let foldlen = v:foldend - v:foldstart + 1
    let lines   = ' ' . foldlen . ' lines: ' . substitute(line, "[\ \t]*", '', '')
    if foldlen < 10
      let lines = ' ' . lines
    endif
    let retval = '+' . v:folddashes . lines

    return retval
  endfunction
endif

let b:undo_ftplugin = "setlocal keywordprg< foldmethod< foldexpr< foldtext<"
      \ . " comments< commentstring< formatoptions< suffixesadd< include<"
      \ . " define<"

let &cpo = s:cpo_save
unlet s:cpo_save

" vim: sw=2 et
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  " Vim filetype plugin
" Language:		eRuby
" Maintainer:		Tim Pope <vimNOSPAM@tpope.org>
" URL:			https://github.com/vim-ruby/vim-ruby
" Release Coordinator:	Doug Kearns <dougkearns@gmail.com>
" Last Change:		2020 Jun 28

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

let s:save_cpo = &cpo
set cpo-=C

" Define some defaults in case the included ftplugins don't set them.
let s:undo_ftplugin = ""
let s:browsefilter = "All Files (*.*)\t*.*\n"
let s:match_words = ""

if !exists("g:eruby_default_subtype")
  let g:eruby_default_subtype = "html"
endif

if &filetype =~ '^eruby\.'
  let b:eruby_subtype = matchstr(&filetype,'^eruby\.\zs\w\+')
elseif !exists("b:eruby_subtype")
  let s:lines = getline(1)."\n".getline(2)."\n".getline(3)."\n".getline(4)."\n".getline(5)."\n".getline("$")
  let b:eruby_subtype = matchstr(s:lines,'eruby_subtype=\zs\w\+')
  if b:eruby_subtype == ''
    let b:eruby_subtype = matchstr(substitute(expand("%:t"),'\c\%(\.erb\|\.eruby\|\.erubis\|\.example\)\+$','',''),'\.\zs\w\+\%(\ze+\w\+\)\=$')
  endif
  if b:eruby_subtype == 'rhtml'
    let b:eruby_subtype = 'html'
  elseif b:eruby_subtype == 'rb'
    let b:eruby_subtype = 'ruby'
  elseif b:eruby_subtype == 'yml'
    let b:eruby_subtype = 'yaml'
  elseif b:eruby_subtype == 'js'
    let b:eruby_subtype = 'javascript'
  elseif b:eruby_subtype == 'txt'
    " Conventional; not a real file type
    let b:eruby_subtype = 'text'
  elseif b:eruby_subtype == ''
    let b:eruby_subtype = g:eruby_default_subtype
  endif
endif

if exists("b:eruby_subtype") && b:eruby_subtype != '' && b:eruby_subtype !=? 'eruby'
  exe "runtime! ftplugin/".b:eruby_subtype.".vim ftplugin/".b:eruby_subtype."_*.vim ftplugin/".b:eruby_subtype."/*.vim"
else
  runtime! ftplugin/html.vim ftplugin/html_*.vim ftplugin/html/*.vim
endif
unlet! b:did_ftplugin

" Override our defaults if these were set by an included ftplugin.
if exists("b:undo_ftplugin")
  let s:undo_ftplugin = b:undo_ftplugin
  unlet b:undo_ftplugin
endif
if exists("b:browsefilter")
  let s:browsefilter = b:browsefilter
  unlet b:browsefilter
endif
if exists("b:match_words")
  let s:match_words = b:match_words
  unlet b:match_words
endif

let s:cfilemap = v:version >= 704 ? maparg('<Plug><cfile>', 'c', 0, 1) : {}
if !get(s:cfilemap, 'buffer') || !s:cfilemap.expr || s:cfilemap.rhs =~# 'ErubyAtCursor()'
  let s:cfilemap = {}
endif
if !has_key(s:cfilemap, 'rhs')
  let s:cfilemap.rhs = "substitute(&l:inex =~# '\\<v:fname\\>' && len(expand('<cfile>')) ? eval(substitute(&l:inex, '\\<v:fname\\>', '\\=string(expand(\"<cfile>\"))', 'g')) : '', '^$', \"\\022\\006\",'')"
endif
let s:ctagmap = v:version >= 704 ? maparg('<Plug><ctag>', 'c', 0, 1) : {}
if !get(s:ctagmap, 'buffer') || !s:ctagmap.expr || s:ctagmap.rhs =~# 'ErubyAtCursor()'
  let s:ctagmap = {}
endif
let s:include = &l:include
let s:path = &l:path
let s:suffixesadd = &l:suffixesadd

runtime! ftplugin/ruby.vim ftplugin/ruby_*.vim ftplugin/ruby/*.vim
let b:did_ftplugin = 1

" Combine the new set of values with those previously included.
if exists("b:undo_ftplugin")
  let s:undo_ftplugin = b:undo_ftplugin . " | " . s:undo_ftplugin
endif
if exists ("b:browsefilter")
  let s:browsefilter = substitute(b:browsefilter,'\cAll Files (\*\.\*)\t\*\.\*\n','','') . s:browsefilter
endif
if exists("b:match_words")
  let s:match_words = b:match_words . ',' . s:match_words
endif

if len(s:include)
  let &l:include = s:include
endif
let &l:path = s:path . (s:path =~# ',$\|^$' ? '' : ',') . &l:path
let &l:suffixesadd = s:suffixesadd . (s:suffixesadd =~# ',$\|^$' ? '' : ',') . &l:suffixesadd
exe 'cmap <buffer><script><expr> <Plug><cfile> ErubyAtCursor() ? ' . maparg('<Plug><cfile>', 'c') . ' : ' . s:cfilemap.rhs
exe 'cmap <buffer><script><expr> <Plug><ctag> ErubyAtCursor() ? ' . maparg('<Plug><ctag>', 'c') . ' : ' . get(s:ctagmap, 'rhs', '"\022\027"')
unlet s:cfilemap s:ctagmap s:include s:path s:suffixesadd

" Change the browse dialog on Win32 to show mainly eRuby-related files
if has("gui_win32")
  let b:browsefilter="eRuby Files (*.erb, *.rhtml)\t*.erb;*.rhtml\n" . s:browsefilter
endif

" Load the combined list of match_words for matchit.vim
if exists("loaded_matchit")
  let b:match_words = s:match_words
endif

" TODO: comments=
setlocal commentstring=<%#%s%>

let b:undo_ftplugin = "setl cms< " .
      \ " | unlet! b:browsefilter b:match_words | " . s:undo_ftplugin

let &cpo = s:save_cpo
unlet s:save_cpo

function! ErubyAtCursor() abort
  let groups = map(['erubyBlock', 'erubyComment', 'erubyExpression', 'erubyOneLiner'], 'hlID(v:val)')
  return !empty(filter(synstack(line('.'), col('.')), 'index(groups, v:val) >= 0'))
endfunction

" vim: nowrap sw=2 sts=2 ts=8:
                                                                                                                                                                                                                                                                                                                                                                                                                       " Vim filetype plugin file
" Language:             eterm(1) configuration file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< inc< fo<"

setlocal comments=:# commentstring=#\ %s include=^\\s*include
setlocal formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          " Vim filetype plugin file
" Language:     Falcon
" Author:       Steven Oliver <oliver.steven@gmail.com>
" Copyright:    Copyright (c) 2009-2013 Steven Oliver
" License:      You may redistribute this under the same terms as Vim itself
" Last Update:  2020 Oct 10
" --------------------------------------------------------------------------

" Only do this when not done yet for this buffer
if (exists("b:did_ftplugin"))
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

setlocal softtabstop=4 shiftwidth=4
setlocal suffixesadd=.fal,.ftd

" Matchit support
if exists("loaded_matchit") && !exists("b:match_words")
  let b:match_ignorecase = 0

  let b:match_words =
	\ '\<\%(if\|case\|while\|until\|for\|do\|class\)\>=\@!' .
	\ ':' .
	\ '\<\%(else\|elsif\|when\)\>' .
	\ ':' .
	\ '\<end\>' .
	\ ',{:},\[:\],(:)'
endif

setlocal comments=sO:*\ -,mO:*\ \ ,exO:*/,s1:/*,mb:*,ex:*/,://

" Windows allows you to filter the open file dialog
if has("gui_win32") && !exists("b:browsefilter")
  let b:browsefilter = "Falcon Source Files (*.fal *.ftd)\t*.fal;*.ftd\n" .
                     \ "All Files (*.*)\t*.*\n"
endif

let b:undo_ftplugin = "setlocal tabstop< shiftwidth< expandtab< fileencoding<"
	\ . " suffixesadd< comments<"
	\ . "| unlet! b:browsefiler"

let &cpo = s:cpo_save
unlet s:cpo_save

" vim: set sw=4 sts=4 et tw=80 :
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       " Vim filetype plugin file
" Language:             fetchmail(1) RC File
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    " Vim filetype plugin file
" Language:     FlexWiki, http://www.flexwiki.com/
" Maintainer:   George V. Reilly  <george@reilly.org>
" Home:         http://www.georgevreilly.com/vim/flexwiki/
" Other Home:   http://www.vim.org/scripts/script.php?script_id=1529
" Author:       George V. Reilly
" Filenames:    *.wiki
" Last Change: Wed Apr 26 11:00 PM 2006 P
" Version:      0.3

if exists("b:did_ftplugin")
  finish
endif

let b:did_ftplugin = 1  " Don't load another plugin for this buffer

" Reset the following options to undo this plugin.
let b:undo_ftplugin = "setl tw< wrap< lbr< et< ts< fenc< bomb< ff<"

" Allow lines of unlimited length. Do NOT want automatic linebreaks,
" as a newline starts a new paragraph in FlexWiki.
setlocal textwidth=0
" Wrap long lines, rather than using horizontal scrolling.
setlocal wrap
" Wrap at a character in 'breakat' rather than at last char on screen
setlocal linebreak
" Don't transform <TAB> characters into spaces, as they are significant
" at the beginning of the line for numbered and bulleted lists.
setlocal noexpandtab
" 4-char tabstops, per flexwiki.el
setlocal tabstop=4
" Save *.wiki files in UTF-8
setlocal fileencoding=utf-8
" Add the UTF-8 Byte Order Mark to the beginning of the file
setlocal bomb
" Save <EOL>s as \n, not \r\n
setlocal fileformat=unix

if exists("g:flexwiki_maps")
  " Move up and down by display lines, to account for screen wrapping
  " of very long lines
  nmap <buffer> <Up>   gk
  nmap <buffer> k      gk
  vmap <buffer> <Up>   gk
  vmap <buffer> k      gk

  nmap <buffer> <Down> gj
  nmap <buffer> j      gj
  vmap <buffer> <Down> gj
  vmap <buffer> j      gj

  " for earlier versions - for when 'wrap' is set
  imap <buffer> <S-Down>   <C-o>gj
  imap <buffer> <S-Up>     <C-o>gk
  if v:version >= 700
      imap <buffer> <Down>   <C-o>gj
      imap <buffer> <Up>     <C-o>gk
  endif
endif
                                                                                                                                                                            " Vim settings file
" Language:	Fortran 2008 (and older: Fortran 2003, 95, 90, 77, 66)
" Version:	(v53) 2021 April 06
" Maintainer:	Ajit J. Thakkar <ajit@unb.ca>; <http://www2.unb.ca/~ajit/>
" Usage:	For instructions, do :help fortran-plugin from Vim
" Credits:
"  Version 0.1 was created in September 2000 by Ajit Thakkar.
"  Since then, useful suggestions and contributions have been made, in order, by:
"  Stefano Zacchiroli, Hendrik Merx, Ben Fritz, David Barnett, Eisuke Kawashima,
"  Doug Kearns, and Fritz Reese.

" Only do these settings when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

let s:cposet=&cpoptions
set cpoptions&vim

" Don't do other file type settings for this buffer
let b:did_ftplugin = 1

" Determine whether this is a fixed or free format source file
" if this hasn't been done yet using the priority:
" buffer-local value
" > global value
" > file extension as in Intel ifort, gcc (gfortran), NAG, Pathscale, and Cray compilers
if !exists("b:fortran_fixed_source")
  if exists("fortran_free_source")
    " User guarantees free source form
    let b:fortran_fixed_source = 0
  elseif exists("fortran_fixed_source")
    " User guarantees fixed source form
    let b:fortran_fixed_source = 1
  elseif expand("%:e") =~? '^f\%(90\|95\|03\|08\)$'
    " Free-form file extension defaults as in Intel ifort, gcc(gfortran), NAG, Pathscale, and Cray compilers
    let b:fortran_fixed_source = 0
  elseif expand("%:e") =~? '^\%(f\|f77\|for\)$'
    " Fixed-form file extension defaults
    let b:fortran_fixed_source = 1
  else
    " Modern fortran still allows both fixed and free source form
    " Assume fixed source form unless signs of free source form
    " are detected in the first five columns of the first s:lmax lines.
    " Detection becomes more accurate and time-consuming if more lines
    " are checked. Increase the limit below if you keep lots of comments at
    " the very top of each file and you have a fast computer.
    let s:lmax = 500
    if ( s:lmax > line("$") )
      let s:lmax = line("$")
    endif
    let b:fortran_fixed_source = 1
    let s:ln=1
    while s:ln <= s:lmax
      let s:test = strpart(getline(s:ln),0,5)
      if s:test !~ '^[Cc*]' && s:test !~ '^ *[!#]' && s:test =~ '[^ 0-9\t]' && s:test !~ '^[ 0-9]*\t'
	let b:fortran_fixed_source = 0
	break
      endif
      let s:ln = s:ln + 1
    endwhile
    unlet! s:lmax s:ln s:test
  endif
endif

" Set comments and textwidth according to source type
if (b:fortran_fixed_source == 1)
  setlocal comments=:!,:*,:C
  " Fixed format requires a textwidth of 72 for code,
  " but some vendor extensions allow longer lines
  if exists("fortran_extended_line_length")
    setlocal tw=132
  elseif exists("fortran_cardimage_line_length")
    setlocal tw=80
  else
    setlocal tw=72
  " If you need to add "&" on continued lines so that the code is
  " compatible with both free and fixed format, then you should do so
  " in column 73 and uncomment the next line
  " setlocal tw=73
  endif
else
  setlocal comments=:!
  " Free format allows a textwidth of 132
  setlocal tw=132
endif

" Set commentstring for foldmethod=marker
setlocal cms=!%s

" Tabs are not a good idea in Fortran so the default is to expand tabs
if !exists("fortran_have_tabs")
  setlocal expandtab
endif

" Set 'formatoptions' to break text lines
setlocal fo+=t

setlocal include=^\\c#\\=\\s*include\\s\\+
setlocal suffixesadd+=.f08,.f03,.f95,.f90,.for,.f,.F,.f77,.ftn,.fpp

" Define patterns for the matchit plugin
if !exists("b:match_words")
  let s:notend = '\%(\<end\s\+\)\@<!'
  let s:notselect = '\%(\<select\s\+\)\@<!'
  let s:notelse = '\%(\<end\s\+\|\<else\s\+\)\@<!'
  let s:notprocedure = '\%(\s\+procedure\>\)\@!'
  let b:match_ignorecase = 1
  let b:match_words =
    \ '(:),' .
    \ '\<select\s*case\>:' . s:notselect. '\<case\>:\<end\s*select\>,' .
    \ s:notelse . '\<if\s*(.\+)\s*then\>:' .
    \ '\<else\s*\%(if\s*(.\+)\s*then\)\=\>:\<end\s*if\>,'.
    \ 'do\s\+\(\d\+\):\%(^\s*\)\@<=\1\s,'.
    \ s:notend . '\<do\>:\<end\s*do\>,'.
    \ s:notelse . '\<where\>:\<elsewhere\>:\<end\s*where\>,'.
    \ s:notend . '\<type\s*[^(]:\<end\s*type\>,'.
    \ s:notend . '\<forall\>:\<end\s*forall\>,'.
    \ s:notend . '\<associate\>:\<end\s*associate\>,'.
    \ s:notend . '\<enum\>:\<end\s*enum\>,'.
    \ s:notend . '\<interface\>:\<end\s*interface\>,'.
    \ s:notend . '\<subroutine\>:\<end\s*subroutine\>,'.
    \ s:notend . '\<function\>:\<end\s*function\>,'.
    \ s:notend . '\<module\>' . s:notprocedure . ':\<end\s*module\>,'.
    \ s:notend . '\<program\>:\<end\s*program\>'
endif

" File filters for :browse e
if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
  let b:browsefilter = "Fortran Files (*.f;*.for;*.f77;*.f90;*.f95;*.f03;*.f08;*.fpp;*.ftn)\t*.f;*.for;*.f77;*.f90;*.f95;*.f03;*.f08;*.fpp;*.ftn\n" .
    \ "All Files (*.*)\t*.*\n"
endif

let b:undo_ftplugin = "setl fo< com< tw< cms< et< inc< sua<"
	\ . "| unlet! b:match_ignorecase b:match_words b:browsefilter"

let &cpoptions=s:cposet
unlet s:cposet

" vim:sw=2
                                                     " Vim filetype plugin file
" Language:	Free Pascal Makefile Generator
" Maintainer:	Doug Kearns <dougkearns@gmail.com>
" Last Change:	2021 Apr 23

if exists("b:did_ftplugin")
  finish
endif

let s:cpo_save = &cpo
set cpo&vim

runtime! ftplugin/make.vim

if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
  let b:browsefilter = "Free Pascal Makefile Definition Files (*.fpc)\t*.fpc\n" ..
		     \ "All Files (*.*)\t*.*\n"
endif

let b:undo_ftplugin = b:undo_ftplugin .. " | unlet! b:browsefilter"

let &cpo = s:cpo_save
unlet s:cpo_save

" vim: nowrap sw=2 sts=2 ts=8 noet:
                                                                                                                                                                                                                                                                                                                                                                                                                                                " Vim ftplugin file
" Language:             FrameScript
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-19

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo< inc< | unlet! b:matchwords"

setlocal comments=s1:/*,mb:*,ex:*/,:// commentstring=/*\ %s\ */
setlocal formatoptions-=t formatoptions+=croql
setlocal include=^\\s*<#Include

if exists("loaded_matchit")
  let s:not_end = '\c\%(\<End\)\@<!'
  let b:match_words =
        \ s:not_end . '\<If\>:\c\<ElseIf\>:\c\<Else\>:\c\<EndIf\>,' .
        \ s:not_end . '\<Loop\>:\c\<EndLoop\>' .
        \ s:not_end . '\<Sub\>:\c\<EndSub\>'
  unlet s:not_end
endif

let &cpo = s:cpo_save 
unlet s:cpo_save
                                                                                                                                                                                                                                                    " Vim filetype plugin file
" Language:	FreeBasic
" Maintainer:	Doug Kearns <dougkearns@gmail.com>
" Last Change:	2015 Jan 10

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

runtime! ftplugin/basic.vim

" vim: ts=8
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      " Vim ftplugin file
" Language: fstab file
" Maintainer: Radu Dineiu <radu.dineiu@gmail.com>
" URL: https://raw.github.com/rid9/vim-fstab/master/ftplugin/fstab.vim
" Last Change: 2021 Jan 02
" Version: 1.0
"
" Credits:
"   Subhaditya Nath <sn03.general@gmail.com>

if exists("b:did_ftplugin")
	finish
endif
let b:did_ftplugin = 1

setlocal commentstring=#%s
let b:undo_ftplugin = "setlocal commentstring<"

" vim: ts=8 ft=vim
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      " Created	: Tue 09 May 2006 02:07:31 PM CDT
" Modified	: Tue 09 May 2006 02:07:31 PM CDT
" Author	: Gautam Iyer <gi1242@users.sourceforge.net>
" Description	: ftplugin for fvwm config files

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s
setlocal formatoptions-=t formatoptions+=croql
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          " Vim filetype plugin file
" Language:	gdb
" Maintainer:	Micha√´l Peeters <NOSPAMm.vim@noekeon.org>
" Last Changed: 26 Oct 2017

if exists("b:did_ftplugin") | finish | endif
let b:did_ftplugin = 1

setlocal commentstring=#%s

" Undo the stuff we changed.
let b:undo_ftplugin = "setlocal cms<"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           " Vim filetype plugin
" Language:	generic git output
" Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
" Last Change:	2019 Dec 05

" Only do this when not done yet for this buffer
if (exists("b:did_ftplugin"))
  finish
endif
let b:did_ftplugin = 1

if !exists('b:git_dir')
  if expand('%:p') =~# '[\/]\.git[\/]modules[\/]\|:[\/][\/]\|^\a\a\+:'
    " Stay out of the way
  elseif expand('%:p') =~# '[\/]\.git[\/]worktrees'
    let b:git_dir = matchstr(expand('%:p'),'.*\.git[\/]worktrees[\/][^\/]\+\>')
  elseif expand('%:p') =~# '\.git\>'
    let b:git_dir = matchstr(expand('%:p'),'.*\.git\>')
  elseif $GIT_DIR != ''
    let b:git_dir = $GIT_DIR
  endif
  if (has('win32') || has('win64')) && exists('b:git_dir')
    let b:git_dir = substitute(b:git_dir,'\\','/','g')
  endif
endif

if exists('*shellescape') && exists('b:git_dir') && b:git_dir != ''
  if b:git_dir =~# '/\.git$' " Not a bare repository
    let &l:path = escape(fnamemodify(b:git_dir,':h'),'\, ').','.&l:path
  endif
  let &l:path = escape(b:git_dir,'\, ').','.&l:path
  let &l:keywordprg = 'git --git-dir='.shellescape(b:git_dir).' show'
else
  setlocal keywordprg=git\ show
endif
if has('gui_running')
  let &l:keywordprg = substitute(&l:keywordprg,'^git\>','git --no-pager','')
endif

setlocal includeexpr=substitute(v:fname,'^[^/]\\+/','','')
let b:undo_ftplugin = "setl keywordprg< path< includeexpr<"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     " Vim filetype plugin
" Language:	git commit file
" Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
" Last Change:	2019 Dec 05

" Only do this when not done yet for this buffer
if (exists("b:did_ftplugin"))
  finish
endif

runtime! ftplugin/git.vim
let b:did_ftplugin = 1

setlocal comments=:# commentstring=#\ %s
setlocal nomodeline tabstop=8 formatoptions+=tl textwidth=72
setlocal formatoptions-=c formatoptions-=r formatoptions-=o formatoptions-=q formatoptions+=n
setlocal formatlistpat+=\\\|^\\s*[-*+]\\s\\+

let b:undo_ftplugin = 'setl modeline< tabstop< formatoptions< tw< com< cms< formatlistpat<'

if exists("g:no_gitcommit_commands") || v:version < 700
  finish
endif

if !exists("b:git_dir")
  let b:git_dir = expand("%:p:h")
endif

command! -bang -bar -buffer -complete=custom,s:diffcomplete -nargs=* DiffGitCached :call s:gitdiffcached(<bang>0,b:git_dir,<f-args>)

let b:undo_ftplugin = b:undo_ftplugin . "|delc DiffGitCached"

function! s:diffcomplete(A,L,P)
  let args = ""
  if a:P <= match(a:L." -- "," -- ")+3
    let args = args . "-p\n--stat\n--shortstat\n--summary\n--patch-with-stat\n--no-renames\n-B\n-M\n-C\n"
  end
  if exists("b:git_dir") && a:A !~ '^-'
    let tree = fnamemodify(b:git_dir,':h')
    if strpart(getcwd(),0,strlen(tree)) == tree
      let args = args."\n".system("git diff --cached --name-only")
    endif
  endif
  return args
endfunction

function! s:gitdiffcached(bang,gitdir,...)
  let tree = fnamemodify(a:gitdir,':h')
  let name = tempname()
  let git = "git"
  if strpart(getcwd(),0,strlen(tree)) != tree
    let git .= " --git-dir=".(exists("*shellescape") ? shellescape(a:gitdir) : '"'.a:gitdir.'"')
  endif
  if a:0
    let extra = join(map(copy(a:000),exists("*shellescape") ? 'shellescape(v:val)' : "'\"'.v:val.'\"'"))
  else
    let extra = "-p --stat=".&columns
  endif
  call system(git." diff --cached --no-color --no-ext-diff ".extra." > ".(exists("*shellescape") ? shellescape(name) : name))
  exe "pedit ".(exists("*fnameescape") ? fnameescape(name) : name)
  wincmd P
  let b:git_dir = a:gitdir
  command! -bang -bar -buffer -complete=custom,s:diffcomplete -nargs=* DiffGitCached :call s:gitdiffcached(<bang>0,b:git_dir,<f-args>)
  nnoremap <buffer> <silent> q :q<CR>
  setlocal buftype=nowrite nobuflisted noswapfile nomodifiable filetype=git
endfunction
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      " Vim filetype plugin
" Language:	git config file
" Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
" Last Change:	2009 Dec 24

" Only do this when not done yet for this buffer
if (exists("b:did_ftplugin"))
  finish
endif
let b:did_ftplugin = 1

setlocal formatoptions-=t formatoptions+=croql
setlocal comments=:#,:; commentstring=;\ %s

let b:undo_ftplugin = "setl fo< com< cms<"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        " Vim filetype plugin
" Language:	git rebase --interactive
" Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
" Last Change:	2019 Dec 05

" Only do this when not done yet for this buffer
if (exists("b:did_ftplugin"))
  finish
endif

runtime! ftplugin/git.vim
let b:did_ftplugin = 1

setlocal comments=:# commentstring=#\ %s formatoptions-=t
setlocal nomodeline
if !exists("b:undo_ftplugin")
  let b:undo_ftplugin = ""
endif
let b:undo_ftplugin = b:undo_ftplugin."|setl com< cms< fo< ml<"

function! s:choose(word) abort
  s/^\(\w\+\>\)\=\(\s*\)\ze\x\{4,40\}\>/\=(strlen(submatch(1)) == 1 ? a:word[0] : a:word) . substitute(submatch(2),'^$',' ','')/e
endfunction

function! s:cycle(count) abort
  let words = ['pick', 'edit', 'fixup', 'squash', 'reword', 'drop']
  let index = index(map(copy(words), 'v:val[0]'), getline('.')[0])
  let index = ((index < 0 ? 0 : index) + 10000 * len(words) + a:count) % len(words)
  call s:choose(words[index])
endfunction

command! -buffer -bar -range Pick   :<line1>,<line2>call s:choose('pick')
command! -buffer -bar -range Squash :<line1>,<line2>call s:choose('squash')
command! -buffer -bar -range Edit   :<line1>,<line2>call s:choose('edit')
command! -buffer -bar -range Reword :<line1>,<line2>call s:choose('reword')
command! -buffer -bar -range Fixup  :<line1>,<line2>call s:choose('fixup')
command! -buffer -bar -range Drop   :<line1>,<line2>call s:choose('drop')
command! -buffer -count=1 -bar -bang Cycle call s:cycle(<bang>0 ? -<count> : <count>)

if exists("g:no_plugin_maps") || exists("g:no_gitrebase_maps")
  finish
endif

nnoremap <buffer> <expr> K col('.') < 7 && expand('<Lt>cword>') =~ '\X' && getline('.') =~ '^\w\+\s\+\x\+\>' ? 'wK' : 'K'
nnoremap <buffer> <silent> <C-A> :<C-U><C-R>=v:count1<CR>Cycle<CR>
nnoremap <buffer> <silent> <C-X> :<C-U><C-R>=v:count1<CR>Cycle!<CR>

let b:undo_ftplugin = b:undo_ftplugin . "|exe 'nunmap <buffer> K'|exe 'nunmap <buffer> <C-A>'|exe 'nunmap <buffer> <C-X>'"
                                                                                                      " Vim filetype plugin
" Language:	git send-email message
" Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
" Last Change:	2009 Dec 24

runtime! ftplugin/mail.vim
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   " Vim filetype plugin file
" Language:	Go
" Maintainer:	David Barnett (https://github.com/google/vim-ft-go)
" Last Change:	2014 Aug 16

if exists('b:did_ftplugin')
  finish
endif
let b:did_ftplugin = 1

setlocal formatoptions-=t

setlocal comments=s1:/*,mb:*,ex:*/,://
setlocal commentstring=//\ %s

let b:undo_ftplugin = 'setl fo< com< cms<'

" vim: sw=2 sts=2 et
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   " Vim filetype plugin file
" Language:             gpg(1) configuration file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               " Language:     gprof
" Maintainer:   Dominique Pelle <dominique.pelle@gmail.com>
" Contributors: Doug Kearns <dougkearns@gmail.com>
" Last Change:  2021 Sep 19

" When cursor is on one line of the gprof call graph,
" calling this function jumps to this function in the call graph.
if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin=1

func! <SID>GprofJumpToFunctionIndex()
  let l:line = getline('.')
  if l:line =~ '[\d\+\]$'
    " We're in a line in the call graph.
    norm! $y%
    call search('^' . escape(@", '[]'), 'sw')
    norm! zz
  elseif l:line =~ '^\(\s*[0-9\.]\+\)\{3}\s\+'
    " We're in line in the flat profile.
    norm! 55|eby$
    call search('^\[\d\+\].*\d\s\+' .  escape(@", '[]*.') . '\>', 'sW')
    norm! zz
  endif
endfunc

if !exists("no_plugin_maps") && !exists("no_gprof_maps")
  " Pressing <C-]> on a line in the gprof flat profile or in
  " the call graph, jumps to the corresponding function inside
  " the flat profile.
  map <buffer> <silent> <C-]> :call <SID>GprofJumpToFunctionIndex()<CR>
  let b:undo_ftplugin = "silent! unmap <buffer> <C-]>"
endif

" vim:sw=2 fdm=indent
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                " Vim filetype plugin file
" Language:	groovy
" Maintainer:	Justin M. Keyes <justinkz@gmail.com>
" Last Change:	2016 May 22

if exists('b:did_ftplugin')
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo-=C

let b:undo_ftplugin = 'setlocal commentstring<'

setlocal commentstring=//%s

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         " Vim filetype plugin file
" Language:             group(5) user group file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments= commentstring= formatoptions-=tcroq formatoptions+=l

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       " Vim filetype plugin file
" Language:             grub(8) configuration file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              " Vim filetype plugin
" Language:	Haml
" Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
" Last Change:	2019 Dec 05

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

let s:save_cpo = &cpo
set cpo-=C

" Define some defaults in case the included ftplugins don't set them.
let s:undo_ftplugin = ""
let s:browsefilter = "All Files (*.*)\t*.*\n"
let s:match_words = ""

runtime! ftplugin/html.vim ftplugin/html_*.vim ftplugin/html/*.vim
unlet! b:did_ftplugin
set matchpairs-=<:>

" Override our defaults if these were set by an included ftplugin.
if exists("b:undo_ftplugin")
  let s:undo_ftplugin = b:undo_ftplugin
  unlet b:undo_ftplugin
endif
if exists("b:browsefilter")
  let s:browsefilter = b:browsefilter
  unlet b:browsefilter
endif
if exists("b:match_words")
  let s:match_words = b:match_words
  unlet b:match_words
endif

runtime! ftplugin/ruby.vim ftplugin/ruby_*.vim ftplugin/ruby/*.vim
let b:did_ftplugin = 1

let &l:define .= empty(&l:define ? '' : '\|') . '^\s*\%(%\w*\)\=\%(\.[[:alnum:]_-]\+\)*#'

" Combine the new set of values with those previously included.
if exists("b:undo_ftplugin")
  let s:undo_ftplugin = b:undo_ftplugin . " | " . s:undo_ftplugin
endif
if exists ("b:browsefilter")
  let s:browsefilter = substitute(b:browsefilter,'\cAll Files (\*\.\*)\t\*\.\*\n','','') . s:browsefilter
endif
if exists("b:match_words")
  let s:match_words = b:match_words . ',' . s:match_words
endif

" Change the browse dialog on Win32 to show mainly Haml-related files
if has("gui_win32")
  let b:browsefilter="Haml Files (*.haml)\t*.haml\nSass Files (*.sass)\t*.sass\n" . s:browsefilter
endif

" Load the combined list of match_words for matchit.vim
if exists("loaded_matchit")
  let b:match_words = s:match_words
endif

setlocal comments= commentstring=-#\ %s

let b:undo_ftplugin = "setl def< cms< com< "
      \ " | unlet! b:browsefilter b:match_words | " . s:undo_ftplugin

let &cpo = s:save_cpo
unlet s:save_cpo

" vim:set sw=2:
                                                                 " Vim filetype plugin
" Language:    Hamster Script
" Version:     2.0.6.0
" Maintainer:  David Fishburn <dfishburn dot vim at gmail dot com>
" Last Change: 2021 Jan 19

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl fo< com< tw< commentstring<"
	\ . "| unlet! b:match_ignorecase b:match_words b:match_skip"

" Set 'formatoptions' to break comment lines but not other lines,
" and insert the comment leader when hitting <CR> or using "o".
setlocal fo-=t fo+=croql

" Use the # sign for comments
setlocal comments=:#

" Format comments to be up to 78 characters long
if &tw == 0
  setlocal tw=78
endif

" Comments start with a double quote
setlocal commentstring=#%s

" Move around functions.
noremap <silent><buffer> [[ :call search('^\s*sub\>', "bW")<CR>
noremap <silent><buffer> ]] :call search('^\s*sub\>', "W")<CR>
noremap <silent><buffer> [] :call search('^\s*endsub\>', "bW")<CR>
noremap <silent><buffer> ][ :call search('^\s*endsub\>', "W")<CR>

" Move around comments
noremap <silent><buffer> ]# :call search('^\s*#\@!', "W")<CR>
noremap <silent><buffer> [# :call search('^\s*#\@!', "bW")<CR>

" Let the matchit plugin know what items can be matched.
if exists("loaded_matchit")
  let b:match_ignorecase = 0
  let b:match_words =
	\ '\<sub\>:\<return\>:\<endsub\>,' .
        \ '\<do\|while\|repeat\|for\>:\<break\>:\<continue\>:\<loop\|endwhile\|until\|endfor\>,' .
	\ '\<if\>:\<else\%[if]\>:\<endif\>' 

  " Ignore ":syntax region" commands, the 'end' argument clobbers if-endif
  " let b:match_skip = 'getline(".") =~ "^\\s*sy\\%[ntax]\\s\\+region" ||
  "	\ synIDattr(synID(line("."),col("."),1),"name") =~? "comment\\|string"'
endif

setlocal ignorecase

let &cpo = s:cpo_save
unlet s:cpo_save

" Disabled, 'cpo' is a global option.
" setlocal cpo+=M		" makes \%( match \)
                                                                                      " Vim filetype plugin file
" Language:             Haskell
" Maintainer:           Daniel Campoverde <alx@sillybytes.net>
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2018-08-27

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=s1fl:{-,mb:-,ex:-},:-- commentstring=--\ %s
setlocal formatoptions-=t formatoptions+=croql
setlocal omnifunc=haskellcomplete#Complete

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         " Vim filetype plugin file
" Language:             Vim help file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2018-12-29

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl fo< tw< cole< cocu< keywordprg<"

setlocal formatoptions+=tcroql textwidth=78 keywordprg=:help
if has("conceal")
  setlocal cole=2 cocu=nc
endif

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         " Vim filetype plugin file
" Language:	hg (Mercurial) commit file
" Maintainer:	Ken Takata <kentkt at csc dot jp>
" Last Change:	2016 Jan 6
" Filenames:	hg-editor-*.txt
" License:	VIM License
" URL:		https://github.com/k-takata/hg-vim

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

setlocal nomodeline

let b:undo_ftplugin = 'setl modeline<'
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     " Vim filetype plugin
" Language:     hog (snort.conf)
" Maintainer: . Victor Roemer, <vroemer@badsec.org>.
" Last Change:  Mar 1, 2013

if exists("b:did_ftplugin")
    finish
endif
let b:did_ftplugin = 1

let s:undo_ftplugin = "setl fo< com< cms< def< inc<"

let s:cpo_save = &cpo
set cpo&vim

setlocal formatoptions=croq
setlocal comments=:#
setlocal commentstring=\c#\ %s
setlocal define=\c^\s\{-}var
setlocal include=\c^\s\{-}include

" Move around configurations 
let s:hog_keyword_match = '\c^\s*\<\(preprocessor\\|config\\|output\\|include\\|ipvar\\|portvar\\|var\\|dynamicpreprocessor\\|' . 
                        \ 'dynamicengine\\|dynamicdetection\\|activate\\|alert\\|drop\\|block\\|dynamic\\|log\\|pass\\|reject\\|sdrop\\|sblock\)\>'

exec "nnoremap <buffer><silent> ]] :call search('" . s:hog_keyword_match . "', 'W' )<CR>"
exec "nnoremap <buffer><silent> [[ :call search('" . s:hog_keyword_match . "', 'bW' )<CR>"

if exists("loaded_matchit")
    let b:match_words =
                  \ '^\s*\<\%(preprocessor\|config\|output\|include\|ipvar\|portvar' . 
                  \ '\|var\|dynamicpreprocessor\|dynamicengine\|dynamicdetection' . 
                  \ '\|activate\|alert\|drop\|block\|dynamic\|log\|pass\|reject' . 
                  \ '\|sdrop\|sblock\>\):$,\::\,:;'
    let b:match_skip = 'r:\\.\{-}$\|^\s*#.\{-}$\|^\s*$'
endif

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              " Vim filetype plugin file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2007-12-04

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 " Vim filetype plugin file
" Language:             hosts_access(5) control file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            " Vim filetype plugin file
" Language:	html
" Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
" Last Changed: 20 Jan 2009
" URL:		http://dwsharp.users.sourceforge.net/vim/ftplugin

if exists("b:did_ftplugin") | finish | endif
let b:did_ftplugin = 1

" Make sure the continuation lines below do not cause problems in
" compatibility mode.
let s:save_cpo = &cpo
set cpo-=C

setlocal matchpairs+=<:>
setlocal commentstring=<!--%s-->
setlocal comments=s:<!--,m:\ \ \ \ ,e:-->

if exists("g:ft_html_autocomment") && (g:ft_html_autocomment == 1)
    setlocal formatoptions-=t formatoptions+=croql
endif

if exists('&omnifunc')
  setlocal omnifunc=htmlcomplete#CompleteTags
  call htmlcomplete#DetectOmniFlavor()
endif

" HTML:  thanks to Johannes Zellner and Benji Fisher.
if exists("loaded_matchit")
    let b:match_ignorecase = 1
    let b:match_words = '<:>,' .
    \ '<\@<=[ou]l\>[^>]*\%(>\|$\):<\@<=li\>:<\@<=/[ou]l>,' .
    \ '<\@<=dl\>[^>]*\%(>\|$\):<\@<=d[td]\>:<\@<=/dl>,' .
    \ '<\@<=\([^/][^ \t>]*\)[^>]*\%(>\|$\):<\@<=/\1>'
endif

" Change the :browse e filter to primarily show HTML-related files.
if has("gui_win32")
    let  b:browsefilter="HTML Files (*.html,*.htm)\t*.htm;*.html\n" .
		\	"JavaScript Files (*.js)\t*.js\n" .
		\	"Cascading StyleSheets (*.css)\t*.css\n" .
		\	"All Files (*.*)\t*.*\n"
endif

" Undo the stuff we changed.
let b:undo_ftplugin = "setlocal commentstring< matchpairs< omnifunc< comments< formatoptions<" .
    \	" | unlet! b:match_ignorecase b:match_skip b:match_words b:browsefilter"

" Restore the saved compatibility options.
let &cpo = s:save_cpo
unlet s:save_cpo
                                                                                                                                                                                                                                                                                                                                                                                                                                       " Vim filetype plugin file
" Language:	Django HTML template
" Maintainer:	Dave Hodder <dmh@dmh.org.uk>
" Last Change:	2007 Jan 25

" Only use this filetype plugin when no other was loaded.
if exists("b:did_ftplugin")
  finish
endif

" Use HTML and Django template ftplugins.
runtime! ftplugin/html.vim
runtime! ftplugin/django.vim
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     " Vim filetype plugin file
" Language:		indent(1) configuration file
" Maintainer:		Doug Kearns <dougkearns@gmail.com>
" Previous Maintainer:	Nikolai Weibull <now@bitwi.se>
" Latest Revision:	2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=s1:/*,mb:*,ex:*/ commentstring&
setlocal formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         " filetype plugin for TeX and variants
" Language:     TeX (ft=initex)
" Maintainer:   Benji Fisher, Ph.D. <benji@member.AMS.org>
" Version:	1.0
" Last Change:	Wed 19 Apr 2006

" Only do this when not done yet for this buffer.
if exists("b:did_ftplugin")
  finish
endif

" Don't load another plugin for this buffer.
let b:did_ftplugin = 1

" Avoid problems if running in 'compatible' mode.
let s:save_cpo = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< define< include< sua<"

" Set 'comments' to format dashed lists in comments
setlocal com=sO:%\ -,mO:%\ \ ,eO:%%,:%

" Set 'commentstring' to recognize the % comment character:
" (Thanks to Ajit Thakkar.)
setlocal cms=%%s

" Allow "[d" to be used to find a macro definition:
let &l:define='\\\([egx]\|char\|mathchar\|count\|dimen\|muskip\|skip\|toks\)\='
	\ .	'def\|\\font\|\\\(future\)\=let'

" Tell Vim to recognize \input bar :
let &l:include = '\\input'
setlocal suffixesadd=.tex

let &cpo = s:save_cpo
unlet s:save_cpo

" vim:sts=2:sw=2:
                   " Vim filetype plugin file
" Language:	InstallShield (ft=ishd)
" Maintainer:	Johannes Zellner <johannes@zellner.org>
" Last Change:	Sat, 24 May 2003 11:55:36 CEST

if exists("b:did_ftplugin") | finish | endif
let b:did_ftplugin = 1

setlocal foldmethod=syntax

" Using line continuation here.
let s:cpo_save = &cpo
set cpo-=C

" matchit support
if exists("loaded_matchit")
    let b:match_ignorecase=0
    let b:match_words=
    \ '\%(^\s*\)\@<=\<function\>\s\+[^()]\+\s*(:\%(^\s*\)\@<=\<begin\>\s*$:\%(^\s*\)\@<=\<return\>:\%(^\s*\)\@<=\<end\>\s*;\s*$,' .
    \ '\%(^\s*\)\@<=\<repeat\>\s*$:\%(^\s*\)\@<=\<until\>\s\+.\{-}\s*;\s*$,' .
    \ '\%(^\s*\)\@<=\<switch\>\s*(.\{-}):\%(^\s*\)\@<=\<\%(case\|default\)\>:\%(^\s*\)\@<=\<endswitch\>\s*;\s*$,' .
    \ '\%(^\s*\)\@<=\<while\>\s*(.\{-}):\%(^\s*\)\@<=\<endwhile\>\s*;\s*$,' .
    \ '\%(^\s*\)\@<=\<for\>.\{-}\<\%(to\|downto\)\>:\%(^\s*\)\@<=\<endfor\>\s*;\s*$,' .
    \ '\%(^\s*\)\@<=\<if\>\s*(.\{-})\s*then:\%(^\s*\)\@<=\<else\s*if\>\s*([^)]*)\s*then:\%(^\s*\)\@<=\<else\>:\%(^\s*\)\@<=\<endif\>\s*;\s*$'
endif

if has("gui_win32") && !exists("b:browsefilter")
    let b:browsefilter = "InstallShield Files (*.rul)\t*.rul\n" .
		       \ "All Files (*.*)\t*.*\n"
endif

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                " Vim filetype plugin
" Language:	J
" Maintainer:	David B√ºrgin <dbuergin@gluet.ch>
" URL:		https://gitlab.com/glts/vim-j
" Last Change:	2015-10-27

if exists('b:did_ftplugin')
  finish
endif
let b:did_ftplugin = 1

let s:save_cpo = &cpo
set cpo&vim

setlocal iskeyword=48-57,A-Z,a-z,_
setlocal comments=:NB.
setlocal commentstring=NB.\ %s
setlocal formatoptions-=t
setlocal matchpairs=(:)
setlocal path-=/usr/include

" Includes. To make the shorthand form "require 'web/cgi'" work, double the
" last path component. Also strip off leading folder names like "~addons/".
setlocal include=\\v^\\s*(load\|require)\\s*'\\zs\\f+\\ze'
setlocal includeexpr=substitute(substitute(tr(v:fname,'\\','/'),'\\v^[^~][^/.]*(/[^/.]+)$','&\\1',''),'\\v^\\~[^/]+/','','')
setlocal suffixesadd=.ijs

let b:undo_ftplugin = 'setlocal suffixesadd< includeexpr< include< path< matchpairs< formatoptions< commentstring< comments< iskeyword<'

" Section movement with ]] ][ [[ []. The start/end patterns below are amended
" inside the function in order to avoid matching on the current cursor line.
let s:sectionstart = '\%(\s*Note\|.\{-}\<\%([0-4]\|13\|noun\|adverb\|conjunction\|verb\|monad\|dyad\)\s\+\%(:\s*0\|def\s\+0\|define\)\)\>.*'
let s:sectionend = '\s*)\s*'

function! s:SearchSection(end, backwards, visualmode) abort
  if a:visualmode !=# ''
    normal! gv
  endif
  let l:flags = a:backwards ? 'bsW' : 'sW'
  if a:end
    call search('^' . s:sectionend . (a:backwards ? '\n\_.\{-}\%#' : '$'), l:flags)
  else
    call search('^' . s:sectionstart . (a:backwards ? '\n\_.\{-}\%#' : '$'), l:flags)
  endif
endfunction

noremap <buffer> <silent> ]] :<C-U>call <SID>SearchSection(0, 0, '')<CR>
xnoremap <buffer> <silent> ]] :<C-U>call <SID>SearchSection(0, 0, visualmode())<CR>
sunmap <buffer> ]]
noremap <buffer> <silent> ][ :<C-U>call <SID>SearchSection(1, 0, '')<CR>
xnoremap <buffer> <silent> ][ :<C-U>call <SID>SearchSection(1, 0, visualmode())<CR>
sunmap <buffer> ][
noremap <buffer> <silent> [[ :<C-U>call <SID>SearchSection(0, 1, '')<CR>
xnoremap <buffer> <silent> [[ :<C-U>call <SID>SearchSection(0, 1, visualmode())<CR>
sunmap <buffer> [[
noremap <buffer> <silent> [] :<C-U>call <SID>SearchSection(1, 1, '')<CR>
xnoremap <buffer> <silent> [] :<C-U>call <SID>SearchSection(1, 1, visualmode())<CR>
sunmap <buffer> []

let b:undo_ftplugin .= ' | silent! execute "unmap <buffer> ]]"'
                   \ . ' | silent! execute "unmap <buffer> ]["'
                   \ . ' | silent! execute "unmap <buffer> [["'
                   \ . ' | silent! execute "unmap <buffer> []"'

" Browse dialog filter on Windows (see ":help browsefilter")
if has('gui_win32') && !exists('b:browsefilter')
  let b:browsefilter = "J Script Files (*.ijs)\t*.ijs\n"
                   \ . "All Files (*.*)\t*.*\n"
  let b:undo_ftplugin .= ' | unlet! b:browsefilter'
endif

" Enhanced "%" matching (see ":help matchit")
if exists('loaded_matchit') && !exists('b:match_words')
  let b:match_ignorecase = 0
  let b:match_words = '^\%(\s*Note\|.\{-}\<\%([0-4]\|13\|noun\|adverb\|conjunction\|verb\|monad\|dyad\)\s\+\%(\:\s*0\|def\s\+0\|define\)\)\>:^\s*\:\s*$:^\s*)\s*$'
                  \ . ',\<\%(for\%(_\a\k*\)\=\|if\|select\|try\|whil\%(e\|st\)\)\.:\<\%(case\|catch[dt]\=\|else\%(if\)\=\|fcase\)\.:\<end\.'
  let b:undo_ftplugin .= ' | unlet! b:match_ignorecase b:match_words'
endif

let &cpo = s:save_cpo
unlet s:save_cpo
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               " Vim filetype plugin file
" Language:	Java
" Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
" Last Change:  2012 Mar 11
" URL:		http://dwsharp.users.sourceforge.net/vim/ftplugin

if exists("b:did_ftplugin") | finish | endif
let b:did_ftplugin = 1

" Make sure the continuation lines below do not cause problems in
" compatibility mode.
let s:save_cpo = &cpo
set cpo-=C

" For filename completion, prefer the .java extension over the .class
" extension.
set suffixes+=.class

" Enable gf on import statements.  Convert . in the package
" name to / and append .java to the name, then search the path.
setlocal includeexpr=substitute(v:fname,'\\.','/','g')
setlocal suffixesadd=.java
if exists("g:ftplugin_java_source_path")
    let &l:path=g:ftplugin_java_source_path . ',' . &l:path
endif

" Set 'formatoptions' to break comment lines but not other lines,
" and insert the comment leader when hitting <CR> or using "o".
setlocal formatoptions-=t formatoptions+=croql

" Set 'comments' to format dashed lists in comments. Behaves just like C.
setlocal comments& comments^=sO:*\ -,mO:*\ \ ,exO:*/

setlocal commentstring=//%s

" Change the :browse e filter to primarily show Java-related files.
if has("gui_win32")
    let  b:browsefilter="Java Files (*.java)\t*.java\n" .
		\	"Properties Files (*.prop*)\t*.prop*\n" .
		\	"Manifest Files (*.mf)\t*.mf\n" .
		\	"All Files (*.*)\t*.*\n"
endif

" Undo the stuff we changed.
let b:undo_ftplugin = "setlocal suffixes< suffixesadd<" .
		\     " formatoptions< comments< commentstring< path< includeexpr<" .
		\     " | unlet! b:browsefilter"

" Restore the saved compatibility options.
let &cpo = s:save_cpo
unlet s:save_cpo
                                                                                                                                                                                                                                                                                                                                                                          " Vim filetype plugin file
" Language:     Javascript
" Maintainer:   Doug Kearns <dougkearns@gmail.com>
" Last Change:  2020 Jun 23
" Contributor:  Romain Lafourcade <romainlafourcade@gmail.com>

if exists("b:did_ftplugin")
    finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo-=C

" Set 'formatoptions' to break comment lines but not other lines,
" and insert the comment leader when hitting <CR> or using "o".
setlocal formatoptions-=t formatoptions+=croql

" Set completion with CTRL-X CTRL-O to autoloaded function.
if exists('&ofu')
    setlocal omnifunc=javascriptcomplete#CompleteJS
endif

" Set 'comments' to format dashed lists in comments.
setlocal comments=sO:*\ -,mO:*\ \ ,exO:*/,s1:/*,mb:*,ex:*/,://

setlocal commentstring=//%s

" Change the :browse e filter to primarily show JavaScript-related files.
if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
    let b:browsefilter =
                \ "JavaScript Files (*.js)\t*.js\n"
                \ .. "JSX Files (*.jsx)\t*.jsx\n"
                \ .. "JavaScript Modules (*.es, *.es6, *.cjs, *.mjs, *.jsm)\t*.es;*.es6;*.cjs;*.mjs;*.jsm\n"
                \ .. "Vue Templates (*.vue)\t*.vue\n"
                \ .. "JSON Files (*.json)\t*.json\n"
                \ .. "All Files (*.*)\t*.*\n"
endif

" The following suffixes should be implied when resolving filenames
setlocal suffixesadd+=.js,.jsx,.es,.es6,.cjs,.mjs,.jsm,.vue,.json

" The following suffixes should have low priority
"   .snap    jest snapshot
setlocal suffixes+=.snap

" Remove irrelevant part of 'path'.
" User is expected to augment it with contextually-relevant paths
setlocal path-=/usr/include

" Matchit configuration
if exists("loaded_matchit")
    let b:match_ignorecase = 0
    let b:match_words =
                \ '\<do\>:\<while\>,'
                \ .. '<\@<=\([^ \t>/]\+\)\%(\s\+[^>]*\%([^/]>\|$\)\|>\|$\):<\@<=/\1>,'
                \ .. '<\@<=\%([^ \t>/]\+\)\%(\s\+[^/>]*\|$\):/>'
endif

" Set 'define' to a comprehensive value
let &l:define =
            \ '\(^\s*(*async\s\+function\|(*function\)'
            \ .. '\|^\s*\(\*\|static\|async\|get\|set\|\i\+\.\)'
            \ .. '\|^\s*\(\ze\i\+\)\(([^)]*).*{$\|\s*[:=,]\)'
            \ .. '\|^\s*\(export\s\+\|export\s\+default\s\+\)*\(var\|let\|const\|function\|class\)'
            \ .. '\|\<as\>'

let b:undo_ftplugin =
            \ "setl fo< ofu< com< cms< sua< su< def< pa<"
            \ .. "| unlet! b:browsefilter b:match_ignorecase b:match_words"

let &cpo = s:cpo_save
unlet s:cpo_save

" vim: textwidth=78 tabstop=8 shiftwidth=4 softtabstop=4 expandtab
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   " Vim filetype plugin file
" Language:	JavaScript React
" Maintainer:	Doug Kearns <dougkearns@gmail.com>
" Last Change:	2020 Aug 19

" Placeholder for backwards compatilibity: .jsx used to stand for JavaScript.
runtime! ftplugin/javascript.vim
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            " Vim filetype plugin
" Language:	Java properties file
" Maintainer:	None
" Last Change:	2019 Dec 01

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

setlocal formatoptions-=t
setlocal comments=:#,:!
setlocal commentstring=#\ %s

let b:undo_ftplugin = "setl cms< com< fo<"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            " Vim filetype plugin
" Language:		JSON
" Maintainer:		David Barnett <daviebdawg+vim@gmail.com>
" Last Change:		2014 Jul 16

if exists('b:did_ftplugin')
  finish
endif
let b:did_ftplugin = 1

let b:undo_ftplugin = 'setlocal formatoptions< comments< commentstring<'

setlocal formatoptions-=t

" JSON has no comments.
setlocal comments=
setlocal commentstring=
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        " Vim filetype plugin
" Language:         JSONC (JSON with Comments)
" Original Author:  Izhak Jakov <izhak724@gmail.com>
" Acknowledgement:  Based off of vim-jsonc maintained by Kevin Locke <kevin@kevinlocke.name>
"                   https://github.com/kevinoid/vim-jsonc
" License:          MIT
" Last Change:      2021 Nov 22

runtime! ftplugin/json.vim

if exists('b:did_ftplugin_jsonc')
  finish
else
  let b:did_ftplugin_jsonc = 1
endif

" Set comment (formatting) related options. {{{1
setlocal commentstring=//%s comments=sO:*\ -,mO:*\ \ ,exO:*/,s1:/*,mb:*,ex:*/,://

" Let Vim know how to disable the plug-in.
let b:undo_ftplugin = 'setlocal commentstring< comments<'
                                                                                                                                                                                                                                                                                                                                                           " Vim filetype plugin file
" Language:	jsp
" Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
" Last Changed: 20 Jan 2009
" URL:		http://dwsharp.users.sourceforge.net/vim/ftplugin

if exists("b:did_ftplugin") | finish | endif

" Make sure the continuation lines below do not cause problems in
" compatibility mode.
let s:save_cpo = &cpo
set cpo-=C

" Define some defaults in case the included ftplugins don't set them.
let s:undo_ftplugin = ""
let s:browsefilter = "Java Files (*.java)\t*.java\n" .
	    \	 "HTML Files (*.html, *.htm)\t*.html;*.htm\n" .
	    \	 "All Files (*.*)\t*.*\n"
let s:match_words = ""

runtime! ftplugin/html.vim ftplugin/html_*.vim ftplugin/html/*.vim
unlet b:did_ftplugin

" Override our defaults if these were set by an included ftplugin.
if exists("b:undo_ftplugin")
    let s:undo_ftplugin = b:undo_ftplugin
    unlet b:undo_ftplugin
endif
if exists("b:browsefilter")
    let s:browsefilter = b:browsefilter
    unlet b:browsefilter
endif
if exists("b:match_words")
    let s:match_words = b:match_words
    unlet b:match_words
endif

runtime! ftplugin/java.vim ftplugin/java_*.vim ftplugin/java/*.vim
let b:did_ftplugin = 1

" Combine the new set of values with those previously included.
if exists("b:undo_ftplugin")
    let s:undo_ftplugin = b:undo_ftplugin . " | " . s:undo_ftplugin
endif
if exists ("b:browsefilter")
    let s:browsefilter = b:browsefilter . s:browsefilter
endif
if exists("b:match_words")
    let s:match_words = b:match_words . ',' . s:match_words
endif

" Load the combined list of match_words for matchit.vim
if exists("loaded_matchit")
    let b:match_words = s:match_words
endif

" Change the :browse e filter to primarily show JSP-related files.
if has("gui_win32")
    let  b:browsefilter="JSP Files (*.jsp)\t*.jsp\n" . s:browsefilter
endif

" Undo the stuff we changed.
let b:undo_ftplugin = "unlet! b:browsefilter b:match_words | " . s:undo_ftplugin

" Restore the saved compatibility options.
let &cpo = s:save_cpo
unlet s:save_cpo
                                     " Vim filetype plugin file
" Language:	Julia
" Maintainer:	Carlo Baldassi <carlobaldassi@gmail.com>
" Homepage:	https://github.com/JuliaEditorSupport/julia-vim
" Last Change:	2021 Aug 04
" adapted from upstream 2021 Aug 4

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:save_cpo = &cpo
set cpo-=C

setlocal include=^\\s*\\%(reload\\\|include\\)\\>
setlocal suffixesadd=.jl
setlocal comments=:#
setlocal commentstring=#\ %s
setlocal cinoptions+=#1
setlocal define=^\\s*macro\\>
setlocal fo-=t fo+=croql

let b:julia_vim_loaded = 1

let b:undo_ftplugin = "setlocal include< suffixesadd< comments< commentstring<"
      \ . " define< fo< shiftwidth< expandtab< indentexpr< indentkeys< cinoptions< completefunc<"
      \ . " | unlet! b:julia_vim_loaded"

" MatchIt plugin support
if exists("loaded_matchit")
  let b:match_ignorecase = 0

  " note: begin_keywords must contain all blocks, in order
  " for nested-structures-skipping to work properly
  " note: 'mutable struct' and 'struct' are defined separately because
  " using \? puts the cursor on 'struct' instead of 'mutable' for some reason
  let b:julia_begin_keywords = '\%(\.\s*\|@\)\@<!\<\%(function\|macro\|begin\|mutable\s\+struct\|\%(mutable\s\+\)\@<!struct\|\%(abstract\|primitive\)\s\+type\|let\|do\|\%(bare\)\?module\|quote\|if\|for\|while\|try\)\>'
  " note: the following regex not only recognizes macros, but also local/global keywords.
  " the purpose is recognizing things like `@inline myfunction()`
  " or `global myfunction(...)` etc, for matchit and block movement functionality
  let s:macro_regex = '\%(@\%([#(]\@!\S\)\+\|\<\%(local\|global\)\)\s\+'
  let s:nomacro = '\%(' . s:macro_regex . '\)\@<!'
  let s:yesmacro = s:nomacro . '\%('. s:macro_regex . '\)\+'
  let b:julia_begin_keywordsm = '\%(' . s:yesmacro . b:julia_begin_keywords . '\)\|'
        \ . '\%(' . s:nomacro . b:julia_begin_keywords . '\)'
  let b:julia_end_keywords = '\<end\>'

  " note: this function relies heavily on the syntax file
  function! JuliaGetMatchWords()
    let [l,c] = [line('.'),col('.')]
    let attr = synIDattr(synID(l, c, 1),"name")
    let c1 = c
    while attr == 'juliaMacro' || expand('<cword>') =~# '\<\%(global\|local\)\>'
      normal! W
      if line('.') > l || col('.') == c1
        call cursor(l, c)
        return ''
      endif
      let attr = synIDattr(synID(l, col('.'), 1),"name")
      let c1 = col('.')
    endwhile
    call cursor(l, c)
    if attr == 'juliaConditional'
      return b:julia_begin_keywordsm . ':\<\%(elseif\|else\)\>:' . b:julia_end_keywords
    elseif attr =~# '\<\%(juliaRepeat\|juliaRepKeyword\)\>'
      return b:julia_begin_keywordsm . ':\<\%(break\|continue\)\>:' . b:julia_end_keywords
    elseif attr == 'juliaBlKeyword'
      return b:julia_begin_keywordsm . ':' . b:julia_end_keywords
    elseif attr == 'juliaException'
      return b:julia_begin_keywordsm . ':\<\%(catch\|finally\)\>:' . b:julia_end_keywords
    endif
    return '\<\>:\<\>'
  endfunction

  let b:match_words = 'JuliaGetMatchWords()'

  " we need to skip everything within comments, strings and
  " the 'begin' and 'end' keywords when they are used as a range rather than as
  " the delimiter of a block
  let b:match_skip = 'synIDattr(synID(line("."),col("."),0),"name") =~# '
        \ . '"\\<julia\\%(Comprehension\\%(For\\|If\\)\\|RangeKeyword\\|Comment\\%([LM]\\|Delim\\)\\|\\%([bs]\\|Shell\\|Printf\\|Doc\\)\\?String\\|StringPrefixed\\|DocStringM\\(Raw\\)\\?\\|RegEx\\|SymbolS\\?\\|Dotted\\)\\>"'

  let b:undo_ftplugin = b:undo_ftplugin
        \ . " | unlet! b:match_words b:match_skip b:match_ignorecase"
        \ . " | unlet! b:julia_begin_keywords b:julia_end_keywords"
        \ . " | delfunction JuliaGetMatchWords"

endif

let &cpo = s:save_cpo
unlet s:save_cpo
                                                                                                                                                                                                                                                                                                                     m   kconfig.vim n   kwt.vim o   ld.vim  p   less.vimq   lftp.vimr   	libao.vim   s   
limits.vim  t   
liquid.vim  u   lisp.vimv   logcheck.vimw   loginaccess.vim x   logindefs.vim   y   logtalk.dictz   logtalk.vim {   lprolog.vim |   lua.vim }   m3build.vim ~   m3quake.vim    m4.vim  Ä   mail.vimÅ   mailaliases.vim Ç   mailcap.vim É   make.vimÑ   man.vim Ö   manconf.vim Ü   markdown.vimá   masm.vimà   
matlab.vim  â   	meson.vim   ä   mf.vim  ã   mma.vim å   modconf.vim ç   modula2.vim é   modula3.vim è   mp.vim  ê   mplayerconf.vim ë   mrxvtrc.vim í   msmessages.vim  ì   
muttrc.vim  î   
nanorc.vim  ï   neomuttrc.vim   ñ   	netrc.vim   ó   	nginx.vim   ò   	nroff.vim   ô   nsis.vimö   objc.vimõ   	ocaml.vim   ú   	occam.vim   ù   
octave.vim  û   pamconf.vim ü   
pascal.vim  †   
passwd.vim  °   	pbtxt.vim       " Vim filetype plugin file
" Vim syntax file
" Maintainer:           Christian Brabandt <cb@256bit.org>
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2015-05-29
" License:              Vim (see :h license)
" Repository:		https://github.com/chrisbra/vim-kconfig

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

" For matchit.vim
if exists("loaded_matchit")
  let b:match_words = '^\<menu\>:\<endmenu\>,^\<if\>:\<endif\>,^\<choice\>:\<endchoice\>'
endif

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                 " Vim filetype plugin file
" Language:	Kimwitu++
" Maintainer:	Michael Piefel <entwurf@piefel.de>
" Last Change:	10 March 2012

" Behaves almost like C++
runtime! ftplugin/cpp.vim ftplugin/cpp_*.vim ftplugin/cpp/*.vim

let s:cpo_save = &cpo
set cpo&vim

" Limit the browser to related files
if has("gui_win32") && !exists("b:browsefilter")
    let b:browsefilter = "Kimwitu/Kimwitu++ Files (*.k)\t*.k\n" .
		\ "Lex/Flex Files (*.l)\t*.l\n" .
		\ "Yacc/Bison Files (*.y)\t*.y\n" .
		\ "All Files (*.*)\t*.*\n"
endif

" Set the errorformat for the Kimwitu++ compiler
set efm+=kc%.%#:\ error\ at\ %f:%l:\ %m

if exists("b:undo_ftplugin")
    let b:undo_ftplugin = b:undo_ftplugin . " | setlocal efm<"
	\ . "| unlet! b:browsefiler"
else
    let b:undo_ftplugin = "setlocal efm<"
	\ . "| unlet! b:browsefiler"
endif

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                             " Vim filetype plugin file
" Language:             ld(1) script
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< inc< fo<"

setlocal comments=s1:/*,mb:*,ex:*/ commentstring=/*%s*/ include=^\\s*INCLUDE
setlocal formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          " Vim filetype plugin
" Language:	less
" Maintainer:	Alessandro Vioni <jenoma@gmail.com>
" URL: https://github.com/genoma/vim-less
" Last Change:	2014 November 24

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let b:undo_ftplugin = "setl cms< def< inc< inex< ofu< sua<"

setlocal formatoptions-=t formatoptions+=croql

setlocal comments=:// commentstring=//\ %s

setlocal omnifunc=csscomplete#CompleteCSS
setlocal suffixesadd=.less
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          " Vim filetype plugin file
" Language:             lftp(1) configuration file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              " Vim filetype plugin file
" Language:             libao.conf(5) configuration file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        " Vim filetype plugin file
" Language:             limits(5) configuration file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            " Vim filetype plugin
" Language:     Liquid
" Maintainer:   Tim Pope <vimNOSPAM@tpope.org>
" Last Change:	2010 May 21

if exists('b:did_ftplugin')
  finish
endif

if !exists('g:liquid_default_subtype')
  let g:liquid_default_subtype = 'html'
endif

if !exists('b:liquid_subtype')
  let s:lines = getline(1)."\n".getline(2)."\n".getline(3)."\n".getline(4)."\n".getline(5)."\n".getline("$")
  let b:liquid_subtype = matchstr(s:lines,'liquid_subtype=\zs\w\+')
  if b:liquid_subtype == ''
    let b:liquid_subtype = matchstr(&filetype,'^liquid\.\zs\w\+')
  endif
  if b:liquid_subtype == ''
    let b:liquid_subtype = matchstr(substitute(expand('%:t'),'\c\%(\.liquid\)\+$','',''),'\.\zs\w\+$')
  endif
  if b:liquid_subtype == ''
    let b:liquid_subtype = g:liquid_default_subtype
  endif
endif

if exists('b:liquid_subtype') && b:liquid_subtype != ''
  exe 'runtime! ftplugin/'.b:liquid_subtype.'.vim ftplugin/'.b:liquid_subtype.'_*.vim ftplugin/'.b:liquid_subtype.'/*.vim'
else
  runtime! ftplugin/html.vim ftplugin/html_*.vim ftplugin/html/*.vim
endif
let b:did_ftplugin = 1

if exists('b:undo_ftplugin')
  let b:undo_ftplugin .= '|'
else
  let b:undo_ftplugin = ''
endif
if exists('b:browsefilter')
  let b:browsefilter = "\n".b:browsefilter
else
  let b:browsefilter = ''
endif
if exists('b:match_words')
  let b:match_words .= ','
elseif exists('loaded_matchit')
  let b:match_words = ''
endif

if has('gui_win32')
  let b:browsefilter="Liquid Files (*.liquid)\t*.liquid" . b:browsefilter
endif

if exists('loaded_matchit')
  let b:match_words .= '\<\%(if\w*\|unless\|case\)\>:\<\%(elsif\|else\|when\)\>:\<end\%(if\w*\|unless\|case\)\>,\<\%(for\|tablerow\)\>:\%({%\s*\)\@<=empty\>:\<end\%(for\|tablerow\)\>,<\(capture\|comment\|highlight\)\>:\<end\1\>'
endif

setlocal commentstring={%\ comment\ %}%s{%\ endcomment\ %}

let b:undo_ftplugin .= 'setl cms< | unlet! b:browsefilter b:match_words'
                                                                                                                                                       " Vim filetype plugin
" Language:      Lisp
" Maintainer:    Sergey Khorev <sergey.khorev@gmail.com>
" URL:		 http://sites.google.com/site/khorser/opensource/vim
" Original author:    Dorai Sitaram <ds26@gte.com>
" Original URL:		 http://www.ccs.neu.edu/~dorai/vimplugins/vimplugins.html
" Last Change:   Mar 10, 2021

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

setl comments=:;;;;,:;;;,:;;,:;,sr:#\|,mb:\|,ex:\|#
setl define=^\\s*(def\\k*
setl formatoptions-=t
setl iskeyword+=+,-,*,/,%,<,=,>,:,$,?,!,@-@,94
setl lisp
setl commentstring=;%s

let b:undo_ftplugin = "setlocal comments< define< formatoptions< iskeyword< lisp< commentstring<"
                                                                                                                                                                                                                                                                         " Vim filetype plugin file
" Language:    Logcheck
" Maintainer:  Debian Vim Maintainers
" Last Change: 2018 Dec 27
" License:     Vim License
" URL: https://salsa.debian.org/vim-team/vim-debian/blob/master/ftplugin/logcheck.vim

if exists('b:did_ftplugin')
    finish
endif
let b:did_ftplugin = 1

let b:undo_ftplugin = 'setl fo<'

" Do not hard-wrap non-comment lines since each line is a self-contained
" regular expression
setlocal formatoptions-=t
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           " Vim filetype plugin file
" Language:             login.access(5) configuration file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      " Vim filetype plugin file
" Language:             login.defs(5) configuration file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        abolish
abolish_category
abolish_events
abolish_object
abolish_protocol
abs
acos
acyclic_term
after
alias
always_true_or_false_goals
arg
asin
asserta
assertz
atan
atan2
atom
atomic
atom_chars
atom_chars
atom_codes
atom_codes
atom_concat
atom_concat
atom_length
at_end_of_stream
bagof
before
built_in
call
callable
calls
catch
category
category_property
ceiling
char_code
char_conversion
clause
clean
close
code_prefix
coinduction
coinductive
compare
complements
complements
complements_object
compound
conforms_to_protocol
context
context_switching_calls
copy_term
cos
create_category
create_logtalk_flag
create_object
create_protocol
current_category
current_char_conversion
current_event
current_input
current_logtalk_flag
current_object
current_op
current_output
current_predicate
current_prolog_flag
current_protocol
debug
define_events
deprecated
discontiguous
div
domain_error
duplicated_directives
dynamic
dynamic_declarations
elif
else
encoding
encoding_directive
endif
end_category
end_object
end_protocol
engines
ensure_loaded
evaluation_error
events
existence_error
exp
expand_goal
expand_term
export
extends
extends_category
extends_object
extends_protocol
fail
false
findall
float
float_fractional_part
float_integer_part
floor
flush_output
forall
forward
functor
get_byte
get_char
get_code
goal_expansion
ground
halt
hook
if
ignore
implements
implements_protocol
imports
imports_category
include
info
initialization
instantiates
instantiates_class
instantiation_error
integer
keysort
lambda_variables
log
logtalk_compile
logtalk_library_path
logtalk_load
logtalk_load_context
logtalk_make
logtalk_make_target_action
max
meta_non_terminal
meta_predicate
min
missing_directives
mod
mode
modules
multifile
nl
nonvar
number
numbervars
number_chars
number_chars
number_codes
number_codes
object
object_property
once
op
open
optimize
parameter
peek_byte
peek_char
peek_code
permission_error
phrase
portability
predicate_property
private
prolog_compatible_version
prolog_compiler
prolog_dialect
prolog_loader
prolog_version
protected
protocol
protocol_property
public
put_byte
put_char
put_code
read
read_term
redefined_built_ins
reexport
reload
rem
repeat
report
representation_error
resource_error
retract
retractall
round
scratch_directory
self
sender
setof
set_input
set_logtalk_flag
set_output
set_prolog_flag
set_stream_position
sign
sin
singleton_variables
sort
source_data
specializes
specializes_class
sqrt
stream_property
subsumes_term
sub_atom
suspicious_calls
synchronized
syntax_error
system_error
tabling
tan
term_expansion
term_variables
this
threaded
threaded_call
threaded_engine
threaded_engine_create
threaded_engine_destroy
threaded_engine_fetch
threaded_engine_next
threaded_engine_next_reified
threaded_engine_post
threaded_engine_self
threaded_engine_yield
threaded_exit
threaded_ignore
threaded_notify
threaded_once
threaded_peek
threaded_wait
threads
throw
trivial_goal_fails
true
truncate
type_error
undefined_predicates
underscore_variables
unify_with_occurs_check
unknown_entities
unknown_predicates
uses
use_module
var
version
write
writeq
write_canonical
xor
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        " Logtalk filetype plugin file
" Language:         Logtalk
" Maintainer:       Paulo Moura <pmoura@logtalk.org>
" Latest Revision:  2018-08-03

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let b:undo_ftplugin = "setl ts< sw< fdm< fdc< ai< dict<"

setlocal ts=4
setlocal sw=4
setlocal fdm=syntax
setlocal fdn=10
setlocal fdc=2
setlocal autoindent
setlocal dict=$VIMRUNTIME/ftplugin/logtalk.dict
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                " Vim settings file
" Language:     LambdaProlog (Teyjus)
" Maintainer:   Markus Mottl  <markus.mottl@gmail.com>
" URL:          http://www.ocaml.info/vim/ftplugin/lprolog.vim
" Last Change:  2006 Feb 05
"               2001 Sep 16 - fixed 'no_mail_maps'-bug (MM)
"               2001 Sep 02 - initial release  (MM)

" Only do these settings when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Don't do other file type settings for this buffer
let b:did_ftplugin = 1

" Error format
setlocal efm=%+A./%f:%l.%c:\ %m formatprg=fmt\ -w75\ -p\\%

" Formatting of comments
setlocal formatprg=fmt\ -w75\ -p\\%

" Add mappings, unless the user didn't want this.
if !exists("no_plugin_maps") && !exists("no_lprolog_maps")
  " Uncommenting
  if !hasmapto('<Plug>Comment')
    nmap <buffer> <LocalLeader>c <Plug>LUncomOn
    vmap <buffer> <LocalLeader>c <Plug>BUncomOn
    nmap <buffer> <LocalLeader>C <Plug>LUncomOff
    vmap <buffer> <LocalLeader>C <Plug>BUncomOff
  endif

  nnoremap <buffer> <Plug>LUncomOn mz0i/* <ESC>$A */<ESC>`z
  nnoremap <buffer> <Plug>LUncomOff <ESC>:s/^\/\* \(.*\) \*\//\1/<CR>
  vnoremap <buffer> <Plug>BUncomOn <ESC>:'<,'><CR>`<O<ESC>0i/*<ESC>`>o<ESC>0i*/<ESC>`<
  vnoremap <buffer> <Plug>BUncomOff <ESC>:'<,'><CR>`<dd`>dd`<
endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 " Vim filetype plugin file.
" Language:	        Lua
" Maintainer:		Doug Kearns <dougkearns@gmail.com>
" Previous Maintainer:	Max Ischenko <mfi@ukr.net>
" Last Change:	        2021 Nov 15

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

" Set 'formatoptions' to break comment lines but not other lines, and insert
" the comment leader when hitting <CR> or using "o".
setlocal formatoptions-=t formatoptions+=croql

setlocal comments=:--
setlocal commentstring=--%s
setlocal suffixesadd=.lua

let b:undo_ftplugin = "setlocal fo< com< cms< sua<"

if exists("loaded_matchit") && !exists("b:match_words")
  let b:match_ignorecase = 0
  let b:match_words =
        \ '\<\%(do\|function\|if\)\>:' .
        \ '\<\%(return\|else\|elseif\)\>:' .
        \ '\<end\>,' .
        \ '\<repeat\>:\<until\>,' .
        \ '\%(--\)\=\[\(=*\)\[:]\1]'
  let b:undo_ftplugin .= " | unlet! b:match_words b:match_ignorecase"
endif

if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
  let b:browsefilter = "Lua Source Files (*.lua)\t*.lua\n" .
	\              "All Files (*.*)\t*.*\n"
  let b:undo_ftplugin .= " | unlet! b:browsefilter"
endif

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 " Vim filetype plugin file
" Language:	Modula-3 Makefile
" Maintainer:	Doug Kearns <dougkearns@gmail.com>
" Last Change:	2021 April 15

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

runtime! ftplugin/m3quake.vim

if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
  let b:browsefilter = "Modula-3 Makefile (m3makefile m3overrides)\tm3makefile;m3overrides\n" ..
	\	       "All Files (*.*)\t*.*\n"
endif

let &cpo = s:cpo_save
unlet s:cpo_save

" vim: nowrap sw=2 sts=2 ts=8 noet:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       " Vim filetype plugin file
" Language:	Modula-3 Quake
" Maintainer:	Doug Kearns <dougkearns@gmail.com>
" Last Change:	2021 April 15

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

setlocal comments=s1:/*,mb:*,ex:*/,:%
setlocal commentstring=%\ %s
setlocal formatoptions-=t formatoptions+=croql

if exists("loaded_matchit") && !exists("b:match_words")
  let b:match_words = '\<\%(proc\|if\|foreach\)\>:\<else\>:\<end\>'
endif

if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
  let b:browsefilter = "Modula-3 Quake Source Files (*.quake)\t*.quake\n" ..
	\	       "All Files (*.*)\t*.*\n"
endif

let b:undo_ftplugin = "setl fo< com< cms< " ..
      \		      "| unlet! b:browsefilter b:match_words"

let &cpo = s:cpo_save
unlet s:cpo_save

" vim: nowrap sw=2 sts=2 ts=8 noet:
                                                                                                                                                                                " Vim filetype plugin file
" Language:             m4
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:#,:dnl commentstring=dnl\ %s
setlocal formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      " Vim filetype plugin file
" Language:	Mail
" Maintainer:	Bram Moolenaar <Bram@vim.org>
" Last Change:	2021 Oct 23

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let b:undo_ftplugin = "setl modeline< tw< fo< comments<"

" Don't use modelines in e-mail messages, avoid trojan horses and nasty
" "jokes" (e.g., setting 'textwidth' to 5).
setlocal nomodeline

" many people recommend keeping e-mail messages 72 chars wide
if &tw == 0
  setlocal tw=72
endif

" Set 'formatoptions' to break text lines and keep the comment leader ">".
setlocal fo+=tcql

" Add n:> to 'comments, in case it was removed elsewhere
setlocal comments+=n:>

" .eml files are universally formatted with DOS line-endings, per RFC5322.
" If the file was not DOS the it will be marked as changed, which is probably
" a good thing.
if expand('%:e') ==? 'eml'
  let b:undo_ftplugin ..= " fileformat=" .. &fileformat
  setlocal fileformat=dos
endif

" Add mappings, unless the user doesn't want this.
if !exists("no_plugin_maps") && !exists("no_mail_maps")
  " Quote text by inserting "> "
  if !hasmapto('<Plug>MailQuote')
    vmap <buffer> <LocalLeader>q <Plug>MailQuote
    nmap <buffer> <LocalLeader>q <Plug>MailQuote
  endif
  vnoremap <buffer> <Plug>MailQuote :s/^/> /<CR>:noh<CR>``
  nnoremap <buffer> <Plug>MailQuote :.,$s/^/> /<CR>:noh<CR>``
endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                " Vim filetype plugin file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 " Vim filetype plugin file
" Language:             Mailcap configuration file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              " Vim filetype plugin file
" Language:	Make
" Maintainer:	Bram Moolenaar <Bram@vim.org>
" Last Change:	2020 Oct 16

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let b:undo_ftplugin = "setl et< sts< sw< fo< com< cms< inc<"

" Make sure a hard tab is used, required for most make programs
setlocal noexpandtab softtabstop=0 shiftwidth=0

" Set 'formatoptions' to break comment lines but not other lines,
" and insert the comment leader when hitting <CR> or using "o".
setlocal fo-=t fo+=croql

" Set 'comments' to format dashed lists in comments
setlocal com=sO:#\ -,mO:#\ \ ,b:#

" Set 'commentstring' to put the marker after a #.
setlocal commentstring=#\ %s

" Including files.
let &l:include = '^\s*include'

" For matchit.vim, suggested by Albert Netymk and Ken Takata.
if exists("loaded_matchit")
  let b:match_words = '^ *ifn\=\(eq\|def\)\>:^ *else\(\s\+ifn\=\(eq\|def\)\)\=\>:^ *endif\>,\<define\>:\<endef\>,^!\s*if\(n\=def\)\=\>:^!\s*else\(if\(n\=def\)\=\)\=\>:^!\s*endif\>'
endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             " Vim filetype plugin file
" Language:	man
" Maintainer:	Jason Franklin <vim@justemail.net>
" Maintainer:	SungHyun Nam <goweol@gmail.com>
" Last Change: 	2021 Sep 26

" To make the ":Man" command available before editing a manual page, source
" this script from your startup vimrc file.

" If 'filetype' isn't "man", we must have been called to only define ":Man".
if &filetype == "man"

  " Only do this when not done yet for this buffer
  if exists("b:did_ftplugin")
    finish
  endif
  let b:did_ftplugin = 1
endif

let s:cpo_save = &cpo
set cpo-=C

if &filetype == "man"
  " allow dot and dash in manual page name.
  setlocal iskeyword+=\.,-
  let b:undo_ftplugin = "setlocal iskeyword<"

  " Add mappings, unless the user didn't want this.
  if !exists("no_plugin_maps") && !exists("no_man_maps")
    if !hasmapto('<Plug>ManBS')
      nmap <buffer> <LocalLeader>h <Plug>ManBS
      let b:undo_ftplugin = b:undo_ftplugin
	    \ . '|silent! nunmap <buffer> <LocalLeader>h'
    endif
    nnoremap <buffer> <Plug>ManBS :%s/.\b//g<CR>:setl nomod<CR>''

    nnoremap <buffer> <silent> <c-]> :call <SID>PreGetPage(v:count)<CR>
    nnoremap <buffer> <silent> <c-t> :call <SID>PopPage()<CR>
    nnoremap <buffer> <silent> q :q<CR>

    " Add undo commands for the maps
    let b:undo_ftplugin = b:undo_ftplugin
	  \ . '|silent! nunmap <buffer> <Plug>ManBS'
	  \ . '|silent! nunmap <buffer> <c-]>'
	  \ . '|silent! nunmap <buffer> <c-t>'
	  \ . '|silent! nunmap <buffer> q'
  endif

  if exists('g:ft_man_folding_enable') && (g:ft_man_folding_enable == 1)
    setlocal foldmethod=indent foldnestmax=1 foldenable
    let b:undo_ftplugin = b:undo_ftplugin
	  \ . '|silent! setl fdm< fdn< fen<'
  endif

endif

if exists(":Man") != 2
  com -nargs=+ -complete=shellcmd Man call s:GetPage(<q-mods>, <f-args>)
  nmap <Leader>K :call <SID>PreGetPage(0)<CR>
  nmap <Plug>ManPreGetPage :call <SID>PreGetPage(0)<CR>
endif

" Define functions only once.
if !exists("s:man_tag_depth")

let s:man_tag_depth = 0

let s:man_sect_arg = ""
let s:man_find_arg = "-w"
try
  if !has("win32") && $OSTYPE !~ 'cygwin\|linux' && system('uname -s') =~ "SunOS" && system('uname -r') =~ "^5"
    let s:man_sect_arg = "-s"
    let s:man_find_arg = "-l"
  endif
catch /E145:/
  " Ignore the error in restricted mode
endtry

func s:PreGetPage(cnt)
  if a:cnt == 0
    let old_isk = &iskeyword
    if &ft == 'man'
      setl iskeyword+=(,)
    endif
    let str = expand("<cword>")
    let &l:iskeyword = old_isk
    let page = substitute(str, '(*\(\k\+\).*', '\1', '')
    let sect = substitute(str, '\(\k\+\)(\([^()]*\)).*', '\2', '')
    if match(sect, '^[0-9 ]\+$') == -1
      let sect = ""
    endif
    if sect == page
      let sect = ""
    endif
  else
    let sect = a:cnt
    let page = expand("<cword>")
  endif
  call s:GetPage('', sect, page)
endfunc

func s:GetCmdArg(sect, page)

  if empty(a:sect)
    return shellescape(a:page)
  endif

  return s:man_sect_arg . ' ' . shellescape(a:sect) . ' ' . shellescape(a:page)
endfunc

func s:FindPage(sect, page)
  let l:cmd = printf('man %s %s', s:man_find_arg, s:GetCmdArg(a:sect, a:page))
  call system(l:cmd)

  if v:shell_error
    return 0
  endif

  return 1
endfunc

func s:GetPage(cmdmods, ...)
  if a:0 >= 2
    let sect = a:1
    let page = a:2
  elseif a:0 >= 1
    let sect = ""
    let page = a:1
  else
    return
  endif

  " To support:	    nmap K :Man <cword>
  if page == '<cword>'
    let page = expand('<cword>')
  endif

  if !exists('g:ft_man_no_sect_fallback') || (g:ft_man_no_sect_fallback == 0)
    if sect != "" && s:FindPage(sect, page) == 0
      let sect = ""
    endif
  endif
  if s:FindPage(sect, page) == 0
    let msg = 'man.vim: no manual entry for "' . page . '"'
    if !empty(sect)
      let msg .= ' in section ' . sect
    endif
    echomsg msg
    return
  endif
  exec "let s:man_tag_buf_".s:man_tag_depth." = ".bufnr("%")
  exec "let s:man_tag_lin_".s:man_tag_depth." = ".line(".")
  exec "let s:man_tag_col_".s:man_tag_depth." = ".col(".")
  let s:man_tag_depth = s:man_tag_depth + 1

  let open_cmd = 'edit'

  " Use an existing "man" window if it exists, otherwise open a new one.
  if &filetype != "man"
    let thiswin = winnr()
    exe "norm! \<C-W>b"
    if winnr() > 1
      exe "norm! " . thiswin . "\<C-W>w"
      while 1
	if &filetype == "man"
	  break
	endif
	exe "norm! \<C-W>w"
	if thiswin == winnr()
	  break
	endif
      endwhile
    endif
    if &filetype != "man"
      if exists("g:ft_man_open_mode")
        if g:ft_man_open_mode == 'vert'
	  let open_cmd = 'vsplit'
        elseif g:ft_man_open_mode == 'tab'
	  let open_cmd = 'tabedit'
        else
	  let open_cmd = 'split'
        endif
      else
	let open_cmd = a:cmdmods . ' split'
      endif
    endif
  endif

  silent execute open_cmd . " $HOME/" . page . '.' . sect . '~'

  " Avoid warning for editing the dummy file twice
  setl buftype=nofile noswapfile

  setl fdc=0 ma nofen nonu nornu
  %delete _
  let unsetwidth = 0
  if empty($MANWIDTH)
    let $MANWIDTH = winwidth(0)
    let unsetwidth = 1
  endif

  " Ensure Vim is not recursively invoked (man-db does this) when doing ctrl-[
  " on a man page reference by unsetting MANPAGER.
  " Some versions of env(1) do not support the '-u' option, and in such case
  " we set MANPAGER=cat.
  if !exists('s:env_has_u')
    call system('env -u x true')
    let s:env_has_u = (v:shell_error == 0)
  endif
  let env_cmd = s:env_has_u ? 'env -u MANPAGER' : 'env MANPAGER=cat'
  let env_cmd .= ' GROFF_NO_SGR=1'
  let man_cmd = env_cmd . ' man ' . s:GetCmdArg(sect, page) . ' | col -b'
  silent exec "r !" . man_cmd

  if unsetwidth
    let $MANWIDTH = ''
  endif
  " Remove blank lines from top and bottom.
  while line('$') > 1 && getline(1) =~ '^\s*$'
    1delete _
  endwhile
  while line('$') > 1 && getline('$') =~ '^\s*$'
    $delete _
  endwhile
  1
  setl ft=man nomod
  setl bufhidden=hide
  setl nobuflisted
  setl noma
endfunc

func s:PopPage()
  if s:man_tag_depth > 0
    let s:man_tag_depth = s:man_tag_depth - 1
    exec "let s:man_tag_buf=s:man_tag_buf_".s:man_tag_depth
    exec "let s:man_tag_lin=s:man_tag_lin_".s:man_tag_depth
    exec "let s:man_tag_col=s:man_tag_col_".s:man_tag_depth
    exec s:man_tag_buf."b"
    exec s:man_tag_lin
    exec "norm! ".s:man_tag_col."|"
    exec "unlet s:man_tag_buf_".s:man_tag_depth
    exec "unlet s:man_tag_lin_".s:man_tag_depth
    exec "unlet s:man_tag_col_".s:man_tag_depth
    unlet s:man_tag_buf s:man_tag_lin s:man_tag_col
  endif
endfunc

endif

let &cpo = s:cpo_save
unlet s:cpo_save

" vim: set sw=2 ts=8 noet:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              " Vim filetype plugin file
" Language:             man.conf(5) - man configuration file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    " Vim filetype plugin
" Language:		Markdown
" Maintainer:		Tim Pope <vimNOSPAM@tpope.org>
" Last Change:		2019 Dec 05

if exists("b:did_ftplugin")
  finish
endif

runtime! ftplugin/html.vim ftplugin/html_*.vim ftplugin/html/*.vim

setlocal comments=fb:*,fb:-,fb:+,n:> commentstring=<!--%s-->
setlocal formatoptions+=tcqln formatoptions-=r formatoptions-=o
setlocal formatlistpat=^\\s*\\d\\+\\.\\s\\+\\\|^[-*+]\\s\\+\\\|^\\[^\\ze[^\\]]\\+\\]:

if exists('b:undo_ftplugin')
  let b:undo_ftplugin .= "|setl cms< com< fo< flp<"
else
  let b:undo_ftplugin = "setl cms< com< fo< flp<"
endif

function! s:NotCodeBlock(lnum) abort
  return synIDattr(synID(v:lnum, 1, 1), 'name') !=# 'markdownCode'
endfunction

function! MarkdownFold() abort
  let line = getline(v:lnum)

  if line =~# '^#\+ ' && s:NotCodeBlock(v:lnum)
    return ">" . match(line, ' ')
  endif

  let nextline = getline(v:lnum + 1)
  if (line =~ '^.\+$') && (nextline =~ '^=\+$') && s:NotCodeBlock(v:lnum + 1)
    return ">1"
  endif

  if (line =~ '^.\+$') && (nextline =~ '^-\+$') && s:NotCodeBlock(v:lnum + 1)
    return ">2"
  endif

  return "="
endfunction

function! s:HashIndent(lnum) abort
  let hash_header = matchstr(getline(a:lnum), '^#\{1,6}')
  if len(hash_header)
    return hash_header
  else
    let nextline = getline(a:lnum + 1)
    if nextline =~# '^=\+\s*$'
      return '#'
    elseif nextline =~# '^-\+\s*$'
      return '##'
    endif
  endif
endfunction

function! MarkdownFoldText() abort
  let hash_indent = s:HashIndent(v:foldstart)
  let title = substitute(getline(v:foldstart), '^#\+\s*', '', '')
  let foldsize = (v:foldend - v:foldstart + 1)
  let linecount = '['.foldsize.' lines]'
  return hash_indent.' '.title.' '.linecount
endfunction

if has("folding") && exists("g:markdown_folding")
  setlocal foldexpr=MarkdownFold()
  setlocal foldmethod=expr
  setlocal foldtext=MarkdownFoldText()
  let b:undo_ftplugin .= " foldexpr< foldmethod< foldtext<"
endif

" vim:set sw=2:
                                                                                 " Vim filetype plugin file
" Language:	Microsoft Macro Assembler (80x86)
" Maintainer:	Wu Yongwei <wuyongwei@gmail.com>
" Last Change:	2020-05-09 23:02:05 +0800

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl iskeyword<"

setlocal iskeyword=@,48-57,_,36,60,62,63,@-@

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          " Vim filetype plugin file
" Language:	matlab
" Maintainer:	Jake Wasserman <jwasserman at gmail dot com>
" Update By:    Gabriel Dupras
" Last Change: 	2021 Aug 30

" Contributors:
" Charles Campbell

if exists("b:did_ftplugin")
	finish
endif
let b:did_ftplugin = 1

let s:save_cpo = &cpo
set cpo-=C

if exists("loaded_matchit")
 let s:conditionalEnd = '\%(\%(^\|;\)\s*\)\@<=end\>'
 let b:match_words=
   \ '\<\%(if\|switch\|for\|while\|try\)\>:\<\%(elseif\|case\|break\|continue\|else\|otherwise\|catch\)\>:' . s:conditionalEnd . ',' .
   \ '\<function\>:\<return\>:\<endfunction\>'
 unlet s:conditionalEnd
endif

setlocal suffixesadd=.m
setlocal suffixes+=.asv
setlocal commentstring=%\ %s

let b:undo_ftplugin = "setlocal suffixesadd< suffixes< commentstring< "
	\ . "| unlet! b:match_words"

let &cpo = s:save_cpo
unlet s:save_cpo
                                                                                                                                                                                             " Vim filetype plugin file
" Language:	meson
" License:	VIM License
" Maintainer:   Liam Beguin <liambeguin@gmail.com>
" Original Author:	Laurent Pinchart <laurent.pinchart@ideasonboard.com>
" Last Change:		2018 Nov 27

if exists("b:did_ftplugin") | finish | endif
let b:did_ftplugin = 1
let s:keepcpo= &cpo
set cpo&vim

setlocal commentstring=#\ %s
setlocal comments=:#
setlocal formatoptions+=croql formatoptions-=t

let b:undo_ftplugin = "setl com< cms< fo<"

if get(g:, "meson_recommended_style", 1)
  setlocal expandtab
  setlocal shiftwidth=2
  setlocal softtabstop=2
  let b:undo_ftplugin .= " | setl et< sts< sw<"
endif

if exists("loaded_matchit") && !exists("b:match_words")
  let b:match_words = '\<if\>:\<elif\>:\<else\>:\<endif\>,' .
	\             '\<foreach\>:\<break\>:\<continue\>:\<endforeach\>'
  let b:undo_ftplugin .= " | unlet! b:match_words"
endif

if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
  let b:browsefilter = "Meson Build Files (meson.build)\tmeson.build\n" .
	\	       "All Files (*.*)\t*.*\n"
  let b:undo_ftplugin .= " | unlet! b:browsefilter"
endif

let &cpo = s:keepcpo
unlet s:keepcpo
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      " Vim filetype plugin file
" Language:           METAFONT
" Maintainer:         Nicola Vitacolonna <nvitacolonna@gmail.com>
" Former Maintainers: Nikolai Weibull <now@bitwi.se>
" Latest Revision:    2016 Oct 2

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo< sua< inc< def< ofu<"
      \ . "| unlet! b:match_ignorecase b:match_words b:match_skip"

setlocal comments=:% commentstring=%\ %s formatoptions-=t formatoptions+=cjroql2
setlocal suffixesadd=.mf
let &l:include = '\<input\>'
let &l:define = '\<\%(let\|newinternal\|interim\|def\|vardef\)\>\|\<\%(primary\|secondary\|tertiary\)def\>\s*[^ .]\+'
setlocal omnifunc=syntaxcomplete#Complete
let g:omni_syntax_group_include_mf = 'mf\w\+'
let g:omni_syntax_group_exclude_mf = 'mfTodoComment'

let s:mp_regex = {
      \ 'beginsection' : '^\s*\%(\%(\|var\|primary\|secondary\|tertiary\)def\|beginchar\|beginlogochar\)\>',
      \ 'endsection'   : '^\s*\%(enddef\|endchar\)\>',
      \ 'beginblock'   : '^\s*\%(begingroup\|if\|for\%(\|suffixes\|ever\)\)\>',
      \ 'endblock'     : '^\s*\%(endgroup\|fi\|endfor\)\>'
      \ }

function! s:move_around(count, what, flags, visual)
  if a:visual
    exe "normal! gv"
  endif
  call search(s:mp_regex[a:what], a:flags.'s') " 's' sets previous context mark
  call map(range(2, a:count), 'search(s:mp_regex[a:what], a:flags)')
endfunction


" Move around macros.
nnoremap <silent><buffer> [[ :<C-U>call <SID>move_around(v:count1, "beginsection", "bW", v:false) <CR>
vnoremap <silent><buffer> [[ :<C-U>call <SID>move_around(v:count1, "beginsection", "bW", v:true)  <CR>
nnoremap <silent><buffer> ]] :<C-U>call <SID>move_around(v:count1, "beginsection", "W",  v:false) <CR>
vnoremap <silent><buffer> ]] :<C-U>call <SID>move_around(v:count1, "beginsection", "W",  v:true)  <CR>
nnoremap <silent><buffer> [] :<C-U>call <SID>move_around(v:count1, "endsection",   "bW", v:false) <CR>
vnoremap <silent><buffer> [] :<C-U>call <SID>move_around(v:count1, "endsection",   "bW", v:true)  <CR>
nnoremap <silent><buffer> ][ :<C-U>call <SID>move_around(v:count1, "endsection",   "W",  v:false) <CR>
vnoremap <silent><buffer> ][ :<C-U>call <SID>move_around(v:count1, "endsection",   "W",  v:true)  <CR>
nnoremap <silent><buffer> [{ :<C-U>call <SID>move_around(v:count1, "beginblock",   "bW", v:false) <CR>
vnoremap <silent><buffer> [{ :<C-U>call <SID>move_around(v:count1, "beginblock",   "bW", v:true)  <CR>
nnoremap <silent><buffer> ]} :<C-U>call <SID>move_around(v:count1, "endblock",     "W",  v:false) <CR>
vnoremap <silent><buffer> ]} :<C-U>call <SID>move_around(v:count1, "endblock",     "W",  v:true)  <CR>

if exists("loaded_matchit")
  let b:match_ignorecase = 0
  let b:match_words =
        \ '\<if\>:\<else\%[if]\>:\<fi\>,' .
        \ '\<for\%(\|suffixes\|ever\)\>:\<exit\%(if\|unless\)\>:\<endfor\>,' .
        \ '\<\%(\|var\|primary\|secondary\|tertiary\)def\>:\<enddef\>,' .
        \ '\<begingroup\>:\<endgroup\>,' .
        \ '\<begin\%(logo\)\?char\>:\<endchar\>'
  " Ignore comments and strings
  let b:match_skip = 'synIDattr(synID(line("."), col("."), 1), "name")
        \ =~# "mf\\(Comment\\|String\\)$"'
endif

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               " Vim filetype plugin file
" Language:	Mathematica
" Maintainer:	Ian Ford <ianf@wolfram.com>
" Last Change:	22 January 2019

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
	finish
endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

let b:undo_ftplugin = "setlocal commentstring<"

setlocal commentstring=\(*%s*\)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  " Vim filetype plugin file
" Language:             modules.conf(5) configuration file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< inc< fo<"

setlocal comments=:# commentstring=#\ %s include=^\\s*include
setlocal formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   " Vim filetype plugin file
" Language:	Modula-2
" Maintainer:	Doug Kearns <dougkearns@gmail.com>
" Last Change:	2021 Apr 08

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

setlocal comments=s0:(*,mb:\ ,ex:*)
setlocal commentstring=(*%s*)
setlocal formatoptions-=t formatoptions+=croql

if exists("loaded_matchit") && !exists("b:match_words")
  " The second branch of the middle pattern is intended to match CASE labels
  let b:match_words = '\<REPEAT\>:\<UNTIL\>,' ..
		    \ '\<\%(BEGIN\|CASE\|FOR\|IF\|LOOP\|WHILE\|WITH\)\>' ..
		    \	':' ..
		    \	'\<\%(ELSIF\|ELSE\)\>\|\%(^\s*\)\@<=\w\+\%(\s*\,\s*\w\+\)\=\s*\:=\@!' ..
		    \	':' ..
		    \ '\<END\>'
endif

if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
  let b:browsefilter = "Modula-2 Source Files (*.def *.mod)\t*.def;*.mod\n" ..
		     \ "All Files (*.*)\t*.*\n"
endif

let b:undo_ftplugin = "setl com< cms< fo< " ..
		    \ "| unlet! b:browsefilter b:match_words"

let &cpo = s:cpo_save
unlet s:cpo_save

" vim: nowrap sw=2 sts=2 ts=8 noet:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      " Vim filetype plugin file
" Language:	Modula-3
" Maintainer:	Doug Kearns <dougkearns@gmail.com>
" Last Change:	2021 Apr 08

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

setlocal comments=s0:(*,mb:\ ,ex:*)
setlocal commentstring=(*%s*)
setlocal formatoptions-=t formatoptions+=croql

if exists("loaded_matchit") && !exists("b:match_words")
  let b:match_words = '\<REPEAT\>:\<UNTIL\>,' ..
		    \ '\<\%(BEGIN\|CASE\|FOR\|IF\|LOCK\|LOOP\|TRY\|TYPECASE\|WHILE\|WITH\)\>' ..
		    \	':' ..
		    \	'\<\%(ELSIF\|ELSE\|EXCEPT\|FINALLY\)\>\|\%(^\s*\)\@<=\S.*=>' ..
		    \	':' ..
		    \ '\<END\>'
endif

if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
  let b:browsefilter = "Modula-3 Source Files (*.m3)\t*.m3\n" ..
		     \ "All Files (*.*)\t*.*\n"
endif

let b:undo_ftplugin = "setl com< cms< fo< " ..
		    \ "| unlet! b:browsefilter b:match_words"

let &cpo = s:cpo_save
unlet s:cpo_save

" vim: nowrap sw=2 sts=2 ts=8 noet:
                     " Vim filetype plugin file
" Language:           MetaPost
" Maintainer:         Nicola Vitacolonna <nvitacolonna@gmail.com>
" Former Maintainers: Nikolai Weibull <now@bitwi.se>
" Latest Revision:    2016 Oct 2

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo< sua< inc< def< ofu<"
      \ . "| unlet! b:match_ignorecase b:match_words b:match_skip"

setlocal comments=:% commentstring=%\ %s formatoptions-=t formatoptions+=cjroql2
setlocal suffixesadd=.mp,.mpiv
let &l:include = '\<\%(input\|loadmodule\)\>' " loadmodule is in MetaFun
let &l:define = '\<\%(let\|newinternal\|interim\|def\|vardef\)\>\|\<\%(primary\|secondary\|tertiary\)def\>\s*[^ .]\+'
setlocal omnifunc=syntaxcomplete#Complete
let g:omni_syntax_group_include_mp = 'mf\w\+,mp\w\+'
let g:omni_syntax_group_exclude_mp = 'mfTodoComment'

if exists(":FixBeginfigs") != 2
  command -nargs=0 FixBeginfigs call s:fix_beginfigs()

  function! s:fix_beginfigs()
    let i = 1
    g/^beginfig(\d*);$/s//\='beginfig('.i.');'/ | let i = i + 1
  endfunction
endif

let s:mp_regex = {
      \ 'beginsection' : '^\s*\%(\%(\|var\|primary\|secondary\|tertiary\)def\|begin\%(fig\|char\|logochar\|glyph\|graph\)\)\>',
      \ 'endsection'   : '^\s*\%(enddef\|end\%(fig\|char\|glyph\|graph\)\)\>',
      \ 'beginblock'   : '^\s*\%(begingroup\|if\|for\%(\|suffixes\|ever\)\)\>',
      \ 'endblock'     : '^\s*\%(endgroup\|fi\|endfor\)\>'
      \ }

function! s:move_around(count, what, flags, visual)
  if a:visual
    exe "normal! gv"
  endif
  call search(s:mp_regex[a:what], a:flags.'s') " 's' sets previous context mark
  call map(range(2, a:count), 'search(s:mp_regex[a:what], a:flags)')
endfunction


" Move around macros.
nnoremap <silent><buffer> [[ :<C-U>call <SID>move_around(v:count1, "beginsection", "bW", v:false) <CR>
vnoremap <silent><buffer> [[ :<C-U>call <SID>move_around(v:count1, "beginsection", "bW", v:true)  <CR>
nnoremap <silent><buffer> ]] :<C-U>call <SID>move_around(v:count1, "beginsection", "W",  v:false) <CR>
vnoremap <silent><buffer> ]] :<C-U>call <SID>move_around(v:count1, "beginsection", "W",  v:true)  <CR>
nnoremap <silent><buffer> [] :<C-U>call <SID>move_around(v:count1, "endsection",   "bW", v:false) <CR>
vnoremap <silent><buffer> [] :<C-U>call <SID>move_around(v:count1, "endsection",   "bW", v:true)  <CR>
nnoremap <silent><buffer> ][ :<C-U>call <SID>move_around(v:count1, "endsection",   "W",  v:false) <CR>
vnoremap <silent><buffer> ][ :<C-U>call <SID>move_around(v:count1, "endsection",   "W",  v:true)  <CR>
nnoremap <silent><buffer> [{ :<C-U>call <SID>move_around(v:count1, "beginblock",   "bW", v:false) <CR>
vnoremap <silent><buffer> [{ :<C-U>call <SID>move_around(v:count1, "beginblock",   "bW", v:true)  <CR>
nnoremap <silent><buffer> ]} :<C-U>call <SID>move_around(v:count1, "endblock",     "W",  v:false) <CR>
vnoremap <silent><buffer> ]} :<C-U>call <SID>move_around(v:count1, "endblock",     "W",  v:true)  <CR>

if exists("loaded_matchit")
  let b:match_ignorecase = 0
  let b:match_words =
        \ '\<if\>:\<else\%[if]\>:\<fi\>,' .
        \ '\<for\%(\|suffixes\|ever\)\>:\<exit\%(if\|unless\)\>:\<endfor\>,' .
        \ '\<\%(\|var\|primary\|secondary\|tertiary\)def\>:\<enddef\>,' .
        \ '\<beginfig\>:\<endfig\>,' .
        \ '\<begingroup\>:\<endgroup\>,' .
        \ '\<begin\%(logo\)\?char\>:\<endchar\>,' .
        \ '\<beginglyph\>:\<endglyph\>,' .
        \ '\<begingraph\>:\<endgraph\>'
  " Ignore comments and strings
  let b:match_skip = 'synIDattr(synID(line("."), col("."), 1), "name")
        \ =~# "^mf\\%(Comment\\|String\\|\\)$\\|^mpTeXinsert$"'
endif

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                " Vim filetype plugin file
" Language:             mplayer(1) configuration file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< inc< fo<"

setlocal comments=:# commentstring=#\ %s include=^\\s*include
setlocal formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        " Created	: Wed 26 Apr 2006 01:20:53 AM CDT
" Modified	: Fri 28 Apr 2006 03:24:01 AM CDT
" Author	: Gautam Iyer <gi1242@users.sourceforge.net>
" Description	: ftplugin for mrxvtrc

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let b:undo_ftplugin = "setl com< cms< fo<"

" Really any line that does not match an option is a comment. But use '!' for
" compatibility with x-defaults files, and "#" (preferred) for compatibility
" with all other config files.
"
" Comments beginning with "#" are preferred because Vim will not flag the
" first word as a spelling error if it is not capitalised. The '!' used as
" comment leaders makes Vim think that every comment line is a new sentence.

setlocal comments=:!,:# commentstring=#\ %s
setlocal formatoptions-=t formatoptions+=croql
                                                                                                                                                                                                                                  " Vim filetype plugin file
" Language:	MS Message files (*.mc)
" Maintainer:	Kevin Locke <kwl7@cornell.edu>
" Last Change:	2008 April 09
" Location:	http://kevinlocke.name/programs/vim/syntax/msmessages.vim

" Based on c.vim

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

" Using line continuation here.
let s:cpo_save = &cpo
set cpo-=C

let b:undo_ftplugin = "setl fo< com< cms< | unlet! b:browsefilter"

" Set 'formatoptions' to format all lines, including comments
setlocal fo-=ct fo+=roql

" Comments includes both ";" which describes a "comment" which will be
" converted to C code and variants on "; //" which will remain comments
" in the generated C code
setlocal comments=:;,:;//,:;\ //,s:;\ /*\ ,m:;\ \ *\ ,e:;\ \ */
setlocal commentstring=;\ //\ %s

" Win32 can filter files in the browse dialog
if has("gui_win32") && !exists("b:browsefilter")
  let b:browsefilter = "MS Message Files (*.mc)\t*.mc\n" .
	\ "Resource Files (*.rc)\t*.rc\n" .
	\ "All Files (*.*)\t*.*\n"
endif

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           " Vim filetype plugin file
" Language:             mutt RC File
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2006-04-19

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< inc< fo<"

setlocal comments=:# commentstring=#\ %s
setlocal formatoptions-=t formatoptions+=croql

let &l:include = '^\s*source\>'

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             " Vim filetype plugin file
" Language:             nanorc(5) - GNU nano configuration file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 " Vim filetype plugin file
" Language:             NeoMutt RC File
" Previous Maintainer:  Guillaume Brogi <gui-gui@netcourrier.com>
" Latest Revision:      2017-09-17
" Original version copied from ftplugin/muttrc.vim

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< inc< fo<"

setlocal comments=:# commentstring=#\ %s
setlocal formatoptions-=t formatoptions+=croql

let &l:include = '^\s*source\>'

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            " Vim filetype plugin file
" Language:             netrc(5) configuration file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments= commentstring= formatoptions-=tcroq formatoptions+=l

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    " Vim filetype plugin
" Language: nginx.conf
" Maintainer: Chris Aumann <me@chr4.org>
" Last Change: Apr 15, 2017

setlocal commentstring=#\ %s
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                " Vim filetype plugin
" Language:	roff(7)
" Maintainer:	Aman Verma
" Homepage:	https://github.com/a-vrma/vim-nroff-ftplugin
" Previous Maintainer:	Chris Spiegel <cspiegel@gmail.com>
" Last Change:	2020 Nov 21

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

setlocal commentstring=.\\\"%s
setlocal comments=:.\\\"
setlocal sections+=Sh

let b:undo_ftplugin = 'setlocal commentstring< comments< sections<'
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        " Vim ftplugin file
" Language:		NSIS script
" Maintainer:		Ken Takata
" URL:			https://github.com/k-takata/vim-nsis
" Previous Maintainer:	Nikolai Weibull <now@bitwi.se>
" Last Change:		2021-10-18

if exists("b:did_ftplugin")
  finish
endif

let s:cpo_save = &cpo
set cpo&vim

let b:did_ftplugin = 1

let b:undo_ftplugin = "setl com< cms< fo< def< inc<"

setlocal comments=s1:/*,mb:*,ex:*/,b:#,:; commentstring=;\ %s
setlocal formatoptions-=t formatoptions+=croql
setlocal define=^\\s*!define\\%(\\%(utc\\)\\=date\\|math\\)\\=
setlocal include=^\\s*!include\\%(/NONFATAL\\)\\=

if exists("loaded_matchit")
  let b:match_ignorecase = 1
  let b:match_words =
	\ '\${\%(If\|IfNot\|Unless\)}:\${\%(Else\|ElseIf\|ElseIfNot\|ElseUnless\)}:\${\%(EndIf\|EndUnless\)},' .
	\ '\${Select}:\${EndSelect},' .
	\ '\${Switch}:\${EndSwitch},' .
	\ '\${\%(Do\|DoWhile\|DoUntil\)}:\${\%(Loop\|LoopWhile\|LoopUntil\)},' .
	\ '\${\%(For\|ForEach\)}:\${Next},' .
	\ '\<Function\>:\<FunctionEnd\>,' .
	\ '\<Section\>:\<SectionEnd\>,' .
	\ '\<SectionGroup\>:\<SectionGroupEnd\>,' .
	\ '\<PageEx\>:\<PageExEnd\>,' .
	\ '\${MementoSection}:\${MementoSectionEnd},' .
	\ '!if\%(\%(macro\)\?n\?def\)\?\>:!else\>:!endif\>,' .
	\ '!macro\>:!macroend\>'
  let b:undo_ftplugin .= " | unlet! b:match_ignorecase b:match_words"
endif

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    " Vim filetype plugin file
" Language:	Objective C
" Maintainer:	Bram Moolenaar <Bram@vim.org>
" Last Change:	2003 Jan 15

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Behaves just like C
runtime! ftplugin/c.vim ftplugin/c_*.vim ftplugin/c/*.vim
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        " Language:    OCaml
" Maintainer:  David Baelde        <firstname.name@ens-lyon.org>
"              Mike Leary          <leary@nwlink.com>
"              Markus Mottl        <markus.mottl@gmail.com>
"              Pierre Vittet       <pierre-vittet@pvittet.com>
"              Stefano Zacchiroli  <zack@bononia.it>
"              Vincent Aravantinos <firstname.name@imag.fr>
" URL:         https://github.com/ocaml/vim-ocaml
" Last Change:
"              2013 Oct 27 - Added commentstring (MM)
"              2013 Jul 26 - load default compiler settings (MM)
"              2013 Jul 24 - removed superfluous efm-setting (MM)
"              2013 Jul 22 - applied fixes supplied by Hirotaka Hamada (MM)

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin=1

" Use standard compiler settings unless user wants otherwise
if !exists("current_compiler")
  :compiler ocaml
endif

" some macro
if exists('*fnameescape')
  function! s:Fnameescape(s)
    return fnameescape(a:s)
  endfun
else
  function! s:Fnameescape(s)
    return escape(a:s," \t\n*?[{`$\\%#'\"|!<")
  endfun
endif

" Error handling -- helps moving where the compiler wants you to go
let s:cposet=&cpoptions
set cpo&vim

" Comment string
setlocal comments=sr:(*\ ,mb:\ ,ex:*)
setlocal comments^=sr:(**,mb:\ \ ,ex:*)
setlocal commentstring=(*%s*)

" Add mappings, unless the user didn't want this.
if !exists("no_plugin_maps") && !exists("no_ocaml_maps")
  " (un)commenting
  if !hasmapto('<Plug>Comment')
    nmap <buffer> <LocalLeader>c <Plug>LUncomOn
    xmap <buffer> <LocalLeader>c <Plug>BUncomOn
    nmap <buffer> <LocalLeader>C <Plug>LUncomOff
    xmap <buffer> <LocalLeader>C <Plug>BUncomOff
  endif

  nnoremap <buffer> <Plug>LUncomOn gI(* <End> *)<ESC>
  nnoremap <buffer> <Plug>LUncomOff :s/^(\* \(.*\) \*)/\1/<CR>:noh<CR>
  xnoremap <buffer> <Plug>BUncomOn <ESC>:'<,'><CR>`<O<ESC>0i(*<ESC>`>o<ESC>0i*)<ESC>`<
  xnoremap <buffer> <Plug>BUncomOff <ESC>:'<,'><CR>`<dd`>dd`<

  nmap <buffer> <LocalLeader>s <Plug>OCamlSwitchEdit
  nmap <buffer> <LocalLeader>S <Plug>OCamlSwitchNewWin

  nmap <buffer> <LocalLeader>t <Plug>OCamlPrintType
  xmap <buffer> <LocalLeader>t <Plug>OCamlPrintType
endif

" Let % jump between structure elements (due to Issac Trotts)
let b:mw =         '\<let\>:\<and\>:\(\<in\>\|;;\)'
let b:mw = b:mw . ',\<if\>:\<then\>:\<else\>'
let b:mw = b:mw . ',\<\(for\|while\)\>:\<do\>:\<done\>'
let b:mw = b:mw . ',\<\(object\|sig\|struct\|begin\)\>:\<end\>'
let b:mw = b:mw . ',\<\(match\|try\)\>:\<with\>'
let b:match_words = b:mw

let b:match_ignorecase=0

function! s:OcpGrep(bang,args) abort
  let grepprg = &l:grepprg
  let grepformat = &l:grepformat
  let shellpipe = &shellpipe
  try
    let &l:grepprg = "ocp-grep -c never"
    setlocal grepformat=%f:%l:%m
    if &shellpipe ==# '2>&1| tee' || &shellpipe ==# '|& tee'
      let &shellpipe = "| tee"
    endif
    execute 'grep! '.a:args
    if empty(a:bang) && !empty(getqflist())
      return 'cfirst'
    else
      return ''
    endif
  finally
    let &l:grepprg = grepprg
    let &l:grepformat = grepformat
    let &shellpipe = shellpipe
  endtry
endfunction
command! -bar -bang -complete=file -nargs=+ Ocpgrep exe s:OcpGrep(<q-bang>, <q-args>)

" switching between interfaces (.mli) and implementations (.ml)
if !exists("g:did_ocaml_switch")
  let g:did_ocaml_switch = 1
  nnoremap <Plug>OCamlSwitchEdit :<C-u>call OCaml_switch(0)<CR>
  nnoremap <Plug>OCamlSwitchNewWin :<C-u>call OCaml_switch(1)<CR>
  fun OCaml_switch(newwin)
    if (match(bufname(""), "\\.mli$") >= 0)
      let fname = s:Fnameescape(substitute(bufname(""), "\\.mli$", ".ml", ""))
      if (a:newwin == 1)
        exec "new " . fname
      else
        exec "arge " . fname
      endif
    elseif (match(bufname(""), "\\.ml$") >= 0)
      let fname = s:Fnameescape(bufname("")) . "i"
      if (a:newwin == 1)
        exec "new " . fname
      else
        exec "arge " . fname
      endif
    endif
  endfun
endif

" Folding support

" Get the modeline because folding depends on indentation
let lnum = search('^\s*(\*:o\?caml:', 'n')
let s:modeline = lnum? getline(lnum): ""

" Get the indentation params
let s:m = matchstr(s:modeline,'default\s*=\s*\d\+')
if s:m != ""
  let s:idef = matchstr(s:m,'\d\+')
elseif exists("g:omlet_indent")
  let s:idef = g:omlet_indent
else
  let s:idef = 2
endif
let s:m = matchstr(s:modeline,'struct\s*=\s*\d\+')
if s:m != ""
  let s:i = matchstr(s:m,'\d\+')
elseif exists("g:omlet_indent_struct")
  let s:i = g:omlet_indent_struct
else
  let s:i = s:idef
endif

" Set the folding method
if exists("g:ocaml_folding")
  setlocal foldmethod=expr
  setlocal foldexpr=OMLetFoldLevel(v:lnum)
endif

let b:undo_ftplugin = "setlocal efm< foldmethod< foldexpr<"
	\ . "| unlet! b:mw b:match_words b:match_ignorecase"


" - Only definitions below, executed once -------------------------------------

if exists("*OMLetFoldLevel")
  let &cpoptions = s:cposet
  unlet s:cposet
  finish
endif

function s:topindent(lnum)
  let l = a:lnum
  while l > 0
    if getline(l) =~ '\s*\%(\<struct\>\|\<sig\>\|\<object\>\)'
      return indent(l)
    endif
    let l = l-1
  endwhile
  return -s:i
endfunction

function OMLetFoldLevel(l)

  " This is for not merging blank lines around folds to them
  if getline(a:l) !~ '\S'
    return -1
  endif

  " We start folds for modules, classes, and every toplevel definition
  if getline(a:l) =~ '^\s*\%(\<val\>\|\<module\>\|\<class\>\|\<type\>\|\<method\>\|\<initializer\>\|\<inherit\>\|\<exception\>\|\<external\>\)'
    exe 'return ">' (indent(a:l)/s:i)+1 '"'
  endif

  " Toplevel let are detected thanks to the indentation
  if getline(a:l) =~ '^\s*let\>' && indent(a:l) == s:i+s:topindent(a:l)
    exe 'return ">' (indent(a:l)/s:i)+1 '"'
  endif

  " We close fold on end which are associated to struct, sig or object.
  " We use syntax information to do that.
  if getline(a:l) =~ '^\s*end\>' && synIDattr(synID(a:l, indent(a:l)+1, 0), "name") != "ocamlKeyword"
    return (indent(a:l)/s:i)+1
  endif

  " Folds end on ;;
  if getline(a:l) =~ '^\s*;;'
    exe 'return "<' (indent(a:l)/s:i)+1 '"'
  endif

  " Comments around folds aren't merged to them.
  if synIDattr(synID(a:l, indent(a:l)+1, 0), "name") == "ocamlComment"
    return -1
  endif

  return '='
endfunction

" Vim support for OCaml .annot files
"
" Last Change: 2007 Jul 17
" Maintainer:  Vincent Aravantinos <vincent.aravantinos@gmail.com>
" License:     public domain
"
" Originally inspired by 'ocaml-dtypes.vim' by Stefano Zacchiroli.
" The source code is quite radically different for we not use python anymore.
" However this plugin should have the exact same behaviour, that's why the
" following lines are the quite exact copy of Stefano's original plugin :
"
" <<
" Executing Ocaml_print_type(<mode>) function will display in the Vim bottom
" line(s) the type of an ocaml value getting it from the corresponding .annot
" file (if any).  If Vim is in visual mode, <mode> should be "visual" and the
" selected ocaml value correspond to the highlighted text, otherwise (<mode>
" can be anything else) it corresponds to the literal found at the current
" cursor position.
"
" Typing '<LocalLeader>t' (LocalLeader defaults to '\', see :h LocalLeader)
" will cause " Ocaml_print_type function to be invoked with the right
" argument depending on the current mode (visual or not).
" >>
"
" If you find something not matching this behaviour, please signal it.
"
" Differences are:
"   - no need for python support
"     + plus : more portable
"     + minus: no more lazy parsing, it looks very fast however
"
"   - ocamlbuild support, ie.
"     + the plugin finds the _build directory and looks for the
"       corresponding file inside;
"     + if the user decides to change the name of the _build directory thanks
"       to the '-build-dir' option of ocamlbuild, the plugin will manage in
"       most cases to find it out (most cases = if the source file has a unique
"       name among your whole project);
"     + if ocamlbuild is not used, the usual behaviour holds; ie. the .annot
"       file should be in the same directory as the source file;
"     + for vim plugin programmers:
"       the variable 'b:_build_dir' contains the inferred path to the build
"       directory, even if this one is not named '_build'.
"
" Bonus :
"   - latin1 accents are handled
"   - lists are handled, even on multiple lines, you don't need the visual mode
"     (the cursor must be on the first bracket)
"   - parenthesized expressions, arrays, and structures (ie. '(...)', '[|...|]',
"     and '{...}') are handled the same way

  " Copied from Stefano's original plugin :
  " <<
  "      .annot ocaml file representation
  "
  "      File format (copied verbatim from caml-types.el)
  "
  "      file ::= block *
  "      block ::= position <SP> position <LF> annotation *
  "      position ::= filename <SP> num <SP> num <SP> num
  "      annotation ::= keyword open-paren <LF> <SP> <SP> data <LF> close-paren
  "
  "      <SP> is a space character (ASCII 0x20)
  "      <LF> is a line-feed character (ASCII 0x0A)
  "      num is a sequence of decimal digits
  "      filename is a string with the lexical conventions of O'Caml
  "      open-paren is an open parenthesis (ASCII 0x28)
  "      close-paren is a closed parenthesis (ASCII 0x29)
  "      data is any sequence of characters where <LF> is always followed by
  "           at least two space characters.
  "
  "      - in each block, the two positions are respectively the start and the
  "        end of the range described by the block.
  "      - in a position, the filename is the name of the file, the first num
  "        is the line number, the second num is the offset of the beginning
  "        of the line, the third num is the offset of the position itself.
  "      - the char number within the line is the difference between the third
  "        and second nums.
  "
  "      For the moment, the only possible keyword is \"type\"."
  " >>


" 1. Finding the annotation file even if we use ocamlbuild

    " In:  two strings representing paths
    " Out: one string representing the common prefix between the two paths
  function! s:Find_common_path (p1,p2)
    let temp = a:p2
    while matchstr(a:p1,temp) == ''
      let temp = substitute(temp,'/[^/]*$','','')
    endwhile
    return temp
  endfun

    " After call:
    "
    "  Following information have been put in s:annot_file_list, using
    "  annot_file_name name as key:
    " - annot_file_path :
    "                       path to the .annot file corresponding to the
    "                       source file (dealing with ocamlbuild stuff)
    " - _build_path:
    "                       path to the build directory even if this one is
    "                       not named '_build'
    " - date_of_last annot:
    "                       Set to 0 until we load the file. It contains the
    "                       date at which the file has been loaded.
  function! s:Locate_annotation()
    let annot_file_name = s:Fnameescape(expand('%:t:r')).'.annot'
    if !exists ("s:annot_file_list[annot_file_name]")
      silent exe 'cd' s:Fnameescape(expand('%:p:h'))
      " 1st case : the annot file is in the same directory as the buffer (no ocamlbuild)
      let annot_file_path = findfile(annot_file_name,'.')
      if annot_file_path != ''
        let annot_file_path = getcwd().'/'.annot_file_path
        let _build_path = ''
      else
        " 2nd case : the buffer and the _build directory are in the same directory
        "      ..
        "     /  \
        "    /    \
        " _build  .ml
        "
        let _build_path = finddir('_build','.')
        if _build_path != ''
          let _build_path = getcwd().'/'._build_path
          let annot_file_path           = findfile(annot_file_name,'_build')
          if annot_file_path != ''
            let annot_file_path = getcwd().'/'.annot_file_path
          endif
        else
          " 3rd case : the _build directory is in a directory higher in the file hierarchy
          "            (it can't be deeper by ocamlbuild requirements)
          "      ..
          "     /  \
          "    /    \
          " _build  ...
          "           \
          "            \
          "           .ml
          "
        ≈ú  ∆ú  «ú  »ú  …ú   ú  Àú  Ãú  Õú  Œú  œú  –ú                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    let _build_path = finddir('_build',';')
          if _build_path != ''
            let project_path                = substitute(_build_path,'/_build$','','')
            let path_relative_to_project    = s:Fnameescape(substitute(expand('%:p:h'),project_path.'/','',''))
            let annot_file_path           = findfile(annot_file_name,project_path.'/_build/'.path_relative_to_project)
          else
            let annot_file_path = findfile(annot_file_name,'**')
            "4th case : what if the user decided to change the name of the _build directory ?
            "           -> we relax the constraints, it should work in most cases
            if annot_file_path != ''
              " 4a. we suppose the renamed _build directory is in the current directory
              let _build_path = matchstr(annot_file_path,'^[^/]*')
              if annot_file_path != ''
                let annot_file_path = getcwd().'/'.annot_file_path
                let _build_path     = getcwd().'/'._build_path
              endif
            else
              let annot_file_name = ''
              "(Pierre Vittet: I have commented 4b because this was crashing
              "my vim (it produced infinite loop))
              "
              " 4b. anarchy : the renamed _build directory may be higher in the hierarchy
              " this will work if the file for which we are looking annotations has a unique name in the whole project
              " if this is not the case, it may still work, but no warranty here
              "let annot_file_path = findfile(annot_file_name,'**;')
              "let project_path      = s:Find_common_path(annot_file_path,expand('%:p:h'))
              "let _build_path       = matchstr(annot_file_path,project_path.'/[^/]*')
            endif
          endif
        endif
      endif

      if annot_file_path == ''
        throw 'E484: no annotation file found'
      endif

      silent exe 'cd' '-'
      let s:annot_file_list[annot_file_name]= [annot_file_path, _build_path, 0]
    endif
  endfun

  " This variable contains a dictionary of lists. Each element of the dictionary
  " represents an annotation system. An annotation system is a list with:
  " - annotation file name as its key
  " - annotation file path as first element of the contained list
  " - build path as second element of the contained list
  " - annot_file_last_mod (contain the date of .annot file) as third element
  let s:annot_file_list = {}

" 2. Finding the type information in the annotation file

  " a. The annotation file is opened in vim as a buffer that
  " should be (almost) invisible to the user.

      " After call:
      " The current buffer is now the one containing the .annot file.
      " We manage to keep all this hidden to the user's eye.
    function! s:Enter_annotation_buffer(annot_file_path)
      let s:current_pos = getpos('.')
      let s:current_hidden = &l:hidden
      set hidden
      let s:current_buf = bufname('%')
      if bufloaded(a:annot_file_path)
        silent exe 'keepj keepalt' 'buffer' s:Fnameescape(a:annot_file_path)
      else
        silent exe 'keepj keepalt' 'view' s:Fnameescape(a:annot_file_path)
      endif
      call setpos(".", [0, 0 , 0 , 0])
    endfun

      " After call:
      "   The original buffer has been restored in the exact same state as before.
    function! s:Exit_annotation_buffer()
      silent exe 'keepj keepalt' 'buffer' s:Fnameescape(s:current_buf)
      let &l:hidden = s:current_hidden
      call setpos('.',s:current_pos)
    endfun

      " After call:
      "   The annot file is loaded and assigned to a buffer.
      "   This also handles the modification date of the .annot file, eg. after a
      "   compilation (return an updated annot_file_list).
    function! s:Load_annotation(annot_file_name)
      let annot = s:annot_file_list[a:annot_file_name]
      let annot_file_path = annot[0]
      let annot_file_last_mod = 0
      if exists("annot[2]")
        let annot_file_last_mod = annot[2]
      endif
      if bufloaded(annot_file_path) && annot_file_last_mod < getftime(annot_file_path)
        " if there is a more recent file
        let nr = bufnr(annot_file_path)
        silent exe 'keepj keepalt' 'bunload' nr
      endif
      if !bufloaded(annot_file_path)
        call s:Enter_annotation_buffer(annot_file_path)
        setlocal nobuflisted
        setlocal bufhidden=hide
        setlocal noswapfile
        setlocal buftype=nowrite
        call s:Exit_annotation_buffer()
        let annot[2] = getftime(annot_file_path)
        " List updated with the new date
        let s:annot_file_list[a:annot_file_name] = annot
      endif
    endfun

  "b. 'search' and 'match' work to find the type information

      "In:  - lin1,col1: position of expression first char
      "     - lin2,col2: position of expression last char
      "Out: - the pattern to be looked for to find the block
      " Must be called in the source buffer (use of line2byte)
    function! s:Block_pattern(lin1,lin2,col1,col2)
      let start_num1 = a:lin1
      let start_num2 = line2byte(a:lin1) - 1
      let start_num3 = start_num2 + a:col1
      let path       = '"\(\\"\|[^"]\)\+"'
      let start_pos  = path.' '.start_num1.' '.start_num2.' '.start_num3
      let end_num1   = a:lin2
      let end_num2   = line2byte(a:lin2) - 1
      let end_num3   = end_num2 + a:col2
      let end_pos    = path.' '.end_num1.' '.end_num2.' '.end_num3
      return '^'.start_pos.' '.end_pos."$"
      " rq: the '^' here is not totally correct regarding the annot file "grammar"
      " but currently the annotation file respects this, and it's a little bit faster with the '^';
      " can be removed safely.
    endfun

      "In: (the cursor position should be at the start of an annotation)
      "Out: the type information
      " Must be called in the annotation buffer (use of search)
    function! s:Match_data()
      " rq: idem as previously, in the following, the '^' at start of patterns is not necessary
      keepj while search('^type($','ce',line(".")) == 0
        keepj if search('^.\{-}($','e') == 0
          throw "no_annotation"
        endif
        keepj if searchpair('(','',')') == 0
          throw "malformed_annot_file"
        endif
      endwhile
      let begin = line(".") + 1
      keepj if searchpair('(','',')') == 0
        throw "malformed_annot_file"
      endif
      let end = line(".") - 1
      return join(getline(begin,end),"\n")
    endfun

      "In:  the pattern to look for in order to match the block
      "Out: the type information (calls s:Match_data)
      " Should be called in the annotation buffer
    function! s:Extract_type_data(block_pattern, annot_file_name)
      let annot_file_path = s:annot_file_list[a:annot_file_name][0]
      call s:Enter_annotation_buffer(annot_file_path)
      try
        if search(a:block_pattern,'e') == 0
          throw "no_annotation"
        endif
        call cursor(line(".") + 1,1)
        let annotation = s:Match_data()
      finally
        call s:Exit_annotation_buffer()
      endtry
      return annotation
    endfun

  "c. link this stuff with what the user wants
  " ie. get the expression selected/under the cursor

    let s:ocaml_word_char = '\w|[\xc0-\xff]|'''

      "In:  the current mode (eg. "visual", "normal", etc.)
      "Out: the borders of the expression we are looking for the type
    function! s:Match_borders(mode)
      if a:mode == "visual"
        let cur = getpos(".")
        normal `<
        let col1 = col(".")
        let lin1 = line(".")
        normal `>
        let col2 = col(".")
        let lin2 = line(".")
        call cursor(cur[1],cur[2])
        return [lin1,lin2,col1-1,col2]
      else
        let cursor_line = line(".")
        let cursor_col  = col(".")
        let line = getline('.')
        if line[cursor_col-1:cursor_col] == '[|'
          let [lin2,col2] = searchpairpos('\[|','','|\]','n')
          return [cursor_line,lin2,cursor_col-1,col2+1]
        elseif     line[cursor_col-1] == '['
          let [lin2,col2] = searchpairpos('\[','','\]','n')
          return [cursor_line,lin2,cursor_col-1,col2]
        elseif line[cursor_col-1] == '('
          let [lin2,col2] = searchpairpos('(','',')','n')
          return [cursor_line,lin2,cursor_col-1,col2]
        elseif line[cursor_col-1] == '{'
          let [lin2,col2] = searchpairpos('{','','}','n')
          return [cursor_line,lin2,cursor_col-1,col2]
        else
          let [lin1,col1] = searchpos('\v%('.s:ocaml_word_char.'|\.)*','ncb')
          let [lin2,col2] = searchpos('\v%('.s:ocaml_word_char.'|\.)*','nce')
          if col1 == 0 || col2 == 0
            throw "no_expression"
          endif
          return [cursor_line,cursor_line,col1-1,col2]
        endif
      endif
    endfun

      "In:  the current mode (eg. "visual", "normal", etc.)
      "Out: the type information (calls s:Extract_type_data)
    function! s:Get_type(mode, annot_file_name)
      let [lin1,lin2,col1,col2] = s:Match_borders(a:mode)
      return s:Extract_type_data(s:Block_pattern(lin1,lin2,col1,col2), a:annot_file_name)
    endfun

      "In: A string destined to be printed in the 'echo buffer'. It has line
      "break and 2 space at each line beginning.
      "Out: A string destined to be yanked, without space and double space.
    function s:unformat_ocaml_type(res)
      "Remove end of line.
      let res = substitute (a:res, "\n", "", "g" )
      "remove double space
      let res =substitute(res , "  ", " ", "g")
      "remove space at beginning of string.
      let res = substitute(res, "^ *", "", "g")
      return res
    endfunction

  "d. main
      "In:         the current mode (eg. "visual", "normal", etc.)
      "After call: the type information is displayed
    if !exists("*Ocaml_get_type")
      function Ocaml_get_type(mode)
        let annot_file_name = s:Fnameescape(expand('%:t:r')).'.annot'
        call s:Locate_annotation()
        call s:Load_annotation(annot_file_name)
        let res = s:Get_type(a:mode, annot_file_name)
        " Copy result in the unnamed buffer
        let @" = s:unformat_ocaml_type(res)
        return res
      endfun
    endif

    if !exists("*Ocaml_get_type_or_not")
      function Ocaml_get_type_or_not(mode)
        let t=reltime()
        try
          let res = Ocaml_get_type(a:mode)
          return res
        catch
          return ""
        endtry
      endfun
    endif

    if !exists("*Ocaml_print_type")
      function Ocaml_print_type(mode)
        if expand("%:e") == "mli"
          echohl ErrorMsg | echo "No annotations for interface (.mli) files" | echohl None
          return
        endif
        try
          echo Ocaml_get_type(a:mode)
        catch /E484:/
          echohl ErrorMsg | echo "No type annotations (.annot) file found" | echohl None
        catch /no_expression/
          echohl ErrorMsg | echo "No expression found under the cursor" | echohl None
        catch /no_annotation/
          echohl ErrorMsg | echo "No type annotation found for the given text" | echohl None
        catch /malformed_annot_file/
          echohl ErrorMsg | echo "Malformed .annot file" | echohl None
        endtry
      endfun
    endif

" Maps
  nnoremap <silent> <Plug>OCamlPrintType :<C-U>call Ocaml_print_type("normal")<CR>
  xnoremap <silent> <Plug>OCamlPrintType :<C-U>call Ocaml_print_type("visual")<CR>`<

let &cpoptions = s:cposet
unlet s:cposet

" vim:sw=2 fdm=indent
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   " Vim filetype plugin file
" Language:	occam
" Copyright:	Christian Jacobsen <clj3@kent.ac.uk>, Mario Schweigler <ms44@kent.ac.uk>
" Maintainer:	Mario Schweigler <ms44@kent.ac.uk>
" Last Change:	23 April 2003

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1
let s:keepcpo= &cpo
set cpo&vim

"{{{  Indent settings
" Set shift width for indent
setlocal shiftwidth=2
" Set the tab key size to two spaces
setlocal softtabstop=2
" Let tab keys always be expanded to spaces
setlocal expandtab
"}}}

"{{{  Formatting
" Break comment lines and insert comment leader in this case
setlocal formatoptions-=t formatoptions+=cql
setlocal comments+=:--
" Maximum length of comments is 78
setlocal textwidth=78
"}}}

"{{{  File browsing filters
" Win32 can filter files in the browse dialog
if has("gui_win32") && !exists("b:browsefilter")
  let b:browsefilter = "All Occam Files (*.occ *.inc)\t*.occ;*.inc\n" .
	\ "Occam Include Files (*.inc)\t*.inc\n" .
	\ "Occam Source Files (*.occ)\t*.occ\n" .
	\ "All Files (*.*)\t*.*\n"
endif
"}}}

"{{{  Undo settings
let b:undo_ftplugin = "setlocal shiftwidth< softtabstop< expandtab<"
	\ . " formatoptions< comments< textwidth<"
	\ . "| unlet! b:browsefiler"
"}}}

let &cpo = s:keepcpo
unlet s:keepcpo
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               " Vim filetype plugin file
" Language:	GNU Octave
" Maintainer:	Doug Kearns <dougkearns@gmail.com>
" Last Change:	2021 Sep 02

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

" TODO: update Matlab ftplugin and source it as the base file?

setlocal comments=s:%{,m:\ ,e:%},s:#{,m:\ ,e:#},:%,:#
setlocal commentstring=#\ %s
setlocal formatoptions-=t formatoptions+=croql

setlocal keywordprg=info\ octave\ --vi-keys\ --index-search

if exists("loaded_matchit") && !exists("b:match_words")
  let b:match_words = '\<unwind_protect\>:\<unwind_protect_cleanup\>:\<end_unwind_protect\>'
  if exists("octave_use_matlab_end")
    let b:match_words ..= ',' ..
	                \ '\<\%(classdef\|enumeration\|events\|for\|function\|if\|methods\|parfor\|properties\|switch\|while\|try\)\>' ..
                        \ ':' ..
			\ '\<\%(elseif\|else\|case\|otherwise\|break\|continue\|catch\)\>' ..
                        \ ':' ..
			\ '\<end\>'
  else
    let b:match_words ..= ',' ..
                        \ '\<classdef\>:\<endclassdef\>,' ..
			\ '\<enumeration\>:\<endenumeration\>,' ..
			\ '\<events\>:\<endevents\>,' ..
			\ '\<do\>:\<\%(break\|continue\)\>:\<until\>' ..
			\ '\<for\>:\<\%(break\|continue\)\>:\<endfor\>,' ..
			\ '\<function\>:\<return\>:\<endfunction\>,' ..
			\ '\<if\>:\<\%(elseif\|else\)\>:\<endif\>,' ..
			\ '\<methods\>:\<endmethods\>,' ..
			\ '\<parfor\>:\<endparfor\>,' ..
			\ '\<properties\>:\<endproperties\>,' ..
			\ '\<switch\>:\<\%(case\|otherwise\)\>:\<endswitch\>,' ..
			\ '\<while\>:\<\%(break\|continue\)\>:\<endwhile\>,' ..
			\ '\<try\>:\<catch\>:\<end_try_catch\>'
  endif
  " only match in statement position
  let s:statement_start = escape('\%(\%(^\|;\)\s*\)\@<=', '\')
  let b:match_words = substitute(b:match_words, '\\<', s:statement_start, 'g')
endif

if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
  let b:browsefilter = "GNU Octave Source Files (*.m)\t*.m\n" ..
		     \ "All Files (*.*)\t*.*\n"
endif

let b:undo_ftplugin = "setl com< cms< fo< kp< " ..
		    \ "| unlet! b:browsefilter b:match_words"

let &cpo = s:cpo_save
unlet s:cpo_save

" vim: nowrap sw=2 sts=2 ts=8 noet:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  " Vim filetype plugin file
" Language:             pam(8) configuration file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               " Vim filetype plugin file
" Language:		Pascal
" Maintainer:		Doug Kearns <dougkearns@gmail.com>
" Previous Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
" Last Change:		2021 Apr 23

if exists("b:did_ftplugin") | finish | endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

set comments=s:(*,m:\ ,e:*),s:{,m:\ ,e:}
set commentstring={%s}

if exists("pascal_delphi")
  set comments+=:///
endif

if !exists("pascal_traditional")
  set commentstring=//\ %s
  set comments+=://
endif

setlocal formatoptions-=t formatoptions+=croql

if exists("loaded_matchit")
  let b:match_ignorecase = 1 " (Pascal is case-insensitive)

  let b:match_words  = '\<\%(asm\|begin\|case\|\%(\%(=\|packed\)\s*\)\@<=\%(class\|object\)\|\%(=\s*\)\@<=interface\|record\|try\)\>'
  let b:match_words .= ':\%(^\s*\)\@<=\%(except\|finally\|else\|otherwise\)\>'
  let b:match_words .= ':\<end\>\.\@!'

  let b:match_words .= ',\<repeat\>:\<until\>'
  " let b:match_words .= ',\<if\>:\<else\>' " FIXME - else clashing with middle else. It seems like a debatable use anyway.
  let b:match_words .= ',\<unit\>:\<\%(\%(^\s*\)\@<=interface\|implementation\|initialization\|finalization\)\>:\<end\.'
endif

if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
  let b:browsefilter = "Pascal Source Files (*.pas *.pp *.inc)\t*.pas;*.pp;*.inc\n" .
		     \ "All Files (*.*)\t*.*\n"
endif

let b:undo_ftplugin = "setl fo< cms< com< " ..
		    \ "| unlet! b:browsefilter b:match_words b:match_ignorecase"

let &cpo = s:cpo_save
unlet s:cpo_save

" vim: nowrap sw=2 sts=2 ts=8 noet:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                           " Vim filetype plugin file
" Language:             passwd(5) password file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments= commentstring= formatoptions-=tcroq formatoptions+=l

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        " Vim filetype plugin file
" Language:             Protobuf Text Format
" Maintainer:           Lakshay Garg <lakshayg@outlook.in>
" Last Change:          2020 Nov 17
" Homepage:             https://github.com/lakshayg/vim-pbtxt

if exists("b:did_ftplugin")
  finish
endif

let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

setlocal commentstring=#\ %s

let &cpo = s:cpo_save
unlet s:cpo_save

" vim: nowrap sw=2 sts=2 ts=8 noet
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ¢   pdf.vim £   perl.vim§   php.vim •   	pinfo.vim   ¶   plaintex.vimß   poke.vim®   postscr.vim ©   procmail.vim™   
prolog.vim  ´   protocols.vim   ¨   ps1.vim ≠   
ps1xml.vim  Æ   	pyrex.vim   Ø   
python.vim  ∞   qf.vim  ±   	quake.vim   ≤   r.vim   ≥   racc.vim¥   raku.vimµ   readline.vim∂   registry.vim∑   reva.vim∏   	rhelp.vim   π   rmd.vim ∫   rnc.vim ª   
rnoweb.vim  º   routeros.vimΩ   rpl.vim æ   rrst.vimø   rst.vim ¿   ruby.vim¡   rust.vim¬   sass.vim√   sbt.vim ƒ   	scala.vim   ≈   	scdoc.vim   ∆   
scheme.vim  «   
screen.vim  »   scss.vim…   sensors.vim     services.vimÀ   setserial.vim   Ã   sexplib.vim Õ   sgml.vimŒ   sh.vim  œ   	sieve.vim   –   slpconf.vim —   
slpreg.vim  “   
slpspi.vim  ”   spec.vim‘   sql.vim ’   sshconfig.vim   ÷   sudoers.vim ◊   svg.vim ÿ    	swift.vim               " Vim filetype plugin file
" Language:	PDF
" Maintainer:	Tim Pope <vimNOSPAM@tpope.info>
" Last Change:	2007 Dec 16

if exists("b:did_ftplugin")
    finish
endif
let b:did_ftplugin = 1

setlocal commentstring=%%s
setlocal comments=:%
let b:undo_ftplugin = "setlocal cms< com< | unlet! b:match_words"

if exists("g:loaded_matchit")
    let b:match_words = '\<\%(\d\+\s\+\d\+\s\+\)obj\>:\<endobj\>,\<stream$:\<endstream\>,\<xref\>:\<trailer\>,<<:>>'
endif

if exists("g:no_plugin_maps") || exists("g:no_pdf_maps") || v:version < 700
    finish
endif

if !exists("b:pdf_tagstack")
    let b:pdf_tagstack = []
endif

let b:undo_ftplugin .= " | silent! nunmap <buffer> <C-]> | silent! nunmap <buffer> <C-T>"
nnoremap <silent><buffer> <C-]> :call <SID>Tag()<CR>
" Inline, so the error from an empty tag stack will be simple.
nnoremap <silent><buffer> <C-T> :if len(b:pdf_tagstack) > 0 <Bar> call setpos('.',remove(b:pdf_tagstack, -1)) <Bar> else <Bar> exe "norm! \<Lt>C-T>" <Bar> endif<CR>

function! s:Tag()
    call add(b:pdf_tagstack,getpos('.'))
    if getline('.') =~ '^\d\+$' && getline(line('.')-1) == 'startxref'
	return s:dodigits(getline('.'))
    elseif getline('.') =~ '/Prev\s\+\d\+\>\%(\s\+\d\)\@!' && expand("<cword>") =~ '^\d\+$'
	return s:dodigits(expand("<cword>"))
    elseif getline('.') =~ '^\d\{10\} \d\{5\} '
	return s:dodigits(matchstr(getline('.'),'^\d\+'))
    else
	let line = getline(".")
	let lastend = 0
	let pat = '\<\d\+\s\+\d\+\s\+R\>'
	while lastend >= 0
	    let beg = match(line,'\C'.pat,lastend)
	    let end = matchend(line,'\C'.pat,lastend)
	    if beg < col(".") && end >= col(".")
		return s:doobject(matchstr(line,'\C'.pat,lastend))
	    endif
	    let lastend = end
	endwhile
	return s:notag()
    endif
endfunction

function! s:doobject(string)
    let first = matchstr(a:string,'^\s*\zs\d\+')
    let second = matchstr(a:string,'^\s*\d\+\s\+\zs\d\+')
    norm! m'
    if first != '' && second != ''
	let oldline = line('.')
	let oldcol = col('.')
	1
	if !search('^\s*'.first.'\s\+'.second.'\s\+obj\>')
	    exe oldline
	    exe 'norm! '.oldcol.'|'
	    return s:notag()
	endif
    endif
endfunction

function! s:dodigits(digits)
    let digits = 0 + substitute(a:digits,'^0*','','')
    norm! m'
    if digits <= 0
	norm! 1go
    else
	" Go one character before the destination and advance.  This method
	" lands us after a newline rather than before, if that is our target.
	exe "goto ".(digits)."|norm! 1 "
    endif
endfunction

function! s:notag()
    silent! call remove(b:pdf_tagstack,-1)
    echohl ErrorMsg
    echo "E426: tag not found"
    echohl NONE
endfunction
                                                                                                                                                                                                                                                                                                                                                                                                                                                                           " Vim filetype plugin file
" Language:      Perl
" Maintainer:    vim-perl <vim-perl@googlegroups.com>
" Homepage:      https://github.com/vim-perl/vim-perl
" Bugs/requests: https://github.com/vim-perl/vim-perl/issues
" Last Change:   2020 Apr 15

if exists("b:did_ftplugin") | finish | endif
let b:did_ftplugin = 1

" Make sure the continuation lines below do not cause problems in
" compatibility mode.
let s:save_cpo = &cpo
set cpo-=C

setlocal formatoptions-=t
setlocal formatoptions+=crqol
setlocal keywordprg=perldoc\ -f

setlocal comments=:#
setlocal commentstring=#%s

" Change the browse dialog on Win32 to show mainly Perl-related files
if has("gui_win32")
    let b:browsefilter = "Perl Source Files (*.pl)\t*.pl\n" .
		       \ "Perl Modules (*.pm)\t*.pm\n" .
		       \ "Perl Documentation Files (*.pod)\t*.pod\n" .
		       \ "All Files (*.*)\t*.*\n"
endif

" Provided by Ned Konz <ned at bike-nomad dot com>
"---------------------------------------------
setlocal include=\\<\\(use\\\|require\\)\\>
setlocal includeexpr=substitute(substitute(substitute(v:fname,'::','/','g'),'->\*','',''),'$','.pm','')
setlocal define=[^A-Za-z_]
setlocal iskeyword+=:

" The following line changes a global variable but is necessary to make
" gf and similar commands work. Thanks to Andrew Pimlott for pointing
" out the problem. If this causes a problem for you, add an
" after/ftplugin/perl.vim file that contains
"       set isfname-=:
set isfname+=:

" Set this once, globally.
if !exists("perlpath")
    if executable("perl")
      try
	if &shellxquote != '"'
	    let perlpath = system('perl -e "print join(q/,/,@INC)"')
	else
	    let perlpath = system("perl -e 'print join(q/,/,@INC)'")
	endif
	let perlpath = substitute(perlpath,',.$',',,','')
      catch /E145:/
	let perlpath = ".,,"
      endtry
    else
	" If we can't call perl to get its path, just default to using the
	" current directory and the directory of the current file.
	let perlpath = ".,,"
    endif
endif

" Append perlpath to the existing path value, if it is set.  Since we don't
" use += to do it because of the commas in perlpath, we have to handle the
" global / local settings, too.
if &l:path == ""
    if &g:path == ""
        let &l:path=perlpath
    else
        let &l:path=&g:path.",".perlpath
    endif
else
    let &l:path=&l:path.",".perlpath
endif
"---------------------------------------------

" Undo the stuff we changed.
let b:undo_ftplugin = "setlocal fo< com< cms< inc< inex< def< isk< isf< kp< path<" .
	    \	      " | unlet! b:browsefilter"

" proper matching for matchit plugin
let b:match_skip = 's:comment\|string\|perlQQ\|perlShellCommand\|perlHereDoc\|perlSubstitution\|perlTranslation\|perlMatch\|perlFormatField'
let b:match_words = '\<if\>:\<elsif\>:\<else\>'

" Restore the saved compatibility options.
let &cpo = s:save_cpo
unlet s:save_cpo
                                                                                                                                                                                                                           " Vim filetype plugin file
" Language:	php
" Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
" Last Changed: 20 Jan 2009
" URL:		http://dwsharp.users.sourceforge.net/vim/ftplugin

if exists("b:did_ftplugin") | finish | endif

" Make sure the continuation lines below do not cause problems in
" compatibility mode.
let s:keepcpo= &cpo
set cpo&vim

" Define some defaults in case the included ftplugins don't set them.
let s:undo_ftplugin = ""
let s:browsefilter = "HTML Files (*.html, *.htm)\t*.html;*.htm\n" .
	    \	     "All Files (*.*)\t*.*\n"
let s:match_words = ""

runtime! ftplugin/html.vim ftplugin/html_*.vim ftplugin/html/*.vim
let b:did_ftplugin = 1

" Override our defaults if these were set by an included ftplugin.
if exists("b:undo_ftplugin")
    let s:undo_ftplugin = b:undo_ftplugin
endif
if exists("b:browsefilter")
    let s:browsefilter = b:browsefilter
endif
if exists("b:match_words")
    let s:match_words = b:match_words
endif
if exists("b:match_skip")
    unlet b:match_skip
endif

" Change the :browse e filter to primarily show PHP-related files.
if has("gui_win32")
    let  b:browsefilter="PHP Files (*.php)\t*.php\n" . s:browsefilter
endif

" ###
" Provided by Mikolaj Machowski <mikmach at wp dot pl>
setlocal include=\\\(require\\\|include\\\)\\\(_once\\\)\\\?
" Disabled changing 'iskeyword', it breaks a command such as "*"
" setlocal iskeyword+=$

if exists("loaded_matchit")
    let b:match_words = '<?php:?>,\<switch\>:\<endswitch\>,' .
		      \ '\<if\>:\<elseif\>:\<else\>:\<endif\>,' .
		      \ '\<while\>:\<endwhile\>,' .
		      \ '\<do\>:\<while\>,' .
		      \ '\<for\>:\<endfor\>,' .
		      \ '\<foreach\>:\<endforeach\>,' .
                      \ '(:),[:],{:},' .
		      \ s:match_words
endif
" ###

if exists('&omnifunc')
  setlocal omnifunc=phpcomplete#CompletePHP
endif

" Section jumping: [[ and ]] provided by Antony Scriven <adscriven at gmail dot com>
let s:function = '\(abstract\s\+\|final\s\+\|private\s\+\|protected\s\+\|public\s\+\|static\s\+\)*function'
let s:class = '\(abstract\s\+\|final\s\+\)*class'
let s:interface = 'interface'
let s:section = '\(.*\%#\)\@!\_^\s*\zs\('.s:function.'\|'.s:class.'\|'.s:interface.'\)'
exe 'nno <buffer> <silent> [[ ?' . escape(s:section, '|') . '?<CR>:nohls<CR>'
exe 'nno <buffer> <silent> ]] /' . escape(s:section, '|') . '/<CR>:nohls<CR>'
exe 'ono <buffer> <silent> [[ ?' . escape(s:section, '|') . '?<CR>:nohls<CR>'
exe 'ono <buffer> <silent> ]] /' . escape(s:section, '|') . '/<CR>:nohls<CR>'

setlocal commentstring=/*%s*/

" Undo the stuff we changed.
let b:undo_ftplugin = "setlocal commentstring< include< omnifunc<" .
	    \	      " | unlet! b:browsefilter b:match_words | " .
	    \	      s:undo_ftplugin

" Restore the saved compatibility options.
let &cpo = s:keepcpo
unlet s:keepcpo
                                                                                                                                                                                                                                                                   " Vim filetype plugin file
" Language:             pinfo(1) configuration file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             " plain TeX filetype plugin
" Language:     plain TeX (ft=plaintex)
" Maintainer:   Benji Fisher, Ph.D. <benji@member.AMS.org>
" Version:	1.1
" Last Change:	Wed 19 Apr 2006

" Only do this when not done yet for this buffer.
if exists("b:did_ftplugin")
  finish
endif

" Start with initex.  This will also define b:did_ftplugin and b:undo_ftplugin .
source $VIMRUNTIME/ftplugin/initex.vim

" Avoid problems if running in 'compatible' mode.
let s:save_cpo = &cpo
set cpo&vim

let b:undo_ftplugin .= "| unlet! b:match_ignorecase b:match_skip b:match_words"

" Allow "[d" to be used to find a macro definition:
let &l:define .= '\|\\new\(count\|dimen\|skip\|muskip\|box\|toks\|read\|write'
	\ .	'\|fam\|insert\)'

" The following lines enable the macros/matchit.vim plugin for
" extended matching with the % key.
" There is no default meaning for \(...\) etc., but many users define one.
if exists("loaded_matchit")
  let b:match_ignorecase = 0
    \ | let b:match_skip = 'r:\\\@<!\%(\\\\\)*%'
    \ | let b:match_words = '(:),\[:],{:},\\(:\\),\\\[:\\],\\{:\\}'
endif " exists("loaded_matchit")

let &cpo = s:save_cpo
unlet s:save_cpo

" vim:sts=2:sw=2:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  " Vim filetype plugin file
" Language:	GNU Poke
" Maintainer:	Doug Kearns <dougkearns@gmail.com>
" Last Change:	2021 March 11

if exists("b:did_ftplugin")
    finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

setlocal comments=sO:*\ -,mO:*\ \ ,exO:*/,s1:/*,mb:*,ex:*/,://
setlocal commentstring=//\ %s
setlocal formatoptions-=t formatoptions+=croql

setlocal include=load
setlocal suffixesadd=.pk

if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
  let b:browsefilter = "Poke Files (*.pk)\t*.pk\n" .
		     \ "All Files (*.*)\t*.*\n"
endif

let b:undo_ftplugin = "setl fo< com< cms< inc< sua<" .
		    \ " | unlet! b:browsefilter"

let &cpo = s:cpo_save
unlet s:cpo_save

" vim: nowrap sw=2 sts=2 ts=8
                                                                                                                                                                                                                                                                                        " Vim filetype plugin file
" Language:	PostScript
" Maintainer:	Mike Williams <mrw@eandem.co.uk>
" Last Change:  24th April 2012

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

" PS comment formatting
setlocal comments=b:%
setlocal formatoptions-=t formatoptions+=rol

" Define patterns for the matchit macro
if !exists("b:match_words")
  let b:match_ignorecase = 0
  let b:match_words = '<<:>>,\<begin\>:\<end\>,\<save\>:\<restore\>,\<gsave\>:\<grestore\>'
endif

" Define patterns for the browse file filter
if has("gui_win32") && !exists("b:browsefilter")
  let b:browsefilter = "PostScript Files (*.ps)\t*.ps\n" .
    \ "EPS Files (*.eps)\t*.eps\n" .
    \ "All Files (*.*)\t*.*\n"
endif

let b:undo_ftplugin = "setlocal comments< formatoptions<"
    \ . "| unlet! b:browsefiler b:match_ignorecase b:match_words"

let &cpo = s:cpo_save
unlet s:cpo_save
                  " Vim filetype plugin file
" Language:             procmail(1) configuration file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< inc< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &l:include = '^\s*INCLUDERC\>'

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 " Vim filetype plugin file
" Language:             Prolog
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=s1:/*,mb:*,ex:*/,:% commentstring=%\ %s
setlocal formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        " Vim filetype plugin file
" Language:             protocols(5) - Internet protocols definition file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       " Vim filetype plugin file
" Language:    Windows PowerShell
" URL:         https://github.com/PProvost/vim-ps1
" Last Change: 2021 Apr 02

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin") | finish | endif

" Don't load another plug-in for this buffer
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

setlocal tw=0
setlocal commentstring=#%s
setlocal formatoptions=tcqro
" Enable autocompletion of hyphenated PowerShell commands,
" e.g. Get-Content or Get-ADUser
setlocal iskeyword+=-

" Change the browse dialog on Win32 to show mainly PowerShell-related files
if has("gui_win32")
	let b:browsefilter =
				\ "All PowerShell Files (*.ps1, *.psd1, *.psm1, *.ps1xml)\t*.ps1;*.psd1;*.psm1;*.ps1xml\n" .
				\ "PowerShell Script Files (*.ps1)\t*.ps1\n" .
				\ "PowerShell Module Files (*.psd1, *.psm1)\t*.psd1;*.psm1\n" .
				\ "PowerShell XML Files (*.ps1xml)\t*.ps1xml\n" .
				\ "All Files (*.*)\t*.*\n"
endif

" Look up keywords by Get-Help:
" check for PowerShell Core in Windows, Linux or MacOS
if executable('pwsh') | let s:pwsh_cmd = 'pwsh'
  " on Windows Subsystem for Linux, check for PowerShell Core in Windows
elseif exists('$WSLENV') && executable('pwsh.exe') | let s:pwsh_cmd = 'pwsh.exe'
  " check for PowerShell <= 5.1 in Windows
elseif executable('powershell.exe') | let s:pwsh_cmd = 'powershell.exe'
endif

if exists('s:pwsh_cmd')
  if !has('gui_running') && executable('less') &&
        \ !(exists('$ConEmuBuild') && &term =~? '^xterm')
    " For exclusion of ConEmu, see https://github.com/Maximus5/ConEmu/issues/2048
    command! -buffer -nargs=1 GetHelp silent exe '!' . s:pwsh_cmd . ' -NoLogo -NoProfile -NonInteractive -ExecutionPolicy RemoteSigned -Command Get-Help -Full "<args>" | ' . (has('unix') ? 'LESS= less' : 'less') | redraw!
  elseif has('terminal')
    command! -buffer -nargs=1 GetHelp silent exe 'term ' . s:pwsh_cmd . ' -NoLogo -NoProfile -NonInteractive -ExecutionPolicy RemoteSigned -Command Get-Help -Full "<args>"' . (executable('less') ? ' | less' : '')
  else
    command! -buffer -nargs=1 GetHelp echo system(s:pwsh_cmd . ' -NoLogo -NoProfile -NonInteractive -ExecutionPolicy RemoteSigned -Command Get-Help -Full <args>')
  endif
endif
setlocal keywordprg=:GetHelp

" Undo the stuff we changed
let b:undo_ftplugin = "setlocal tw< cms< fo< iskeyword< keywordprg<" .
			\ " | unlet! b:browsefilter"

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            " Vim filetype plugin file
" Language:    Windows PowerShell
" URL:         https://github.com/PProvost/vim-ps1
" Last Change: 2021 Apr 02

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin") | finish | endif

" Don't load another plug-in for this buffer
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

setlocal tw=0
setlocal commentstring=#%s
setlocal formatoptions=tcqro

" Change the browse dialog on Win32 to show mainly PowerShell-related files
if has("gui_win32")
  let b:browsefilter = 
        \ "All PowerShell Files (*.ps1, *.psd1, *.psm1, *.ps1xml)\t*.ps1;*.psd1;*.psm1;*.ps1xml\n" .
        \ "PowerShell Script Files (*.ps1)\t*.ps1\n" .
        \ "PowerShell Module Files (*.psd1, *.psm1)\t*.psd1;*.psm1\n" .
        \ "PowerShell XML Files (*.ps1xml)\t*.ps1xml\n" .
        \ "All Files (*.*)\t*.*\n"
endif

" Undo the stuff we changed
let b:undo_ftplugin = "setlocal tw< cms< fo<" .
      \ " | unlet! b:browsefilter"

let &cpo = s:cpo_save
unlet s:cpo_save
               " Vim filetype plugin file
" Language:	Pyrex
" Maintainer:	Marco Barisione <marco.bari@people.it>
" URL:		http://marcobari.altervista.org/pyrex_vim.html
" Last Change:	2012 May 18

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif
let s:keepcpo= &cpo
set cpo&vim

" Behaves just like Python
runtime! ftplugin/python.vim ftplugin/python_*.vim ftplugin/python/*.vim

if has("gui_win32") && exists("b:browsefilter")
    let  b:browsefilter = "Pyrex files (*.pyx,*.pxd)\t*.pyx;*.pxd\n" .
			\ "Python Files (*.py)\t*.py\n" .
			\ "C Source Files (*.c)\t*.c\n" .
			\ "C Header Files (*.h)\t*.h\n" .
			\ "C++ Source Files (*.cpp *.c++)\t*.cpp;*.c++\n" .
			\ "All Files (*.*)\t*.*\n"
endif

let &cpo = s:keepcpo
unlet s:keepcpo
                                                                                                                                                                                                                                                                  " Vim filetype plugin file
" Language:	python
" Maintainer:	Tom Picton <tom@tompicton.co.uk>
" Previous Maintainer: James Sully <sullyj3@gmail.com>
" Previous Maintainer: Johannes Zellner <johannes@zellner.org>
" Last Change:	Mon, 5 October 2020
" https://github.com/tpict/vim-ftplugin-python

if exists("b:did_ftplugin") | finish | endif
let b:did_ftplugin = 1
let s:keepcpo= &cpo
set cpo&vim

setlocal cinkeys-=0#
setlocal indentkeys-=0#
setlocal include=^\\s*\\(from\\\|import\\)
setlocal define=^\\s*\\(def\\\|class\\)

" For imports with leading .., append / and replace additional .s with ../
let b:grandparent_match = '^\(.\.\)\(\.*\)'
let b:grandparent_sub = '\=submatch(1)."/".repeat("../",strlen(submatch(2)))'

" For imports with a single leading ., replace it with ./
let b:parent_match = '^\.\(\.\)\@!'
let b:parent_sub = './'

" Replace any . sandwiched between word characters with /
let b:child_match = '\(\w\)\.\(\w\)'
let b:child_sub = '\1/\2'

setlocal includeexpr=substitute(substitute(substitute(
      \v:fname,
      \b:grandparent_match,b:grandparent_sub,''),
      \b:parent_match,b:parent_sub,''),
      \b:child_match,b:child_sub,'g')

setlocal suffixesadd=.py
setlocal comments=b:#,fb:-
setlocal commentstring=#\ %s

if has('python3')
  setlocal omnifunc=python3complete#Complete
elseif has('python')
  setlocal omnifunc=pythoncomplete#Complete
endif

set wildignore+=*.pyc

let b:next_toplevel='\v%$\|^(class\|def\|async def)>'
let b:prev_toplevel='\v^(class\|def\|async def)>'
let b:next_endtoplevel='\v%$\|\S.*\n+(def\|class)'
let b:prev_endtoplevel='\v\S.*\n+(def\|class)'
let b:next='\v%$\|^\s*(class\|def\|async def)>'
let b:prev='\v^\s*(class\|def\|async def)>'
let b:next_end='\v\S\n*(%$\|^(\s*\n*)*(class\|def\|async def)\|^\S)'
let b:prev_end='\v\S\n*(^(\s*\n*)*(class\|def\|async def)\|^\S)'

if !exists('g:no_plugin_maps') && !exists('g:no_python_maps')
    execute "nnoremap <silent> <buffer> ]] :call <SID>Python_jump('n', '". b:next_toplevel."', 'W', v:count1)<cr>"
    execute "nnoremap <silent> <buffer> [[ :call <SID>Python_jump('n', '". b:prev_toplevel."', 'Wb', v:count1)<cr>"
    execute "nnoremap <silent> <buffer> ][ :call <SID>Python_jump('n', '". b:next_endtoplevel."', 'W', v:count1, 0)<cr>"
    execute "nnoremap <silent> <buffer> [] :call <SID>Python_jump('n', '". b:prev_endtoplevel."', 'Wb', v:count1, 0)<cr>"
    execute "nnoremap <silent> <buffer> ]m :call <SID>Python_jump('n', '". b:next."', 'W', v:count1)<cr>"
    execute "nnoremap <silent> <buffer> [m :call <SID>Python_jump('n', '". b:prev."', 'Wb', v:count1)<cr>"
    execute "nnoremap <silent> <buffer> ]M :call <SID>Python_jump('n', '". b:next_end."', 'W', v:count1, 0)<cr>"
    execute "nnoremap <silent> <buffer> [M :call <SID>Python_jump('n', '". b:prev_end."', 'Wb', v:count1, 0)<cr>"

    execute "onoremap <silent> <buffer> ]] :call <SID>Python_jump('o', '". b:next_toplevel."', 'W', v:count1)<cr>"
    execute "onoremap <silent> <buffer> [[ :call <SID>Python_jump('o', '". b:prev_toplevel."', 'Wb', v:count1)<cr>"
    execute "onoremap <silent> <buffer> ][ :call <SID>Python_jump('o', '". b:next_endtoplevel."', 'W', v:count1, 0)<cr>"
    execute "onoremap <silent> <buffer> [] :call <SID>Python_jump('o', '". b:prev_endtoplevel."', 'Wb', v:count1, 0)<cr>"
    execute "onoremap <silent> <buffer> ]m :call <SID>Python_jump('o', '". b:next."', 'W', v:count1)<cr>"
    execute "onoremap <silent> <buffer> [m :call <SID>Python_jump('o', '". b:prev."', 'Wb', v:count1)<cr>"
    execute "onoremap <silent> <buffer> ]M :call <SID>Python_jump('o', '". b:next_end."', 'W', v:count1, 0)<cr>"
    execute "onoremap <silent> <buffer> [M :call <SID>Python_jump('o', '". b:prev_end."', 'Wb', v:count1, 0)<cr>"

    execute "xnoremap <silent> <buffer> ]] :call <SID>Python_jump('x', '". b:next_toplevel."', 'W', v:count1)<cr>"
    execute "xnoremap <silent> <buffer> [[ :call <SID>Python_jump('x', '". b:prev_toplevel."', 'Wb', v:count1)<cr>"
    execute "xnoremap <silent> <buffer> ][ :call <SID>Python_jump('x', '". b:next_endtoplevel."', 'W', v:count1, 0)<cr>"
    execute "xnoremap <silent> <buffer> [] :call <SID>Python_jump('x', '". b:prev_endtoplevel."', 'Wb', v:count1, 0)<cr>"
    execute "xnoremap <silent> <buffer> ]m :call <SID>Python_jump('x', '". b:next."', 'W', v:count1)<cr>"
    execute "xnoremap <silent> <buffer> [m :call <SID>Python_jump('x', '". b:prev."', 'Wb', v:count1)<cr>"
    execute "xnoremap <silent> <buffer> ]M :call <SID>Python_jump('x', '". b:next_end."', 'W', v:count1, 0)<cr>"
    execute "xnoremap <silent> <buffer> [M :call <SID>Python_jump('x', '". b:prev_end."', 'Wb', v:count1, 0)<cr>"
endif

if !exists('*<SID>Python_jump')
  fun! <SID>Python_jump(mode, motion, flags, count, ...) range
      let l:startofline = (a:0 >= 1) ? a:1 : 1

      if a:mode == 'x'
          normal! gv
      endif

      if l:startofline == 1
          normal! 0
      endif

      let cnt = a:count
      mark '
      while cnt > 0
          call search(a:motion, a:flags)
          let cnt = cnt - 1
      endwhile

      if l:startofline == 1
          normal! ^
      endif
  endfun
endif

if has("browsefilter") && !exists("b:browsefilter")
    let b:browsefilter = "Python Files (*.py)\t*.py\n" .
                \ "All Files (*.*)\t*.*\n"
endif

if !exists("g:python_recommended_style") || g:python_recommended_style != 0
    " As suggested by PEP8.
    setlocal expandtab tabstop=4 softtabstop=4 shiftwidth=4
endif

" Use pydoc for keywordprg.
" Unix users preferentially get pydoc3, then pydoc2.
" Windows doesn't have a standalone pydoc executable in $PATH by default, nor
" does it have separate python2/3 executables, so Windows users just get
" whichever version corresponds to their installed Python version.
if executable('python3')
  setlocal keywordprg=python3\ -m\ pydoc
elseif executable('python')
  setlocal keywordprg=python\ -m\ pydoc
endif

" Script for filetype switching to undo the local stuff we may have changed
let b:undo_ftplugin = 'setlocal cinkeys<'
      \ . '|setlocal comments<'
      \ . '|setlocal commentstring<'
      \ . '|setlocal expandtab<'
      \ . '|setlocal include<'
      \ . '|setlocal includeexpr<'
      \ . '|setlocal indentkeys<'
      \ . '|setlocal keywordprg<'
      \ . '|setlocal omnifunc<'
      \ . '|setlocal shiftwidth<'
      \ . '|setlocal softtabstop<'
      \ . '|setlocal suffixesadd<'
      \ . '|setlocal tabstop<'
      \ . '|silent! nunmap <buffer> [M'
      \ . '|silent! nunmap <buffer> [['
      \ . '|silent! nunmap <buffer> []'
      \ . '|silent! nunmap <buffer> [m'
      \ . '|silent! nunmap <buffer> ]M'
      \ . '|silent! nunmap <buffer> ]['
      \ . '|silent! nunmap <buffer> ]]'
      \ . '|silent! nunmap <buffer> ]m'
      \ . '|silent! ounmap <buffer> [M'
      \ . '|silent! ounmap <buffer> [['
      \ . '|silent! ounmap <buffer> []'
      \ . '|silent! ounmap <buffer> [m'
      \ . '|silent! ounmap <buffer> ]M'
      \ . '|silent! ounmap <buffer> ]['
      \ . '|silent! ounmap <buffer> ]]'
      \ . '|silent! ounmap <buffer> ]m'
      \ . '|silent! xunmap <buffer> [M'
      \ . '|silent! xunmap <buffer> [['
      \ . '|silent! xunmap <buffer> []'
      \ . '|silent! xunmap <buffer> [m'
      \ . '|silent! xunmap <buffer> ]M'
      \ . '|silent! xunmap <buffer> ]['
      \ . '|silent! xunmap <buffer> ]]'
      \ . '|silent! xunmap <buffer> ]m'
      \ . '|unlet! b:browsefilter'
      \ . '|unlet! b:child_match'
      \ . '|unlet! b:child_sub'
      \ . '|unlet! b:grandparent_match'
      \ . '|unlet! b:grandparent_sub'
      \ . '|unlet! b:next'
      \ . '|unlet! b:next_end'
      \ . '|unlet! b:next_endtoplevel'
      \ . '|unlet! b:next_toplevel'
      \ . '|unlet! b:parent_match'
      \ . '|unlet! b:parent_sub'
      \ . '|unlet! b:prev'
      \ . '|unlet! b:prev_end'
      \ . '|unlet! b:prev_endtoplevel'
      \ . '|unlet! b:prev_toplevel'
      \ . '|unlet! b:undo_ftplugin'

let &cpo = s:keepcpo
unlet s:keepcpo
                                                                                                                                                                                                                                      " Vim filetype plugin file
" Language:     Vim's quickfix window
" Maintainer:   Lech Lorens <Lech.Lorens@gmail.com>
" Last Change: 	2019 Jul 15

if exists("b:did_ftplugin")
  finish
endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

if !get(g:, 'qf_disable_statusline')
  let b:undo_ftplugin = "set stl<"

  " Display the command that produced the list in the quickfix window:
  setlocal stl=%t%{exists('w:quickfix_title')?\ '\ '.w:quickfix_title\ :\ ''}\ %=%-15(%l,%c%V%)\ %P
endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    " Vim filetype plugin file
" Language:             Quake[1-3] configuration file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:// commentstring=//\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         " Vim filetype plugin file
" Language: R
" Maintainer: Jakson Alves de Aquino <jalvesaq@gmail.com>
" Homepage: https://github.com/jalvesaq/R-Vim-runtime
" Last Change:	Sat Aug 15, 2020  11:37AM

" Only do this when not yet done for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

setlocal iskeyword=@,48-57,_,.
setlocal formatoptions-=t
setlocal commentstring=#\ %s
setlocal comments=:#',:###,:##,:#

if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
  let b:browsefilter = "R Source Files (*.R)\t*.R\n" .
        \ "Files that include R (*.Rnw *.Rd *.Rmd *.Rrst)\t*.Rnw;*.Rd;*.Rmd;*.Rrst\n" .
        \ "All Files (*.*)\t*.*\n"
endif

let b:undo_ftplugin = "setl cms< com< fo< isk< | unlet! b:browsefilter"

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                  " Vim filetype plugin file
" Language:             Racc input file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=s1:/*,mb:*,ex:*/,:# commentstring=#\ %s
setlocal formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               " Vim filetype plugin file
" Language:      Raku
" Maintainer:    vim-perl <vim-perl@googlegroups.com>
" Homepage:      https://github.com/Raku/vim-raku
" Bugs/requests: https://github.com/Raku/vim-raku/issues
" Last Change:   2021-04-16
" Contributors:  Hinrik √ñrn Sigur√∞sson <hinrik.sig@gmail.com>
"
" Based on ftplugin/perl.vim by Dan Sharp <dwsharp at hotmail dot com>

if exists("b:did_ftplugin") | finish | endif
let b:did_ftplugin = 1

" Make sure the continuation lines below do not cause problems in
" compatibility mode.
let s:save_cpo = &cpo
set cpo-=C

setlocal formatoptions-=t
setlocal formatoptions+=crqol
setlocal keywordprg=p6doc

setlocal comments=:#\|,:#=,:#
setlocal commentstring=#%s

" Provided by Ned Konz <ned at bike-nomad dot com>
"---------------------------------------------
setlocal include=\\<\\(use\\\|require\\)\\>
setlocal includeexpr=substitute(v:fname,'::','/','g')
setlocal suffixesadd=.rakumod,.rakudoc,.pm6,.pm
setlocal define=[^A-Za-z_]

" The following line changes a global variable but is necessary to make
" gf and similar commands work. Thanks to Andrew Pimlott for pointing out
" the problem. If this causes a problem for you, add an
" after/ftplugin/raku.vim file that contains
"       set isfname-=:
set isfname+=:
setlocal iskeyword=@,48-57,_,192-255,-

" Raku exposes its CompUnits through $*REPO, but mapping module names to
" compunit paths is nontrivial. Probably it's more convenient to rely on
" people using zef, which has a handy store of sources for modules it has
" installed.
func s:compareReverseFtime(a, b)
    let atime = getftime(a:a)
    let btime = getftime(a:b)
    return atime > btime ? -1 : atime == btime ? 0 : 1
endfunc

let &l:path = "lib,."
if exists('$RAKULIB')
    let &l:path = &l:path . "," . $RAKULIB
endif
let &l:path = &l:path . "," . join(
            \ sort(glob("~/.zef/store/*/*/lib", 0, 1), "s:compareReverseFtime"),
            \ ',')

" Convert ascii-based ops into their single-character unicode equivalent
if get(g:, 'raku_unicode_abbrevs', 0)
    iabbrev 