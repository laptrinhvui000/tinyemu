EWISH':'','CAL_MONTH_FRENCH':'','CAL_EASTER_DEFAULT':'','CAL_EASTER_ROMAN':'','CAL_EASTER_ALWAYS_GREGORIAN':'','CAL_EASTER_ALWAYS_JULIAN':'','CAL_JEWISH_ADD_ALAFIM_GERESH':'','CAL_JEWISH_ADD_ALAFIM':'','CAL_JEWISH_ADD_GERESHAYIM':'',}
let php_builtin['constants']['curl']={'CURLOPT_POSTFIELDS':'','CURLOPT_CAINFO':'','CURLOPT_AUTOREFERER':'','CURLOPT_COOKIESESSION':'','CURLOPT_DNS_USE_GLOBAL_CACHE':'','CURLOPT_DNS_CACHE_TIMEOUT':'','CURLOPT_FTP_SSL':'','CURLFTPSSL_TRY':'','CURLFTPSSL_ALL':'','CURLFTPSSL_CONTROL':'','CURLFTPSSL_NONE':'','CURLOPT_PRIVATE':'','CURLOPT_FTPSSLAUTH':'','CURLOPT_PORT':'','CURLOPT_FILE':'','CURLOPT_INFILE':'','CURLOPT_INFILESIZE':'','CURLOPT_URL':'','CURLOPT_PROXY':'','CURLOPT_VERBOSE':'','CURLOPT_HEADER':'','CURLOPT_HTTPHEADER':'','CURLOPT_NOPROGRESS':'','CURLOPT_NOBODY':'','CURLOPT_FAILONERROR':'','CURLOPT_UPLOAD':'','CURLOPT_POST':'','CURLOPT_FTPLISTONLY':'','CURLOPT_FTPAPPEND':'','CURLOPT_FTP_CREATE_MISSING_DIRS':'','CURLOPT_NETRC':'','CURLOPT_FOLLOWLOCATION':'','CURLOPT_FTPASCII':'','CURLOPT_PUT':'','CURLOPT_MUTE':'','CURLOPT_USERPWD':'','CURLOPT_PROXYUSERPWD':'','CURLOPT_RANGE':'','CURLOPT_TIMEOUT':'','CURLOPT_TIMEOUT_MS':'','CURLOPT_TCP_NODELAY':'','CURLOPT_PROGRESSFUNCTION':'','CURLOPT_REFERER':'','CURLOPT_USERAGENT':'','CURLOPT_FTPPORT':'','CURLOPT_FTP_USE_EPSV':'','CURLOPT_LOW_SPEED_LIMIT':'','CURLOPT_LOW_SPEED_TIME':'','CURLOPT_RESUME_FROM':'','CURLOPT_COOKIE':'','CURLOPT_SSLCERT':'','CURLOPT_SSLCERTPASSWD':'','CURLOPT_WRITEHEADER':'','CURLOPT_SSL_VERIFYHOST':'','CURLOPT_COOKIEFILE':'','CURLOPT_SSLVERSION':'','CURLOPT_TIMECONDITION':'','CURLOPT_TIMEVALUE':'','CURLOPT_CUSTOMREQUEST':'','CURLOPT_STDERR':'','CURLOPT_TRANSFERTEXT':'','CURLOPT_RETURNTRANSFER':'','CURLOPT_QUOTE':'','CURLOPT_POSTQUOTE':'','CURLOPT_INTERFACE':'','CURLOPT_KRB4LEVEL':'','CURLOPT_HTTPPROXYTUNNEL':'','CURLOPT_FILETIME':'','CURLOPT_WRITEFUNCTION':'','CURLOPT_READFUNCTION':'','CURLOPT_PASSWDFUNCTION':'','CURLOPT_HEADERFUNCTION':'','CURLOPT_MAXREDIRS':'','CURLOPT_MAXCONNECTS':'','CURLOPT_CLOSEPOLICY':'','CURLOPT_FRESH_CONNECT':'','CURLOPT_FORBID_REUSE':'','CURLOPT_RANDOM_FILE':'','CURLOPT_EGDSOCKET':'','CURLOPT_CONNECTTIMEOUT':'','CURLOPT_CONNECTTIMEOUT_MS':'','CURLOPT_SSL_VERIFYPEER':'','CURLOPT_CAPATH':'','CURLOPT_COOKIEJAR':'','CURLOPT_SSL_CIPHER_LIST':'','CURLOPT_BINARYTRANSFER':'','CURLOPT_NOSIGNAL':'','CURLOPT_PROXYTYPE':'','CURLOPT_BUFFERSIZE':'','CURLOPT_HTTPGET':'','CURLOPT_HTTP_VERSION':'','CURLOPT_SSLKEY':'','CURLOPT_SSLKEYTYPE':'','CURLOPT_SSLKEYPASSWD':'','CURLOPT_SSLENGINE':'','CURLOPT_SSLENGINE_DEFAULT':'','CURLOPT_SSLCERTTYPE':'','CURLOPT_CRLF':'','CURLOPT_ENCODING':'','CURLOPT_PROXYPORT':'','CURLOPT_UNRESTRICTED_AUTH':'','CURLOPT_FTP_USE_EPRT':'','CURLOPT_HTTP200ALIASES':'','CURLOPT_HTTPAUTH':'','CURLAUTH_BASIC':'','CURLAUTH_DIGEST':'','CURLAUTH_GSSNEGOTIATE':'','CURLAUTH_NTLM':'','CURLAUTH_ANY':'','CURLAUTH_ANYSAFE':'','CURLOPT_PROXYAUTH':'','CURLOPT_MAX_RECV_SPEED_LARGE':'','CURLOPT_MAX_SEND_SPEED_LARGE':'','CURLCLOSEPOLICY_LEAST_RECENTLY_USED':'','CURLCLOSEPOLICY_LEAST_TRAFFIC':'','CURLCLOSEPOLICY_SLOWEST':'','CURLCLOSEPOLICY_CALLBACK':'','CURLCLOSEPOLICY_OLDEST':'','CURLINFO_PRIVATE':'','CURLINFO_EFFECTIVE_URL':'','CURLINFO_HTTP_CODE':'','CURLINFO_HEADER_OUT':'','CURLINFO_HEADER_SIZE':'','CURLINFO_REQUEST_SIZE':'','CURLINFO_TOTAL_TIME':'','CURLINFO_NAMELOOKUP_TIME':'','CURLINFO_CONNECT_TIME':'','CURLINFO_PRETRANSFER_TIME':'','CURLINFO_SIZE_UPLOAD':'','CURLINFO_SIZE_DOWNLOAD':'','CURLINFO_SPEED_DOWNLOAD':'','CURLINFO_SPEED_UPLOAD':'','CURLINFO_FILETIME':'','CURLINFO_SSL_VERIFYRESULT':'','CURLINFO_CONTENT_LENGTH_DOWNLOAD':'','CURLINFO_CONTENT_LENGTH_UPLOAD':'','CURLINFO_STARTTRANSFER_TIME':'','CURLINFO_CONTENT_TYPE':'','CURLINFO_REDIRECT_TIME':'','CURLINFO_REDIRECT_COUNT':'','CURL_TIMECOND_IFMODSINCE':'','CURL_TIMECOND_IFUNMODSINCE':'','CURL_TIMECOND_LASTMOD':'','CURL_VERSION_IPV6':'','CURL_VERSION_KERBEROS4':'','CURL_VERSION_SSL':'','CURL_VERSION_LIBZ':'','CURLVERSION_NOW':'','CURLE_OK':'','CURLE_UNSUPPORTED_PROTOCOL':'','CURLE_FAILED_INIT':'','CURLE_URL_MALFORMAT':'','CURLE_URL_MALFORMAT_USER':'','CURLE_COULDNT_RESOLVE_PROXY':'','CURLE_COULDNT_RESOLVE_HOST':'','CURLE_COULDNT_CONNECT':'','CURLE_FTP_WEIRD_SERVER_REPLY':'','CURLE_FTP_ACCESS_DENIED':'','CURLE_FTP_USER_PASSWORD_INCORRECT':'','CURLE_FTP_WEIRD_PASS_REPLY':'','CURLE_FTP_WEIRD_USER_REPLY':'','CURLE_FTP_WEIRD_PASV_REPLY':'','CURLE_FTP_WEIRD_227_FORMAT':'','CURLE_FTP_CANT_GET_HOST':'','CURLE_FTP_CANT_RECONNECT':'','CURLE_FTP_COULDNT_SET_BINARY':'','CURLE_PARTIAL_FILE':'','CURLE_FTP_COULDNT_RETR_FILE':'','CURLE_FTP_WRITE_ERROR':'','CURLE_FTP_QUOTE_ERROR':'','CURLE_HTTP_NOT_FOUND':'','CURLE_WRITE_ERROR':'','CURLE_MALFORMAT_USER':'','CURLE_FTP_COULDNT_STOR_FILE':'','CURLE_READ_ERROR':'','CURLE_OUT_OF_MEMORY':'','CURLE_OPERATION_TIMEOUTED':'','CURLE_FTP_COULDNT_SET_ASCII':'','CURLE_FTP_PORT_FAILED':'','CURLE_FTP_COULDNT_USE_REST':'','CURLE_FTP_COULDNT_GET_SIZE':'','CURLE_HTTP_RANGE_ERROR':'','CURLE_HTTP_POST_ERROR':'','CURLE_SSL_CONNECT_ERROR':'','CURLE_FTP_BAD_DOWNLOAD_RESUME':'','CURLE_FILE_COULDNT_READ_FILE':'','CURLE_LDAP_CANNOT_BIND':'','CURLE_LDAP_SEARCH_FAILED':'','CURLE_LIBRARY_NOT_FOUND':'','CURLE_FUNCTION_NOT_FOUND':'','CURLE_ABORTED_BY_CALLBACK':'','CURLE_BAD_FUNCTION_ARGUMENT':'','CURLE_BAD_CALLING_ORDER':'','CURLE_HTTP_PORT_FAILED':'','CURLE_BAD_PASSWORD_ENTERED':'','CURLE_TOO_MANY_REDIRECTS':'','CURLE_UNKNOWN_TELNET_OPTION':'','CURLE_TELNET_OPTION_SYNTAX':'','CURLE_OBSOLETE':'','CURLE_SSL_PEER_CERTIFICATE':'','CURLE_GOT_NOTHING':'','CURLE_SSL_ENGINE_NOTFOUND':'','CURLE_SSL_ENGINE_SETFAILED':'','CURLE_SEND_ERROR':'','CURLE_RECV_ERROR':'','CURLE_SHARE_IN_USE':'','CURLE_SSL_CERTPROBLEM':'','CURLE_SSL_CIPHER':'','CURLE_SSL_CACERT':'','CURLE_BAD_CONTENT_ENCODING':'','CURLE_LDAP_INVALID_URL':'','CURLE_FILESIZE_EXCEEDED':'','CURLE_FTP_SSL_FAILED':'','CURLFTPAUTH_DEFAULT':'','CURLFTPAUTH_SSL':'','CURLFTPAUTH_TLS':'','CURLPROXY_HTTP':'','CURLPROXY_SOCKS5':'','CURL_NETRC_OPTIONAL':'','CURL_NETRC_IGNORED':'','CURL_NETRC_REQUIRED':'','CURL_HTTP_VERSION_NONE':'','CURL_HTTP_VERSION_1_0':'','CURL_HTTP_VERSION_1_1':'','CURLM_CALL_MULTI_PERFORM':'','CURLM_OK':'','CURLM_BAD_HANDLE':'','CURLM_BAD_EASY_HANDLE':'','CURLM_OUT_OF_MEMORY':'','CURLM_INTERNAL_ERROR':'','CURLMSG_DONE':'','CURLOPT_KEYPASSWD':'','CURLOPT_SSH_AUTH_TYPES':'','CURLOPT_SSH_HOST_PUBLIC_KEY_MD5':'','CURLOPT_SSH_PRIVATE_KEYFILE':'','CURLOPT_SSH_PUBLIC_KEYFILE':'','CURLMOPT_PIPELINING':'','CURLMOPT_MAXCONNECTS':'','CURLSSH_AUTH_ANY':'','CURLSSH_AUTH_DEFAULT':'','CURLSSH_AUTH_HOST':'','CURLSSH_AUTH_KEYBOARD':'','CURLSSH_AUTH_NONE':'','CURLSSH_AUTH_PASSWORD':'','CURLSSH_AUTH_PUBLICKEY':'','CURL_WRAPPERS_ENABLED':'','CURLPAUSE_ALL':'','CURLPAUSE_CONT':'','CURLPAUSE_RECV':'','CURLPAUSE_RECV_CONT':'','CURLPAUSE_SEND':'','CURLPAUSE_SEND_CONT':'','CURLM_XXX':'','CURLOPT_CERTINFO':'','CURLOPT_CONNECT_ONLY':'','CURLINFO_':'','CURLOPT_PROTOCOLS':'','CURLOPT_REDIR_PROTOCOLS':'','CURLOPT_IPRESOLVE':'','CURL_IPRESOLVE_WHATEVER':'','CURL_IPRESOLVE_V4':'','CURL_IPRESOLVE_V6':'','CURLOPT_SHARE':'','CURLSHOPT_SHARE':'','CURLSHOPT_UNSHARE':'','CURL_LOCK_DATA_COOKIE':'','CURL_LOCK_DATA_DNS':'','CURL_LOCK_DATA_SSL_SESSION':'',}
let php_builtin['constants']['date_time']={'DATE_ATOM':'','DATE_COOKIE':'','DATE_ISO8601':'','DATE_RFC822':'','DATE_RFC850':'','DATE_RFC1036':'','DATE_RFC1123':'','DATE_RFC2822':'','DATE_RFC3339':'','DATE_RSS':'','DATE_W3C':'','SUNFUNCS_RET_TIMESTAMP':'','SUNFUNCS_RET_STRING':'','SUNFUNCS_RET_DOUBLE':'','LC_TIME':'',}
let php_builtin['constants']['libxml']={'LIBXML_ERR_WARNING':'','LIBXML_ERR_ERROR':'','LIBXML_ERR_FATAL':'','LIBXML_NONET':'','LIBXML_COMPACT':'','LIBXML_DTDATTR':'','LIBXML_DTDLOAD':'','LIBXML_DTDVALID':'','LIBXML_HTML_NOIMPLIED':'','LIBXML_HTML_NODEFDTD':'','LIBXML_NOBLANKS':'','LIBXML_NOCDATA':'','LIBXML_NOEMPTYTAG':'','LIBXML_NOENT':'','LIBXML_NOERROR':'','LIBXML_NOWARNING':'','LIBXML_NOXMLDECL':'','LIBXML_NSCLEAN':'','LIBXML_PARSEHUGE':'','LIBXML_PEDANTIC':'','LIBXML_XINCLUDE':'','LIBXML_ERR_NONE':'','LIBXML_VERSION':'','LIBXML_DOTTED_VERSION':'','LIBXML_SCHEMA_CREATE':'',}
let php_builtin['constants']['mysqli']={'MYSQLI_REPORT_OFF':'','MYSQLI_REPORT_ALL':'','MYSQLI_REPORT_STRICT':'','MYSQLI_REPORT_ERROR':'','MYSQLI_REPORT_INDEX':'','MYSQLI_ASSOC':'','MYSQLI_NUM':'','MYSQLI_BOTH':'','PHP_INT_MAX':'','MYSQLI_READ_DEFAULT_GROUP':'','MYSQLI_READ_DEFAULT_FILE':'','MYSQLI_OPT_CONNECT_TIMEOUT':'','MYSQLI_OPT_LOCAL_INFILE':'','MYSQLI_INIT_COMMAND':'','MYSQLI_CLIENT_SSL':'','MYSQLI_CLIENT_COMPRESS':'','MYSQLI_CLIENT_INTERACTIVE':'','MYSQLI_CLIENT_IGNORE_SPACE':'','MYSQLI_CLIENT_NO_SCHEMA':'','MYSQLI_CLIENT_MULTI_QUERIES':'','MYSQLI_STORE_RESULT':'','MYSQLI_USE_RESULT':'','MYSQLI_NOT_NULL_FLAG':'','MYSQLI_PRI_KEY_FLAG':'','MYSQLI_UNIQUE_KEY_FLAG':'','MYSQLI_MULTIPLE_KEY_FLAG':'','MYSQLI_BLOB_FLAG':'','MYSQLI_UNSIGNED_FLAG':'','MYSQLI_ZEROFILL_FLAG':'','MYSQLI_AUTO_INCREMENT_FLAG':'','MYSQLI_TIMESTAMP_FLAG':'','MYSQLI_SET_FLAG':'','MYSQLI_NUM_FLAG':'','MYSQLI_PART_KEY_FLAG':'','MYSQLI_GROUP_FLAG':'','MYSQLI_TYPE_DECIMAL':'','MYSQLI_TYPE_NEWDECIMAL':'','MYSQLI_TYPE_BIT':'','MYSQLI_TYPE_TINY':'','MYSQLI_TYPE_SHORT':'','MYSQLI_TYPE_LONG':'','MYSQLI_TYPE_FLOAT':'','MYSQLI_TYPE_DOUBLE':'','MYSQLI_TYPE_NULL':'','MYSQLI_TYPE_TIMESTAMP':'','MYSQLI_TYPE_LONGLONG':'','MYSQLI_TYPE_INT24':'','MYSQLI_TYPE_DATE':'','MYSQLI_TYPE_TIME':'','MYSQLI_TYPE_DATETIME':'','MYSQLI_TYPE_YEAR':'','MYSQLI_TYPE_NEWDATE':'','MYSQLI_TYPE_INTERVAL':'','MYSQLI_TYPE_ENUM':'','MYSQLI_TYPE_SET':'','MYSQLI_TYPE_TINY_BLOB':'','MYSQLI_TYPE_MEDIUM_BLOB':'','MYSQLI_TYPE_LONG_BLOB':'','MYSQLI_TYPE_BLOB':'','MYSQLI_TYPE_VAR_STRING':'','MYSQLI_TYPE_STRING':'','MYSQLI_TYPE_CHAR':'','MYSQLI_TYPE_GEOMETRY':'','MYSQLI_NEED_DATA':'','MYSQLI_NO_DATA':'','MYSQLI_DATA_TRUNCATED':'','MYSQLI_ENUM_FLAG':'','MYSQLI_BINARY_FLAG':'','MYSQLI_CURSOR_TYPE_FOR_UPDATE':'','MYSQLI_CURSOR_TYPE_NO_CURSOR':'','MYSQLI_CURSOR_TYPE_READ_ONLY':'','MYSQLI_CURSOR_TYPE_SCROLLABLE':'','MYSQLI_STMT_ATTR_CURSOR_TYPE':'','MYSQLI_STMT_ATTR_PREFETCH_ROWS':'','MYSQLI_STMT_ATTR_UPDATE_MAX_LENGTH':'','MYSQLI_SET_CHARSET_NAME':'','MYSQLI_DEBUG_TRACE_ENABLED':'','MYSQLI_SERVER_QUERY_NO_GOOD_INDEX_USED':'','MYSQLI_SERVER_QUERY_NO_INDEX_USED':'','MYSQLI_REFRESH_GRANT':'','MYSQLI_REFRESH_LOG':'','MYSQLI_REFRESH_TABLES':'','MYSQLI_REFRESH_HOSTS':'','MYSQLI_REFRESH_STATUS':'','MYSQLI_REFRESH_THREADS':'','MYSQLI_REFRESH_SLAVE':'','MYSQLI_REFRESH_MASTER':'','MYSQLI_TRANS_COR_AND_CHAIN':'','MYSQLI_TRANS_COR_AND_NO_CHAIN':'','MYSQLI_TRANS_COR_RELEASE':'','MYSQLI_TRANS_COR_NO_RELEASE':'','MYSQL_READ_DEFAULT_FILE':'','MYSQLI_SERVER_PUBLIC_KEY':'','MYSQLI_NO_CHANGE_USER_ON_PCONNECT':'','MYSQLI_ASYNC':'','MYSQLI_OPT_INT_AND_FLOAT_NATIVE':'','MYSQLI_CLIENT_FOUND_ROWS':'','MULTI_STATEMENT':'','MYSQLI_RPL_MASTER':'','MYSQLI_RPL_SLAVE':'','MYSQLI_RPL_ADMIN':'',}
let php_builtin['constants']['spl']={'READ_AHEAD':'','MIT_NEED_ALL':'','MIT_KEYS_ASSOC':'','CALL_TOSTRING':'','CATCH_GET_CHILD':'','RIT_LEAVES_ONLY':'','LOCK_SH':'','LOCK_EX':'','LOCK_UN':'','LOCK_NB':'','SEEK_SET':'','SEEK_CUR':'','SEEK_END':'','PHP_INT_MAX':'',}
let php_builtin['constants']['unknow']={'PHP_INI_ALL':'','PHP_INI_PERDIR':'','PHP_INI_SYSTEM':'','PHP_INI_USER':'','COUNTER_FLAG_PERSIST':'','COUNTER_FLAG_SAVE':'','COUNTER_FLAG_NO_OVERWRITE':'','COUNTER_META_NAME':'','COUNTER_META_IS_PERISTENT':'','COUNTER_RESET_NEVER':'','COUNTER_RESET_PER_LOAD':'','COUNTER_RESET_PER_REQUEST':'','PDO_PLACEHOLDER_NAMED':'','PDO_PLACEHOLDER_POSITIONAL':'','PDO_PLACEHOLDER_NONE':'','PDO_CASE_NATURAL':'','PDO_CASE_UPPER':'','PDO_CASE_LOWER':'','PDO_ATTR_CASE':'','PHP_COUNTER_API':'','PHPAPI':'','COMPILE_DL_COUNTER':'','ZEND_GET_MODULE':'','HAVE_COUNTER':'','COUNTER_G':'','TSRMLS_DC':'','TSRMLS_FETCH':'','STANDARD_MODULE_HEADER':'','STANDARD_MODULE_HEADER_EX':'','STANDARD_MODULE_PROPERTIES':'','STANDARD_MODULE_PROPERTIES_EX':'','ZEND_MODULE_API_NO':'','ZEND_DEBUG':'','USING_ZTS':'','NO_VERSION_YET':'','NO_MODULE_GLOBALS':'','PHP_MODULE_GLOBALS':'','IGNORE_PATH':'','USE_PATH':'','IGNORE_URL':'','IGNORE_URL_WIN':'','ENFORCE_SAFE_MODE':'','REPORT_ERRORS':'','STREAM_MUST_SEEK':'','STREAM_WILL_CAST':'',}
let php_builtin['constants']['directories']={'DIRECTORY_SEPARATOR':'','PATH_SEPARATOR':'','SCANDIR_SORT_ASCENDING':'','SCANDIR_SORT_DESCENDING':'','SCANDIR_SORT_NONE':'',}
let php_builtin['constants']['dom']={'XML_ELEMENT_NODE':'','XML_ATTRIBUTE_NODE':'','XML_TEXT_NODE':'','XML_CDATA_SECTION_NODE':'','XML_ENTITY_REF_NODE':'','XML_ENTITY_NODE':'','XML_PI_NODE':'','XML_COMMENT_NODE':'','XML_DOCUMENT_NODE':'','XML_DOCUMENT_TYPE_NODE':'','XML_DOCUMENT_FRAG_NODE':'','XML_NOTATION_NODE':'','XML_HTML_DOCUMENT_NODE':'','XML_DTD_NODE':'','XML_ELEMENT_DECL_NODE':'','XML_ATTRIBUTE_DECL_NODE':'','XML_ENTITY_DECL_NODE':'','XML_NAMESPACE_DECL_NODE':'','XML_ATTRIBUTE_CDATA':'','XML_ATTRIBUTE_ID':'','XML_ATTRIBUTE_IDREF':'','XML_ATTRIBUTE_IDREFS':'','XML_ATTRIBUTE_ENTITY':'','XML_ATTRIBUTE_NMTOKEN':'','XML_ATTRIBUTE_NMTOKENS':'','XML_ATTRIBUTE_ENUMERATION':'','XML_ATTRIBUTE_NOTATION':'','DOM_PHP_ERR':'','DOM_INDEX_SIZE_ERR':'','DOMSTRING_SIZE_ERR':'','DOM_HIERARCHY_REQUEST_ERR':'','DOM_WRONG_DOCUMENT_ERR':'','DOM_INVALID_CHARACTER_ERR':'','DOM_NO_DATA_ALLOWED_ERR':'','DOM_NO_MODIFICATION_ALLOWED_ERR':'','DOM_NOT_FOUND_ERR':'','DOM_NOT_SUPPORTED_ERR':'','DOM_INUSE_ATTRIBUTE_ERR':'','DOM_INVALID_STATE_ERR':'','DOM_SYNTAX_ERR':'','DOM_INVALID_MODIFICATION_ERR':'','DOM_NAMESPACE_ERR':'','DOM_INVALID_ACCESS_ERR':'','DOM_VALIDATION_ERR':'','DOM_NOT_FOUND_ERROR':'','DOM_NOT_FOUND':'',}
let php_builtin['constants']['command_line_usage']={'PHP_SAPI':'','STDIN':'','STDOUT':'','STDERR':'',}
let php_builtin['constants']['handling_file_uploads']={'UPLOAD_ERR_OK':'','UPLOAD_ERR_INI_SIZE':'','UPLOAD_ERR_FORM_SIZE':'','UPLOAD_ERR_PARTIAL':'','UPLOAD_ERR_NO_FILE':'','UPLOAD_ERR_NO_TMP_DIR':'','UPLOAD_ERR_CANT_WRITE':'','UPLOAD_ERR_EXTENSION':'',}
let php_builtin['constants']['fileinfo']={'FILEINFO_NONE':'','FILEINFO_SYMLINK':'','FILEINFO_MIME_TYPE':'','FILEINFO_MIME_ENCODING':'','FILEINFO_MIME':'','FILEINFO_COMPRESS':'','FILEINFO_DEVICES':'','FILEINFO_CONTINUE':'','FILEINFO_PRESERVE_ATIME':'','FILEINFO_RAW':'',}
let php_builtin['constants']['filesystem']={'SEEK_SET':'','SEEK_CUR':'','SEEK_END':'','LOCK_SH':'','LOCK_EX':'','LOCK_UN':'','LOCK_NB':'','GLOB_BRACE':'','GLOB_ONLYDIR':'','GLOB_MARK':'','GLOB_NOSORT':'','GLOB_NOCHECK':'','GLOB_NOESCAPE':'','GLOB_AVAILABLE_FLAGS':'','PATHINFO_DIRNAME':'','PATHINFO_BASENAME':'','PATHINFO_EXTENSION':'','PATHINFO_FILENAME':'','FILE_USE_INCLUDE_PATH':'','FILE_NO_DEFAULT_CONTEXT':'','FILE_APPEND':'','FILE_IGNORE_NEW_LINES':'','FILE_SKIP_EMPTY_LINES':'','FILE_BINARY':'','FILE_TEXT':'','INI_SCANNER_NORMAL':'','INI_SCANNER_RAW':'','FNM_NOESCAPE':'','FNM_PATHNAME':'','FNM_PERIOD':'','FNM_CASEFOLD':'','GLOB_ERR':'',}
let php_builtin['constants']['filter']={'FILTER_FLAG_NO_ENCODE_QUOTES':'','INPUT_POST':'','INPUT_GET':'','INPUT_COOKIE':'','INPUT_ENV':'','INPUT_SERVER':'','INPUT_SESSION':'','INPUT_REQUEST':'','FILTER_FLAG_NONE':'','FILTER_REQUIRE_SCALAR':'','FILTER_REQUIRE_ARRAY':'','FILTER_FORCE_ARRAY':'','FILTER_NULL_ON_FAILURE':'','FILTER_VALIDATE_INT':'','FILTER_VALIDATE_BOOLEAN':'','FILTER_VALIDATE_FLOAT':'','FILTER_VALIDATE_REGEXP':'','FILTER_VALIDATE_URL':'','FILTER_VALIDATE_EMAIL':'','FILTER_VALIDATE_IP':'','FILTER_DEFAULT':'','FILTER_UNSAFE_RAW':'','FILTER_SANITIZE_STRING':'','FILTER_SANITIZE_STRIPPED':'','FILTER_SANITIZE_ENCODED':'','FILTER_SANITIZE_SPECIAL_CHARS':'','FILTER_SANITIZE_EMAIL':'','FILTER_SANITIZE_URL':'','FILTER_SANITIZE_NUMBER_INT':'','FILTER_SANITIZE_NUMBER_FLOAT':'','FILTER_SANITIZE_MAGIC_QUOTES':'','FILTER_CALLBACK':'','FILTER_FLAG_ALLOW_OCTAL':'','FILTER_FLAG_ALLOW_HEX':'','FILTER_FLAG_STRIP_LOW':'','FILTER_FLAG_STRIP_HIGH':'','FILTER_FLAG_ENCODE_LOW':'','FILTER_FLAG_ENCODE_HIGH':'','FILTER_FLAG_ENCODE_AMP':'','FILTER_FLAG_EMPTY_STRING_NULL':'','FILTER_FLAG_ALLOW_FRACTION':'','FILTER_FLAG_ALLOW_THOUSAND':'','FILTER_FLAG_ALLOW_SCIENTIFIC':'','FILTER_FLAG_PATH_REQUIRED':'','FILTER_FLAG_QUERY_REQUIRED':'','FILTER_FLAG_IPV4':'','FILTER_FLAG_IPV6':'','FILTER_FLAG_NO_RES_RANGE':'','FILTER_FLAG_NO_PRIV_RANGE':'','FILTER_SANITIZE_RAW':'','FILTER_SANITIZE_FULL_SPECIAL_CHARS':'','ENT_QUOTES':'',}
let php_builtin['constants']['php_options_info']={'ASSERT_CALLBACK':'','RUSAGE_CHILDREN':'','PHP_SAPI':'','PHP_OS':'','CREDITS_DOCS':'','CREDITS_GENERAL':'','CREDITS_GROUP':'','CREDITS_MODULES':'','CREDITS_FULLPAGE':'','PHP_VERSION_ID':'','PHP_VERSION':'','PATH_SEPARATOR':'','CREDITS_SAPI':'','CREDITS_QA':'','CREDITS_ALL':'','INFO_GENERAL':'','INFO_CREDITS':'','INFO_CONFIGURATION':'','INFO_MODULES':'','INFO_ENVIRONMENT':'','INFO_VARIABLES':'','INFO_LICENSE':'','INFO_ALL':'','ASSERT_ACTIVE':'','ASSERT_BAIL':'','ASSERT_WARNING':'','ASSERT_QUIET_EVAL':'','PHP_WINDOWS_VERSION_MAJOR':'','PHP_WINDOWS_VERSION_MINOR':'','PHP_WINDOWS_VERSION_BUILD':'','PHP_WINDOWS_VERSION_PLATFORM':'','PHP_WINDOWS_VERSION_SP_MAJOR':'','PHP_WINDOWS_VERSION_SP_MINOR':'','PHP_WINDOWS_VERSION_SUITEMASK':'','PHP_WINDOWS_VERSION_PRODUCTTYPE':'','PHP_WINDOWS_NT_DOMAIN_CONTROLLER':'','PHP_WINDOWS_NT_SERVER':'','PHP_WINDOWS_NT_WORKSTATION':'',}
let php_builtin['constants']['strings']={'CRYPT_SALT_LENGTH':'','CRYPT_STD_DES':'','CRYPT_EXT_DES':'','CRYPT_MD5':'','CRYPT_BLOWFISH':'','CRYPT_SHA256':'','CRYPT_SHA512':'','HTML_ENTITIES':'','HTML_SPECIALCHARS':'','ENT_COMPAT':'','ENT_QUOTES':'','ENT_NOQUOTES':'','ENT_HTML401':'','ENT_XML1':'','ENT_XHTML':'','ENT_HTML5':'','ENT_IGNORE':'','ENT_SUBSTITUTE':'','ENT_DISALLOWED':'','CHAR_MAX':'','LC_MONETARY':'','AM_STR':'','PM_STR':'','D_T_FMT':'','D_FMT':'','T_FMT':'','T_FMT_AMPM':'','ERA':'','ERA_YEAR':'','ERA_D_T_FMT':'','ERA_D_FMT':'','ERA_T_FMT':'','INT_CURR_SYMBOL':'','CURRENCY_SYMBOL':'','CRNCYSTR':'','MON_DECIMAL_POINT':'','MON_THOUSANDS_SEP':'','MON_GROUPING':'','POSITIVE_SIGN':'','NEGATIVE_SIGN':'','INT_FRAC_DIGITS':'','FRAC_DIGITS':'','P_CS_PRECEDES':'','P_SEP_BY_SPACE':'','N_CS_PRECEDES':'','N_SEP_BY_SPACE':'','P_SIGN_POSN':'','N_SIGN_POSN':'','DECIMAL_POINT':'','RADIXCHAR':'','THOUSANDS_SEP':'','THOUSEP':'','GROUPING':'','YESEXPR':'','NOEXPR':'','YESSTR':'','NOSTR':'','CODESET':'','LC_ALL':'','LC_COLLATE':'','LC_CTYPE':'','LC_NUMERIC':'','LC_TIME':'','LC_MESSAGES':'','PHP_INT_MAX':'','STR_PAD_RIGHT':'','STR_PAD_LEFT':'','STR_PAD_BOTH':'',}
let php_builtin['constants']['error_handling']={'DEBUG_BACKTRACE_PROVIDE_OBJECT':'','DEBUG_BACKTRACE_IGNORE_ARGS':'',}
let php_builtin['constants']['math']={'PHP_INT_MAX':'','M_PI':'','PHP_ROUND_HALF_UP':'','PHP_ROUND_HALF_DOWN':'','PHP_ROUND_HALF_EVEN':'','PHP_ROUND_HALF_ODD':'','M_E':'','M_LOG2E':'','M_LOG10E':'','M_LN2':'','M_LN10':'','M_PI_2':'','M_PI_4':'','M_1_PI':'','M_2_PI':'','M_SQRTPI':'','M_2_SQRTPI':'','M_SQRT2':'','M_SQRT3':'','M_SQRT1_2':'','M_LNPI':'','M_EULER':'','NAN':'','INF':'',}
let php_builtin['constants']['network']={'LOG_EMERG':'','LOG_ALERT':'','LOG_CRIT':'','LOG_ERR':'','LOG_WARNING':'','LOG_NOTICE':'','LOG_INFO':'','LOG_DEBUG':'','LOG_KERN':'','LOG_USER':'','LOG_MAIL':'','LOG_DAEMON':'','LOG_AUTH':'','LOG_SYSLOG':'','LOG_LPR':'','LOG_NEWS':'','LOG_CRON':'','LOG_AUTHPRIV':'','LOG_LOCAL0':'','LOG_LOCAL1':'','LOG_LOCAL2':'','LOG_LOCAL3':'','LOG_LOCAL4':'','LOG_LOCAL5':'','LOG_LOCAL6':'','LOG_LOCAL7':'','LOG_PID':'','LOG_CONS':'','LOG_ODELAY':'','LOG_NDELAY':'','LOG_NOWAIT':'','LOG_PERROR':'','DNS_A':'','DNS_CNAME':'','DNS_HINFO':'','DNS_MX':'','DNS_NS':'','DNS_PTR':'','DNS_SOA':'','DNS_TXT':'','DNS_AAAA':'','DNS_SRV':'','DNS_NAPTR':'','DNS_A6':'','DNS_ALL':'','DNS_ANY':'','SID':'','LOG_UUCP':'',}
let php_builtin['constants']['urls']={'PHP_QUERY_RFC1738':'','PHP_QUERY_RFC3986':'','PHP_URL_SCHEME':'','PHP_URL_HOST':'','PHP_URL_PORT':'','PHP_URL_USER':'','PHP_URL_PASS':'','PHP_URL_PATH':'','PHP_URL_QUERY':'','PHP_URL_FRAGMENT':'',}
let php_builtin['constants']['gd']={'IMAGETYPE_GIF':'','IMAGETYPE_JPEG':'','IMAGETYPE_PNG':'','IMAGETYPE_SWF':'','IMAGETYPE_PSD':'','IMAGETYPE_BMP':'','IMAGETYPE_TIFF_II':'','IMAGETYPE_TIFF_MM':'','IMAGETYPE_JPC':'','IMAGETYPE_JP2':'','IMAGETYPE_JPX':'','IMAGETYPE_JB2':'','IMAGETYPE_SWC':'','IMAGETYPE_IFF':'','IMAGETYPE_WBMP':'','IMAGETYPE_XBM':'','IMAGETYPE_ICO':'','IMG_CROP_THRESHOLD':'','IMG_ARC_PIE':'','IMG_ARC_CHORD':'','IMG_ARC_NOFILL':'','IMG_ARC_EDGED':'','IMG_FILTER_NEGATE':'','IMG_FILTER_GRAYSCALE':'','IMG_FILTER_BRIGHTNESS':'','IMG_FILTER_CONTRAST':'','IMG_FILTER_COLORIZE':'','IMG_FILTER_EDGEDETECT':'','IMG_FILTER_EMBOSS':'','IMG_FILTER_GAUSSIAN_BLUR':'','IMG_FILTER_SELECTIVE_BLUR':'','IMG_FILTER_MEAN_REMOVAL':'','IMG_FILTER_SMOOTH':'','IMG_FILTER_PIXELATE':'','IMG_FLIP_HORIZONTAL':'','IMG_FLIP_VERTICAL':'','IMG_FLIP_BOTH':'','IMG_GD2_RAW':'','IMG_GD2_COMPRESSED':'','IMG_EFFECT_REPLACE':'','IMG_EFFECT_ALPHABLEND':'','IMG_EFFECT_NORMAL':'','IMG_EFFECT_OVERLAY':'','PNG_NO_FILTER':'','PNG_ALL_FILTERS':'','IMG_NEAREST_NEIGHBOUR':'','IMG_BILINEAR_FIXED':'','IMG_BICUBIC':'','IMG_BICUBIC_FIXED':'','IMG_COLOR_BRUSHED':'','IMG_COLOR_STYLEDBRUSHED':'','IMG_BELL':'','IMG_BESSEL':'','IMG_BLACKMAN':'','IMG_BOX':'','IMG_BSPLINE':'','IMG_CATMULLROM':'','IMG_GAUSSIAN':'','IMG_GENERALIZED_CUBIC':'','IMG_HERMITE':'','IMG_HAMMING':'','IMG_HANNING':'','IMG_MITCHELL':'','IMG_POWER':'','IMG_QUADRATIC':'','IMG_SINC':'','IMG_WEIGHTED4':'','IMG_TRIANGLE':'','IMG_COLOR_STYLED':'','IMG_COLOR_TRANSPARENT':'','IMG_COLOR_TILED':'','IMG_GIF':'','IMG_JPG':'','IMG_PNG':'','IMG_WBMP':'','IMG_XPM':'','GD_VERSION':'','GD_MAJOR_VERSION':'','GD_MINOR_VERSION':'','GD_RELEASE_VERSION':'','GD_EXTRA_VERSION':'','GD_BUNDLED':'','IMG_JPEG':'','IMG_ARC_ROUNDED':'','IMAGETYPE_JPEG2000':'','PNG_FILTER_NONE':'','PNG_FILTER_SUB':'','PNG_FILTER_UP':'','PNG_FILTER_AVG':'','PNG_FILTER_PAETH':'',}
let php_builtin['constants']['json']={'JSON_BIGINT_AS_STRING':'','JSON_HEX_QUOT':'','JSON_HEX_TAG':'','JSON_HEX_AMP':'','JSON_HEX_APOS':'','JSON_NUMERIC_CHECK':'','JSON_PRETTY_PRINT':'','JSON_UNESCAPED_SLASHES':'','JSON_FORCE_OBJECT':'','JSON_UNESCAPED_UNICODE':'','JSON_ERROR_NONE':'','JSON_ERROR_DEPTH':'','JSON_ERROR_STATE_MISMATCH':'','JSON_ERROR_CTRL_CHAR':'','JSON_ERROR_SYNTAX':'','JSON_ERROR_UTF8':'','JSON_ERROR_RECURSION':'','JSON_ERROR_INF_OR_NAN':'','NAN':'','INF':'','JSON_ERROR_UNSUPPORTED_TYPE':'','JSON_PARTIAL_OUTPUT_ON_ERROR':'',}
let php_builtin['constants']['multibyte_string']={'MB_CASE_UPPER':'','MB_CASE_LOWER':'','MB_CASE_TITLE':'','MB_OVERLOAD_MAIL':'','MB_OVERLOAD_STRING':'','MB_OVERLOAD_REGEX':'',}
let php_builtin['constants']['mssql']={'SQLTEXT':'','SQLVARCHAR':'','SQLCHAR':'','SQLINT1':'','SQLINT2':'','SQLINT4':'','SQLBIT':'','SQLFLT4':'','SQLFLT8':'','SQLFLTN':'','MSSQL_ASSOC':'','MSSQL_NUM':'','MSSQL_BOTH':'',}
let php_builtin['constants']['mysql']={'MYSQL_CLIENT_SSL':'','MYSQL_CLIENT_COMPRESS':'','MYSQL_CLIENT_IGNORE_SPACE':'','MYSQL_CLIENT_INTERACTIVE':'','MYSQL_ASSOC':'','MYSQL_NUM':'','MYSQL_BOTH':'','MYSQL_PORT':'',}
let php_builtin['constants']['output_control']={'PHP_OUTPUT_HANDLER_STDFLAGS':'','PHP_OUTPUT_HANDLER_CLEANABLE':'','PHP_OUTPUT_HANDLER_FLUSHABLE':'','PHP_OUTPUT_HANDLER_REMOVABLE':'','PHP_OUTPUT_HANDLER_START':'','PHP_OUTPUT_HANDLER_WRITE':'','PHP_OUTPUT_HANDLER_FLUSH':'','PHP_OUTPUT_HANDLER_CLEAN':'','PHP_OUTPUT_HANDLER_FINAL':'','PHP_OUTPUT_HANDLER_CONT':'','PHP_OUTPUT_HANDLER_END':'',}
let php_builtin['constants']['password_hashing']={'PASSWORD_DEFAULT':'','PASSWORD_BCRYPT':'','CRYPT_BLOWFISH':'',}
let php_builtin['constants']['postgresql']={'PGSQL_CONNECT_FORCE_NEW':'','PGSQL_CONNECTION_OK':'','PGSQL_CONNECTION_BAD':'','PGSQL_CONV_IGNORE_DEFAULT':'','PGSQL_CONV_FORCE_NULL':'','PGSQL_CONV_IGNORE_NOT_NULL':'','PGSQL_DML_NO_CONV':'','PGSQL_DML_ESCAPE':'','PGSQL_DML_EXEC':'','PGSQL_DML_ASYNC':'','PGSQL_DML_STRING':'','PGSQL_ASSOC':'','PGSQL_NUM':'','PGSQL_BOTH':'','PGSQL_CONV_OPTS':'','INV_READ':'','INV_WRITE':'','INV_ARCHIVE':'','PGSQL_SEEK_SET':'','PGSQL_SEEK_CUR':'','PGSQL_SEEK_END':'','PGSQL_DIAG_SEVERITY':'','PGSQL_DIAG_SQLSTATE':'','PGSQL_DIAG_MESSAGE_PRIMARY':'','PGSQL_DIAG_MESSAGE_DETAIL':'','PGSQL_DIAG_MESSAGE_HINT':'','PGSQL_DIAG_STATEMENT_POSITION':'','PGSQL_DIAG_INTERNAL_POSITION':'','PGSQL_DIAG_INTERNAL_QUERY':'','PGSQL_DIAG_CONTEXT':'','PGSQL_DIAG_SOURCE_FILE':'','PGSQL_DIAG_SOURCE_LINE':'','PGSQL_DIAG_SOURCE_FUNCTION':'','PGSQL_STATUS_LONG':'','PGSQL_STATUS_STRING':'','PGSQL_EMPTY_QUERY':'','PGSQL_COMMAND_OK':'','PGSQL_TUPLES_OK':'','PGSQL_COPY_OUT':'','PGSQL_COPY_IN':'','PGSQL_BAD_RESPONSE':'','PGSQL_NONFATAL_ERROR':'','PGSQL_FATAL_ERROR':'','PGSQL_ERRORS_TERSE':'','PGSQL_ERRORS_DEFAULT':'','PGSQL_ERRORS_VERBOSE':'','PGSQL_TRANSACTION_IDLE':'','PGSQL_TRANSACTION_ACTIVE':'','PGSQL_TRANSACTION_INTRANS':'','PGSQL_TRANSACTION_INERROR':'','PGSQL_TRANSACTION_UNKNOWN':'','PG_DIAG_STATEMENT_POSITION':'','PG_DIAG_INTERNAL_QUERY':'',}
let php_builtin['constants']['pcre']={'PREG_GREP_INVERT':'','PREG_NO_ERROR':'','PREG_INTERNAL_ERROR':'','PREG_BACKTRACK_LIMIT_ERROR':'','PREG_RECURSION_LIMIT_ERROR':'','PREG_BAD_UTF8_ERROR':'','PREG_BAD_UTF8_OFFSET_ERROR':'','PREG_PATTERN_ORDER':'','PREG_SET_ORDER':'','PREG_OFFSET_CAPTURE':'','PREG_SPLIT_NO_EMPTY':'','PREG_SPLIT_DELIM_CAPTURE':'','PREG_SPLIT_OFFSET_CAPTURE':'','PCRE_VERSION':'',}
let php_builtin['constants']['program_execution']={'STDIN':'',}
let php_builtin['constants']['sessions']={'SID':'','PHP_SESSION_DISABLED':'','PHP_SESSION_NONE':'','PHP_SESSION_ACTIVE':'','UPLOAD_ERR_EXTENSION':'',}
let php_builtin['constants']['variable_handling']={'PHP_INT_MAX':'',}
let php_builtin['constants']['misc']={'WAIT_IO_COMPLETION':'','CONNECTION_ABORTED':'','CONNECTION_NORMAL':'','CONNECTION_TIMEOUT':'',}
let php_builtin['constants']['streams']={'STREAM_FILTER_READ':'','STREAM_FILTER_WRITE':'','STREAM_FILTER_ALL':'','PHP_INT_MAX':'','STREAM_CLIENT_CONNECT':'','STREAM_CLIENT_ASYNC_CONNECT':'','STREAM_CLIENT_PERSISTENT':'','STREAM_CRYPTO_METHOD_TLS_CLIENT':'','STREAM_CRYPTO_METHOD_TLS_SERVER':'','STREAM_PF_INET':'','STREAM_PF_INET6':'','STREAM_PF_UNIX':'','STREAM_SOCK_DGRAM':'','STREAM_SOCK_RAW':'','STREAM_SOCK_RDM':'','STREAM_SOCK_SEQPACKET':'','STREAM_SOCK_STREAM':'','STREAM_IPPROTO_ICMP':'','STREAM_IPPROTO_IP':'','STREAM_IPPROTO_RAW':'','STREAM_IPPROTO_TCP':'','STREAM_IPPROTO_UDP':'','STREAM_OOB':'','STREAM_PEEK':'','AF_INET':'','STREAM_SERVER_BIND':'','STREAM_SHUT_RD':'','STREAM_SHUT_WR':'','STREAM_SHUT_RDWR':'','STREAM_IS_URL':'','PSFS_PASS_ON':'','PSFS_FEED_ME':'','PSFS_ERR_FATAL':'','PSFS_FLAG_NORMAL':'','PSFS_FLAG_FLUSH_INC':'','PSFS_FLAG_FLUSH_CLOSE':'','STREAM_USE_PATH':'','STREAM_REPORT_ERRORS':'','STREAM_SERVER_LISTEN':'','STREAM_NOTIFY_RESOLVE':'','STREAM_NOTIFY_CONNECT':'','STREAM_NOTIFY_AUTH_REQUIRED':'','STREAM_NOTIFY_SEVERITY_ERR':'','STREAM_NOTIFY_MIME_TYPE_IS':'','STREAM_NOTIFY_FILE_SIZE_IS':'','STREAM_NOTIFY_REDIRECTED':'','STREAM_NOTIFY_PROGRESS':'','STREAM_NOTIFY_COMPLETED':'','STREAM_NOTIFY_FAILURE':'','STREAM_NOTIFY_AUTH_RESULT':'','STREAM_NOTIFY_SEVERITY_INFO':'','STREAM_NOTIFY_SEVERITY_WARN':'','STREAM_CAST_FOR_SELECT':'','STREAM_CAST_AS_STREAM':'','STREAM_META_TOUCH':'','STREAM_META_OWNER':'','STREAM_META_OWNER_NAME':'','STREAM_META_GROUP':'','STREAM_META_GROUP_NAME':'','STREAM_META_ACCESS':'','STREAM_MKDIR_RECURSIVE':'','LOCK_EX':'','LOCK_UN':'','LOCK_SH':'','LOCK_NB':'','SEEK_SET':'','SEEK_CUR':'','SEEK_END':'','STREAM_OPTION_BLOCKING':'','STREAM_OPTION_READ_TIMEOUT':'','STREAM_OPTION_WRITE_BUFFER':'','STREAM_BUFFER_NONE':'','STREAM_BUFFER_FULL':'',}
let php_builtin['constants']['iconv']={'ICONV_IMPL':'','ICONV_VERSION':'','ICONV_MIME_DECODE_STRICT':'','ICONV_MIME_DECODE_CONTINUE_ON_ERROR':'',}
let php_builtin['constants']['phpini_directives']={'PATH_SEPARATOR':'','PHP_INI_SYSTEM':'',}
let php_builtin['constants']['types']={'NAN':'','PHP_INT_SIZE':'','PHP_INT_MAX':'',}
let php_builtin['constants']['pdo']={'PDO_PARAM_BOOL':'',}
let php_builtin['constants']['list_of_reserved_words']={'PHP_VERSION':'','PHP_MAJOR_VERSION':'','PHP_MINOR_VERSION':'','PHP_RELEASE_VERSION':'','PHP_VERSION_ID':'','PHP_EXTRA_VERSION':'','PHP_ZTS':'','PHP_DEBUG':'','PHP_MAXPATHLEN':'','PHP_OS':'','PHP_SAPI':'','PHP_EOL':'','PHP_INT_MAX':'','PHP_INT_SIZE':'','DEFAULT_INCLUDE_PATH':'','PEAR_INSTALL_DIR':'','PEAR_EXTENSION_DIR':'','PHP_EXTENSION_DIR':'','PHP_PREFIX':'','PHP_BINDIR':'','PHP_BINARY':'','PHP_MANDIR':'','PHP_LIBDIR':'','PHP_DATADIR':'','PHP_SYSCONFDIR':'','PHP_LOCALSTATEDIR':'','PHP_CONFIG_FILE_PATH':'','PHP_CONFIG_FILE_SCAN_DIR':'','PHP_SHLIB_SUFFIX':'',}
let php_builtin['constants']['php_type_comparison_tables']={'NAN':'',}

" Built in functions
let g:php_builtin_functions = {}
for [ext, data] in items(php_builtin['functions'])
	call extend(g:php_builtin_functions, data)
endfor

" Built in class
let g:php_builtin_classes = {}
for [ext, data] in items(php_builtin['classes'])
	call extend(g:php_builtin_classes, data)
endfor

" Built in interfaces
let g:php_builtin_interfaces = {}
for [ext, data] in items(php_builtin['interfaces'])
	call extend(g:php_builtin_interfaces, data)
endfor

" Built in constants
let g:php_constants = {}
for [ext, data] in items(php_builtin['constants'])
	call extend(g:php_constants, data)
endfor

" When the classname not found or found but the tags doesn't contain that
" class we will try to complete any method of any builtin class. To speed up
" that lookup we compile a 'ClassName::MethodName':'info' dictionary from the
" builtin class information
let g:php_builtin_object_functions = {}

" When completing for 'everyting imaginable' (no class context, not a
" variable) we need a list of built-in classes in a format of {'classname':''}
" for performance reasons we precompile this too
let g:php_builtin_classnames = {}

" In order to reduce file size, empty keys are omitted from class structures.
" To make the structure of in-memory hashes normalized we will add them in runtime
let required_class_hash_keys = ['constants', 'properties', 'static_properties', 'methods', 'static_methods']

for [classname, class_info] in items(g:php_builtin_classes)
	for property_name in required_class_hash_keys
		if !has_key(class_info, property_name)
			let class_info[property_name] = {}
		endif
	endfor

	let g:php_builtin_classnames[classname] = ''
	for [method_name, method_info] in items(class_info.methods)
		let g:php_builtin_object_functions[classname.'::'.method_name.'('] = method_info.signature
	endfor
	for [method_name, method_info] in items(class_info.static_methods)
		let g:php_builtin_object_functions[classname.'::'.method_name.'('] = method_info.signature
	endfor
endfor

let g:php_builtin_interfacenames = {}
for [interfacename, info] in items(g:php_builtin_interfaces)
	for property_name in required_class_hash_keys
		if !has_key(class_info, property_name)
			let class_info[property_name] = {}
		endif
	endfor

	let g:php_builtin_interfacenames[interfacename] = ''
	for [method_name, method_info] in items(class_info.methods)
		let g:php_builtin_object_functions[interfacename.'::'.method_name.'('] = method_info.signature
	endfor
	for [method_name, method_info] in items(class_info.static_methods)
		let g:php_builtin_object_functions[interfacename.'::'.method_name.'('] = method_info.signature
	endfor
endfor


" Add control structures (they are outside regular pattern of PHP functions)
let php_control = {
			\ 'include(': 'string filename | resource',
			\ 'include_once(': 'string filename | resource',
			\ 'require(': 'string filename | resource',
			\ 'require_once(': 'string filename | resource',
			\ }
call extend(g:php_builtin_functions, php_control)


" Built-in variables " {{{
let g:php_builtin_vars ={
			\ '$GLOBALS':'',
			\ '$_SERVER':'',
			\ '$_GET':'',
			\ '$_POST':'',
			\ '$_COOKIE':'',
			\ '$_FILES':'',
			\ '$_ENV':'',
			\ '$_REQUEST':'',
			\ '$_SESSION':'',
			\ '$HTTP_SERVER_VARS':'',
			\ '$HTTP_ENV_VARS':'',
			\ '$HTTP_COOKIE_VARS':'',
			\ '$HTTP_GET_VARS':'',
			\ '$HTTP_POST_VARS':'',
			\ '$HTTP_POST_FILES':'',
			\ '$HTTP_SESSION_VARS':'',
			\ '$php_errormsg':'',
			\ '$this':'',
			\ }
" }}}
endfunction
" }}}

" vim: foldmethod=marker:noexpandtab:ts=8:sts=4
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            "python3complete.vim - Omni Completion for python
" Maintainer: <vacancy>
" Previous Maintainer: Aaron Griffin <aaronmgriffin@gmail.com>
" Version: 0.9
" Last Updated: 2020 Oct 9
"
" Roland Puntaier: this file contains adaptations for python3 and is parallel to pythoncomplete.vim
"
" Changes
" TODO:
" 'info' item output can use some formatting work
" Add an "unsafe eval" mode, to allow for return type evaluation
" Complete basic syntax along with import statements
"   i.e. "import url<c-x,c-o>"
" Continue parsing on invalid line??
"
" v 0.9
"   * Fixed docstring parsing for classes and functions
"   * Fixed parsing of *args and **kwargs type arguments
"   * Better function param parsing to handle things like tuples and
"     lambda defaults args
"
" v 0.8
"   * Fixed an issue where the FIRST assignment was always used instead of
"   using a subsequent assignment for a variable
"   * Fixed a scoping issue when working inside a parameterless function
"
"
" v 0.7
"   * Fixed function list sorting (_ and __ at the bottom)
"   * Removed newline removal from docs.  It appears vim handles these better in
"   recent patches
"
" v 0.6:
"   * Fixed argument completion
"   * Removed the 'kind' completions, as they are better indicated
"   with real syntax
"   * Added tuple assignment parsing (whoops, that was forgotten)
"   * Fixed import handling when flattening scope
"
" v 0.5:
" Yeah, I skipped a version number - 0.4 was never public.
"  It was a bugfix version on top of 0.3.  This is a complete
"  rewrite.
"

if !has('python3')
    echo "Error: Required vim compiled with +python3"
    finish
endif

function! python3complete#Complete(findstart, base)
    "findstart = 1 when we need to get the text length
    if a:findstart == 1
        let line = getline('.')
        let idx = col('.')
        while idx > 0
            let idx -= 1
            let c = line[idx]
            if c =~ '\w'
                continue
            elseif ! c =~ '\.'
                let idx = -1
                break
            else
                break
            endif
        endwhile

        return idx
    "findstart = 0 when we need to return the list of completions
    else
        "vim no longer moves the cursor upon completion... fix that
        let line = getline('.')
        let idx = col('.')
        let cword = ''
        while idx > 0
            let idx -= 1
            let c = line[idx]
            if c =~ '\w' || c =~ '\.'
                let cword = c . cword
                continue
            elseif strlen(cword) > 0 || idx == 0
                break
            endif
        endwhile
	execute "py3 vimpy3complete('" . escape(cword, "'") . "', '" . escape(a:base, "'") . "')"
        return g:python3complete_completions
    endif
endfunction

function! s:DefPython()
py3 << PYTHONEOF
import sys, tokenize, io, types
from token import NAME, DEDENT, NEWLINE, STRING

debugstmts=[]
def dbg(s): debugstmts.append(s)
def showdbg():
    for d in debugstmts: print("DBG: %s " % d)

def vimpy3complete(context,match):
    global debugstmts
    debugstmts = []
    try:
        import vim
        cmpl = Completer()
        cmpl.evalsource('\n'.join(vim.current.buffer),vim.eval("line('.')"))
        all = cmpl.get_completions(context,match)
        all.sort(key=lambda x:x['abbr'].replace('_','z'))
        dictstr = '['
        # have to do this for double quoting
        for cmpl in all:
            dictstr += '{'
            for x in cmpl: dictstr += '"%s":"%s",' % (x,cmpl[x])
            dictstr += '"icase":0},'
        if dictstr[-1] == ',': dictstr = dictstr[:-1]
        dictstr += ']'
        #dbg("dict: %s" % dictstr)
        vim.command("silent let g:python3complete_completions = %s" % dictstr)
        #dbg("Completion dict:\n%s" % all)
    except vim.error:
        dbg("VIM Error: %s" % vim.error)

class Completer(object):
    def __init__(self):
       self.compldict = {}
       self.parser = PyParser()

    def evalsource(self,text,line=0):
        sc = self.parser.parse(text,line)
        src = sc.get_code()
        dbg("source: %s" % src)
        try: exec(src,self.compldict)
        except: dbg("parser: %s, %s" % (sys.exc_info()[0],sys.exc_info()[1]))
        for l in sc.locals:
            try: exec(l,self.compldict)
            except: dbg("locals: %s, %s [%s]" % (sys.exc_info()[0],sys.exc_info()[1],l))

    def _cleanstr(self,doc):
        return doc.replace('"',' ').replace("'",' ')

    def get_arguments(self,func_obj):
        def _ctor(class_ob):
            try: return class_ob.__init__
            except AttributeError:
                for base in class_ob.__bases__:
                    rc = _ctor(base)
                    if rc is not None: return rc
            return None

        arg_offset = 1
        if type(func_obj) == type: func_obj = _ctor(func_obj)
        elif type(func_obj) == types.MethodType: arg_offset = 1
        else: arg_offset = 0

        arg_text=''
        if type(func_obj) in [types.FunctionType, types.LambdaType,types.MethodType]:
            try:
                cd = func_obj.__code__
                real_args = cd.co_varnames[arg_offset:cd.co_argcount]
                defaults = func_obj.__defaults__ or []
                defaults = ["=%s" % name for name in defaults]
                defaults = [""] * (len(real_args)-len(defaults)) + defaults
                items = [a+d for a,d in zip(real_args,defaults)]
                if func_obj.__code__.co_flags & 0x4:
                    items.append("...")
                if func_obj.__code__.co_flags & 0x8:
                    items.append("***")
                arg_text = (','.join(items)) + ')'
            except:
                dbg("arg completion: %s: %s" % (sys.exc_info()[0],sys.exc_info()[1]))
                pass
        if len(arg_text) == 0:
            # The doc string sometimes contains the function signature
            #  this works for a lot of C modules that are part of the
            #  standard library
            doc = func_obj.__doc__
            if doc:
                doc = doc.lstrip()
                pos = doc.find('\n')
                if pos > 0:
                    sigline = doc[:pos]
                    lidx = sigline.find('(')
                    ridx = sigline.find(')')
                    if lidx > 0 and ridx > 0:
                        arg_text = sigline[lidx+1:ridx] + ')'
        if len(arg_text) == 0: arg_text = ')'
        return arg_text

    def get_completions(self,context,match):
        #dbg("get_completions('%s','%s')" % (context,match))
        stmt = ''
        if context: stmt += str(context)
        if match: stmt += str(match)
        try:
            result = None
            all = {}
            ridx = stmt.rfind('.')
            if len(stmt) > 0 and stmt[-1] == '(':
                result = eval(_sanitize(stmt[:-1]), self.compldict)
                doc = result.__doc__
                if doc is None: doc = ''
                args = self.get_arguments(result)
                return [{'word':self._cleanstr(args),'info':self._cleanstr(doc)}]
            elif ridx == -1:
                match = stmt
                all = self.compldict
            else:
                match = stmt[ridx+1:]
                stmt = _sanitize(stmt[:ridx])
                result = eval(stmt, self.compldict)
                all = dir(result)

            dbg("completing: stmt:%s" % stmt)
            completions = []

            try: maindoc = result.__doc__
            except: maindoc = ' '
            if maindoc is None: maindoc = ' '
            for m in all:
                if m == "_PyCmplNoType": continue #this is internal
                try:
                    dbg('possible completion: %s' % m)
                    if m.find(match) == 0:
                        if result is None: inst = all[m]
                        else: inst = getattr(result,m)
                        try: doc = inst.__doc__
                        except: doc = maindoc
                        typestr = str(inst)
                        if doc is None or doc == '': doc = maindoc

                        wrd = m[len(match):]
                        c = {'word':wrd, 'abbr':m,  'info':self._cleanstr(doc)}
                        if "function" in typestr:
                            c['word'] += '('
                            c['abbr'] += '(' + self._cleanstr(self.get_arguments(inst))
                        elif "method" in typestr:
                            c['word'] += '('
                            c['abbr'] += '(' + self._cleanstr(self.get_arguments(inst))
                        elif "module" in typestr:
                            c['word'] += '.'
                        elif "type" in typestr:
                            c['word'] += '('
                            c['abbr'] += '('
                        completions.append(c)
                except:
                    i = sys.exc_info()
                    dbg("inner completion: %s,%s [stmt='%s']" % (i[0],i[1],stmt))
            return completions
        except:
            i = sys.exc_info()
            dbg("completion: %s,%s [stmt='%s']" % (i[0],i[1],stmt))
            return []

class Scope(object):
    def __init__(self,name,indent,docstr=''):
        self.subscopes = []
        self.docstr = docstr
        self.locals = []
        self.parent = None
        self.name = name
        self.indent = indent

    def add(self,sub):
        #print('push scope: [%s@%s]' % (sub.name,sub.indent))
        sub.parent = self
        self.subscopes.append(sub)
        return sub

    def doc(self,str):
        """ Clean up a docstring """
        d = str.replace('\n',' ')
        d = d.replace('\t',' ')
        while d.find('  ') > -1: d = d.replace('  ',' ')
        while d[0] in '"\'\t ': d = d[1:]
        while d[-1] in '"\'\t ': d = d[:-1]
        dbg("Scope(%s)::docstr = %s" % (self,d))
        self.docstr = d

    def local(self,loc):
        self._checkexisting(loc)
        self.locals.append(loc)

    def copy_decl(self,indent=0):
        """ Copy a scope's declaration only, at the specified indent level - not local variables """
        return Scope(self.name,indent,self.docstr)

    def _checkexisting(self,test):
        "Convienance function... keep out duplicates"
        if test.find('=') > -1:
            var = test.split('=')[0].strip()
            for l in self.locals:
                if l.find('=') > -1 and var == l.split('=')[0].strip():
                    self.locals.remove(l)

    def get_code(self):
        str = ""
        if len(self.docstr) > 0: str += '"""'+self.docstr+'"""\n'
        for l in self.locals:
            if l.startswith('import'): str += l+'\n'
        str += 'class _PyCmplNoType:\n    def __getattr__(self,name):\n        return None\n'
        for sub in self.subscopes:
            str += sub.get_code()
        for l in self.locals:
            if not l.startswith('import'): str += l+'\n'

        return str

    def pop(self,indent):
        #print('pop scope: [%s] to [%s]' % (self.indent,indent))
        outer = self
        while outer.parent != None and outer.indent >= indent:
            outer = outer.parent
        return outer

    def currentindent(self):
        #print('parse current indent: %s' % self.indent)
        return '    '*self.indent

    def childindent(self):
        #print('parse child indent: [%s]' % (self.indent+1))
        return '    '*(self.indent+1)

class Class(Scope):
    def __init__(self, name, supers, indent, docstr=''):
        Scope.__init__(self,name,indent, docstr)
        self.supers = supers
    def copy_decl(self,indent=0):
        c = Class(self.name,self.supers,indent, self.docstr)
        for s in self.subscopes:
            c.add(s.copy_decl(indent+1))
        return c
    def get_code(self):
        str = '%sclass %s' % (self.currentindent(),self.name)
        if len(self.supers) > 0: str += '(%s)' % ','.join(self.supers)
        str += ':\n'
        if len(self.docstr) > 0: str += self.childindent()+'"""'+self.docstr+'"""\n'
        if len(self.subscopes) > 0:
            for s in self.subscopes: str += s.get_code()
        else:
            str += '%spass\n' % self.childindent()
        return str


class Function(Scope):
    def __init__(self, name, -p  .p  /p  0p  1p  2p  3p  4p  5p  6p                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          params, indent, docstr=''):
        Scope.__init__(self,name,indent, docstr)
        self.params = params
    def copy_decl(self,indent=0):
        return Function(self.name,self.params,indent, self.docstr)
    def get_code(self):
        str = "%sdef %s(%s):\n" % \
            (self.currentindent(),self.name,','.join(self.params))
        if len(self.docstr) > 0: str += self.childindent()+'"""'+self.docstr+'"""\n'
        str += "%spass\n" % self.childindent()
        return str

class PyParser:
    def __init__(self):
        self.top = Scope('global',0)
        self.scope = self.top
        self.parserline = 0

    def _parsedotname(self,pre=None):
        #returns (dottedname, nexttoken)
        name = []
        if pre is None:
            tokentype, token, indent = self.donext()
            if tokentype != NAME and token != '*':
                return ('', token)
        else: token = pre
        name.append(token)
        while True:
            tokentype, token, indent = self.donext()
            if token != '.': break
            tokentype, token, indent = self.donext()
            if tokentype != NAME: break
            name.append(token)
        return (".".join(name), token)

    def _parseimportlist(self):
        imports = []
        while True:
            name, token = self._parsedotname()
            if not name: break
            name2 = ''
            if token == 'as': name2, token = self._parsedotname()
            imports.append((name, name2))
            while token != "," and "\n" not in token:
                tokentype, token, indent = self.donext()
            if token != ",": break
        return imports

    def _parenparse(self):
        name = ''
        names = []
        level = 1
        while True:
            tokentype, token, indent = self.donext()
            if token in (')', ',') and level == 1:
                if '=' not in name: name = name.replace(' ', '')
                names.append(name.strip())
                name = ''
            if token == '(':
                level += 1
                name += "("
            elif token == ')':
                level -= 1
                if level == 0: break
                else: name += ")"
            elif token == ',' and level == 1:
                pass
            else:
                name += "%s " % str(token)
        return names

    def _parsefunction(self,indent):
        self.scope=self.scope.pop(indent)
        tokentype, fname, ind = self.donext()
        if tokentype != NAME: return None

        tokentype, open, ind = self.donext()
        if open != '(': return None
        params=self._parenparse()

        tokentype, colon, ind = self.donext()
        if colon != ':': return None

        return Function(fname,params,indent)

    def _parseclass(self,indent):
        self.scope=self.scope.pop(indent)
        tokentype, cname, ind = self.donext()
        if tokentype != NAME: return None

        super = []
        tokentype, thenext, ind = self.donext()
        if thenext == '(':
            super=self._parenparse()
        elif thenext != ':': return None

        return Class(cname,super,indent)

    def _parseassignment(self):
        assign=''
        tokentype, token, indent = self.donext()
        if tokentype == tokenize.STRING or token == 'str':  
            return '""'
        elif token == '(' or token == 'tuple':
            return '()'
        elif token == '[' or token == 'list':
            return '[]'
        elif token == '{' or token == 'dict':
            return '{}'
        elif tokentype == tokenize.NUMBER:
            return '0'
        elif token == 'open' or token == 'file':
            return 'file'
        elif token == 'None':
            return '_PyCmplNoType()'
        elif token == 'type':
            return 'type(_PyCmplNoType)' #only for method resolution
        else:
            assign += token
            level = 0
            while True:
                tokentype, token, indent = self.donext()
                if token in ('(','{','['):
                    level += 1
                elif token in (']','}',')'):
                    level -= 1
                    if level == 0: break
                elif level == 0:
                    if token in (';','\n'): break
                    assign += token
        return "%s" % assign

    def donext(self):
        type, token, (lineno, indent), end, self.parserline = next(self.gen)
        if lineno == self.curline:
            #print('line found [%s] scope=%s' % (line.replace('\n',''),self.scope.name))
            self.currentscope = self.scope
        return (type, token, indent)

    def _adjustvisibility(self):
        newscope = Scope('result',0)
        scp = self.currentscope
        while scp != None:
            if type(scp) == Function:
                slice = 0
                #Handle 'self' params
                if scp.parent != None and type(scp.parent) == Class:
                    slice = 1
                    newscope.local('%s = %s' % (scp.params[0],scp.parent.name))
                for p in scp.params[slice:]:
                    i = p.find('=')
                    if len(p) == 0: continue
                    pvar = ''
                    ptype = ''
                    if i == -1:
                        pvar = p
                        ptype = '_PyCmplNoType()'
                    else:
                        pvar = p[:i]
                        ptype = _sanitize(p[i+1:])
                    if pvar.startswith('**'):
                        pvar = pvar[2:]
                        ptype = '{}'
                    elif pvar.startswith('*'):
                        pvar = pvar[1:]
                        ptype = '[]'

                    newscope.local('%s = %s' % (pvar,ptype))

            for s in scp.subscopes:
                ns = s.copy_decl(0)
                newscope.add(ns)
            for l in scp.locals: newscope.local(l)
            scp = scp.parent

        self.currentscope = newscope
        return self.currentscope

    #p.parse(vim.current.buffer[:],vim.eval("line('.')"))
    def parse(self,text,curline=0):
        self.curline = int(curline)
        buf = io.StringIO(''.join(text) + '\n')
        self.gen = tokenize.generate_tokens(buf.readline)
        self.currentscope = self.scope

        try:
            freshscope=True
            while True:
                tokentype, token, indent = self.donext()
                #dbg( 'main: token=[%s] indent=[%s]' % (token,indent))

                if tokentype == DEDENT or token == "pass":
                    self.scope = self.scope.pop(indent)
                elif token == 'def':
                    func = self._parsefunction(indent)
                    if func is None:
                        print("function: syntax error...")
                        continue
                    dbg("new scope: function")
                    freshscope = True
                    self.scope = self.scope.add(func)
                elif token == 'class':
                    cls = self._parseclass(indent)
                    if cls is None:
                        print("class: syntax error...")
                        continue
                    freshscope = True
                    dbg("new scope: class")
                    self.scope = self.scope.add(cls)
                    
                elif token == 'import':
                    imports = self._parseimportlist()
                    for mod, alias in imports:
                        loc = "import %s" % mod
                        if len(alias) > 0: loc += " as %s" % alias
                        self.scope.local(loc)
                    freshscope = False
                elif token == 'from':
                    mod, token = self._parsedotname()
                    if not mod or token != "import":
                        print("from: syntax error...")
                        continue
                    names = self._parseimportlist()
                    for name, alias in names:
                        loc = "from %s import %s" % (mod,name)
                        if len(alias) > 0: loc += " as %s" % alias
                        self.scope.local(loc)
                    freshscope = False
                elif tokentype == STRING:
                    if freshscope: self.scope.doc(token)
                elif tokentype == NAME:
                    name,token = self._parsedotname(token) 
                    if token == '=':
                        stmt = self._parseassignment()
                        dbg("parseassignment: %s = %s" % (name, stmt))
                        if stmt != None:
                            self.scope.local("%s = %s" % (name,stmt))
                    freshscope = False
        except StopIteration: #thrown on EOF
            pass
        except:
            dbg("parse error: %s, %s @ %s" %
                (sys.exc_info()[0], sys.exc_info()[1], self.parserline))
        return self._adjustvisibility()

def _sanitize(str):
    val = ''
    level = 0
    for c in str:
        if c in ('(','{','['):
            level += 1
        elif c in (']','}',')'):
            level -= 1
        elif level == 0:
            val += c
    return val

sys.path.extend(['.','..'])
PYTHONEOF
endfunction

call s:DefPython()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             "pythoncomplete.vim - Omni Completion for python
" Maintainer: <vacancy>
" Previous Maintainer: Aaron Griffin <aaronmgriffin@gmail.com>
" Version: 0.9
" Last Updated: 2020 Oct 9
"
" Changes
" TODO:
" 'info' item output can use some formatting work
" Add an "unsafe eval" mode, to allow for return type evaluation
" Complete basic syntax along with import statements
"   i.e. "import url<c-x,c-o>"
" Continue parsing on invalid line??
"
" v 0.9
"   * Fixed docstring parsing for classes and functions
"   * Fixed parsing of *args and **kwargs type arguments
"   * Better function param parsing to handle things like tuples and
"     lambda defaults args
"
" v 0.8
"   * Fixed an issue where the FIRST assignment was always used instead of
"   using a subsequent assignment for a variable
"   * Fixed a scoping issue when working inside a parameterless function
"
"
" v 0.7
"   * Fixed function list sorting (_ and __ at the bottom)
"   * Removed newline removal from docs.  It appears vim handles these better in
"   recent patches
"
" v 0.6:
"   * Fixed argument completion
"   * Removed the 'kind' completions, as they are better indicated
"   with real syntax
"   * Added tuple assignment parsing (whoops, that was forgotten)
"   * Fixed import handling when flattening scope
"
" v 0.5:
" Yeah, I skipped a version number - 0.4 was never public.
"  It was a bugfix version on top of 0.3.  This is a complete
"  rewrite.
"

if !has('python')
    echo "Error: Required vim compiled with +python"
    finish
endif

function! pythoncomplete#Complete(findstart, base)
    "findstart = 1 when we need to get the text length
    if a:findstart == 1
        let line = getline('.')
        let idx = col('.')
        while idx > 0
            let idx -= 1
            let c = line[idx]
            if c =~ '\w'
                continue
            elseif ! c =~ '\.'
                let idx = -1
                break
            else
                break
            endif
        endwhile

        return idx
    "findstart = 0 when we need to return the list of completions
    else
        "vim no longer moves the cursor upon completion... fix that
        let line = getline('.')
        let idx = col('.')
        let cword = ''
        while idx > 0
            let idx -= 1
            let c = line[idx]
            if c =~ '\w' || c =~ '\.'
                let cword = c . cword
                continue
            elseif strlen(cword) > 0 || idx == 0
                break
            endif
        endwhile
        execute "python vimcomplete('" . escape(cword, "'") . "', '" . escape(a:base, "'") . "')"
        return g:pythoncomplete_completions
    endif
endfunction

function! s:DefPython()
python << PYTHONEOF
import sys, tokenize, cStringIO, types
from token import NAME, DEDENT, NEWLINE, STRING

debugstmts=[]
def dbg(s): debugstmts.append(s)
def showdbg():
    for d in debugstmts: print "DBG: %s " % d

def vimcomplete(context,match):
    global debugstmts
    debugstmts = []
    try:
        import vim
        def complsort(x,y):
            try:
                xa = x['abbr']
                ya = y['abbr']
                if xa[0] == '_':
                    if xa[1] == '_' and ya[0:2] == '__':
                        return xa > ya
                    elif ya[0:2] == '__':
                        return -1
                    elif y[0] == '_':
                        return xa > ya
                    else:
                        return 1
                elif ya[0] == '_':
                    return -1
                else:
                   return xa > ya
            except:
                return 0
        cmpl = Completer()
        cmpl.evalsource('\n'.join(vim.current.buffer),vim.eval("line('.')"))
        all = cmpl.get_completions(context,match)
        all.sort(complsort)
        dictstr = '['
        # have to do this for double quoting
        for cmpl in all:
            dictstr += '{'
            for x in cmpl: dictstr += '"%s":"%s",' % (x,cmpl[x])
            dictstr += '"icase":0},'
        if dictstr[-1] == ',': dictstr = dictstr[:-1]
        dictstr += ']'
        #dbg("dict: %s" % dictstr)
        vim.command("silent let g:pythoncomplete_completions = %s" % dictstr)
        #dbg("Completion dict:\n%s" % all)
    except vim.error:
        dbg("VIM Error: %s" % vim.error)

class Completer(object):
    def __init__(self):
       self.compldict = {}
       self.parser = PyParser()

    def evalsource(self,text,line=0):
        sc = self.parser.parse(text,line)
        src = sc.get_code()
        dbg("source: %s" % src)
        try: exec(src) in self.compldict
        except: dbg("parser: %s, %s" % (sys.exc_info()[0],sys.exc_info()[1]))
        for l in sc.locals:
            try: exec(l) in self.compldict
            except: dbg("locals: %s, %s [%s]" % (sys.exc_info()[0],sys.exc_info()[1],l))

    def _cleanstr(self,doc):
        return doc.replace('"',' ').replace("'",' ')

    def get_arguments(self,func_obj):
        def _ctor(obj):
            try: return class_ob.__init__.im_func
            except AttributeError:
                for base in class_ob.__bases__:
                    rc = _find_constructor(base)
                    if rc is not None: return rc
            return None

        arg_offset = 1
        if type(func_obj) == types.ClassType: func_obj = _ctor(func_obj)
        elif type(func_obj) == types.MethodType: func_obj = func_obj.im_func
        else: arg_offset = 0
        
        arg_text=''
        if type(func_obj) in [types.FunctionType, types.LambdaType]:
            try:
                cd = func_obj.func_code
                real_args = cd.co_varnames[arg_offset:cd.co_argcount]
                defaults = func_obj.func_defaults or ''
                defaults = map(lambda name: "=%s" % name, defaults)
                defaults = [""] * (len(real_args)-len(defaults)) + defaults
                items = map(lambda a,d: a+d, real_args, defaults)
                if func_obj.func_code.co_flags & 0x4:
                    items.append("...")
                if func_obj.func_code.co_flags & 0x8:
                    items.append("***")
                arg_text = (','.join(items)) + ')'

            except:
                dbg("arg completion: %s: %s" % (sys.exc_info()[0],sys.exc_info()[1]))
                pass
        if len(arg_text) == 0:
            # The doc string sometimes contains the function signature
            #  this works for a lot of C modules that are part of the
            #  standard library
            doc = func_obj.__doc__
            if doc:
                doc = doc.lstrip()
                pos = doc.find('\n')
                if pos > 0:
                    sigline = doc[:pos]
                    lidx = sigline.find('(')
                    ridx = sigline.find(')')
                    if lidx > 0 and ridx > 0:
                        arg_text = sigline[lidx+1:ridx] + ')'
        if len(arg_text) == 0: arg_text = ')'
        return arg_text

    def get_completions(self,context,match):
        dbg("get_completions('%s','%s')" % (context,match))
        stmt = ''
        if context: stmt += str(context)
        if match: stmt += str(match)
        try:
            result = None
            all = {}
            ridx = stmt.rfind('.')
            if len(stmt) > 0 and stmt[-1] == '(':
                result = eval(_sanitize(stmt[:-1]), self.compldict)
                doc = result.__doc__
                if doc is None: doc = ''
                args = self.get_arguments(result)
                return [{'word':self._cleanstr(args),'info':self._cleanstr(doc)}]
            elif ridx == -1:
                match = stmt
                all = self.compldict
            else:
                match = stmt[ridx+1:]
                stmt = _sanitize(stmt[:ridx])
                result = eval(stmt, self.compldict)
                all = dir(result)

            dbg("completing: stmt:%s" % stmt)
            completions = []

            try: maindoc = result.__doc__
            except: maindoc = ' '
            if maindoc is None: maindoc = ' '
            for m in all:
                if m == "_PyCmplNoType": continue #this is internal
                try:
                    dbg('possible completion: %s' % m)
                    if m.find(match) == 0:
                        if result is None: inst = all[m]
                        else: inst = getattr(result,m)
                        try: doc = inst.__doc__
                        except: doc = maindoc
                        typestr = str(inst)
                        if doc is None or doc == '': doc = maindoc

                        wrd = m[len(match):]
                        c = {'word':wrd, 'abbr':m,  'info':self._cleanstr(doc)}
                        if "function" in typestr:
                            c['word'] += '('
                            c['abbr'] += '(' + self._cleanstr(self.get_arguments(inst))
                        elif "method" in typestr:
                            c['word'] += '('
                            c['abbr'] += '(' + self._cleanstr(self.get_arguments(inst))
                        elif "module" in typestr:
                            c['word'] += '.'
                        elif "class" in typestr:
                            c['word'] += '('
                            c['abbr'] += '('
                        completions.append(c)
                except:
                    i = sys.exc_info()
                    dbg("inner completion: %s,%s [stmt='%s']" % (i[0],i[1],stmt))
            return completions
        except:
            i = sys.exc_info()
            dbg("completion: %s,%s [stmt='%s']" % (i[0],i[1],stmt))
            return []

class Scope(object):
    def __init__(self,name,indent,docstr=''):
        self.subscopes = []
        self.docstr = docstr
        self.locals = []
        self.parent = None
        self.name = name
        self.indent = indent

    def add(self,sub):
        #print 'push scope: [%s@%s]' % (sub.name,sub.indent)
        sub.parent = self
        self.subscopes.append(sub)
        return sub

    def doc(self,str):
        """ Clean up a docstring """
        d = str.replace('\n',' ')
        d = d.replace('\t',' ')
        while d.find('  ') > -1: d = d.replace('  ',' ')
        while d[0] in '"\'\t ': d = d[1:]
        while d[-1] in '"\'\t ': d = d[:-1]
        dbg("Scope(%s)::docstr = %s" % (self,d))
        self.docstr = d

    def local(self,loc):
        self._checkexisting(loc)
        self.locals.append(loc)

    def copy_decl(self,indent=0):
        """ Copy a scope's declaration only, at the specified indent level - not local variables """
        return Scope(self.name,indent,self.docstr)

    def _checkexisting(self,test):
        "Convienance function... keep out duplicates"
        if test.find('=') > -1:
            var = test.split('=')[0].strip()
            for l in self.locals:
                if l.find('=') > -1 and var == l.split('=')[0].strip():
                    self.locals.remove(l)

    def get_code(self):
        str = ""
        if len(self.docstr) > 0: str += '"""'+self.docstr+'"""\n'
        for l in self.locals:
            if l.startswith('import'): str += l+'\n'
        str += 'class _PyCmplNoType:\n    def __getattr__(self,name):\n        return None\n'
        for sub in self.subscopes:
            str += sub.get_code()
        for l in self.locals:
            if not l.startswith('import'): str += l+'\n'

        return str

    def pop(self,indent):
        #print 'pop scope: [%s] to [%s]' % (self.indent,indent)
        outer = self
        while outer.parent != None and outer.indent >= indent:
            outer = outer.parent
        return outer

    def currentindent(self):
        #print 'parse current indent: %s' % self.indent
        return '    '*self.indent

    def childindent(self):
        #print 'parse child indent: [%s]' % (self.indent+1)
        return '    '*(self.indent+1)

class Class(Scope):
    def __init__(self, name, supers, indent, docstr=''):
        Scope.__init__(self,name,indent, docstr)
        self.supers = supers
    def copy_decl(self,indent=0):
        c = Class(self.name,self.supers,indent, self.docstr)
        for s in self.subscopes:
            c.add(s.Dp  Ep  Fp  Gp  Hp  Ip  Jp  Kp  Lp  Mp                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          copy_decl(indent+1))
        return c
    def get_code(self):
        str = '%sclass %s' % (self.currentindent(),self.name)
        if len(self.supers) > 0: str += '(%s)' % ','.join(self.supers)
        str += ':\n'
        if len(self.docstr) > 0: str += self.childindent()+'"""'+self.docstr+'"""\n'
        if len(self.subscopes) > 0:
            for s in self.subscopes: str += s.get_code()
        else:
            str += '%spass\n' % self.childindent()
        return str


class Function(Scope):
    def __init__(self, name, params, indent, docstr=''):
        Scope.__init__(self,name,indent, docstr)
        self.params = params
    def copy_decl(self,indent=0):
        return Function(self.name,self.params,indent, self.docstr)
    def get_code(self):
        str = "%sdef %s(%s):\n" % \
            (self.currentindent(),self.name,','.join(self.params))
        if len(self.docstr) > 0: str += self.childindent()+'"""'+self.docstr+'"""\n'
        str += "%spass\n" % self.childindent()
        return str

class PyParser:
    def __init__(self):
        self.top = Scope('global',0)
        self.scope = self.top
        self.parserline = 0

    def _parsedotname(self,pre=None):
        #returns (dottedname, nexttoken)
        name = []
        if pre is None:
            tokentype, token, indent = self.next()
            if tokentype != NAME and token != '*':
                return ('', token)
        else: token = pre
        name.append(token)
        while True:
            tokentype, token, indent = self.next()
            if token != '.': break
            tokentype, token, indent = self.next()
            if tokentype != NAME: break
            name.append(token)
        return (".".join(name), token)

    def _parseimportlist(self):
        imports = []
        while True:
            name, token = self._parsedotname()
            if not name: break
            name2 = ''
            if token == 'as': name2, token = self._parsedotname()
            imports.append((name, name2))
            while token != "," and "\n" not in token:
                tokentype, token, indent = self.next()
            if token != ",": break
        return imports

    def _parenparse(self):
        name = ''
        names = []
        level = 1
        while True:
            tokentype, token, indent = self.next()
            if token in (')', ',') and level == 1:
                if '=' not in name: name = name.replace(' ', '')
                names.append(name.strip())
                name = ''
            if token == '(':
                level += 1
                name += "("
            elif token == ')':
                level -= 1
                if level == 0: break
                else: name += ")"
            elif token == ',' and level == 1:
                pass
            else:
                name += "%s " % str(token)
        return names

    def _parsefunction(self,indent):
        self.scope=self.scope.pop(indent)
        tokentype, fname, ind = self.next()
        if tokentype != NAME: return None

        tokentype, open, ind = self.next()
        if open != '(': return None
        params=self._parenparse()

        tokentype, colon, ind = self.next()
        if colon != ':': return None

        return Function(fname,params,indent)

    def _parseclass(self,indent):
        self.scope=self.scope.pop(indent)
        tokentype, cname, ind = self.next()
        if tokentype != NAME: return None

        super = []
        tokentype, next, ind = self.next()
        if next == '(':
            super=self._parenparse()
        elif next != ':': return None

        return Class(cname,super,indent)

    def _parseassignment(self):
        assign=''
        tokentype, token, indent = self.next()
        if tokentype == tokenize.STRING or token == 'str':  
            return '""'
        elif token == '(' or token == 'tuple':
            return '()'
        elif token == '[' or token == 'list':
            return '[]'
        elif token == '{' or token == 'dict':
            return '{}'
        elif tokentype == tokenize.NUMBER:
            return '0'
        elif token == 'open' or token == 'file':
            return 'file'
        elif token == 'None':
            return '_PyCmplNoType()'
        elif token == 'type':
            return 'type(_PyCmplNoType)' #only for method resolution
        else:
            assign += token
            level = 0
            while True:
                tokentype, token, indent = self.next()
                if token in ('(','{','['):
                    level += 1
                elif token in (']','}',')'):
                    level -= 1
                    if level == 0: break
                elif level == 0:
                    if token in (';','\n'): break
                    assign += token
        return "%s" % assign

    def next(self):
        type, token, (lineno, indent), end, self.parserline = self.gen.next()
        if lineno == self.curline:
            #print 'line found [%s] scope=%s' % (line.replace('\n',''),self.scope.name)
            self.currentscope = self.scope
        return (type, token, indent)

    def _adjustvisibility(self):
        newscope = Scope('result',0)
        scp = self.currentscope
        while scp != None:
            if type(scp) == Function:
                slice = 0
                #Handle 'self' params
                if scp.parent != None and type(scp.parent) == Class:
                    slice = 1
                    newscope.local('%s = %s' % (scp.params[0],scp.parent.name))
                for p in scp.params[slice:]:
                    i = p.find('=')
                    if len(p) == 0: continue
                    pvar = ''
                    ptype = ''
                    if i == -1:
                        pvar = p
                        ptype = '_PyCmplNoType()'
                    else:
                        pvar = p[:i]
                        ptype = _sanitize(p[i+1:])
                    if pvar.startswith('**'):
                        pvar = pvar[2:]
                        ptype = '{}'
                    elif pvar.startswith('*'):
                        pvar = pvar[1:]
                        ptype = '[]'

                    newscope.local('%s = %s' % (pvar,ptype))

            for s in scp.subscopes:
                ns = s.copy_decl(0)
                newscope.add(ns)
            for l in scp.locals: newscope.local(l)
            scp = scp.parent

        self.currentscope = newscope
        return self.currentscope

    #p.parse(vim.current.buffer[:],vim.eval("line('.')"))
    def parse(self,text,curline=0):
        self.curline = int(curline)
        buf = cStringIO.StringIO(''.join(text) + '\n')
        self.gen = tokenize.generate_tokens(buf.readline)
        self.currentscope = self.scope

        try:
            freshscope=True
            while True:
                tokentype, token, indent = self.next()
                #dbg( 'main: token=[%s] indent=[%s]' % (token,indent))

                if tokentype == DEDENT or token == "pass":
                    self.scope = self.scope.pop(indent)
                elif token == 'def':
                    func = self._parsefunction(indent)
                    if func is None:
                        print "function: syntax error..."
                        continue
                    dbg("new scope: function")
                    freshscope = True
                    self.scope = self.scope.add(func)
                elif token == 'class':
                    cls = self._parseclass(indent)
                    if cls is None:
                        print "class: syntax error..."
                        continue
                    freshscope = True
                    dbg("new scope: class")
                    self.scope = self.scope.add(cls)
                    
                elif token == 'import':
                    imports = self._parseimportlist()
                    for mod, alias in imports:
                        loc = "import %s" % mod
                        if len(alias) > 0: loc += " as %s" % alias
                        self.scope.local(loc)
                    freshscope = False
                elif token == 'from':
                    mod, token = self._parsedotname()
                    if not mod or token != "import":
                        print "from: syntax error..."
                        continue
                    names = self._parseimportlist()
                    for name, alias in names:
                        loc = "from %s import %s" % (mod,name)
                        if len(alias) > 0: loc += " as %s" % alias
                        self.scope.local(loc)
                    freshscope = False
                elif tokentype == STRING:
                    if freshscope: self.scope.doc(token)
                elif tokentype == NAME:
                    name,token = self._parsedotname(token) 
                    if token == '=':
                        stmt = self._parseassignment()
                        dbg("parseassignment: %s = %s" % (name, stmt))
                        if stmt != None:
                            self.scope.local("%s = %s" % (name,stmt))
                    freshscope = False
        except StopIteration: #thrown on EOF
            pass
        except:
            dbg("parse error: %s, %s @ %s" %
                (sys.exc_info()[0], sys.exc_info()[1], self.parserline))
        return self._adjustvisibility()

def _sanitize(str):
    val = ''
    level = 0
    for c in str:
        if c in ('(','{','['):
            level += 1
        elif c in (']','}',')'):
            level -= 1
        elif level == 0:
            val += c
    return val

sys.path.extend(['.','..'])
PYTHONEOF
endfunction

call s:DefPython()
" vim: set et ts=4:
                                                                                                                                                                                                                                                                                                                                                                                                                                      " Vim completion script
" Language:		Ruby
" Maintainer:		Mark Guzman <segfault@hasno.info>
" URL:			https://github.com/vim-ruby/vim-ruby
" Release Coordinator:	Doug Kearns <dougkearns@gmail.com>
" Last Change:		2020 Apr 12
" ----------------------------------------------------------------------------
"
" Ruby IRB/Complete author: Keiju ISHITSUKA(keiju@ishitsuka.com)
" ----------------------------------------------------------------------------

" {{{ requirement checks

function! s:ErrMsg(msg)
    echohl ErrorMsg
    echo a:msg
    echohl None
endfunction

if !has('ruby')
    call s:ErrMsg( "Error: Rubycomplete requires vim compiled with +ruby" )
    call s:ErrMsg( "Error: falling back to syntax completion" )
    " lets fall back to syntax completion
    setlocal omnifunc=syntaxcomplete#Complete
    finish
endif

if version < 700
    call s:ErrMsg( "Error: Required vim >= 7.0" )
    finish
endif
" }}} requirement checks

" {{{ configuration failsafe initialization
if !exists("g:rubycomplete_rails")
    let g:rubycomplete_rails = 0
endif

if !exists("g:rubycomplete_classes_in_global")
    let g:rubycomplete_classes_in_global = 0
endif

if !exists("g:rubycomplete_buffer_loading")
    let g:rubycomplete_buffer_loading = 0
endif

if !exists("g:rubycomplete_include_object")
    let g:rubycomplete_include_object = 0
endif

if !exists("g:rubycomplete_include_objectspace")
    let g:rubycomplete_include_objectspace = 0
endif
" }}} configuration failsafe initialization

" {{{ regex patterns

" Regex that defines the start-match for the 'end' keyword.
let s:end_start_regex =
      \ '\C\%(^\s*\|[=,*/%+\-|;{]\|<<\|>>\|:\s\)\s*\zs' .
      \ '\<\%(module\|class\|if\|for\|while\|until\|case\|unless\|begin' .
      \   '\|\%(\K\k*[!?]\?\s\+\)\=def\):\@!\>' .
      \ '\|\%(^\|[^.:@$]\)\@<=\<do:\@!\>'

" Regex that defines the middle-match for the 'end' keyword.
let s:end_middle_regex = '\<\%(ensure\|else\|\%(\%(^\|;\)\s*\)\@<=\<rescue:\@!\>\|when\|elsif\):\@!\>'

" Regex that defines the end-match for the 'end' keyword.
let s:end_end_regex = '\%(^\|[^.:@$]\)\@<=\<end:\@!\>'

" }}} regex patterns

" {{{ vim-side support functions
let s:rubycomplete_debug = 0

function! s:dprint(msg)
    if s:rubycomplete_debug == 1
        echom a:msg
    endif
endfunction

function! s:GetBufferRubyModule(name, ...)
    if a:0 == 1
        let [snum,enum] = s:GetBufferRubyEntity(a:name, "module", a:1)
    else
        let [snum,enum] = s:GetBufferRubyEntity(a:name, "module")
    endif
    return snum . '..' . enum
endfunction

function! s:GetBufferRubyClass(name, ...)
    if a:0 >= 1
        let [snum,enum] = s:GetBufferRubyEntity(a:name, "class", a:1)
    else
        let [snum,enum] = s:GetBufferRubyEntity(a:name, "class")
    endif
    return snum . '..' . enum
endfunction

function! s:GetBufferRubySingletonMethods(name)
endfunction

function! s:GetBufferRubyEntity( name, type, ... )
    let lastpos = getpos(".")
    let lastline = lastpos
    if (a:0 >= 1)
        let lastline = [ 0, a:1, 0, 0 ]
        call cursor( a:1, 0 )
    endif

    let stopline = 1

    let crex = '^\s*\<' . a:type . '\>\s*\<' . escape(a:name, '*') . '\>\s*\(<\s*.*\s*\)\?'
    let [lnum,lcol] = searchpos( crex, 'w' )
    "let [lnum,lcol] = searchpairpos( crex . '\zs', '', '\(end\|}\)', 'w' )

    if lnum == 0 && lcol == 0
        call cursor(lastpos[1], lastpos[2])
        return [0,0]
    endif

    let curpos = getpos(".")
    let [enum,ecol] = searchpairpos( s:end_start_regex, s:end_middle_regex, s:end_end_regex, 'W' )
    call cursor(lastpos[1], lastpos[2])

    if lnum > enum
        return [0,0]
    endif
    " we found a the class def
    return [lnum,enum]
endfunction

function! s:IsInClassDef()
    return s:IsPosInClassDef( line('.') )
endfunction

function! s:IsPosInClassDef(pos)
    let [snum,enum] = s:GetBufferRubyEntity( '.*', "class" )
    let ret = 'nil'

    if snum < a:pos && a:pos < enum
        let ret = snum . '..' . enum
    endif

    return ret
endfunction

function! s:IsInComment(pos)
    let stack = synstack(a:pos[0], a:pos[1])
    if !empty(stack)
        return synIDattr(stack[0], 'name') =~ 'ruby\%(.*Comment\|Documentation\)'
    else
        return 0
    endif
endfunction

function! s:GetRubyVarType(v)
    let stopline = 1
    let vtp = ''
    let curpos = getpos('.')
    let sstr = '^\s*#\s*@var\s*'.escape(a:v, '*').'\>\s\+[^ \t]\+\s*$'
    let [lnum,lcol] = searchpos(sstr,'nb',stopline)
    if lnum != 0 && lcol != 0
        call setpos('.',curpos)
        let str = getline(lnum)
        let vtp = substitute(str,sstr,'\1','')
        return vtp
    endif
    call setpos('.',curpos)
    let ctors = '\(now\|new\|open\|get_instance'
    if exists('g:rubycomplete_rails') && g:rubycomplete_rails == 1 && s:rubycomplete_rails_loaded == 1
        let ctors = ctors.'\|find\|create'
    else
    endif
    let ctors = ctors.'\)'

    let fstr = '=\s*\([^ \t]\+.' . ctors .'\>\|[\[{"''/]\|%[xwQqr][(\[{@]\|[A-Za-z0-9@:\-()\.]\+...\?\|lambda\|&\)'
    let sstr = ''.escape(a:v, '*').'\>\s*[+\-*/]*'.fstr
    let pos = searchpos(sstr,'bW')
    while pos != [0,0] && s:IsInComment(pos)
        let pos = searchpos(sstr,'bW')
    endwhile
    if pos != [0,0]
        let [lnum, col] = pos
        let str = matchstr(getline(lnum),fstr,col)
        let str = substitute(str,'^=\s*','','')

        call setpos('.',pos)
        if str == '"' || str == '''' || stridx(tolower(str), '%q[') != -1
            return 'String'
        elseif str == '[' || stridx(str, '%w[') != -1
            return 'Array'
        elseif str == '{'
            return 'Hash'
        elseif str == '/' || str == '%r{'
            return 'Regexp'
        elseif strlen(str) >= 4 && stridx(str,'..') != -1
            return 'Range'
        elseif stridx(str, 'lambda') != -1 || str == '&'
            return 'Proc'
        elseif strlen(str) > 4
            let l = stridx(str,'.')
            return str[0:l-1]
        end
        return ''
    endif
    call setpos('.',curpos)
    return ''
endfunction

"}}} vim-side support functions

"{{{ vim-side completion function
function! rubycomplete#Init()
    execute "ruby VimRubyCompletion.preload_rails"
endfunction

function! rubycomplete#Complete(findstart, base)
     "findstart = 1 when we need to get the text length
    if a:findstart
        let line = getline('.')
        let idx = col('.')
        while idx > 0
            let idx -= 1
            let c = line[idx-1]
            if c =~ '\w'
                continue
            elseif ! c =~ '\.'
                let idx = -1
                break
            else
                break
            endif
        endwhile

        return idx
    "findstart = 0 when we need to return the list of completions
    else
        let g:rubycomplete_completions = []
        execute "ruby VimRubyCompletion.get_completions('" . a:base . "')"
        return g:rubycomplete_completions
    endif
endfunction
"}}} vim-side completion function

"{{{ ruby-side code
function! s:DefRuby()
ruby << RUBYEOF
# {{{ ruby completion

begin
    require 'rubygems' # let's assume this is safe...?
rescue Exception
    #ignore?
end
class VimRubyCompletion
# {{{ constants
  @@debug = false
  @@ReservedWords = [
        "BEGIN", "END",
        "alias", "and",
        "begin", "break",
        "case", "class",
        "def", "defined", "do",
        "else", "elsif", "end", "ensure",
        "false", "for",
        "if", "in",
        "module",
        "next", "nil", "not",
        "or",
        "redo", "rescue", "retry", "return",
        "self", "super",
        "then", "true",
        "undef", "unless", "until",
        "when", "while",
        "yield",
      ]

  @@Operators = [ "%", "&", "*", "**", "+",  "-",  "/",
        "<", "<<", "<=", "<=>", "==", "===", "=~", ">", ">=", ">>",
        "[]", "[]=", "^", ]
# }}} constants

# {{{ buffer analysis magic
  def load_requires

    custom_paths = VIM::evaluate("get(g:, 'rubycomplete_load_paths', [])")

    if !custom_paths.empty?
      $LOAD_PATH.concat(custom_paths).uniq!
    end

    buf = VIM::Buffer.current
    enum = buf.line_number
    nums = Range.new( 1, enum )
    nums.each do |x|

      ln = buf[x]
      begin
        if /.*require_relative\s*(.*)$/.match( ln )
          eval( "require %s" % File.expand_path($1) )
        elsif /.*require\s*(["'].*?["'])/.match( ln )
          eval( "require %s" % $1 )
        end
      rescue Exception => e
        dprint e.inspect
      end
    end
  end

  def load_gems
    fpath = VIM::evaluate("get(g:, 'rubycomplete_gemfile_path', 'Gemfile')")
    return unless File.file?(fpath) && File.readable?(fpath)
    want_bundler = VIM::evaluate("get(g:, 'rubycomplete_use_bundler')")
    parse_file = !want_bundler
    begin
      require 'bundler'
      Bundler.setup
      Bundler.require
    rescue Exception
      parse_file = true
    end
    if parse_file
      File.new(fpath).each_line do |line|
        begin
          require $1 if /\s*gem\s*['"]([^'"]+)/.match(line)
        rescue Exception
        end
      end
    end
  end

  def load_buffer_class(name)
    dprint "load_buffer_class(%s) START" % name
    classdef = get_buffer_entity(name, 's:GetBufferRubyClass("%s")')
    return if classdef == nil

    pare = /^\s*class\s*(.*)\s*<\s*(.*)\s*\n/.match( classdef )
    load_buffer_class( $2 ) if pare != nil  && $2 != name # load parent class if needed

    mixre = /.*\n\s*(include|prepend)\s*(.*)\s*\n/.match( classdef )
    load_buffer_module( $2 ) if mixre != nil && $2 != name # load mixins if needed

    begin
      eval classdef
    rescue Exception
      VIM::evaluate( "s:ErrMsg( 'Problem loading class \"%s\", was it already completed?' )" % name )
    end
    dprint "load_buffer_class(%s) END" % name
  end

  def load_buffer_module(name)
    dprint "load_buffer_module(%s) START" % name
    classdef = get_buffer_entity(name, 's:GetBufferRubyModule("%s")')
    return if classdef == nil

    begin
      eval classdef
    rescue Exception
      VIM::evaluate( "s:ErrMsg( 'Problem loading module \"%s\", was it already completed?' )" % name )
    end
    dprint "load_buffer_module(%s) END" % name
  end

  def get_buffer_entity(name, vimfun)
    loading_allowed = VIM::evaluate("exists('g:rubycomplete_buffer_loading') && g:rubycomplete_buffer_loading")
    return nil if loading_allowed.to_i.zero?
    return nil if /(\"|\')+/.match( name )
    buf = VIM::Buffer.current
    nums = eval( VIM::evaluate( vimfun % name ) )
    return nil if nums == nil
    return nil if nums.min == nums.max && nums.min == 0

    dprint "get_buffer_entity START"
    visited = []
    clscnt = 0
    bufname = VIM::Buffer.current.name
    classdef = ""
    cur_line = VIM::Buffer.current.line_number
    while (nums != nil && !(nums.min == 0 && nums.max == 0) )
      dprint "visited: %s" % visited.to_s
      break if visited.index( nums )
      visited << nums

      nums.each do |x|
        if x != cur_line
          next if x == 0
          ln = buf[x]
          is_const = false
          if /^\s*(module|class|def|include)\s+/.match(ln) || is_const = /^\s*?[A-Z]([A-z]|[1-9])*\s*?[|]{0,2}=\s*?.+\s*?/.match(ln)
            clscnt += 1 if /class|module/.match($1)
            # We must make sure to load each constant only once to avoid errors
            if is_const
                ln.gsub!(/\s*?[|]{0,2}=\s*?/, '||=')
            end
            #dprint "\$1$1
            classdef += "%s\n" % ln
            classdef += "end\n" if /def\s+/.match(ln)
            dprint ln
          end
        end
      end

      nm = "%s(::.*)*\", %s, \"" % [ name, nums.last ]
      nums = eval( VIM::evaluate( vimfun % nm ) )
      dprint "nm: \"%s\"" % nm
      dprint "vimfun: %s" % (vimfun % nm)
      dprint "got nums: %s" % nums.to_s
    end
    if classdef.length > 1
        classdef += "end\n"*clscnt
        # classdef = "class %s\n%s\nend\n" % [ bufname.gsub( /\/|\\/, "_" ), classdef ]
    end

    dprint "get_buffer_entity END"
    dprint "classdef====start"
    lns = classdef.split( "\n" )
    lns.each { |x| dprint x }
    dprint "classdef====end"
    return classdef
  end

  def get_var_type( receiver )
    if /(\"|\')+/.match( receiver )
      "String"
    else
      VIM::evaluate("s:GetRubyVarType('%s')" % receiver)
 [p  \p  ]p  ^p  _p  `p  ap  bp  cp  dp  ep  fp  gp  hp                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             end
  end

  def dprint( txt )
    print txt if @@debug
  end

  def escape_vim_singlequote_string(str)
    str.to_s.gsub(/'/,"\\'")
  end

  def get_buffer_entity_list( type )
    # this will be a little expensive.
    loading_allowed = VIM::evaluate("exists('g:rubycomplete_buffer_loading') && g:rubycomplete_buffer_loading")
    allow_aggressive_load = VIM::evaluate("exists('g:rubycomplete_classes_in_global') && g:rubycomplete_classes_in_global")
    return [] if allow_aggressive_load.to_i.zero? || loading_allowed.to_i.zero?

    buf = VIM::Buffer.current
    eob = buf.length
    ret = []
    rg = 1..eob
    re = eval( "/^\s*%s\s*([A-Za-z0-9_:-]*)(\s*<\s*([A-Za-z0-9_:-]*))?\s*/" % type )

    rg.each do |x|
      if re.match( buf[x] )
        next if type == "def" && eval( VIM::evaluate("s:IsPosInClassDef(%s)" % x) ) != nil
        ret.push $1
      end
    end

    return ret
  end

  def get_buffer_modules
    return get_buffer_entity_list( "modules" )
  end

  def get_buffer_methods
    return get_buffer_entity_list( "def" )
  end

  def get_buffer_classes
    return get_buffer_entity_list( "class" )
  end

  def load_rails
    allow_rails = VIM::evaluate("exists('g:rubycomplete_rails') && g:rubycomplete_rails")
    return if allow_rails.to_i.zero?

    buf_path = VIM::evaluate('expand("%:p")')
    file_name = VIM::evaluate('expand("%:t")')
    vim_dir = VIM::evaluate('getcwd()')
    file_dir = buf_path.gsub( file_name, '' )
    file_dir.gsub!( /\\/, "/" )
    vim_dir.gsub!( /\\/, "/" )
    vim_dir << "/"
    dirs = [ vim_dir, file_dir ]
    sdirs = [ "", "./", "../", "../../", "../../../", "../../../../" ]
    rails_base = nil

    dirs.each do |dir|
      sdirs.each do |sub|
        trail = "%s%s" % [ dir, sub ]
        tcfg = "%sconfig" % trail

        if File.exists?( tcfg )
          rails_base = trail
          break
        end
      end
      break if rails_base
    end

    return if rails_base == nil
    $:.push rails_base unless $:.index( rails_base )

    bootfile = rails_base + "config/boot.rb"
    envfile = rails_base + "config/environment.rb"
    if File.exists?( bootfile ) && File.exists?( envfile )
      begin
        require bootfile
        require envfile
        begin
          require 'console_app'
          require 'console_with_helpers'
        rescue Exception
          dprint "Rails 1.1+ Error %s" % $!
          # assume 1.0
        end
        #eval( "Rails::Initializer.run" ) #not necessary?
        VIM::command('let s:rubycomplete_rails_loaded = 1')
        dprint "rails loaded"
      rescue Exception
        dprint "Rails Error %s" % $!
        VIM::evaluate( "s:ErrMsg('Error loading rails environment')" )
      end
    end
  end

  def get_rails_helpers
    allow_rails = VIM::evaluate("exists('g:rubycomplete_rails') && g:rubycomplete_rails")
    rails_loaded = VIM::evaluate('s:rubycomplete_rails_loaded')
    return [] if allow_rails.to_i.zero? || rails_loaded.to_i.zero?

    buf_path = VIM::evaluate('expand("%:p")')
    buf_path.gsub!( /\\/, "/" )
    path_elm = buf_path.split( "/" )
    dprint "buf_path: %s" % buf_path
    types = [ "app", "db", "lib", "test", "components", "script" ]

    i = nil
    ret = []
    type = nil
    types.each do |t|
      i = path_elm.index( t )
      break if i
    end
    type = path_elm[i]
    type.downcase!

    dprint "type: %s" % type
    case type
      when "app"
        i += 1
        subtype = path_elm[i]
        subtype.downcase!

        dprint "subtype: %s" % subtype
        case subtype
          when "views"
            ret += ActionView::Base.instance_methods
            ret += ActionView::Base.methods
          when "controllers"
            ret += ActionController::Base.instance_methods
            ret += ActionController::Base.methods
          when "models"
            ret += ActiveRecord::Base.instance_methods
            ret += ActiveRecord::Base.methods
        end

      when "db"
        ret += ActiveRecord::ConnectionAdapters::SchemaStatements.instance_methods
        ret += ActiveRecord::ConnectionAdapters::SchemaStatements.methods
    end

    return ret
  end

  def add_rails_columns( cls )
    allow_rails = VIM::evaluate("exists('g:rubycomplete_rails') && g:rubycomplete_rails")
    rails_loaded = VIM::evaluate('s:rubycomplete_rails_loaded')
    return [] if allow_rails.to_i.zero? || rails_loaded.to_i.zero?

    begin
        eval( "#{cls}.establish_connection" )
        return [] unless eval( "#{cls}.ancestors.include?(ActiveRecord::Base).to_s" )
        col = eval( "#{cls}.column_names" )
        return col if col
    rescue
        dprint "add_rails_columns err: (cls: %s) %s" % [ cls, $! ]
        return []
    end
    return []
  end

  def clean_sel(sel, msg)
    ret = sel.reject{|x|x.nil?}.uniq
    ret = ret.grep(/^#{Regexp.quote(msg)}/) if msg != nil
    ret
  end

  def get_rails_view_methods
    allow_rails = VIM::evaluate("exists('g:rubycomplete_rails') && g:rubycomplete_rails")
    rails_loaded = VIM::evaluate('s:rubycomplete_rails_loaded')
    return [] if allow_rails.to_i.zero? || rails_loaded.to_i.zero?

    buf_path = VIM::evaluate('expand("%:p")')
    buf_path.gsub!( /\\/, "/" )
    pelm = buf_path.split( "/" )
    idx = pelm.index( "views" )

    return [] unless idx
    idx += 1

    clspl = pelm[idx].camelize.pluralize
    cls = clspl.singularize

    ret = []
    begin
      ret += eval( "#{cls}.instance_methods" )
      ret += eval( "#{clspl}Helper.instance_methods" )
    rescue Exception
      dprint "Error: Unable to load rails view helpers for %s: %s" % [ cls, $! ]
    end

    return ret
  end
# }}} buffer analysis magic

# {{{ main completion code
  def self.preload_rails
    a = VimRubyCompletion.new
    if VIM::evaluate("has('nvim')") == 0
      require 'thread'
      Thread.new(a) do |b|
        begin
        b.load_rails
        rescue
        end
      end
    end
    a.load_rails
  rescue
  end

  def self.get_completions(base)
    b = VimRubyCompletion.new
    b.get_completions base
  end

  def get_completions(base)
    loading_allowed = VIM::evaluate("exists('g:rubycomplete_buffer_loading') && g:rubycomplete_buffer_loading")
    if loading_allowed.to_i == 1
      load_requires
      load_rails
    end

    want_gems = VIM::evaluate("get(g:, 'rubycomplete_load_gemfile')")
    load_gems unless want_gems.to_i.zero?

    input = VIM::Buffer.current.line
    cpos = VIM::Window.current.cursor[1] - 1
    input = input[0..cpos]
    input += base
    input.sub!(/.*[ \t\n\"\\'`><=;|&{(]/, '') # Readline.basic_word_break_characters
    input.sub!(/self\./, '')
    input.sub!(/.*((\.\.[\[(]?)|([\[(]))/, '')

    dprint 'input %s' % input
    message = nil
    receiver = nil
    methods = []
    variables = []
    classes = []
    constants = []

    case input
      when /^(\/[^\/]*\/)\.([^.]*)$/ # Regexp
        receiver = $1
        message = Regexp.quote($2)
        methods = Regexp.instance_methods(true)

      when /^([^\]]*\])\.([^.]*)$/ # Array
        receiver = $1
        message = Regexp.quote($2)
        methods = Array.instance_methods(true)

      when /^([^\}]*\})\.([^.]*)$/ # Proc or Hash
        receiver = $1
        message = Regexp.quote($2)
        methods = Proc.instance_methods(true) | Hash.instance_methods(true)

      when /^(:[^:.]*)$/ # Symbol
        dprint "symbol"
        if Symbol.respond_to?(:all_symbols)
          receiver = $1
          message = $1.sub( /:/, '' )
          methods = Symbol.all_symbols.collect{|s| s.id2name}
          methods.delete_if { |c| c.match( /'/ ) }
        end

      when /^::([A-Z][^:\.\(]*)?$/ # Absolute Constant or class methods
        dprint "const or cls"
        receiver = $1
        methods = Object.constants.collect{ |c| c.to_s }.grep(/^#{receiver}/)

      when /^(((::)?[A-Z][^:.\(]*)+?)::?([^:.]*)$/ # Constant or class methods
        receiver = $1
        message = Regexp.quote($4)
        dprint "const or cls 2 [recv: \'%s\', msg: \'%s\']" % [ receiver, message ]
        load_buffer_class( receiver )
        load_buffer_module( receiver )
        begin
          constants = eval("#{receiver}.constants").collect{ |c| c.to_s }.grep(/^#{message}/)
          methods = eval("#{receiver}.methods").collect{ |m| m.to_s }.grep(/^#{message}/)
        rescue Exception
          dprint "exception: %s" % $!
          constants = []
          methods = []
        end

      when /^(:[^:.]+)\.([^.]*)$/ # Symbol
        dprint "symbol"
        receiver = $1
        message = Regexp.quote($2)
        methods = Symbol.instance_methods(true)

      when /^([0-9_]+(\.[0-9_]+)?(e[0-9]+)?)\.([^.]*)$/ # Numeric
        dprint "numeric"
        receiver = $1
        message = Regexp.quote($4)
        begin
          methods = eval(receiver).methods
        rescue Exception
          methods = []
        end

      when /^(\$[^.]*)$/ #global
        dprint "global"
        methods = global_variables.grep(Regexp.new(Regexp.quote($1)))

      when /^((\.?[^.]+)+?)\.([^.]*)$/ # variable
        dprint "variable"
        receiver = $1
        message = Regexp.quote($3)
        load_buffer_class( receiver )

        cv = eval("self.class.constants")
        vartype = get_var_type( receiver )
        dprint "vartype: %s" % vartype

        invalid_vartype = ['', "gets"]
        if !invalid_vartype.include?(vartype)
          load_buffer_class( vartype )

          begin
            methods = eval("#{vartype}.instance_methods")
            variables = eval("#{vartype}.instance_variables")
          rescue Exception
            dprint "load_buffer_class err: %s" % $!
          end
        elsif (cv).include?(receiver)
          # foo.func and foo is local var.
          methods = eval("#{receiver}.methods")
          vartype = receiver
        elsif /^[A-Z]/ =~ receiver and /\./ !~ receiver
          vartype = receiver
          # Foo::Bar.func
          begin
            methods = eval("#{receiver}.methods")
          rescue Exception
          end
        else
          # func1.func2
          ObjectSpace.each_object(Module){|m|
            next if m.name != "IRB::Context" and
              /^(IRB|SLex|RubyLex|RubyToken)/ =~ m.name
            methods.concat m.instance_methods(false)
          }
        end
        variables += add_rails_columns( "#{vartype}" ) if vartype && !invalid_vartype.include?(vartype)

      when /^\(?\s*[A-Za-z0-9:^@.%\/+*\(\)]+\.\.\.?[A-Za-z0-9:^@.%\/+*\(\)]+\s*\)?\.([^.]*)/
        message = $1
        methods = Range.instance_methods(true)

      when /^\.([^.]*)$/ # unknown(maybe String)
        message = Regexp.quote($1)
        methods = String.instance_methods(true)

    else
      dprint "default/other"
      inclass = eval( VIM::evaluate("s:IsInClassDef()") )

      if inclass != nil
        dprint "inclass"
        classdef = "%s\n" % VIM::Buffer.current[ inclass.min ]
        found = /^\s*class\s*([A-Za-z0-9_-]*)(\s*<\s*([A-Za-z0-9_:-]*))?\s*\n$/.match( classdef )

        if found != nil
          receiver = $1
          message = input
          load_buffer_class( receiver )
          begin
            methods = eval( "#{receiver}.instance_methods" )
            variables += add_rails_columns( "#{receiver}" )
          rescue Exception
            found = nil
          end
        end
      end

      if inclass == nil || found == nil
        dprint "inclass == nil"
        methods = get_buffer_methods
        methods += get_rails_view_methods

        cls_const = Class.constants
        constants = cls_const.select { |c| /^[A-Z_-]+$/.match( c ) }
        classes = eval("self.class.constants") - constants
        classes += get_buffer_classes
        classes += get_buffer_modules

        include_objectspace = VIM::evaluate("exists('g:rubycomplete_include_objectspace') && g:rubycomplete_include_objectspace")
        ObjectSpace.each_object(Class) { |cls| classes << cls.to_s } if include_objectspace == "1"
        message = receiver = input
      end

      methods += get_rails_helpers
      methods += Kernel.public_methods
    end

    include_object = VIM::evaluate("exists('g:rubycomplete_include_object') && g:rubycomplete_include_object")
    methods = clean_sel( methods, message )
    methods = (methods-Object.instance_methods) if include_object == "0"
    rbcmeth = (VimRubyCompletion.instance_methods-Object.instance_methods) # lets remove those rubycomplete methods
    methods = (methods-rbcmeth)

    variables = clean_sel( variables, message )
    classes = clean_sel( classes, message ) - ["VimRubyCompletion"]
    constants = clean_sel( constants, message )

    valid = []
    valid += methods.collect { |m| { :name => m.to_s, :type => 'm' } }
    valid += variables.collect { |v| { :name => v.to_s, :type => 'v' } }
    valid += classes.collect { |c| { :name => c.to_s, :type => 't' } }
    valid += constants.collect { |d| { :name => d.to_s, :type => 'd' } }
    valid.sort! { |x,y| x[:name] <=> y[:name] }

    outp = ""

    rg = 0..valid.length
    rg.step(150) do |x|
      stpos = 0+x
      enpos = 150+x
      valid[stpos..enpos].each { |c| outp += "{'word':'%s','item':'%s','kind':'%s'}," % [ c[:name], c[:name], c[:type] ].map{|x|escape_vim_singlequote_string(x)} }
      outp.sub!(/,$/, '')

      VIM::command("call extend(g:rubycomplete_completions, [%s])" % outp)
      outp = ""
    end
  end
# }}} main completion code

end # VimRubyCompletion
# }}} ruby completion
RUBYEOF
endfunction

let s:rubycomplete_rails_loaded = 0

call s:DefRuby()
"}}} ruby-side code

" vim:tw=78:sw=4:ts=8:et:fdm=marker:ft=vim:norl:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          " Author: Kevin Ballard
" Description: Helper functions for Rust commands/mappings
" Last Modified: May 27, 2014
" For bugs, patches and license go to https://github.com/rust-lang/rust.vim

" Jump {{{1

function! rust#Jump(mode, function) range
	let cnt = v:count1
	normal! m'
	if a:mode ==# 'v'
		norm! gv
	endif
	let foldenable = &foldenable
	set nofoldenable
	while cnt > 0
		execute "call <SID>Jump_" . a:function . "()"
		let cnt = cnt - 1
	endwhile
	let &foldenable = foldenable
endfunction

function! s:Jump_Back()
	call search('{', 'b')
	keepjumps normal! w99[{
endfunction

function! s:Jump_Forward()
	normal! j0
	call search('{', 'b')
	keepjumps normal! w99[{%
	call search('{')
endfunction

" Run {{{1

function! rust#Run(bang, args)
	let args = s:ShellTokenize(a:args)
	if a:bang
		let idx = index(l:args, '--')
		if idx != -1
			let rustc_args = idx == 0 ? [] : l:args[:idx-1]
			let args = l:args[idx+1:]
		else
			let rustc_args = l:args
			let args = []
		endif
	else
		let rustc_args = []
	endif

	let b:rust_last_rustc_args = l:rustc_args
	let b:rust_last_args = l:args

	call s:WithPath(function("s:Run"), rustc_args, args)
endfunction

function! s:Run(dict, rustc_args, args)
	let exepath = a:dict.tmpdir.'/'.fnamemodify(a:dict.path, ':t:r')
	if has('win32')
		let exepath .= '.exe'
	endif

	let relpath = get(a:dict, 'tmpdir_relpath', a:dict.path)
	let rustc_args = [relpath, '-o', exepath] + a:rustc_args

	let rustc = exists("g:rustc_path") ? g:rustc_path : "rustc"

	let pwd = a:dict.istemp ? a:dict.tmpdir : ''
	let output = s:system(pwd, shellescape(rustc) . " " . join(map(rustc_args, 'shellescape(v:val)')))
	if output != ''
		echohl WarningMsg
		echo output
		echohl None
	endif
	if !v:shell_error
		exe '!' . shellescape(exepath) . " " . join(map(a:args, 'shellescape(v:val)'))
	endif
endfunction

" Expand {{{1

function! rust#Expand(bang, args)
	let args = s:ShellTokenize(a:args)
	if a:bang && !empty(l:args)
		let pretty = remove(l:args, 0)
	else
		let pretty = "expanded"
	endif
	call s:WithPath(function("s:Expand"), pretty, args)
endfunction

function! s:Expand(dict, pretty, args)
	try
		let rustc = exists("g:rustc_path") ? g:rustc_path : "rustc"

		if a:pretty =~? '^\%(everybody_loops$\|flowgraph=\)'
			let flag = '--xpretty'
		else
			let flag = '--pretty'
		endif
		let relpath = get(a:dict, 'tmpdir_relpath', a:dict.path)
		let args = [relpath, '-Z', 'unstable-options', l:flag, a:pretty] + a:args
		let pwd = a:dict.istemp ? a:dict.tmpdir : ''
		let output = s:system(pwd, shellescape(rustc) . " " . join(map(args, 'shellescape(v:val)')))
		if v:shell_error
			echohl WarningMsg
			echo output
			echohl None
		else
			new
			silent put =output
			1
			d
			setl filetype=rust
			setl buftype=nofile
			setl bufhidden=hide
			setl noswapfile
			" give the buffer a nice name
			let suffix = 1
			let basename = fnamemodify(a:dict.path, ':t:r')
			while 1
				let bufname = basename
				if suffix > 1 | let bufname .= ' ('.suffix.')' | endif
				let bufname .= '.pretty.rs'
				if bufexists(bufname)
					let suffix += 1
					continue
				endif
				exe 'silent noautocmd keepalt file' fnameescape(bufname)
				break
			endwhile
		endif
	endtry
endfunction

function! rust#CompleteExpand(lead, line, pos)
	if a:line[: a:pos-1] =~ '^RustExpand!\s*\S*$'
		" first argument and it has a !
		let list = ["normal", "expanded", "typed", "expanded,identified", "flowgraph=", "everybody_loops"]
		if !empty(a:lead)
			call filter(list, "v:val[:len(a:lead)-1] == a:lead")
		endif
		return list
	endif

	return glob(escape(a:lead, "*?[") . '*', 0, 1)
endfunction

" Emit {{{1

function! rust#Emit(type, args)
	let args = s:ShellTokenize(a:args)
	call s:WithPath(function("s:Emit"), a:type, args)
endfunction

function! s:Emit(dict, type, args)
	try
		let output_path = a:dict.tmpdir.'/output'

		let rustc = exists("g:rustc_path") ? g:rustc_path : "rustc"

		let relpath = get(a:dict, 'tmpdir_relpath', a:dict.path)
		let args = [relpath, '--emit', a:type, '-o', output_path] + a:args
		let pwd = a:dict.istemp ? a:dict.tmpdir : ''
		let output = s:system(pwd, shellescape(rustc) . " " . join(map(args, 'shellescape(v:val)')))
		if output != ''
			echohl WarningMsg
			echo output
			echohl None
		endif
		if !v:shell_error
			new
			exe 'silent keepalt read' fnameescape(output_path)
			1
			d
			if a:type == "llvm-ir"
				setl filetype=llvm
				let extension = 'll'
			elseif a:type == "asm"
				setl filetype=asm
				let extension = 's'
			endif
			setl buftype=nofile
			setl bufhidden=hide
			setl noswapfile
			if exists('l:extension')
				" give the buffer a nice name
				let suffix = 1
				let basename = fnamemodify(a:dict.path, ':t:r')
				while 1
					let bufname = basename
					if suffix > 1 | let bufname .= ' ('.suffix.')' | endif
					let bufname .= '.'.extension
					if bufexists(bufname)
						let suffix += 1
						continue
					endif
					exe 'silent noautocmd keepalt file' fnameescape(bufname)
					break
				endwhile
			endif
		endif
	endtry
endfunction

" Utility functions {{{1

" Invokes func(dict, ...)
" Where {dict} is a dictionary with the following keys:
"   'path' - The path to the file
"   'tmpdir' - The path to a temporary directory that will be deleted when the
"              function returns.
"   'istemp' - 1 if the path is a file inside of {dict.tmpdir} or 0 otherwise.
" If {istemp} is 1 then an additional key is provided:
"   'tmpdir_relpath' - The {path} relative to the {tmpdir}.
"
" {dict.path} may be a path to a file inside of {dict.tmpdir} or it may be the
" existing path of the current buffer. If the path is inside of {dict.tmpdir}
" then it is guaranteed to have a '.rs' extension.
function! s:WithPath(func, ...)
	let buf = bufnr('')
	let saved = {}
	let dict = {}
	try
		let saved.write = &write
		set write
		let dict.path = expand('%')
		let pathisempty = empty(dict.path)

		" Always create a tmpdir in case the wrapped command wants it
		let dict.tmpdir = tempname()
		call mkdir(dict.tmpdir)

		if pathisempty || !saved.write
			let dict.istemp = 1
			" if we're doing this because of nowrite, preserve the filename
			if !pathisempty
				let filename = expand('%:t:r').".rs"
			else
				let filename = 'unnamed.rs'
			endif
			let dict.tmpdir_relpath = filename
			let dict.path = dict.tmpdir.'/'.filename

			let saved.mod = &mod
			set nomod

			silent exe 'keepalt write! ' . fnameescape(dict.path)
			if pathisempty
				silent keepalt 0file
			endif
		else
			let dict.istemp = 0
			update
		endif

		call call(a:func, [dict] + a:000)
	finally
		if bufexists(buf)
			for [opt, value] in items(saved)
				silent call setbufvar(buf, '&'.opt, value)
				unlet value " avoid variable type mismatches
			endfor
		endif
		if has_key(dict, 'tmpdir') | silent call s:RmDir(dict.tmpdir) | endif
	endtry
endfunction

function! rust#AppendCmdLine(text)
	call setcmdpos(getcmdpos())
	let cmd = getcmdline() . a:text
	return cmd
endfunction

" Tokenize the string according to sh parsing rules
function! s:ShellTokenize(text)
	" states:
	" 0: start of word
	" 1: unquoted
	" 2: unquoted backslash
	" 3: double-quote
	" 4: double-quoted backslash
	" 5: single-quote
	let l:state = 0
	let l:current = ''
	let l:args = []
	for c in split(a:text, '\zs')
		if l:state == 0 || l:state == 1 " unquoted
			if l:c ==# ' '
				if l:state == 0 | continue | endif
				call add(l:args, l:current)
				let l:current = ''
				let l:state = 0
			elseif l:c ==# '\'
				let l:state = 2
			elseif l:c ==# '"'
				let l:state = 3
			elseif l:c ==# "'"
				let l:state = 5
			else
				let l:current .= l:c
				let l:state = 1
			endif
		elseif l:state == 2 " unquoted backslash
			if l:c !=# "\n" " can it even be \n?
				let l:current .= l:c
			endif
			let l:state = 1
		elseif l:state == 3 " double-quote
			if l:c ==# '\'
				let l:state = 4
			elseif l:c ==# '"'
				let l:state = 1
			else
				let l:current .= l:c
			endif
		elseif l:state == 4 " double-quoted backslash
			if stridx('$`"\', l:c) >= 0
				let l:current .= l:c
			elseif l:c ==# "\n" " is this even possible?
				" skip it
			else
				let l:current .= '\'.l:c
			endif
			let l:state = 3
		elseif l:state == 5 " single-quoted
			if l:c == "'"
				let l:state = 1
			else
				let l:current .= l:c
			endif
		endif
	endfor
	if l:state != 0
		call add(l:args, l:current)
	endif
	return l:args
endfunction

function! s:RmDir(path)
	" sanity check; make sure it's not empty, /, or $HOME
	if empty(a:path)
		echoerr 'Attempted to delete empty path'
		return 0
	elseif a:path == '/' || a:path == $HOME
		echoerr 'Attempted to delete protected path: ' . a:path
		return 0
	endif
	return system("rm -rf " . shellescape(a:path))
endfunction

" Executes {cmd} with the cwd set to {pwd}, without changing Vim's cwd.
" If {pwd} is the empty string then it doesn't change the cwd.
function! s:system(pwd, cmd)
	let cmd = a:cmd
	if !empty(a:pwd)
		let cmd = 'cd ' . shellescape(a:pwd) . ' && ' . cmd
	endif
	return system(cmd)
endfunction

" Playpen Support {{{1
" Parts of gist.vim by Yasuhiro Matsumoto <mattn.jp@gmail.com> reused
" gist.vim available under the BSD license, available at
" http://github.com/mattn/gist-vim
function! s:has_webapi()
    if !exists("*webapi#http#post")
	try
	    call webapi#http#post()
	catch
	endtry
    endif
    return exists("*webapi#http#post")
endfunction

function! rust#Play(count, line1, line2, ...) abort
    redraw

    let l:rust_playpen_url = get(g:, 'rust_playpen_url', 'https://play.rust-lang.org/')
    let l:rust_shortener_url = get(g:, 'rust_shortener_url', 'https://is.gd/')

    if !s:has_webapi()
	echohl ErrorMsg | echomsg ':RustPlay depends on webapi.vim (https://github.com/mattn/webapi-vim)' | echohl None
	return
    endif

    let bufname = bufname('%')
    if a:count < 1
	let content = join(getline(a:line1, a:line2), "\n")
    else
	let save_regcont = @"
	let save_regtype = getregtype('"')
	silent! normal! gvy
	let content = @"
	call setreg('"', save_regcont, save_regtype)
    endif

    let body = l:rust_playpen_url."?code=".webapi#http#encodeURI(content)

    if strlen(body) > 5000
	echohl ErrorMsg | echomsg 'Buffer too large, max 5000 encoded characters ('.strlen(body).')' | echohl None
	return
    endif

    let payload = "format=simple&url=".webapi#http#encodeURI(body)
    let res = webapi#http#post(l:rust_shortener_url.'create.php', payload, {})
    let url = res.content

    redraw | echomsg 'Done: '.url
endfunction

" }}}1

" vim: set noet sw=8 ts=8:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 " Author: Stephen Sugden <stephen@stephensugden.com>
"
" Adapted from https://github.com/fatih/vim-go
" For bugs, patches and license go to https://github.com/rust-lang/rust.vim

if !exists("g:rustfmt_autosave")
	let g:rustfmt_autosave = 0
endif

if !exists("g:rustfmt_command")
	let g:rustfmt_command = "rustfmt"
endif

if !exists("g:rustfmt_options")
	let g:rustfmt_options = ""
endif

if !exists("g:rustfmt_fail_silently")
	let g:rustfmt_fail_silently = 0
endif

let s:got_fmt_error = 0

function! s:RustfmtCommandRange(filename, line1, line2)
	let l:arg = {"file": shellescape(a:filename), "range": [a:line1, a:line2]}
	return printf("%s %s --write-mode=overwrite --file-lines '[%s]'", g:rustfmt_command, g:rustfmt_options, json_encode(l:arg))
endfunction

function! s:RustfmtCommand(filename)
	return g:rustfmt_command . " --write-mode=overwrite " . g:rustfmt_options . " " . shellescape(a:filename)
endfunction

function! s:RunRustfmt(command, curw, tmpname)
	if exists("*systemlist")
		let out = systemlist(a:command)
	else
		let out = split(system(a:command), '\r\?\n')
	endif

	if v:shell_error == 0 || v:shell_error == 3
		" remove undo point caused via BufWritePre
		try | silent undojoin | catch | endtry

		" Replace current file with temp file, then reload buffer
		call rename(a:tmpname, expand('%'))
		silent edit!
		let &syntax = &syntax

		" only clear location list if it was previously filled to prevent
		" clobbering other additions
		if s:got_fmt_error
			let s:got_fmt_error = 0
			call setloclist(0, [])
			lwindow
		endif
	elseif g:rustfmt_fail_silently == 0
		" otherwise get the errors and put them in the location list
		let errors = []

		for line in out
			" src/lib.rs:13:5: 13:10 error: expected `,`, or `}`, found `value`
			let tokens = matchlist(line, '^\(.\{-}\):\(\d\+\):\(\d\+\):\s*\(\d\+:\d\+\s*\)\?\s*error: \(.*\)')
			if !empty(tokens)
				call add(errors, {"filename": @%,
						 \"lnum":     tokens[2],
						 \"col":      tokens[3],
						 \"text":     tokens[5]})
			endif
		endfor

		if empty(errors)
			% | " Couldn't detect rustfmt error format, output errors
		endif

		if !empty(errors)
			call setloclist(0, errors, 'r')
			echohl Error | echomsg "rustfmt returned error" | echohl None
		endif

		let s:got_fmt_error = 1
		lwindow
		" We didn't use the temp file, so clean up
		call delete(a:tmpname)
	endif

	call winrestview(a:curw)
endfunction

function! rustfmt#FormatRange(line1, line2)
	let l:curw = winsaveview()
	let l:tmpname = expand("%:p:h") . "/." . expand("%:p:t") . ".rustfmt"
	call writefile(getline(1, '$'), l:tmpname)

	let command = s:RustfmtCommandRange(l:tmpname, a:line1, a:line2)

	call s:RunRustfmt(command, l:curw, l:tmpname)
endfunction

function! rustfmt#Format()
	let l:curw = winsaveview()
	let l:tmpname = expand("%:p:h") . "/." . expand("%:p:t") . ".rustfmt"
	call writefile(getline(1, '$'), l:tmpname)

	let command = s:RustfmtCommand(l:tmpname)

	call s:RunRustfmt(command, l:curw, l:tmpname)
endfunction
                                                                                  " Vim script to download a missing spell file
" Maintainer:	Bram Moolenaar <Bram@vim.org>
" Last Change:	2020 Jul 10

if !exists('g:spellfile_URL')
  " Always use https:// because it's secure.  The certificate is for nluug.nl,
  " thus we can't use the alias ftp.vim.org here.
  let g:spellfile_URL = 'https://ftp.nluug.nl/pub/vim/runtime/spell'
endif
let s:spellfile_URL = ''    " Start with nothing so that s:donedict is reset.

" This function is used for the spellfile plugin.
function! spellfile#LoadFile(lang)
  " If the netrw plugin isn't loaded we silently skip everything.
  if !exists(":Nread")
    if &verbose
      echomsg 'spellfile#LoadFile(): Nread command is not available.'
    endif
    return
  endif
  let lang = tolower(a:lang)

  " If the URL changes we try all files again.
  if s:spellfile_URL != g:spellfile_URL
    let s:donedict = {}
    let s:spellfile_URL = g:spellfile_URL
  endif

  " I will say this only once!
  if has_key(s:donedict, lang . &enc)
    if &verbose
      echomsg 'spellfile#LoadFile(): Tried this language/encoding before.'
    endif
    return
  endif
  let s:donedict[lang . &enc] = 1

  " Find spell directories we can write in.
  let [dirlist, dirchoices] = spellfile#GetDirChoices()
  if len(dirlist) == 0
    let dir_to_create = spellfile#WritableSpellDir()
    if &verbose || dir_to_create != ''
      echomsg 'spellfile#LoadFile(): There is no writable spell directory.'
    endif
    if dir_to_create != ''
      if confirm("Shall I create " . dir_to_create, "&Yes\n&No", 2) == 1
	" After creating the directory it should show up in the list.
	call mkdir(dir_to_create, "p")
	let [dirlist, dirchoices] = spellfile#GetDirChoices()
      endif
    endif
    if len(dirlist) == 0
      return
    endif
  endif

  let msg = 'Cannot find spell file for "' . lang . '" in ' . &enc
  let msg .= "\nDo you want me to try downloading it?"
  if confirm(msg, "&Yes\n&No", 2) == 1
    let enc = &encoding
    if enc == 'iso-8859-15'
      let enc = 'latin1'
    endif
    let fname = lang . '.' . enc . '.spl'

    " Split the window, read the file into a new buffer.
    " Remember the buffer number, we check it below.
    new
    let newbufnr = winbufnr(0)
    setlocal bin fenc=
    echo 'Downloading ' . fname . '...'
    call spellfile#Nread(fname)
    if getline(2) !~ 'VIMspell'
      " Didn't work, perhaps there is an ASCII one.
      " Careful: Nread() may have opened a new window for the error message,
      " we need to go back to our own buffer and window.
      if newbufnr != winbufnr(0)
	let winnr = bufwinnr(newbufnr)
	if winnr == -1
	  " Our buffer has vanished!?  Open a new window.
	  echomsg "download buffer disappeared, opening a new one"
	  new
	  setlocal bin fenc=
	else
	  exe winnr . "wincmd w"
	endif
      endif
      if newbufnr == winbufnr(0)
	" We are back the old buffer, remove any (half-finished) download.
        g/^/d
      else
	let newbufnr = winbufnr(0)
      endif

      let fname = lang . '.ascii.spl'
      echo 'Could not find it, trying ' . fname . '...'
      call spellfile#Nread(fname)
      if getline(2) !~ 'VIMspell'
	echo 'Sorry, downloading failed'
	exe newbufnr . "bwipe!"
	return
      endif
    endif

    " Delete the empty first line and mark the file unmodified.
    1d
    set nomod

    let msg = "In which directory do you want to write the file:"
    for i in range(len(dirlist))
      let msg .= "\n" . (i + 1) . '. ' . dirlist[i]
    endfor
    let dirchoice = confirm(msg, dirchoices) - 2
    if dirchoice >= 0
      if exists('*fnameescape')
	let dirname = fnameescape(dirlist[dirchoice])
      else
	let dirname = escape(dirlist[dirchoice], ' ')
      endif
      setlocal fenc=
      exe "write " . dirname . '/' . fname

      " Also download the .sug file, if the user wants to.
      let msg = "Do you want me to try getting the .sug file?\n"
      let msg .= "This will improve making suggestions for spelling mistakes,\n"
      let msg .= "but it uses quite a bit of memory."
      if confirm(msg, "&No\n&Yes") == 2
	g/^/d
	let fname = substitute(fname, '\.spl$', '.sug', '')
	echo 'Downloading ' . fname . '...'
	call spellfile#Nread(fname)
	if getline(2) =~ 'VIMsug'
	  1d
	  exe "write " . dirname . '/' . fname
	  set nomod
	else
	  echo 'Sorry, downloading failed'
	  " Go back to our own buffer/window, Nread() may have taken us to
	  " another window.
	  if newbufnr != winbufnr(0)
	    let winnr = bufwinnr(newbufnr)
	    if winnr != -1
	      exe winnr . "wincmd w"
	    endif
	  endif
	  if newbufnr == winbufnr(0)
	    set nomod
	  endif
	endif
      endif
    endif

    " Wipe out the buffer we used.
    exe newbufnr . "bwipe"
  endif
endfunc

" Read "fname" from the server.
function! spellfile#Nread(fname)
  " We do our own error handling, don't want a window for it.
  if exists("g:netrw_use_errorwindow")
    let save_ew = g:netrw_use_errorwindow
  endif
  let g:netrw_use_errorwindow=0

  if g:spellfile_URL =~ '^ftp://'
    " for an ftp server use a default login and password to avoid a prompt
    let machine = substitute(g:spellfile_URL, 'ftp://\([^/]*\).*', '\1', '')
    let dir = substitute(g:spellfile_URL, 'ftp://[^/]*/\(.*\)', '\1', '')
    exe 'Nread "' . machine . ' anonymous vim7user ' . dir . '/' . a:fname . '"'
  else
    exe 'Nread ' g:spellfile_URL . '/' . a:fname
  endif

  if exists("save_ew")
    let g:netrw_use_errorwindow = save_ew
  else
    unlet g:netrw_use_errorwindow
  endif
endfunc

" Get a list of writable spell directories and choices for confirm().
function! spellfile#GetDirChoices()
  let dirlist = []
  let dirchoices = '&Cancel'
  for dir in split(globpath(&rtp, 'spell'), "\n")
    if filewritable(dir) == 2
      call add(dirlist, dir)
      let dirchoices .= "\n&" . len(dirlist)
    endif
  endfor
  return [dirlist, dirchoices]
endfunc

function! spellfile#WritableSpellDir()
  if has("unix")
    " For Unix always use the $HOME/.vim directory
    return $HOME . "/.vim/spell"
  endif
  for dir in split(&rtp, ',')
    if filewritable(dir) == 2
      return dir . "/spell"
    endif
  endfor
  return ''
endfunction
                                    " Vim OMNI completion script for SQL
" Language:    SQL
" Maintainer:  David Fishburn <dfishburn dot vim at gmail dot com>
" Version:     16.0
" Last Change: 2017 Oct 15
" Homepage:    http://www.vim.org/scripts/script.php?script_id=1572
" Usage:       For detailed help
"              ":help sql.txt"
"              or ":help ft-sql-omni"
"              or read $VIMRUNTIME/doc/sql.txt

" History
"
" TODO
"     - Jonas Enberg - if no table is found when using column completion
"       look backwards to a FROM clause and find the first table
"       and complete it.
"
" Version 16.0 (Dec 2015)
"     - NF: If resetting the cache and table, procedure or view completion
"           had been used via dbext, have dbext delete or recreate the 
"           dictionary so that new objects are picked up for the 
"           next completion.
"
" Version 15.0 (May 2013)
"     - NF: Changed the SQL precached syntax items, omni_sql_precache_syntax_groups,
"           to use regular expressions to pick up extended syntax group names.
"           This requires an updated SyntaxComplete plugin version 13.0.
"           If the required versions have not been installed, previous
"           behaviour will not be impacted.
"
" Version 14.0 (Dec 2012)
"     - BF: Added check for cpo
"
" Version 13.0 (Dec 2012)
"     - NF: When completing column lists or drilling into a table
"           and g:omni_sql_include_owner is enabled, the
"           only the table name would be replaced with the column
"           list instead of the table name and owner (if specified).
"     - NF: When completing column lists using table aliases
"           and g:omni_sql_include_owner is enabled, account
"           for the owner name when looking up the table
"           list instead of the table name and owner (if specified).
"     - BF: When completing column lists or drilling into a table
"           and g:omni_sql_include_owner is enabled, the
"           column list could often not be found for the table.
"     - BF: When OMNI popped up, possibly the wrong word
"           would be replaced for column and column list options.
"
" Version 12.0 (Feb 2012)
"     - Partial column name completion did not work when a table
"       name or table alias was provided (Jonas Enberg).
"     - Improved the handling of column completion.  First we match any
"       columns from a previous completion.  If not matches are found, we
"       consider the partial name to be a table or table alias for the
"       query and attempt to match on it.
"
" Version 11.0 (Jan 2012)
"     Added g:omni_sql_default_compl_type variable
"         - You can specify which type of completion to default to
"           when pressing <C-X><C-O>.  The entire list of available
"           choices can be found in the calls to sqlcomplete#Map in:
"               ftplugin/sql.vim
"
" Version 10.0
"     Updated PreCacheSyntax()
"         - Now returns a List of the syntax items it finds.
"           This allows other plugins / scripts to use this list for their own
"           purposes.  In this case XPTemplate can use them for a Choose list.
"         - Verifies the parameters are the correct type and displays a
"           warning if not.
"         - Verifies the parameters are the correct type and displays a
"           warning if not.
"     Updated SQLCWarningMsg()
"         - Prepends warning message with SQLComplete so you know who issued
"           the warning.
"     Updated SQLCErrorMsg()
"         - Prepends error message with SQLComplete so you know who issued
"           the error.
"
" Version 9.0 (May 2010)
"     This change removes some of the support for tables with spaces in their
"     names in order to simplify the regexes used to pull out query table
"     aliases for more robust table name and column name code completion.
"     Full support for "table names with spaces" can be added in again
"     after 7.3.
"
" Version 8.0
"     Incorrectly re-executed the g:ftplugin_sql_omni_key_right and g:ftplugin_sql_omni_key_left
"     when drilling in and out of a column list for a table.
"
" Version 7.0 (Jan 2010)
"     Better handling of object names
"
" Version 6.0 (Apr 2008)
"     Supports object names with spaces "my table name"
"
" Set completion with CTRL-X CTRL-O to autoloaded function.
" This check is in place in case this script is
" sourced directly instead of using the autoload feature.
if exists('&omnifunc')
    " Do not set the option if already set since this
    " results in an E117 warning.
    if &omnifunc == ""
        setlocal omnifunc=sqlcomplete#Complete
    endif
endif

if exists('g:loaded_sql_completion')
    finish
endif
let g:loaded_sql_completion = 160
let s:keepcpo= &cpo
set cpo&vim

" Maintains filename of dictionary
let s:sql_file_table        = ""
let s:sql_file_procedure    = ""
let s:sql_file_view         = ""

" Define various arrays to be used for caching
let s:tbl_name              = []
let s:tbl_alias             = []
let s:tbl_cols              = []
let s:syn_list              = []
let s:syn_value             = []

" Used in conjunction with the syntaxcomplete plugin
let s:save_inc              = ""
let s:save_exc              = ""
if !exists('g:omni_syntax_group_include_sql')
    let g:omni_syntax_group_include_sql = ''
endif
if !exists('g:omni_syntax_group_exclude_sql')
    let g:omni_syntax_group_exclude_sql = ''
endif
let s:save_inc = g:omni_syntax_group_include_sql
let s:save_exc = g:omni_syntax_group_exclude_sql

" Used with the column list
let s:save_prev_table       = ""

" Default the option to verify table alias
if !exists('g:omni_sql_use_tbl_alias')
    let g:omni_sql_use_tbl_alias = 'a'
endif
" Default syntax items to precache
if !exists('g:omni_sql_precache_syntax_groups')
    let g:omni_sql_precache_syntax_groups = [
                \ 'syntax\w*',
                \ 'sqlKeyword\w*',
                \ 'sqlFunction\w*',
                \ 'sqlOption\w*',
                \ 'sqlType\w*',
                \ 'sqlStatement\w*'
                \ ]
endif
" Set ignorecase to the ftplugin standard
if !exists('g:omni_sql_ignorecase')
    let g:omni_sql_ignorecase = &ignorecase
endif
" During table completion, should the table list also
" include the owner name
if !exists('g:omni_sql_include_owner')
    let g:omni_sql_include_owner = 0
    if exists('g:loaded_dbext')
        if g:loaded_dbext >= 300
            " New to dbext 3.00, by default the table lists include the owner
            " name of the table.  This is used when determining how much of
            " whatever has been typed should be replaced as part of the
            " code replacement.
            let g:omni_sql_include_owner = 1
        endif
    endif
endif
" Default type of completion used when <C-X><C-O> is pressed
if !exists('g:omni_sql_default_compl_type')
    let g:omni_sql_default_compl_type = 'table'
endif

" This function is used for the 'omnifunc' option.
" It is called twice by omni and it is responsible
" for returning the completion list of items.
" But it must also determine context of what to complete
" and what to "replace" with the completion.
" The a:base, is replaced directly with what the user
" chooses from the choices.
" The s:prepend provides context for the completion.
function! sqlcomplete#Complete(findstart, base)

    " Default to table name completion
    let compl_type = 'table'
    " Allow maps to specify what type of object completion they want
    if exists('b:sql_compl_type')
        let compl_type = b:sql_compl_type
    endif
    let begindot = 0

    " First pass through this function determines how much of the line should
    " be replaced by whatever is chosen from the completion list
    if a:findstart
        " Locate the start of the item, including "."
        let line     = getline('.')
        let start    = col('.') - 1
        let lastword = -1
        " Check if the first character is a ".", for column completion
        if line[start - 1] == '.'
            let begindot = 1
        endif
        while start > 0
            " Additional code was required to handle objects which
            " can contain spaces like "my table name".
            if line[start - 1] !~ '\(\w\|\.\)'
                " If the previous character is not a period or word character
                break
            " elseif line[start - 1] =~ '\(\w\|\s\+\)'
            "     let start -= 1
            elseif line[start - 1] =~ '\w'
                " If the previous character is word character continue back
                let start -= 1
            elseif line[start - 1] =~ '\.' &&
                        \ compl_type =~ 'column\|table\|view\|procedure'
                " If the previous character is a period and we are completing
                " an object which can be specified with a period like this:
                "     table_name.column_name
                "     owner_name.table_name

                " If lastword has already been set for column completion
                " break from the loop, since we do not also want to pickup
                " a table name if it was also supplied.
                " Unless g:omni_sql_include_owner == 1, then we can
                " include the ownername.
                if lastword != -1 && compl_type == 'column'
                            \ && g:omni_sql_include_owner == 0
                    break
                endif
                " If column completion was specified stop at the "." if
                " a . was specified, otherwise, replace all the way up
                " to the owner name (if included).
                if lastword == -1 && compl_type == 'column' && begindot == 1
                    let lastword = start
                endif
                " If omni_sql_include_owner = 0, do not include the table
                " name as part of the substitution, so break here
                if lastword == -1 &&
                            \ compl_type =~ '\<\(table\|view\|procedure\|column\|column_csv\)\>' &&
                            \ g:omni_sql_include_owner == 0
                    let lastword = start
                    break
                endif
                let start -= 1
            else
                break
            endif
        endwhile

        " Return the column of the last word, which is going to be changed.
        " Remember the text that comes before it in s:prepended.
        if lastword == -1
            let s:prepended = ''
            return start
        endif
        let s:prepended = strpart(line, start, lastword - start)
        return lastword
    endif

    " Second pass through this function will determine what data to put inside
    " of the completion list
    " s:prepended is set by the first pass
    let base = s:prepended . a:base

    " Default the completion list to an empty list
    let compl_list = []

    " Default to table name completion
    let compl_type = g:omni_sql_default_compl_type
    " Allow maps to specify what type of object completion they want
    if exists('b:sql_compl_type')
        let compl_type = b:sql_compl_type
        unlet b:sql_compl_type
    endif

    if compl_type == 'tableReset'
        let compl_type = 'table'
        let base = ''
    endif

    if compl_type == 'table' ||
                \ compl_type == 'procedure' ||
                \ compl_type == 'view'

        " This type of completion relies upon the dbext.vim plugin
        if s:SQLCCheck4dbext() == -1
            return []
        endif

        " Allow the user to override the dbext plugin to specify whether
        " the owner/creator should be included in the list
        if g:loaded_dbext >= 300
            let saveSetting = DB_listOption('dict_show_owner')
            exec 'DBSetOption dict_show_owner='.(g:omni_sql_include_owner==1?'1':'0')
        endif

        let compl_type_uc = substitute(compl_type, '\w\+', '\u&', '')
        " Same call below, no need to do it twice
        " if s:sql_file_{compl_type} == ""
        "     let s:sql_file_{compl_type} = DB_getDictionaryName(compl_type_uc)
        " endif
        let s:sql_file_{compl_type} = DB_getDictionaryName(compl_type_uc)
        if s:sql_file_{compl_type} != ""
            if filereadable(s:sql_file_{compl_type})
                let compl_list =p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       readfile(s:sql_file_{compl_type})
            endif
        endif

        if g:loaded_dbext > 300
            exec 'DBSetOption dict_show_owner='.saveSetting
        endif
    elseif compl_type =~? 'column'

        " This type of completion relies upon the dbext.vim plugin
        if s:SQLCCheck4dbext() == -1
            return []
        endif

        if base == ""
            " The last time we displayed a column list we stored
            " the table name.  If the user selects a column list
            " without a table name of alias present, assume they want
            " the previous column list displayed.
            let base = s:save_prev_table
        endif

        let owner  = ''
        let column = ''

        if base =~ '\.'
            " Check if the owner/creator has been specified
            let owner  = matchstr( base, '^\zs.*\ze\..*\..*' )
            let table  = matchstr( base, '^\(.*\.\)\?\zs.*\ze\..*' )
            let column = matchstr( base, '.*\.\zs.*' )

            if g:omni_sql_include_owner == 1 && owner == '' && table != '' && column != ''
                let owner  = table
                let table  = column
                let column = ''
            endif

            " It is pretty well impossible to determine if the user
            " has entered:
            "    owner.table
            "    table.column_prefix
            " So there are a couple of things we can do to mitigate
            " this issue.
            "    1.  Check if the dbext plugin has the option turned
            "        on to even allow owners
            "    2.  Based on 1, if the user is showing a table list
            "        and the DrillIntoTable (using <Right>) then
            "        this will be owner.table.  In this case, we can
            "        check to see the table.column exists in the
            "        cached table list.  If it does, then we have
            "        determined the user has actually chosen
            "        owner.table, not table.column_prefix.
            let found = -1
            if g:omni_sql_include_owner == 1 && owner == ''
                if filereadable(s:sql_file_table)
                    let tbl_list = readfile(s:sql_file_table)
                    let found    = index( tbl_list, ((table != '')?(table.'.'):'').column)
                endif
            endif
            " If the table.column was found in the table list, we can safely assume
            " the owner was not provided and shift the items appropriately.
            " OR
            " If the user has indicated not to use table owners at all and
            " the base ends in a '.' we know they are not providing a column
            " name, so we can shift the items appropriately.
            " if found != -1 || (g:omni_sql_include_owner == 0 && base !~ '\.$')
            "     let owner  = table
            "     let table  = column
            "     let column = ''
            " endif
        else
            " If no "." was provided and the user asked for
            " column level completion, first attempt the match
            " on any previous column lists.  If the user asked
            " for a list of columns comma separated, continue as usual.
            if compl_type == 'column' && s:save_prev_table != ''
                " The last time we displayed a column list we stored
                " the table name.  If the user selects a column list
                " without a table name of alias present, assume they want
                " the previous column list displayed.
                let table     = s:save_prev_table
                let list_type = ''

                let compl_list  = s:SQLCGetColumns(table, list_type)
                if ! empty(compl_list)
                    " If no column prefix has been provided and the table
                    " name was provided, append it to each of the items
                    " returned.
                    let compl_list = filter(deepcopy(compl_list), 'v:val=~"^'.base.'"' )

                    " If not empty, we have a match on columns
                    " return the list
                    if ! empty(compl_list)
                        return compl_list
                    endif
                endif
            endif
            " Since no columns were found to match the base supplied
            " assume the user is trying to complete the column list
            " for a table (and or an alias to a table).
            let table  = base
        endif

        " Get anything after the . and consider this the table name
        " If an owner has been specified, then we must consider the
        " base to be a partial column name
        " let base  = matchstr( base, '^\(.*\.\)\?\zs.*' )

        if table != ""
            let s:save_prev_table = base
            let list_type         = ''

            if compl_type == 'column_csv'
                " Return one array element, with a comma separated
                " list of values instead of multiple array entries
                " for each column in the table.
                let list_type     = 'csv'
            endif

            " If we are including the OWNER for the objects, then for
            " table completion, if we have it, it should be included
            " as there can be the same table names in a database yet
            " with different owner names.
            if g:omni_sql_include_owner == 1 && owner != '' && table != ''
                let compl_list  = s:SQLCGetColumns(owner.'.'.table, list_type)
            else
                let compl_list  = s:SQLCGetColumns(table, list_type)
            endif

            if column != ''
                " If no column prefix has been provided and the table
                " name was provided, append it to each of the items
                " returned.
                let compl_list = map(compl_list, 'table.".".v:val')
                if owner != ''
                    " If an owner has been provided append it to each of the
                    " items returned.
                    let compl_list = map(compl_list, 'owner.".".v:val')
                endif
            else
                let base = ''
            endif

            if compl_type == 'column_csv'
                " Join the column array into 1 single element array
                " but make the columns column separated
                let compl_list        = [join(compl_list, ', ')]
            endif
        endif
    elseif compl_type == 'resetCache'
        " Reset all cached items
        let s:tbl_name           = []
        let s:tbl_alias          = []
        let s:tbl_cols           = []
        let s:syn_list           = []
        let s:syn_value          = []

        if s:sql_file_table != ""
            if g:loaded_dbext >= 2300
                call DB_DictionaryDelete("table")
            else
                DBCompleteTables!
            endif
        endif
        if s:sql_file_procedure != ""
            if g:loaded_dbext >= 2300
                call DB_DictionaryDelete("procedure")
            else
                DBCompleteProcedures!
            endif
        endif
        if s:sql_file_view != ""
            if g:loaded_dbext >= 2300
                call DB_DictionaryDelete("view")
            else
                DBCompleteViews!
            endif
        endif

        let s:sql_file_table     = ""
        let s:sql_file_procedure = ""
        let s:sql_file_view      = ""

        let msg = "All SQL cached items have been removed."
        call s:SQLCWarningMsg(msg)
        " Leave time for the user to read the error message
        :sleep 2
    else
        let compl_list = s:SQLCGetSyntaxList(compl_type)
    endif

    if base != ''
        " Filter the list based on the first few characters the user entered.
        " Check if the text matches at the beginning
        "         \\(^.base.'\\)
        " or
        " Match to a owner.table or alias.column type match
        "         ^\\(\\w\\+\\.\\)\\?'.base.'\\)
        " or
        " Handle names with spaces "my table name"
        "         "\\(^'.base.'\\|^\\(\\w\\+\\.\\)\\?'.base.'\\)"'
        "
        let expr = 'v:val '.(g:omni_sql_ignorecase==1?'=~?':'=~#').' "\\(^'.base.'\\|^\\(\\w\\+\\.\\)\\?'.base.'\\)"'
        " let expr = 'v:val '.(g:omni_sql_ignorecase==1?'=~?':'=~#').' "\\(^'.base.'\\)"'
        " let expr = 'v:val '.(g:omni_sql_ignorecase==1?'=~?':'=~#').' "\\(^'.base.'\\|\\(\\.\\)\\?'.base.'\\)"'
        " let expr = 'v:val '.(g:omni_sql_ignorecase==1?'=~?':'=~#').' "\\(^'.base.'\\|\\([^.]*\\)\\?'.base.'\\)"'
        let compl_list = filter(deepcopy(compl_list), expr)

        if empty(compl_list) && compl_type == 'table' && base =~ '\.$'
            " It is possible we could be looking for column name completion
            " and the user simply hit C-X C-O to lets try it as well
            " since we had no hits with the tables.
            " If the base ends with a . it is hard to know if we are
            " completing table names or column names.
            let list_type = ''

            let compl_list  = s:SQLCGetColumns(base, list_type)
        endif
    endif

    if exists('b:sql_compl_savefunc') && b:sql_compl_savefunc != ""
        let &omnifunc = b:sql_compl_savefunc
    endif

    if empty(compl_list)
        call s:SQLCWarningMsg( 'Could not find type['.compl_type.'] using prepend[.'.s:prepended.'] base['.a:base.']' )
    endif

    return compl_list
endfunc

function! sqlcomplete#PreCacheSyntax(...)
    let syn_group_arr = []
    let syn_items     = []

    if a:0 > 0
        if type(a:1) != 3
            call s:SQLCWarningMsg("Parameter is not a list. Example:['syntaxGroup1', 'syntaxGroup2']")
            return ''
        endif
        let syn_group_arr = a:1
    else
        let syn_group_arr = g:omni_sql_precache_syntax_groups
    endif
    " For each group specified in the list, precache all
    " the syntax items.
    if !empty(syn_group_arr)
        for group_name in syn_group_arr
            let syn_items = extend( syn_items, s:SQLCGetSyntaxList(group_name) )
        endfor
    endif

    return syn_items
endfunction

function! sqlcomplete#ResetCacheSyntax(...)
    let syn_group_arr = []

    if a:0 > 0
        if type(a:1) != 3
            call s:SQLCWarningMsg("Parameter is not a list. Example:['syntaxGroup1', 'syntaxGroup2']")
            return ''
        endif
        let syn_group_arr = a:1
    else
        let syn_group_arr = g:omni_sql_precache_syntax_groups
    endif
    " For each group specified in the list, precache all
    " the syntax items.
    if !empty(syn_group_arr)
        for group_name in syn_group_arr
            let list_idx = index(s:syn_list, group_name, 0, &ignorecase)
            if list_idx > -1
                " Remove from list of groups
                call remove( s:syn_list, list_idx )
                " Remove from list of keywords
                call remove( s:syn_value, list_idx )
            endif
        endfor
    endif
endfunction

function! sqlcomplete#Map(type)
    " Tell the SQL plugin what you want to complete
    let b:sql_compl_type=a:type
    " Record previous omnifunc, if the SQL completion
    " is being used in conjunction with other filetype
    " completion plugins
    if &omnifunc != "" && &omnifunc != 'sqlcomplete#Complete'
        " Record the previous omnifunc, the plugin
        " will automatically set this back so that it
        " does not interfere with other ftplugins settings
        let b:sql_compl_savefunc=&omnifunc
    endif
    " Set the OMNI func for the SQL completion plugin
    let &omnifunc='sqlcomplete#Complete'
endfunction

function! sqlcomplete#DrillIntoTable()
    " If the omni popup window is visible
    if pumvisible()
        call sqlcomplete#Map('column')
        " C-Y, makes the currently highlighted entry active
        " and trigger the omni popup to be redisplayed
        call feedkeys("\<C-Y>\<C-X>\<C-O>", 'n')
    else
	" If the popup is not visible, simple perform the normal
	" key behaviour.
	" Must use exec since the key must be preceded by "\"
	" or feedkeys will simply push each character of the string
	" rather than the "key press".
        exec 'call feedkeys("\'.g:ftplugin_sql_omni_key_right.'", "n")'
    endif
    return ""
endfunction

function! sqlcomplete#DrillOutOfColumns()
    " If the omni popup window is visible
    if pumvisible()
        call sqlcomplete#Map('tableReset')
        " Trigger the omni popup to be redisplayed
        call feedkeys("\<C-X>\<C-O>")
    else
	" If the popup is not visible, simple perform the normal
	" key behaviour.
	" Must use exec since the key must be preceded by "\"
	" or feedkeys will simply push each character of the string
	" rather than the "key press".
        exec 'call feedkeys("\'.g:ftplugin_sql_omni_key_left.'", "n")'
    endif
    return ""
endfunction

function! s:SQLCWarningMsg(msg)
    echohl WarningMsg
    echomsg 'SQLComplete:'.a:msg
    echohl None
endfunction

function! s:SQLCErrorMsg(msg)
    echohl ErrorMsg
    echomsg 'SQLComplete:'.a:msg
    echohl None
endfunction

function! s:SQLCGetSyntaxList(syn_group)
    let syn_group  = a:syn_group
    let compl_list = []

    " Check if we have already cached the syntax list
    let list_idx = index(s:syn_list, syn_group, 0, &ignorecase)
    if list_idx > -1
        " Return previously cached value
        let compl_list = s:syn_value[list_idx]
    else
        let s:save_inc = g:omni_syntax_group_include_sql
        let s:save_exc = g:omni_syntax_group_exclude_sql
        let g:omni_syntax_group_include_sql = ''
        let g:omni_syntax_group_exclude_sql = ''

        " Request the syntax list items from the
        " syntax completion plugin
        if syn_group == 'syntax'
            " Handle this special case.  This allows the user
            " to indicate they want all the syntax items available,
            " so do not specify a specific include list.
            let syn_value                       = syntaxcomplete#OmniSyntaxList()
        else
            " The user has specified a specific syntax group
            let g:omni_syntax_group_include_sql = syn_group
            let syn_value                       = syntaxcomplete#OmniSyntaxList(syn_group)
        endif
        let g:omni_syntax_group_include_sql = s:save_inc
        let g:omni_syntax_group_exclude_sql = s:save_exc
        " Cache these values for later use
        let s:syn_list  = add( s:syn_list,  syn_group )
        let s:syn_value = add( s:syn_value, syn_value )
        let compl_list  = syn_value
    endif

    return compl_list
endfunction

function! s:SQLCCheck4dbext()
    if !exists('g:loaded_dbext')
        let msg = "The dbext plugin must be loaded for dynamic SQL completion"
        call s:SQLCErrorMsg(msg)
        " Leave time for the user to read the error message
        :sleep 2
        return -1
    elseif g:loaded_dbext < 600
        let msg = "The dbext plugin must be at least version 5.30 " .
                    \ " for dynamic SQL completion"
        call s:SQLCErrorMsg(msg)
        " Leave time for the user to read the error message
        :sleep 2
        return -1
    endif
    return 1
endfunction

function! s:SQLCAddAlias(table_name, table_alias, cols)
    " Strip off the owner if included
    let table_name  = matchstr(a:table_name, '\%(.\{-}\.\)\?\zs\(.*\)' )
    let table_alias = a:table_alias
    let cols        = a:cols

    if g:omni_sql_use_tbl_alias != 'n'
        if table_alias == ''
            if 'da' =~? g:omni_sql_use_tbl_alias
                if table_name =~ '_'
                    " Treat _ as separators since people often use these
                    " for word separators
                    let save_keyword = &iskeyword
                    setlocal iskeyword-=_

                    " Get the first letter of each word
                    " [[:alpha:]] is used instead of \w
                    " to catch extended accented characters
                    "
                    let table_alias = substitute(
                                \ table_name,
                                \ '\<[[:alpha:]]\+\>_\?',
                                \ '\=strpart(submatch(0), 0, 1)',
                                \ 'g'
                                \ )
                    " Restore original value
                    let &iskeyword = save_keyword
                elseif table_name =~ '\u\U'
                    let table_alias = substitute(
                                \ table_name, '\(\u\)\U*', '\1', 'g')
                else
                    let table_alias = strpart(table_name, 0, 1)
                endif
            endif
        endif
        if table_alias != ''
            " Following a word character, make sure there is a . and no spaces
            let table_alias = substitute(table_alias, '\w\zs\.\?\s*$', '.', '')
            if 'a' =~? g:omni_sql_use_tbl_alias && a:table_alias == ''
                let table_alias = inputdialog("Enter table alias:", table_alias)
            endif
        endif
        if table_alias != ''
            let cols = substitute(cols, '\<\w', table_alias.'&', 'g')
        endif
    endif

    return cols
endfunction

function! s:SQLCGetObjectOwner(object)
    " The owner regex matches a word at the start of the string which is
    " followed by a dot, but doesn't include the dot in the result.
    " ^           - from beginning of line
    " \("\|\[\)\? - ignore any quotes
    " \zs         - start the match now
    " .\{-}       - get owner name
    " \ze         - end the match
    " \("\|\[\)\? - ignore any quotes
    " \.          - must by followed by a .
    " let owner = matchstr( a:object, '^\s*\zs.*\ze\.' )
    let owner = matchstr( a:object, '^\("\|\[\)\?\zs\.\{-}\ze\("\|\]\)\?\.' )
    return owner
endfunction

function! s:SQLCGetColumns(table_name, list_type)
    if a:table_name =~ '\.'
        " Check if the owner/creator has been specified
        let owner  = matchstr( a:table_name, '^\zs.*\ze\..*\..*' )
        let table  = matchstr( a:table_name, '^\(.*\.\)\?\zs.*\ze\..*' )
        let column = matchstr( a:table_name, '.*\.\zs.*' )

        if g:omni_sql_include_owner == 1 && owner == '' && table != '' && column != ''
            let owner  = table
            let table  = column
            let column = ''
        endif
    else
        let owner  = ''
        let table  = matchstr(a:table_name, '^["\[\]a-zA-Z0-9_ ]\+\ze\.\?')
        let column = ''
    endif

    " Check if the table name was provided as part of the column name
    " let table_name   = matchstr(a:table_name, '^["\[\]a-zA-Z0-9_ ]\+\ze\.\?')
    let table_name   = table
    let table_cols   = []
    let table_alias  = ''
    let move_to_top  = 1

    let table_name   = substitute(table_name, '\s*\(.\{-}\)\s*$', '\1', 'g')

    " If the table name was given as:
    "     where c.
    let table_name   = substitute(table_name, '^\c\(WHERE\|AND\|OR\)\s\+', '', '')
    if g:loaded_dbext >= 300
        let saveSettingAlias = DB_listOption('use_tbl_alias')
        exec 'DBSetOption use_tbl_alias=n'
    endif

    let table_name_stripped = substitute(table_name, '["\[\]]*', '', 'g')

    " Check if we have already cached the column list for this table
    " by its name
    let list_idx = index(s:tbl_name, table_name_stripped, 0, &ignorecase)
    if list_idx > -1
        let table_cols = split(s:tbl_cols[list_idx], '\n')
    else
        " Check if we have already cached the column list for this table
        " by its alias, assuming the table_name provided was actually
        " the alias for the table instead
        "     select *
        "       from area a
        "      where a.
        let list_idx = index(s:tbl_alias, table_name_stripped, 0, &ignorecase)
        if list_idx > -1
            let table_alias = table_name_stripped
            let table_name  = s:tbl_name[list_idx]
            let table_cols  = split(s:tbl_cols[list_idx], '\n')
        endif
    endif

    " If we have not found a cached copy of the table
    " And the table ends in a "." or we are looking for a column list
    " if list_idx == -1 && (a:table_name =~ '\.' || b:sql_compl_type =~ 'column')
    " if list_idx == -1 && (a:table_name =~ '\.' || a:list_type =~ 'csv')
    if list_idx == -1
         let saveY      = @y
         let saveSearch = @/
         let saveWScan  = &wrapscan
         let curline    = line(".")
         let curcol     = col(".")

         " Do not let searches wrap
         setlocal nowrapscan
         " If . was entered, look at the word just before the .
         " We are looking for something like this:
         "    select *
         "      from customer c
         "     where c.
         " So when . is pressed, we need to find 'c'
         "

         " Search backwards to the beginning of the statement
         " and do NOT wrap
         " exec 'silent! normal! v?\<\(select\|update\|delete\|;\)\>'."\n".'"yy'
         exec 'silent! normal! ?\<\c\(select\|update\|delete\|;\)\>'."\n"

         " Start characterwise visual mode
         " Advance right one character
         " Search forward until one of the following:
         "     1.  Another select/update/delete statement
         "     2.  A ; at the end of a line (the delimiter)
         "     3.  The end of the file (in case no delimiter)
         " Yank the visually selected text into the "y register.
         exec 'silent! normal! vl/\c\(\<select\>\|\<update\>\|\<delete\>\|;\s*$\|\%$\)'."\n".'"yy'

         let query = @y
         let query = substitute(query, "\n", ' ', 'g')
         let found = 0

         " if query =~? '^\c\(select\)'
         if query =~? '^\(select\|update\|delete\)'
             let found = 1
             "  \(\(\<\w\+\>\)\.\)\?   -
             " '\c\(from\|join\|,\).\{-}'  - Starting at the from clause (case insensitive)
             " '\zs\(\(\<\w\+\>\)\.\)\?' - Get the owner name (optional)
             " '\<\w\+\>\ze' - Get the table name
             " '\s\+\<'.table_name.'\>' - Followed by the alias
             " '\s*\.\@!.*'  - Cannot be followed by a .
             " '\(\<where\>\|$\)' - Must be followed by a WHERE clause
             " '.*'  - Exclude the rest of the line in the match
             " let table_name_new = matchstr(@y,
             "             \ '\c\(from\|join\|,\).\{-}'.
             "             \ '\zs\(\("\|\[\)\?.\{-}\("\|\]\)\.\)\?'.
             "             \ '\("\|\[\)\?.\{-}\("\|\]\)\?\ze'.
             "             \ '\s\+\%(as\s\+\)\?\<'.
             "             \ matchstr(table_name, '.\{-}\ze\.\?$').
             "             \ '\>'.
             "             \ '\s*\.\@!.*'.
             "             \ '\(\<where\>\|$\)'.
             "             \ '.*'
             "             \ )
             "
             "
             " ''\c\(\<from\>\|\<join\>\|,\)\s*'  - Starting at the from clause (case insensitive)
             " '\zs\(\("\|\[\)\?\w\+\("\|\]\)\?\.\)\?' - Get the owner name (optional)
             " '\("\|\[\)\?\w\+\("\|\]\)\?\ze' - Get the table name
             " '\s\+\%(as\s\+\)\?\<'.matchstr(table_name, '.\{-}\ze\.\?$').'\>' - Followed by the alias
             " '\s*\.\@!.*'  - Cannot be followed by a .
             " '\(\<where\>\|$\)' - Must be followed by a WHERE clause
             " '.*'  - Exclude the rest of the line in the match
             let table_name_new = matchstr(@y,
                         \ '\c\(\<from\>\|\<join\>\|,\)\s*'.
                         \ '\zs\(\("\|\[\)\?\w\+\("\|\]\)\?\.\)\?'.
                         \ '\("\|\[\)\?\w\+\("\|\]\)\?\ze'.
                         \ '\s\+\%(as\s\+\)\?\<'.
                         \ matchstr(table_name, '.\{-}\ze\.\?$').
                         \ '\>'.
                         \ '\s*\.\@!.*'.
                         \ '\(\<where\>\|$\)'.
                         \ '.*'
                         \ )

             if table_name_new != ''
                 let table_alias = table_name
                 if g:omni_sql_include_owner == 1
                    let table_name  = matchstr( table_name_new, '^\zs\(.\{-}\.\)\?\(.\{-}\.\)\?.*\ze' )
                 else
                     " let table_name  = matchstr( table_name_new, '^\(.*\.\)\?\zs.*\ze' )
                    let table_name  = matchstr( table_name_new, '^\(.\{-}\.\)\?\zs\(.\{-}\.\)\?.*\ze' )
                 endif

                 let list_idx = index(s:tbl_name, table_name, 0, &ignorecase)
                 if list_idx > -1
                     let table_cols  = split(s:tbl_cols[list_idx])
                     let s:tbl_name[list_idx]  = table_name
                     let s:tbl_alias[list_idx] = table_alias
                 else
                     let list_idx = index(s:tbl_alias, table_name, 0, &ignorecase)
                     if list_idx > -1
                         let table_cols = split(s:tbl_cols[list_idx])
                         let s:tbl_name[list_idx]  = table_name
                         let s:tbl_alias[list_idx] = table_alias
                     endif
                 endif

             endif
         else
             " Simply assume it is a table name provided with a . on the end
             let found = 1
         endif

         let @y        = saveY
         let @/        = saveSearch
         let &wrapscan = saveWScan

         " Return to previous location
         call cursor(curline, curcol)

         if found == 0
             if g:loaded_dbext > 300
                 exec 'DBSetOption use_tbl_alias='.saveSettingAlias
             endif

             " Not a SQL statement, do not display a list
             return []
         endif
    endif

    if empty(table_cols)
        " Specify silent mode, no messages to the user (tbl, 1)
        " Specify do not comma separate (tbl, 1, 1)
        " let table_cols_str = DB_getListColumn(table_name, 1, 1)
        let table_cols_str = DB_getListColumn((owner!=''?owner.'.':'').table_name, 1, 1)

        if table_cols_str != ""
            let s:tbl_name  = add( s:tbl_name,  table_name )
            let s:tbl_alias = add( s:tbl_alias, table_alias )
            let s:tbl_cols  = add( s:tbl_cols,  table_cols_str )
            let table_cols  = split(table_cols_str, '\n')
        endif

    endif

    if g:loaded_dbext > 300
        exec 'DBSetOption use_tbl_alias='.saveSettingAlias
    endif

    " If the user has asked for a comma separate list of column
    " values, ask the user if they want to prepend each column
    " with a tablename alias.
    if a:list_type == 'csv' && !empty(table_cols)
        let cols       = join(table_cols, ', ')
        let cols       = s:SQLCAddAlias(table_name, table_alias, cols)
        let table_cols = [cols]
    endif

    return table_cols
endfunction
"  Restore:
let &cpo= s:keepcpo
unlet s:keepcpo
" vim: ts=4 fdm=marker
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             " Vim completion script
" Language:    All languages, uses existing syntax highlighting rules
" Maintainer:  David Fishburn <dfishburn dot vim at gmail dot com>
" Version:     15.0
" Last Change: 2021 Apr 27
" Usage:       For detailed help, ":help ft-syntax-omni"

" History
"
" Version 15.0
"   - SyntaxComplete ignored all buffer specific overrides, always used global
"     https://github.com/vim/vim/issues/8153
"
" Version 14.0
"   - Fixed issue with single quotes and is_keyword
"     https://github.com/vim/vim/issues/7463
"
" Version 13.0
"   - Extended the option omni_syntax_group_include_{filetype}
"     to accept a comma separated list of regex's rather than
"     string.  For example, for the javascript filetype you could
"     use:
"        let g:omni_syntax_group_include_javascript = 'javascript\w\+,jquery\w\+'
"   - Some syntax files (perl.vim) use the match // syntax as a mechanism
"     to identify keywords.  This update attempts to parse the
"     match syntax and pull out syntax items which are at least
"     3 words or more.
"
" Version 12.0
"   - It is possible to have '-' as part of iskeyword, when
"     checking for character ranges, tighten up the regex.
"     E688: More targets than List items.
"
" Version 11.0
"   - Corrected which characters required escaping during
"     substitution calls.
"
" Version 10.0
"   - Cycle through all the character ranges specified in the
"     iskeyword option and build a list of valid word separators.
"     Prior to this change, only actual characters were used,
"     where for example ASCII "45" == "-".  If "45" were used
"     in iskeyword the hyphen would not be picked up.
"     This introduces a new option, since the character ranges
"     specified could be multibyte:
"         let g:omni_syntax_use_single_byte = 1
"   - This by default will only allow single byte ASCII
"     characters to be added and an additional check to ensure
"     the character is printable (see documentation for isprint).
"
" Version 9.0
"   - Add the check for cpo.
"
" Version 8.0
"   - Updated SyntaxCSyntaxGroupItems()
"         - Some additional syntax items were also allowed
"           on nextgroup= lines which were ignored by default.
"           Now these lines are processed independently.
"
" Version 7.0
"   - Updated syntaxcomplete#OmniSyntaxList()
"         - Looking up the syntax groups defined from a syntax file
"           looked for only 1 format of {filetype}GroupName, but some
"           syntax writers use this format as well:
"               {b:current_syntax}GroupName
"   -       OmniSyntaxList() will now check for both if the first
"           method does not find a match.
"
" Version 6.0
"   - Added syntaxcomplete#OmniSyntaxList()
"         - Allows other plugins to use this for their own
"           purposes.
"         - It will return a List of all syntax items for the
"           syntax group name passed in.
"         - XPTemplate for SQL will use this function via the
"           sqlcomplete plugin to populate a Choose box.
"
" Version 5.0
"   - Updated SyntaxCSyntaxGroupItems()
"         - When processing a list of syntax groups, the final group
"           was missed in function SyntaxCSyntaxGroupItems.
"
" Set completion with CTRL-X CTRL-O to autoloaded function.
" This check is in place in case this script is
" sourced directly instead of using the autoload feature.
if exists('+omnifunc')
    " Do not set the option if already set since this
    " results in an E117 warning.
    if &omnifunc == ""
        setlocal omnifunc=syntaxcomplete#Complete
    endif
endif

if exists('g:loaded_syntax_completion')
    finish
endif
let g:loaded_syntax_completion = 150

" Turn on support for line continuations when creating the script
let s:cpo_save = &cpo
set cpo&vim

" Set ignorecase to the ftplugin standard
" This is the default setting, but if you define a buffer local
" variable you can override this on a per filetype.
if !exists('g:omni_syntax_ignorecase')
    let g:omni_syntax_ignorecase = &ignorecase
endif

" Indicates whether we should use the iskeyword option to determine
" how to split words.
" This is the default setting, but if you define a buffer local
" variable you can override this on a per filetype.
if !exists('g:omni_syntax_use_iskeyword')
    let g:omni_syntax_use_iskeyword = 1
endif

" When using iskeyword, this setting controls whether the characters
" should be limited to single byte characters.
if !exists('g:omni_syntax_use_single_byte')
    let g:omni_syntax_use_single_byte = 1
endif

" When using iskeyword, this setting controls whether the characters
" should be limited to single byte characters.
if !exists('g:omni_syntax_use_iskeyword_numeric')
    let g:omni_syntax_use_iskeyword_numeric = 1
endif

" Only display items in the completion window that are at least
" this many characters in length.
" This is the default setting, but if you define a buffer local
" variable you can override this on a per filetype.
if !exists('g:omni_syntax_minimum_length')
    let g:omni_syntax_minimum_length = 0
endif

" This script will build a completion list based on the syntax
" elements defined by the files in $VIMRUNTIME/syntax.
" let s:syn_remove_words = 'match,matchgroup=,contains,'.
let s:syn_remove_words = 'matchgroup=,contains,'.
            \ 'links to,start=,end='
            " \ 'links to,start=,end=,nextgroup='

let s:cache_name = []
let s:cache_list = []
let s:prepended  = ''

" This function is used for the 'omnifunc' option.
function! syntaxcomplete#Complete(findstart, base)

    " Allow user to override ignorecase per buffer 
    let l:omni_syntax_ignorecase = g:omni_syntax_ignorecase
    if exists('b:omni_syntax_ignorecase')
        let l:omni_syntax_ignorecase = b:omni_syntax_ignorecase
    endif

    if a:findstart
        " Locate the start of the item, including "."
        let line = getline('.')
        let start = col('.') - 1
        let lastword = -1
        while start > 0
            " if line[start - 1] =~ '\S'
            "     let start -= 1
            " elseif line[start - 1] =~ '\.'
            if line[start - 1] =~ '\k'
                let start -= 1
                let lastword = a:findstart
            else
                break
            endif
        endwhile

        " Return the column of the last word, which is going to be changed.
        " Remember the text that comes before it in s:prepended.
        if lastword == -1
            let s:prepended = ''
            return start
        endif
        let s:prepended = strpart(line, start, (col('.') - 1) - start)
        return start
    endif

    " let base = s:prepended . a:base
    let base = substitute(s:prepended, "'", "''", 'g')

    let filetype = substitute(&filetype, '\.', '_', 'g')
    let list_idx = index(s:cache_name, filetype, 0, &ignorecase)
    if list_idx > -1
        let compl_list = s:cache_list[list_idx]
    else
        let compl_list   = OmniSyntaxList()
        let s:cache_name = add( s:cache_name,  filetype )
        let s:cache_list = add( s:cache_list,  compl_list )
    endif

    " Return list of matches.

    if base != ''
        " let compstr    = join(compl_list, ' ')
        " let expr       = (l:omni_syntax_ignorecase==0?'\C':'').'\<\%('.base.'\)\@!\w\+\s*'
        " let compstr    = substitute(compstr, expr, '', 'g')
        " let compl_list = split(compstr, '\s\+')

        " Filter the list based on the first few characters the user
        " entered
        let expr = 'v:val '.(l:omni_syntax_ignorecase==1?'=~?':'=~#')." '^".escape(base, '\\/.*$^~[]').".*'"
        let compl_list = filter(deepcopy(compl_list), expr)
    endif

    return compl_list
endfunc

function! syntaxcomplete#OmniSyntaxList(...)
    if a:0 > 0
        let parms = []
        if 3 == type(a:1)
            let parms = a:1
        elseif 1 == type(a:1)
            let parms = split(a:1, ',')
        endif
        return OmniSyntaxList( parms )
    else
        return OmniSyntaxList()
    endif
endfunc

function! syntaxcomplete#OmniSyntaxClearCache()
    let s:cache_name = []
    let s:cache_list = []
endfunction

" To retrieve all syntax items regardless of syntax group:
"     echo OmniSyntaxList( [] )
" 
" To retrieve only the syntax items for the sqlOperator syntax group:
"     echo OmniSyntaxList( ['sqlOperator'] )
" 
" To retrieve all syntax items for both the sqlOperator and sqlType groups:
"     echo OmniSyntaxList( ['sqlOperator', 'sqlType'] )
" 
" A regular expression can also be used:
"     echo OmniSyntaxList( ['sql\w\+'] )
" 
" From within a plugin, you would typically assign the output to a List: >
"     let myKeywords = []
"     let myKeywords = OmniSyntaxList( ['sqlKeyword'] )
function! OmniSyntaxList(...)
    let list_parms = []
    if a:0 > 0
        if 3 == type(a:1)
            let list_parms = a:1
        elseif 1 == type(a:1)
            let list_parms = split(a:1, ',')
        endif
    endif

    " Default to returning a dictionary, if use_dictionary is set to 0
    " a list will be returned.
    " let use_dictionary = 1
    " if a:0 > 0 && a:1 != ''
    "     let use_dictionary = a:1
    " endif

    let saveL = @l
    let filetype = substitute(&filetype, '\.', '_', 'g')

    if empty(list_parms)
        " Allow user to override per buffer 
        if exists('g:omni_syntax_group_include_'.filetype)
            let l:omni_syntax_group_include_{filetype} = g:omni_syntax_group_include_{filetype}
        endif
        if exists('b:omni_syntax_group_include_'.filetype)
            let l:omni_syntax_group_include_{filetype} = b:omni_syntax_group_include_{filetype}
        endif

        " Default the include group to include the requested syntax group
        let syntax_group_include_{filetype} = ''
        " Check if there are any overrides specified for this filetype
        if exists('l:omni_syntax_group_include_'.filetype)
            let syntax_group_include_{filetype} =
                        \ substitute( l:omni_syntax_group_include_{filetype},'\s\+','','g')
            let list_parms = split(l:omni_syntax_group_include_{filetype}, ',')
            if syntax_group_include_{filetype} =~ '\w'
                let syntax_group_include_{filetype} =
                            \ substitute( syntax_group_include_{filetype},
                            \ '\s*,\s*', '\\|', 'g'
                            \ )
            endif
        endif
    else
        " A specific list was provided, use it
    endif

    " Loop through all the syntax groupnames, and build a
    " syntax file which contains these names.  This can
    " work generically for any filetype that does not already
    " have a plugin defined.
    " This ASSUMES the syntax groupname BEGINS with the name
    " of the filetype.  From my casual viewing of the vim7\syntax
    " directory this is true for almost all syntax definitions.
    " As an example, the SQL syntax groups have this pattern:
    "     sqlType
    "     sqlOperators
    "     sqlKeyword ...
    if !empty(list_parms) && empty(substitute(join(list_parms), '[a-zA-Z ]', '', 'g'))
        " If list_parms only includes word characters, use it to limit
        " the syntax elements.
        " If using regex syntax list will fail to find those items, so
        " simply grab the who syntax list.
        redir @l
        silent! exec 'syntax list '.join(list_parms)
        redir END
    else
        redir @l
        silent! exec 'syntax list'
        redir END
    endif

    let syntax_full = "\n".@l
    let @l = saveL

    if syntax_full =~ 'E28'
                \ || syntax_full =~ 'E411'
                \ || syntax_full =~ 'E415'
                \ || syntax_full =~ 'No Syntax items'
        return []
    endif

    let filetype = substitute(&filetype, '\.', '_', 'g')

    let list_exclude_groups = []
    if a:0 > 0
        " Do nothing since we have specific a specific list of groups
    else
        " Default the exclude group to nothing
        let syntax_group_exclude_{filetype} = ''

        " Allow user to override per buffer 
        if exists('g:omni_syntax_group_exclude_'.filetype)
            let l:omni_syntax_group_exclude_{filetype} = g:omni_syntax_group_exclude_{filetype}
        endif
        if exists('b:omni_syntax_group_exclude_'.filetype)
       p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   let l:omni_syntax_group_exclude_{filetype} = b:omni_syntax_group_exclude_{filetype}
        endif

        " Check if there are any overrides specified for this filetype
        if exists('l:omni_syntax_group_exclude_'.filetype)
            let syntax_group_exclude_{filetype} =
                        \ substitute( l:omni_syntax_group_exclude_{filetype},'\s\+','','g')
            let list_exclude_groups = split(l:omni_syntax_group_exclude_{filetype}, ',')
            if syntax_group_exclude_{filetype} =~ '\w'
                let syntax_group_exclude_{filetype} =
                            \ substitute( syntax_group_exclude_{filetype},
                            \ '\s*,\s*', '\\|', 'g'
                            \ )
            endif
        endif
    endif

    if empty(list_parms)
        let list_parms = [&filetype.'\w\+']
    endif

    let syn_list = ''
    let index    = 0
    for group_regex in list_parms
        " Sometimes filetypes can be composite names, like c.doxygen
        " Loop through each individual part looking for the syntax
        " items specific to each individual filetype.
        " let ftindex  = 0
        " let ftindex  = match(syntax_full, group_regex, ftindex)

        " while ftindex > -1
            " let ft_part_name = matchstr( syntax_full, '\w\+', ftindex )

            " Syntax rules can contain items for more than just the current
            " filetype.  They can contain additional items added by the user
            " via autocmds or their vimrc.
            " Some syntax files can be combined (html, php, jsp).
            " We want only items that begin with the filetype we are interested in.
            let next_group_regex = '\n' .
                        \ '\zs'.group_regex.'\ze'.
                        \ '\s\+xxx\s\+'
            let index    = match(syntax_full, next_group_regex, index)

            " For the matched group name, strip off any of the regex special
            " characters and see if we get a match with the current syntax
            if index == -1 && exists('b:current_syntax') && substitute(group_regex, '[^a-zA-Z ]\+.*', '', 'g') !~ '^'.b:current_syntax
                " There appears to be two standards when writing syntax files.
                " Either items begin as:
                "     syn keyword {filetype}Keyword         values ...
                "     let b:current_syntax = "sql"
                "     let b:current_syntax = "sqlanywhere"
                " Or
                "     syn keyword {syntax_filename}Keyword  values ...
                "     let b:current_syntax = "mysql"
                " So, we will make the format of finding the syntax group names
                " a bit more flexible and look for both if the first fails to
                " find a match.
                let next_group_regex = '\n' .
                            \ '\zs'.b:current_syntax.'\w\+\ze'.
                            \ '\s\+xxx\s\+'
                let index    = 0
                let index    = match(syntax_full, next_group_regex, index)
            endif

            while index > -1
                let group_name = matchstr( syntax_full, '\w\+', index )

                let get_syn_list = 1
                for exclude_group_name in list_exclude_groups
                    if '\<'.exclude_group_name.'\>' =~ '\<'.group_name.'\>'
                        let get_syn_list = 0
                    endif
                endfor

                " This code is no longer needed in version 6.0 since we have
                " augmented the syntax list command to only retrieve the syntax
                " groups we are interested in.
                "
                " if get_syn_list == 1
                "     if syntax_group_include_{filetype} != ''
                "         if '\<'.syntax_group_include_{filetype}.'\>' !~ '\<'.group_name.'\>'
                "             let get_syn_list = 0
                "         endif
                "     endif
                " endif

                if get_syn_list == 1
                    " Pass in the full syntax listing, plus the group name we
                    " are interested in.
                    let extra_syn_list = s:SyntaxCSyntaxGroupItems(group_name, syntax_full)
                    let syn_list = syn_list . extra_syn_list . "\n"
                endif

                let index = index + strlen(group_name)
                let index = match(syntax_full, next_group_regex, index)
            endwhile

            " let ftindex  = ftindex + len(ft_part_name)
            " let ftindex  = match( syntax_full, group_regex, ftindex )
        " endwhile
    endfor

"   " Sometimes filetypes can be composite names, like c.doxygen
"   " Loop through each individual part looking for the syntax
"   " items specific to each individual filetype.
"   let syn_list = ''
"   let ftindex  = 0
"   let ftindex  = match(&filetype, '\w\+', ftindex)

"   while ftindex > -1
"       let ft_part_name = matchstr( &filetype, '\w\+', ftindex )

"       " Syntax rules can contain items for more than just the current
"       " filetype.  They can contain additional items added by the user
"       " via autocmds or their vimrc.
"       " Some syntax files can be combined (html, php, jsp).
"       " We want only items that begin with the filetype we are interested in.
"       let next_group_regex = '\n' .
"                   \ '\zs'.ft_part_name.'\w\+\ze'.
"                   \ '\s\+xxx\s\+'
"       let index    = 0
"       let index    = match(syntax_full, next_group_regex, index)

"       if index == -1 && exists('b:current_syntax') && ft_part_name != b:current_syntax
"           " There appears to be two standards when writing syntax files.
"           " Either items begin as:
"           "     syn keyword {filetype}Keyword         values ...
"           "     let b:current_syntax = "sql"
"           "     let b:current_syntax = "sqlanywhere"
"           " Or
"           "     syn keyword {syntax_filename}Keyword  values ...
"           "     let b:current_syntax = "mysql"
"           " So, we will make the format of finding the syntax group names
"           " a bit more flexible and look for both if the first fails to
"           " find a match.
"           let next_group_regex = '\n' .
"                       \ '\zs'.b:current_syntax.'\w\+\ze'.
"                       \ '\s\+xxx\s\+'
"           let index    = 0
"           let index    = match(syntax_full, next_group_regex, index)
"       endif

"       while index > -1
"           let group_name = matchstr( syntax_full, '\w\+', index )

"           let get_syn_list = 1
"           for exclude_group_name in list_exclude_groups
"               if '\<'.exclude_group_name.'\>' =~ '\<'.group_name.'\>'
"                   let get_syn_list = 0
"               endif
"           endfor

"           " This code is no longer needed in version 6.0 since we have
"           " augmented the syntax list command to only retrieve the syntax
"           " groups we are interested in.
"           "
"           " if get_syn_list == 1
"           "     if syntax_group_include_{filetype} != ''
"           "         if '\<'.syntax_group_include_{filetype}.'\>' !~ '\<'.group_name.'\>'
"           "             let get_syn_list = 0
"           "         endif
"           "     endif
"           " endif

"           if get_syn_list == 1
"               " Pass in the full syntax listing, plus the group name we
"               " are interested in.
"               let extra_syn_list = s:SyntaxCSyntaxGroupItems(group_name, syntax_full)
"               let syn_list = syn_list . extra_syn_list . "\n"
"           endif

"           let index = index + strlen(group_name)
"           let index = match(syntax_full, next_group_regex, index)
"       endwhile

"       let ftindex  = ftindex + len(ft_part_name)
"       let ftindex  = match( &filetype, '\w\+', ftindex )
"   endwhile

    " Convert the string to a List and sort it.
    let compl_list = sort(split(syn_list))

    if &filetype == 'vim'
        let short_compl_list = []
        for i in range(len(compl_list))
            if i == len(compl_list)-1
                let next = i
            else
                let next = i + 1
            endif
            if  compl_list[next] !~ '^'.compl_list[i].'.$'
                let short_compl_list += [compl_list[i]]
            endif
        endfor

        return short_compl_list
    else
        return compl_list
    endif
endfunction

function! s:SyntaxCSyntaxGroupItems( group_name, syntax_full )

    " Allow user to override iskeyword per buffer 
    let l:omni_syntax_use_iskeyword = g:omni_syntax_use_iskeyword
    if exists('b:omni_syntax_use_iskeyword')
        let l:omni_syntax_use_iskeyword = b:omni_syntax_use_iskeyword
    endif

    " Allow user to override iskeyword_numeric per buffer 
    let l:omni_syntax_use_iskeyword_numeric = g:omni_syntax_use_iskeyword_numeric
    if exists('b:omni_syntax_use_iskeyword_numeric')
        let l:omni_syntax_use_iskeyword_numeric = b:omni_syntax_use_iskeyword_numeric
    endif

    " Allow user to override iskeyword_numeric per buffer 
    let l:omni_syntax_use_single_byte = g:omni_syntax_use_single_byte
    if exists('b:omni_syntax_use_single_byte')
        let l:omni_syntax_use_single_byte = b:omni_syntax_use_single_byte
    endif

    " Allow user to override minimum_length per buffer 
    let l:omni_syntax_minimum_length = g:omni_syntax_minimum_length
    if exists('b:omni_syntax_minimum_length')
        let l:omni_syntax_minimum_length = b:omni_syntax_minimum_length
    endif

    let syn_list = ""

    " From the full syntax listing, strip out the portion for the
    " request group.
    " Query:
    "     \n           - must begin with a newline
    "     a:group_name - the group name we are interested in
    "     \s\+xxx\s\+  - group names are always followed by xxx
    "     \zs          - start the match
    "     .\{-}        - everything ...
    "     \ze          - end the match
    "     \(           - start a group or 2 potential matches
    "     \n\w         - at the first newline starting with a character
    "     \|           - 2nd potential match
    "     \%$          - matches end of the file or string
    "     \)           - end a group
    let syntax_group = matchstr(a:syntax_full,
                \ "\n".a:group_name.'\s\+xxx\s\+\zs.\{-}\ze\(\n\w\|\%$\)'
                \ )

    if syntax_group != ""
        " let syn_list = substitute( @l, '^.*xxx\s*\%(contained\s*\)\?', "", '' )
        " let syn_list = substitute( @l, '^.*xxx\s*', "", '' )

        " We only want the words for the lines beginning with
        " containedin, but there could be other items.

        " Tried to remove all lines that do not begin with contained
        " but this does not work in all cases since you can have
        "    contained nextgroup=...
        " So this will strip off the ending of lines with known
        " keywords.
        let syn_list = substitute(
                    \    syntax_group, '\<\('.
                    \    substitute(
                    \      escape(s:syn_remove_words, '\\/.*$^~[]')
                    \      , ',', '\\|', 'g'
                    \    ).
                    \    '\).\{-}\%($\|'."\n".'\)'
                    \    , "\n", 'g'
                    \  )

        " Attempt to deal with lines using the match syntax
        " javaScriptDocTags xxx match /@\(param\|argument\|requires\|file\)\>/
        " Though it can use any types of regex, so this plugin will attempt
        " to restrict it
        " 1.  Only use \( or \%( constructs remove all else
        " 2   Remove and []s
        " 3.  Account for match //constructs
        "                       \%(\%(ms\|me\|hs\|he\|rs\|re\|lc\)\S\+\)\?
        " 4.  Hope for the best
        "
        "
        let syn_list_old = syn_list
        while syn_list =~ '\<match\>\s\+\/'
            if syn_list =~ 'perlElseIfError'
                let syn_list = syn_list
            endif
            " Check if the match has words at least 3 characters long
            if syn_list =~ '\<match \/\zs.\{-}\<\w\{3,}\>.\{-}\ze\\\@<!\/\%(\%(ms\|me\|hs\|he\|rs\|re\|lc\)\S\+\)\?\s\+'
                " Remove everything after / and before the first \(
                let syn_list = substitute( syn_list, '\<match \/\zs.\{-}\ze\\%\?(.\{-}\\\@<!\/\%(\%(ms\|me\|hs\|he\|rs\|re\|lc\)\S\+\)\?\s\+', '', 'g' )
                " Remove everything after \) and up to the ending /
                let syn_list = substitute( syn_list, '\<match \/.\{-}\\)\zs.\{-}\ze\/\%(\%(ms\|me\|hs\|he\|rs\|re\|lc\)\S\+\)\?\s\+', '', 'g' )

                " Remove any character classes
                " let syn_list = substitute( syn_list, '\<match /\zs.\{-}\[[^]]*\].\{-}\ze\/ ', '', 'g' )
                let syn_list = substitute( syn_list, '\%(\<match \/[^/]\{-}\)\@<=\[[^]]*\]\ze.\{-}\\\@<!\/\%(\%(ms\|me\|hs\|he\|rs\|re\|lc\)\S\+\)\?', '', 'g' )
                " Remove any words < 3 characters
                let syn_list = substitute( syn_list, '\%(\<match \/[^/]\{-}\)\@<=\<\w\{1,2}\>\ze.\{-}\\\@<!\/\%(\%(ms\|me\|hs\|he\|rs\|re\|lc\)\S\+\)\?\s\+', '', 'g' )
                " Remove all non-word characters
                " let syn_list = substitute( syn_list, '\<match /\zs.\{-}\<\W\+\>.\{-}\ze\/ ', "", 'g' )
                " let syn_list = substitute( syn_list, '\%(\<match \/[^/]\{-}\)\@<=\W\+\ze.\{-}\/ ', ' ', 'g' )
                " Do this by using the outer substitute() call to gather all
                " text between the match /.../ tags.
                " The inner substitute() call operates on the text selected
                " and replaces all non-word characters.
                let syn_list = substitute( syn_list, '\<match \/\zs\(.\{-}\)\ze\\\@<!\/\%(\%(ms\|me\|hs\|he\|rs\|re\|lc\)\S\+\)\?\s\+'
                            \ , '\=substitute(submatch(1), "\\W\\+", " ", "g")'
                            \ , 'g' )
                " Remove the match / / syntax
                let syn_list = substitute( syn_list, '\<match \/\(.\{-}\)\/\%(\%(ms\|me\|hs\|he\|rs\|re\|lc\)\S\+\)\?\s\+', '\1', 'g' )
            else
                " No words long enough, remove the match
                " Remove the match syntax
                " let syn_list = substitute( syn_list, '\<match \/[^\/]*\/\%(\%(ms\|me\|hs\|he\|rs\|re\|lc\)\S\+\)\?\s\+', '', 'g' )
                let syn_list = substitute( syn_list, '\<match \/\%(.\{-}\)\?\/\%(\%(ms\|me\|hs\|he\|rs\|re\|lc\)\S\+\)\?\s\+', '', 'g' )
            endif
            if syn_list =~ '\<match\>\s\+\/'
                " Problem removing the match / / tags
                let syn_list = ''
            endif
        endwhile


        " Now strip off the newline + blank space + contained.
        " Also include lines with nextgroup=@someName skip_key_words syntax_element
                    " \    syn_list, '\%(^\|\n\)\@<=\s*\<\(contained\|nextgroup=\)'
                    " \    syn_list, '\%(^\|\n\)\@<=\s*\<\(contained\|nextgroup=[@a-zA-Z,]*\)'
        let syn_list = substitute(
                    \    syn_list, '\<\(contained\|nextgroup=[@a-zA-Z,]*\)'
                    \    , "", 'g'
                    \ )

        " This can leave lines like this
        "     =@vimMenuList  skipwhite onoremenu
        " Strip the special option keywords first
        "     :h :syn-skipwhite*
        let syn_list = substitute(
                    \    syn_list, '\<\(skipwhite\|skipnl\|skipempty\)\>'
                    \    , "", 'g'
                    \ )

        " Now remove the remainder of the nextgroup=@someName lines
        let syn_list = substitute(
                    \    syn_list, '\%(^\|\n\)\@<=\s*\(@\w\+\)'
                    \    , "", 'g'
                    \ )
 
        if l:omni_syntax_use_iskeyword == 0
            " There are a number of items which have non-word characters in
            " them, *'T_F1'*.  vim.vim is one such file.
            " This will replace non-word characters with spaces.
            "   setlocal filetype=forth
            "   let g:omni_syntax_use_iskeyword = 1
            "   let g:omni_syntax_use_iskeyword_numeric = 1
            " You will see entries like
            "   #>>
            "   (.local)
            " These were found doing a grep in vim82\syntax
            "   grep iskeyword *
            "   forth.vim:setlocal iskeyword=!,@,33-35,%,$,38-64,A-Z,91-96,a-z,123-126,128-255
            let syn_list = substitute( syn_list, '[^0-9A-Za-z_ ]', ' ', 'g' )
        else
            if l:omni_syntax_use_iskeyword_numeric == 1
                " iskeyword can contain value like this
                " 38,42,43,45,47-58,60-62,64-90,97-122,_,+,-,*,/,%,<,=,>,:,$,?,!,@-@,94
                " Numeric values convert to their ASCII equivalent using the
                " nr2char() function.
                "     &       38
                "     *       42
                "     +       43
                "     -       45
                "     ^       94
                " Iterate through all numeric specifications and convert those
                " to their ascii equivalent ensuring the character is printable.
                " If so, add it to the list.
                let accepted_chars = ''
                for item in split(&iskeyword, ',')
                    if item =~ '\d-\d'
                        " This is a character range (ie 47-58),
                        " cycle through each character within the range
                        let [b:start, b:end] = split(item, '-')
                        for range_item in range( b:start, b:end )
                            if range_item <= 127 || l:omni_syntax_use_single_byte == 0
                                if nr2char(range_item) =~ '\p'
                                    let accepted_chars = accepted_chars . nr2char(range_item)
                                endif
                            endif
                        endfor
                    elseif item =~ '^\d\+$'
                        " Only numeric, translate to a character
                        if item < 127 || l:omni_syntax_use_single_byte == 0
                            if nr2char(item) =~ '\p'
                                let accepted_chars = accepted_chars . nr2char(item)
                            endif
                        endif
                    else
                        if char2nr(item) < 127 || l:omni_syntax_use_single_byte == 0
                            if item =~ '\p'
                                let accepted_chars = accepted_chars . item
                            endif
                        endif
                    endif
                endfor
                " Escape special regex characters
                " Looks like the wrong chars are escaped.  In a collection,
                "      :h /[]
                "      only `]', `\', `-' and `^' are special:
                " let accepted_chars = escape(accepted_chars, '\\/.*$^~[]' )
                let accepted_chars = escape(accepted_chars, ']\-^' )
                " Remove all characters that are not acceptable
                let syn_list = substitute( syn_list, '[^A-Za-z'.accepted_chars.']', ' ', 'g' )
            else
                let accept_chars = ','.&iskeyword.','
                " Remove all character ranges
                " let accept_chars = substitute(accept_chars, ',[^,]\+-[^,]\+,', ',', 'g')
                let accept_chars = substitute(accept_chars, ',\@<=[^,]\+-[^,]\+,', '', 'g')
                " Remove all numeric specifications
                " let accept_chars = substitute(accept_chars, ',\d\{-},', ',', 'g')
                let accept_chars = substitute(accept_chars, ',\@<=\d\{-},', '', 'g')
                " Remove all commas
                let accept_chars = substitute(accept_chars, ',', '', 'g')
                " Escape special regex characters
                " Looks like the wrong chars are escaped.  In a collection,
                "      :h /[]
                "      only `]', `\', `-' and `^' are special:
                " let accept_chars = escape(accept_chars, '\\/.*$^~[]' )
                let accept_chars = escape(accept_chars, ']\-^' )
                " Remove all characters that are not acceptable
                let syn_list = substitute( syn_list, '[^0-9A-Za-z_'.accept_chars.']', ' ', 'g' )
            endif
        endif

        if l:omni_syntax_minimum_length > 0
            " If the user specified a minimum length, enforce it
            let syn_list = substitute(' '.syn_list.' ', ' \S\{,'.l:omni_syntax_minimum_length.'}\ze ', ' ', 'g')
        endif
    else
        let syn_list = ''
    endif

    return syn_list
endfunction

function! OmniSyntaxShowChars(spec)
  let result = []
  for item in split(a:spec, ',')
    if len(item) > 1
      if item == '@-@'
        call add(result, char2nr(item))
      else
        call extend(result, call('range', split(item, '-')))
      endif
    else
      if item == '@'  " assume this is [A-Za-z]
        for [c1, c2] in [['A', 'Z'], ['a', 'z']]
          call extend(result, range(char2nr(c1), char2nr(c2)))
        endfor
      else
        call add(result, char2nr(item))
      endif
    endif
  endfor
  return join(map(result, 'nr2char(v:val)'), ', ')
endfunction

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                             " tar.vim: Handles browsing tarfiles
"            AUTOLOAD PORTION
" Date:		Jan 07, 2020
" Version:	32
" Maintainer:	Charles E Campbell <NcampObell@SdrPchip.AorgM-NOSPAM>
" License:	Vim License  (see vim's :help license)
"
"	Contains many ideas from Michael Toren's <tar.vim>
"
" Copyright:    Copyright (C) 2005-2017 Charles E. Campbell {{{1
"               Permission is hereby granted to use and distribute this code,
"               with or without modifications, provided that this copyright
"               notice is copied with it. Like anything else that's free,
"               tar.vim and tarPlugin.vim are provided *as is* and comes
"               with no warranty of any kind, either expressed or implied.
"               By using this plugin, you agree that in no event will the
"               copyright holder be liable for any damages resulting from
"               the use of this software.
"     call inputsave()|call input("Press <cr> to continue")|call inputrestore()
" ---------------------------------------------------------------------
" Load Once: {{{1
if &cp || exists("g:loaded_tar")
 finish
endif
let g:loaded_tar= "v32"
if v:version < 702
 echohl WarningMsg
 echo "***warning*** this version of tar needs vim 7.2"
 echohl Normal
 finish
endif
let s:keepcpo= &cpo
set cpo&vim
"DechoTabOn
"call Decho("loading autoload/tar.vim")

" ---------------------------------------------------------------------
"  Default Settings: {{{1
if !exists("g:tar_browseoptions")
 let g:tar_browseoptions= "Ptf"
endif
if !exists("g:tar_readoptions")
 let g:tar_readoptions= "OPxf"
endif
if !exists("g:tar_cmd")
 let g:tar_cmd= "tar"
endif
if !exists("g:tar_writeoptions")
 let g:tar_writeoptions= "uf"
endif
if !exists("g:tar_delfile")
 let g:tar_delfile="--delete -f"
endif
if !exists("g:netrw_cygwin")
 if has("win32") || has("win95") || has("win64") || has("win16")
  if &shell =~ '\%(\<bash\>\|\<zsh\>\)\%(\.exe\)\=$'
   let g:netrw_cygwin= 1
  else
   let g:netrw_cygwin= 0
  endif
 else
  let g:netrw_cygwin= 0
 endif
endif
if !exists("g:tar_copycmd")
 if !exists("g:netrw_localcopycmd")
  if has("win32") || has("win95") || has("win64") || has("win16")
   if g:netrw_cygwin
    let g:netrw_localcopycmd= "cp"
   else
    let g:netrw_localcopycmd= "copy"
   endif
  elseif has("unix") || has("macunix")
   let g:netrw_localcopycmd= "cp"
  else
   let g:netrw_localcopycmd= ""
  endif
 endif
 let g:tar_copycmd= g:netrw_localcopycmd
endif
if !exists("g:tar_extractcmd")
 let g:tar_extractcmd= "tar -xf"
endif

" set up shell quoting character
if !exists("g:tar_shq")
 if exists("+shq") && exists("&shq") && &shq != ""
  let g:tar_shq= &shq
 elseif has("win32") || has("win95") || has("win64") || has("win16")
  if exists("g:netrw_cygwin") && g:netrw_cygwin
   let g:tar_shq= "'"
  else
   let g:tar_shq= '"'
  endif
 else
  let g:tar_shq= "'"
 endif
" call Decho("g:tar_shq<".g:tar_shq.">")
endif

" ----------------
"  Functions: {{{1
" ----------------

" ---------------------------------------------------------------------
" tar#Browse: {{{2
fun! tar#Browse(tarfile)
"  call Dfunc("tar#Browse(tarfile<".a:tarfile.">)")
  let repkeep= &report
  set report=10

  " sanity checks
  if !executable(g:tar_cmd)
   redraw!
"   call Decho('***error*** (tar#Browse) "'.g:tar_cmd.'" not available on your system')
   echohl Error | echo '***error*** (tar#Browse) "'.g:tar_cmd.'" not available on your system'
   let &report= repkeep
"   call Dret("tar#Browse")
   return
  endif
  if !filereadable(a:tarfile)
"   call Decho('a:tarfile<'.a:tarfile.'> not filereadable')
   if a:tarfile !~# '^\a\+://'
    " if it's an url, don't complain, let url-handlers such as vim do its thing
    redraw!
"    call Decho("***error*** (tar#Browse) File not readable<".a:tarfile.">")
    echohl Error | echo "***error*** (tar#Browse) File not readable<".a:tarfile.">" | echohl None
   endif
   let &report= repkeep
"   call Dret("tar#Browse : file<".a:tarfile."> not readable")
   return
  endif
  if &ma != 1
   set ma
  endif
  let b:tarfile= a:tarfile

  setlocal noswapfile
  setlocal buftype=nofile
  setlocal bufhidden=hide
  setlocal nobuflisted
  setlocal nowrap
  set ft=tar

  " give header
"  call Decho("printing header")
  let lastline= line("$")
  call setline(lastline+1,'" tar.vim version '.g:loaded_tar)
  call setline(lastline+2,'" Browsing tarfile '.a:tarfile)
  call setline(lastline+3,'" Select a file with cursor and press ENTER')
  keepj $put =''
  keepj sil! 0d
  keepj $

  let tarfile= a:tarfile
  if has("win32unix") && executable("cygpath")
   " assuming cygwin
   let tarfile=substitute(system("cygpath -u ".shellescape(tarfile,0)),'\n$','','e')
  endif
  let curlast= line("$")

  if tarfile =~# '\.\(gz\)$'
"   call Decho("1: exe silent r! gzip -d -c -- ".shellescape(tarfile,1)." | ".g:tar_cmd." -".g:tar_browseoptions." - ")
   exe "sil! r! gzip -d -c -- ".shellescape(tarfile,1)." | ".g:tar_cmd." -".g:tar_browseoptions." - "

  elseif tarfile =~# '\.\(tgz\)$' || tarfile =~# '\.\(tbz\)$' || tarfile =~# '\.\(txz\)$' || tarfile =~# '\.\(tzs\)$'
   if has("unix") && executable("file")
    let filekind= system("file ".shellescape(tarfile,1)) =~ "bzip2"
   else
    let filekind= ""
   endif

   if filekind =~ "bzip2"
    exe "sil! r! bzip2 -d -c -- ".shellescape(tarfile,1)." | ".g:tar_cmd." -".g:tar_browseoptions." - "
   elseif filekind =~ "XZ"
    exe "sil! r! xz -d -c -- ".shellescape(tarfile,1)." | ".g:tar_cmd." -".g:tar_browseoptions." - "
   elseif filekind =~ "Zstandard"
    exe "sil! r! zstd --decompress --stdout -- ".shellescape(tarfile,1)." | ".g:tar_cmd." -".g:tar_browseoptions." - "
   else
    exe "sil! r! gzip -d -c -- ".shellescape(tarfile,1)." | ".g:tar_cmd." -".g:tar_browseoptions." - "
   endif

  elseif tarfile =~# '\.lrp'
"   call Decho("2: exe silent r! cat -- ".shellescape(tarfile,1)."|gzip -d -c -|".g:tar_cmd." -".g:tar_browseoptions." - ")
   exe "sil! r! cat -- ".shellescape(tarfile,1)."|gzip -d -c -|".g:tar_cmd." -".g:tar_browseoptions." - "
  elseif tarfile =~# '\.\(bz2\|tbz\|tb2\)$'
"   call Decho("3: exe silent r! bzip2 -d -c -- ".shellescape(tarfile,1)." | ".g:tar_cmd." -".g:tar_browseoptions." - ")
   exe "sil! r! bzip2 -d -c -- ".shellescape(tarfile,1)." | ".g:tar_cmd." -".g:tar_browseoptions." - "
  elseif tarfile =~# '\.\(lzma\|tlz\)$'
"   call Decho("3: exe silent r! lzma -d -c -- ".shellescape(tarfile,1)." | ".g:tar_cmd." -".g:tar_browseoptions." - ")
   exe "sil! r! lzma -d -c -- ".shellescape(tarfile,1)." | ".g:tar_cmd." -".g:tar_browseoptions." - "
  elseif tarfile =~# '\.\(xz\|txz\)$'
"   call Decho("3: exe silent r! xz --decompress --stdout -- ".shellescape(tarfile,1)." | ".g:tar_cmd." -".g:tar_browseoptions." - ")
   exe "sil! r! xz --decompress --stdout -- ".shellescape(tarfile,1)." | ".g:tar_cmd." -".g:tar_browseoptions." - "
  elseif tarfile =~# '\.\(zst\|tzs\)$'
   exe "sil! r! zstd --decompress --stdout -- ".shellescape(tarfile,1)." | ".g:tar_cmd." -".g:tar_browseoptions." - "
  else
   if tarfile =~ '^\s*-'
    " A file name starting with a dash is taken as an option.  Prepend ./ to avoid that.
    let tarfile = substitute(tarfile, '-', './-', '')
   endif
"   call Decho("4: exe silent r! ".g:tar_cmd." -".g:tar_browseoptions." ".shellescape(tarfile,0))
   exe "sil! r! ".g:tar_cmd." -".g:tar_browseoptions." ".shellescape(tarfile,1)
  endif
  if v:shell_error != 0
   redraw!
   echohl WarningMsg | echo "***warning*** (tar#Browse) please check your g:tar_browseoptions<".g:tar_browseoptions.">"
"   call Dret("tar#Browse : a:tarfile<".a:tarfile.">")
   return
  endif
  if line("$") == curlast || ( line("$") == (curlast + 1) && getline("$") =~# '\c\%(warning\|error\|inappropriate\|unrecognized\)')
   redraw!
   echohl WarningMsg | echo "***warning*** (tar#Browse) ".a:tarfile." doesn't appear to be a tar file" | echohl None
   keepj sil! %d
   let eikeep= &ei
   set ei=BufReadCmd,FileReadCmd
   exe "r ".fnameescape(a:tarfile)
   let &ei= eikeep
   keepj sil! 1d
"   call Dret("tar#Browse : a:tarfile<".a:tarfile.">")
   return
  endif

  " set up maps supported for tar
  setlocal noma nomod ro
  noremap <silent> <buffer>	<cr>		:call <SID>TarBrowseSelect()<cr>
  noremap <silent> <buffer>	x	 	:call tar#Extract()<cr>       
  if &mouse != ""
   noremap <silent> <buffer>	<leftmouse>	<leftmouse>:call <SID>TarBrowseSelect()<cr>
  endif

  let &report= repkeep
"  call Dret("tar#Browse : b:tarfile<".b:tarfile.">")
endfun

" ---------------------------------------------------------------------
" TarBrowseSelect: {{{2
fun! s:TarBrowseSelect()
"  call Dfunc("TarBrowseSelect() b:tarfile<".b:tarfile."> curfile<".expand("%").">")
  let repkeep= &report
  set report=10
  let fname= getline(".")
"  call Decho("fname<".fname.">")

  if !exists("g:tar_secure") && fname =~ '^\s*-\|\s\+-'
   redraw!
   echohl WarningMsg | echo '***warning*** (tar#BrowseSelect) rejecting tarfile member<'.fname.'> because of embedded "-"'
"   call Dret('tar#BrowseSelect : rejecting tarfile member<'.fname.'> because of embedded "-"')
   return
  endif

  " sanity check
  if fname =~ '^"'
   let &report= repkeep
"   call Dret("TarBrowseSelect")
   return
  endif

  " about to make a new window, need to use b:tarfile
  let tarfile= b:tarfile
  let curfile= expand("%")
  if has("win32unix") && executable("cygpath")
   " assuming cygwin
   let tarfile=substitute(system("cygpath -u ".shellescape(tarfile,0)),'\n$','','e')
  endif

  " open a new window (tar#Read will read a file into it)
  noswapfile new
  if !exists("g:tar_nomax") || g:tar_nomax == 0
   wincmd _
  endif
  let s:tblfile_{winnr()}= curfile
  call tar#Read("tarfile:".tarfile.'::'.fname,1)
  filetype detect
  set nomod
  exe 'com! -buffer -nargs=? -complete=file TarDiff	:call tar#Diff(<q-args>,"'.fnameescape(fname).'")'

  let &report= repkeep
"  call Dret("TarBrowseSelect : s:tblfile_".winnr()."<".s:tblfile_{winnr()}.">")
endfun

" ---------------------------------------------------------------------
" tar#Read: {{{2
fun! tar#Read(fname,mode)
"  call Dfunc("tar#Read(fname<".a:fname.">,mode=".a:mode.")")
  let repkeep= &report
  set report=10
  let tarfile = substitute(a:fname,'tarfile:\(.\{-}\)::.*$','\1','')
  let fname   = substitute(a:fname,'tarfile:.\{-}::\(.*\)$','\1','')
  if has("win32unix") && executable("cygpath")
   " assuming cygwin
   let tarfile=substitute(system("cygpath -u ".shellescape(tarfile,0)),'\n$','','e')
  endif
"  call Decho("tarfile<".tarfile.">")
"  call Decho("fname<".fname.">")

  if  fname =~ '\.bz2$' && executable("bzcat")
   let decmp= "|bzcat"
   let doro = 1
  elseif      fname =~ '\.t\=gz$'  && executable("zcat")
   let decmp= "|zcat"
   let doro = 1
  elseif  fname =~ '\.lzma$' && executable("lzcat")
   let decmp= "|lzcat"
   let doro = 1
  elseif  fname =~ '\.xz$' && executable("xzcat")
   let decmp= "|xzcat"
   let doro = 1
  elseif  fname =~ '\.zst$' && executable("zstdcat")
   let decmp= "|zstdcat"
   let doro = 1
  else
   let decmp=""
   let doro = 0
   if fname =~ '\.bz2$\|\.gz$\|\.lzma$\|\.xz$\|\.zip$\|\.Z$'
    setlocal bin
   endif
  endif

  if exists("g:tar_secure")
   let tar_secure= " -- "
  else
   let tar_secure= " "
  endif

  if tarfile =~# '\.bz2$'
   exe "sil! r! bzip2 -d -c -- ".shellescape(tarfile,1)."| ".g:tar_cmd." -".g:tar_readoptions." - ".tar_secure.shellescape(fname,1).decmp
  elseif tarfile =~# '\.\(gz\)$'
   exe "sil! r! gzip -d -c -- ".shellescape(tarfile,1)."| ".g:tar_cmd." -".g:tar_readoptions." - ".tar_secure.shellescape(fname,1).decmp

  elseif tarfile =~# '\(\.tgz\|\.tbz\|\.txz\)'
   if has("unix") && executable("file")
    let filekind= system("file ".shellescape(tarfile,1))
   else
    let filekind= ""
   endif
   if filekind =~ "bzip2"
    exe "sil! r! bzip2 -d -c -- ".shellescape(tarfile,1)."| ".g:tar_cmd." -".g:tar_readoptions." - ".tar_secure.shellescape(fname,1).decmp
   elseif filekind =~ "XZ"
    exe "sil! r! xz -d -c -- ".shellescape(tarfile,1)."| ".g:tar_cmd." -".g:tar_readoptions." - ".tar_secure.shellescape(fname,1).decmp
   elseif filekind =~ "Zstandard"
    exe "sil! r! zstd --decompress --stdout -- ".shellescape(tarfile,1)."| ".g:tar_cmd." -".g:tar_readoptions." - ".tar_secure.shellescape(fname,1).decmp
   else
    exe "sil! r! gzip -d -c -- ".shellescape(tarfile,1)."| ".g:tar_p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          cmd." -".g:tar_readoptions." - ".tar_secure.shellescape(fname,1).decmp
   endif

  elseif tarfile =~# '\.lrp$'
   exe "sil! r! cat -- ".shellescape(tarfile,1)." | gzip -d -c - | ".g:tar_cmd." -".g:tar_readoptions." - ".tar_secure.shellescape(fname,1).decmp
  elseif tarfile =~# '\.lzma$'
   exe "sil! r! lzma -d -c -- ".shellescape(tarfile,1)."| ".g:tar_cmd." -".g:tar_readoptions." - ".tar_secure.shellescape(fname,1).decmp
  elseif tarfile =~# '\.\(xz\|txz\)$'
   exe "sil! r! xz --decompress --stdout -- ".shellescape(tarfile,1)." | ".g:tar_cmd." -".g:tar_readoptions." - ".tar_secure.shellescape(fname,1).decmp
  else
   if tarfile =~ '^\s*-'
    " A file name starting with a dash is taken as an option.  Prepend ./ to avoid that.
    let tarfile = substitute(tarfile, '-', './-', '')
   endif
"   call Decho("8: exe silent r! ".g:tar_cmd." -".g:tar_readoptions.tar_secure.shellescape(tarfile,1)." ".shellescape(fname,1).decmp)
   exe "silent r! ".g:tar_cmd." -".g:tar_readoptions.shellescape(tarfile,1)." ".tar_secure.shellescape(fname,1).decmp
  endif

  if doro
   " because the reverse process of compressing changed files back into the tarball is not currently supported
   setlocal ro
  endif

  let b:tarfile= a:fname
  exe "file tarfile::".fnameescape(fname)

  " cleanup
  keepj sil! 0d
  set nomod

  let &report= repkeep
"  call Dret("tar#Read : b:tarfile<".b:tarfile.">")
endfun

" ---------------------------------------------------------------------
" tar#Write: {{{2
fun! tar#Write(fname)
"  call Dfunc("tar#Write(fname<".a:fname.">) b:tarfile<".b:tarfile."> tblfile_".winnr()."<".s:tblfile_{winnr()}.">")
  let repkeep= &report
  set report=10

  if !exists("g:tar_secure") && a:fname =~ '^\s*-\|\s\+-'
   redraw!
   echohl WarningMsg | echo '***warning*** (tar#Write) rejecting tarfile member<'.a:fname.'> because of embedded "-"'
"   call Dret('tar#Write : rejecting tarfile member<'.fname.'> because of embedded "-"')
   return
  endif

  " sanity checks
  if !executable(g:tar_cmd)
   redraw!
"   call Decho('***error*** (tar#Browse) "'.g:tar_cmd.'" not available on your system')
   let &report= repkeep
"   call Dret("tar#Write")
   return
  endif
  if !exists("*mkdir")
   redraw!
"   call Decho("***error*** (tar#Write) sorry, mkdir() doesn't work on your system")
   echohl Error | echo "***error*** (tar#Write) sorry, mkdir() doesn't work on your system" | echohl None
   let &report= repkeep
"   call Dret("tar#Write")
   return
  endif

  let curdir= getcwd()
  let tmpdir= tempname()
"  call Decho("orig tempname<".tmpdir.">")
  if tmpdir =~ '\.'
   let tmpdir= substitute(tmpdir,'\.[^.]*$','','e')
  endif
"  call Decho("tmpdir<".tmpdir.">")
  call mkdir(tmpdir,"p")

  " attempt to change to the indicated directory
  try
   exe "cd ".fnameescape(tmpdir)
  catch /^Vim\%((\a\+)\)\=:E344/
   redraw!
"   call Decho("***error*** (tar#Write) cannot cd to temporary directory")
   echohl Error | echo "***error*** (tar#Write) cannot cd to temporary directory" | Echohl None
   let &report= repkeep
"   call Dret("tar#Write")
   return
  endtry
"  call Decho("current directory now: ".getcwd())

  " place temporary files under .../_ZIPVIM_/
  if isdirectory("_ZIPVIM_")
   call s:Rmdir("_ZIPVIM_")
  endif
  call mkdir("_ZIPVIM_")
  cd _ZIPVIM_
"  call Decho("current directory now: ".getcwd())

  let tarfile = substitute(b:tarfile,'tarfile:\(.\{-}\)::.*$','\1','')
  let fname   = substitute(b:tarfile,'tarfile:.\{-}::\(.*\)$','\1','')

  " handle compressed archives
  if tarfile =~# '\.bz2'
   call system("bzip2 -d -- ".shellescape(tarfile,0))
   let tarfile = substitute(tarfile,'\.bz2','','e')
   let compress= "bzip2 -- ".shellescape(tarfile,0)
"   call Decho("compress<".compress.">")
  elseif tarfile =~# '\.gz'
   call system("gzip -d -- ".shellescape(tarfile,0))
   let tarfile = substitute(tarfile,'\.gz','','e')
   let compress= "gzip -- ".shellescape(tarfile,0)
"   call Decho("compress<".compress.">")
  elseif tarfile =~# '\.tgz'
   call system("gzip -d -- ".shellescape(tarfile,0))
   let tarfile = substitute(tarfile,'\.tgz','.tar','e')
   let compress= "gzip -- ".shellescape(tarfile,0)
   let tgz     = 1
"   call Decho("compress<".compress.">")
  elseif tarfile =~# '\.xz'
   call system("xz -d -- ".shellescape(tarfile,0))
   let tarfile = substitute(tarfile,'\.xz','','e')
   let compress= "xz -- ".shellescape(tarfile,0)
"   call Decho("compress<".compress.">")
  elseif tarfile =~# '\.zst'
   call system("zstd --decompress -- ".shellescape(tarfile,0))
   let tarfile = substitute(tarfile,'\.zst','','e')
   let compress= "zstd -- ".shellescape(tarfile,0)
  elseif tarfile =~# '\.lzma'
   call system("lzma -d -- ".shellescape(tarfile,0))
   let tarfile = substitute(tarfile,'\.lzma','','e')
   let compress= "lzma -- ".shellescape(tarfile,0)
"   call Decho("compress<".compress.">")
  endif
"  call Decho("tarfile<".tarfile.">")

  if v:shell_error != 0
   redraw!
"   call Decho("***error*** (tar#Write) sorry, unable to update ".tarfile." with ".fname)
   echohl Error | echo "***error*** (tar#Write) sorry, unable to update ".tarfile." with ".fname | echohl None
  else

"   call Decho("tarfile<".tarfile."> fname<".fname.">")
 
   if fname =~ '/'
    let dirpath = substitute(fname,'/[^/]\+$','','e')
    if has("win32unix") && executable("cygpath")
     let dirpath = substitute(system("cygpath ".shellescape(dirpath, 0)),'\n','','e')
    endif
    call mkdir(dirpath,"p")
   endif
   if tarfile !~ '/'
    let tarfile= curdir.'/'.tarfile
   endif
   if tarfile =~ '^\s*-'
    " A file name starting with a dash may be taken as an option.  Prepend ./ to avoid that.
    let tarfile = substitute(tarfile, '-', './-', '')
   endif
"   call Decho("tarfile<".tarfile."> fname<".fname.">")
 
   if exists("g:tar_secure")
    let tar_secure= " -- "
   else
    let tar_secure= " "
   endif
   exe "w! ".fnameescape(fname)
   if has("win32unix") && executable("cygpath")
    let tarfile = substitute(system("cygpath ".shellescape(tarfile,0)),'\n','','e')
   endif
 
   " delete old file from tarfile
"   call Decho("system(".g:tar_cmd." ".g:tar_delfile." ".shellescape(tarfile,0)." -- ".shellescape(fname,0).")")
   call system(g:tar_cmd." ".g:tar_delfile." ".shellescape(tarfile,0).tar_secure.shellescape(fname,0))
   if v:shell_error != 0
    redraw!
"    call Decho("***error*** (tar#Write) sorry, unable to update ".fnameescape(tarfile)." with ".fnameescape(fname))
    echohl Error | echo "***error*** (tar#Write) sorry, unable to update ".fnameescape(tarfile)." with ".fnameescape(fname) | echohl None
   else
 
    " update tarfile with new file 
"    call Decho(g:tar_cmd." -".g:tar_writeoptions." ".shellescape(tarfile,0).tar_secure.shellescape(fname,0))
    call system(g:tar_cmd." -".g:tar_writeoptions." ".shellescape(tarfile,0).tar_secure.shellescape(fname,0))
    if v:shell_error != 0
     redraw!
"     call Decho("***error*** (tar#Write) sorry, unable to update ".fnameescape(tarfile)." with ".fnameescape(fname))
     echohl Error | echo "***error*** (tar#Write) sorry, unable to update ".fnameescape(tarfile)." with ".fnameescape(fname) | echohl None
    elseif exists("compress")
"     call Decho("call system(".compress.")")
     call system(compress)
     if exists("tgz")
"      call Decho("rename(".tarfile.".gz,".substitute(tarfile,'\.tar$','.tgz','e').")")
      call rename(tarfile.".gz",substitute(tarfile,'\.tar$','.tgz','e'))
     endif
    endif
   endif

   " support writing tarfiles across a network
   if s:tblfile_{winnr()} =~ '^\a\+://'
"    call Decho("handle writing <".tarfile."> across network to <".s:tblfile_{winnr()}.">")
    let tblfile= s:tblfile_{winnr()}
    1split|noswapfile enew
    let binkeep= &l:binary
    let eikeep = &ei
    set binary ei=all
    exe "noswapfile e! ".fnameescape(tarfile)
    call netrw#NetWrite(tblfile)
    let &ei       = eikeep
    let &l:binary = binkeep
    q!
    unlet s:tblfile_{winnr()}
   endif
  endif
  
  " cleanup and restore current directory
  cd ..
  call s:Rmdir("_ZIPVIM_")
  exe "cd ".fnameescape(curdir)
  setlocal nomod

  let &report= repkeep
"  call Dret("tar#Write")
endfun

" ---------------------------------------------------------------------
" tar#Diff: {{{2
fun! tar#Diff(userfname,fname)
"  call Dfunc("tar#Diff(userfname<".a:userfname."> fname<".a:fname.")")
  let fname= a:fname
  if a:userfname != ""
   let fname= a:userfname
  endif
  if filereadable(fname)
   " sets current file (from tarball) for diff'ing
   " splits window vertically
   " opens original file, sets it for diff'ing
   " sets up b:tardiff_otherbuf variables so each buffer knows about the other (for closing purposes)
   diffthis
   wincmd v
   exe "noswapfile e ".fnameescape(fname)
   diffthis
  else
   redraw!
   echo "***warning*** unable to read file<".fname.">"
  endif
"  call Dret("tar#Diff")
endfun

" ---------------------------------------------------------------------
" tar#Extract: extract a file from a (possibly compressed) tar archive {{{2
fun! tar#Extract()
"  call Dfunc("tar#Extract()")

  let repkeep= &report
  set report=10
  let fname= getline(".")
"  call Decho("fname<".fname.">")

  if !exists("g:tar_secure") && fname =~ '^\s*-\|\s\+-'
   redraw!
   echohl WarningMsg | echo '***warning*** (tar#BrowseSelect) rejecting tarfile member<'.fname.'> because of embedded "-"'
"   call Dret('tar#BrowseSelect : rejecting tarfile member<'.fname.'> because of embedded "-"')
   return
  endif

  " sanity check
  if fname =~ '^"'
   let &report= repkeep
"   call Dret("TarBrowseSelect")
   return
  endif

  let tarball = expand("%")
"  call Decho("tarball<".tarball.">")
  let tarbase = substitute(tarball,'\..*$','','')
"  call Decho("tarbase<".tarbase.">")

  let extractcmd= netrw#WinPath(g:tar_extractcmd)
  if filereadable(tarbase.".tar")
"   call Decho("system(".extractcmd." ".shellescape(tarbase).".tar ".shellescape(fname).")")
   call system(extractcmd." ".shellescape(tarbase).".tar ".shellescape(fname))
   if v:shell_error != 0
    echohl Error | echo "***error*** ".extractcmd." ".tarbase.".tar ".fname.": failed!" | echohl NONE
"    call Decho("***error*** ".extractcmd." ".tarbase.".tar ".fname.": failed!")
   else
    echo "***note*** successfully extracted ".fname
   endif

  elseif filereadable(tarbase.".tgz")
   let extractcmd= substitute(extractcmd,"-","-z","")
"   call Decho("system(".extractcmd." ".shellescape(tarbase).".tgz ".shellescape(fname).")")
   call system(extractcmd." ".shellescape(tarbase).".tgz ".shellescape(fname))
   if v:shell_error != 0
    echohl Error | echo "***error*** ".extractcmd." ".tarbase.".tgz ".fname.": failed!" | echohl NONE
"    call Decho("***error*** ".extractcmd."t ".tarbase.".tgz ".fname.": failed!")
   else
    echo "***note*** successfully extracted ".fname
   endif

  elseif filereadable(tarbase.".tar.gz")
   let extractcmd= substitute(extractcmd,"-","-z","")
"   call Decho("system(".extractcmd." ".shellescape(tarbase).".tar.gz ".shellescape(fname).")")
   call system(extractcmd." ".shellescape(tarbase).".tar.gz ".shellescape(fname))
   if v:shell_error != 0
    echohl Error | echo "***error*** ".extractcmd." ".tarbase.".tar.gz ".fname.": failed!" | echohl NONE
"    call Decho("***error*** ".extractcmd." ".tarbase.".tar.gz ".fname.": failed!")
   else
    echo "***note*** successfully extracted ".fname
   endif

  elseif filereadable(tarbase.".tbz")
   let extractcmd= substitute(extractcmd,"-","-j","")
"   call Decho("system(".extractcmd." ".shellescape(tarbase).".tbz ".shellescape(fname).")")
   call system(extractcmd." ".shellescape(tarbase).".tbz ".shellescape(fname))
   if v:shell_error != 0
    echohl Error | echo "***error*** ".extractcmd."j ".tarbase.".tbz ".fname.": failed!" | echohl NONE
"    call Decho("***error*** ".extractcmd."j ".tarbase.".tbz ".fname.": failed!")
   else
    echo "***note*** successfully extracted ".fname
   endif

  elseif filereadable(tarbase.".tar.bz2")
   let extractcmd= substitute(extractcmd,"-","-j","")
"   call Decho("system(".extractcmd." ".shellescape(tarbase).".tar.bz2 ".shellescape(fname).")")
   call system(extractcmd." ".shellescape(tarbase).".tar.bz2 ".shellescape(fname))
   if v:shell_error != 0
    echohl Error | echo "***error*** ".extractcmd."j ".tarbase.".tar.bz2 ".fname.": failed!" | echohl NONE
"    call Decho("***error*** ".extractcmd."j ".tarbase.".tar.bz2 ".fname.": failed!")
   else
    echo "***note*** successfully extracted ".fname
   endif

  elseif filereadable(tarbase.".txz")
   let extractcmd= substitute(extractcmd,"-","-J","")
"   call Decho("system(".extractcmd." ".shellescape(tarbase).".txz ".shellescape(fname).")")
   call system(extractcmd." ".shellescape(tarbase).".txz ".shellescape(fname))
   if v:shell_error != 0
    echohl Error | echo "***error*** ".extractcmd." ".tarbase.".txz ".fname.": failed!" | echohl NONE
"    call Decho("***error*** ".extractcmd." ".tarbase.".txz ".fname.": failed!")
   else
    echo "***note*** successfully extracted ".fname
   endif

  elseif filereadable(tarbase.".tar.xz")
   let extractcmd= substitute(extractcmd,"-","-J","")
"   call Decho("system(".extractcmd." ".shellescape(tarbase).".tar.xz ".shellescape(fname).")")
   call system(extractcmd." ".shellescape(tarbase).".tar.xz ".shellescape(fname))
   if v:shell_error != 0
    echohl Error | echo "***error*** ".extractcmd." ".tarbase.".tar.xz ".fname.": failed!" | echohl NONE
"    call Decho("***error*** ".extractcmd." ".tarbase.".tar.xz ".fname.": failed!")
   else
    echo "***note*** successfully extracted ".fname
   endif

  elseif filereadable(tarbase.".tzs")
   let extractcmd= substitute(extractcmd,"-","--zstd","")
"   call Decho("system(".extractcmd." ".shellescape(tarbase).".tzs ".shellescape(fname).")")
   call system(extractcmd." ".shellescape(tarbase).".txz ".shellescape(fname))
   if v:shell_error != 0
    echohl Error | echo "***error*** ".extractcmd." ".tarbase.".tzs ".fname.": failed!" | echohl NONE
"    call Decho("***error*** ".extractcmd." ".tarbase.".tzs ".fname.": failed!")
   else
    echo "***note*** successfully extracted ".fname
   endif

  elseif filereadable(tarbase.".tar.zst")
   let extractcmd= substitute(extractcmd,"-","--zstd","")
"   call Decho("system(".extractcmd." ".shellescape(tarbase).".tar.zst ".shellescape(fname).")")
   call system(extractcmd." ".shellescape(tarbase).".tar.xz ".shellescape(fname))
   if v:shell_error != 0
    echohl Error | echo "***error*** ".extractcmd." ".tarbase.".tar.zst ".fname.": failed!" | echohl NONE
"    call Decho("***error*** ".extractcmd." ".tarbase.".tar.zst ".fname.": failed!")
   else
    echo "***note*** successfully extracted ".fname
   endif
  endif

  " restore option
  let &report= repkeep

"  call Dret("tar#Extract")
endfun

" ---------------------------------------------------------------------
" s:Rmdir: {{{2
fun! s:Rmdir(fname)
"  call Dfunc("Rmdir(fname<".a:fname.">)")
  if has("unix")
   call system("/bin/rm -rf -- ".shellescape(a:fname,0))
  elseif has("win32") || has("win95") || has("win64") || has("win16")
   if &shell =~? "sh$"
    call system("/bin/rm -rf -- ".shellescape(a:fname,0))
   else
    call system("del /S ".shellescape(a:fname,0))
   endif
  endif
"  call Dret("Rmdir")
endfun

" ---------------------------------------------------------------------
" tar#Vimuntar: installs a tarball in the user's .vim / vimfiles directory {{{2
fun! tar#Vimuntar(...)
"  call Dfunc("tar#Vimuntar() a:0=".a:0." a:1<".(exists("a:1")? a:1 : "-n/a-").">")
  let tarball = expand("%")
"  call Decho("tarball<".tarball.">")
  let tarbase = substitute(tarball,'\..*$','','')
"  call Decho("tarbase<".tarbase.">")
  let tarhome = expand("%:p")
  if has("win32") || has("win95") || has("win64") || has("win16")
   let tarhome= substitute(tarhome,'\\','/','g')
  endif
  let tarhome= substitute(tarhome,'/[^/]*$','','')
"  call Decho("tarhome<".tarhome.">")
  let tartail = expand("%:t")
"  call Decho("tartail<".tartail.">")
  let curdir  = getcwd()
"  call Decho("curdir <".curdir.">")
  " set up vimhome
  if a:0 > 0 && a:1 != ""
   let vimhome= a:1
  else
   let vimhome= vimball#VimballHome()
  endif
"  call Decho("vimhome<".vimhome.">")

"  call Decho("curdir<".curdir."> vimhome<".vimhome.">")
  if simplify(curdir) != simplify(vimhome)
   " copy (possibly compressed) tarball to .vim/vimfiles
"   call Decho(netrw#WinPath(g:tar_copycmd)." ".shellescape(tartail)." ".shellescape(vimhome))
   call system(netrw#WinPath(g:tar_copycmd)." ".shellescape(tartail)." ".shellescape(vimhome))
"   call Decho("exe cd ".fnameescape(vimhome))
   exe "cd ".fnameescape(vimhome)
  endif
"  call Decho("getcwd<".getcwd().">")

  " if necessary, decompress the tarball; then, extract it
  if tartail =~ '\.tgz'
   if executable("gunzip")
    silent exe "!gunzip ".shellescape(tartail)
   elseif executable("gzip")
    silent exe "!gzip -d ".shellescape(tartail)
   else
    echoerr "unable to decompress<".tartail."> on this system"
    if simplify(curdir) != simplify(tarhome)
     " remove decompressed tarball, restore directory
"     call Decho("delete(".tartail.".tar)")
     call delete(tartail.".tar")
"     call Decho("exe cd ".fnameescape(curdir))
     exe "cd ".fnameescape(curdir)
    endif
"    call Dret("tar#Vimuntar")
    return
   endif
  else
   call vimball#Decompress(tartail,0)
  endif
  let extractcmd= netrw#WinPath(g:tar_extractcmd)
"  call Decho("system(".extractcmd." ".shellescape(tarbase.".tar").")")
  call system(extractcmd." ".shellescape(tarbase.".tar"))

  " set up help
  if filereadable("doc/".tarbase.".txt")
"   call Decho("exe helptags ".getcwd()."/doc")
   exe "helptags ".getcwd()."/doc"
  endif

  if simplify(tarhome) != simplify(vimhome)
   " remove decompressed tarball, restore directory
   call delete(vimhome."/".tarbase.".tar")
   exe "cd ".fnameescape(curdir)
  endif

"  call Dret("tar#Vimuntar")
endfun

" =====================================================================
" Modelines And Restoration: {{{1
let &cpo= s:keepcpo
unlet s:keepcpo
" vim:ts=8 fdm=marker
                                                                                                                                                                                                                                                                                                                                                                                                 " Vim autoload file for the tohtml plugin.
" Maintainer: Ben Fritz <fritzophrenic@gmail.com>
" Last Change: 2019 Aug 16
"
" Additional contributors:
"
"	      Original by Bram Moolenaar <Bram@vim.org>
"	      Diff2HTML() added by Christian Brabandt <cb@256bit.org>
"
"	      See Mercurial change logs for more!

" this file uses line continuations
let s:cpo_sav = &cpo
set cpo&vim

" Automatically find charsets from all encodings supported natively by Vim. With
" the 8bit- and 2byte- prefixes, Vim can actually support more encodings than
" this. Let the user specify these however since they won't be supported on
" every system.
"
" Note, not all of Vim's supported encodings have a charset to use.
"
" Names in this list are from:
"   http://www.iana.org/assignments/character-sets
" g:tohtml#encoding_to_charset: {{{
let g:tohtml#encoding_to_charset = {
      \ 'latin1' : 'ISO-8859-1',
      \ 'iso-8859-2' : 'ISO-8859-2',
      \ 'iso-8859-3' : 'ISO-8859-3',
      \ 'iso-8859-4' : 'ISO-8859-4',
      \ 'iso-8859-5' : 'ISO-8859-5',
      \ 'iso-8859-6' : 'ISO-8859-6',
      \ 'iso-8859-7' : 'ISO-8859-7',
      \ 'iso-8859-8' : 'ISO-8859-8',
      \ 'iso-8859-9' : 'ISO-8859-9',
      \ 'iso-8859-10' : '',
      \ 'iso-8859-13' : 'ISO-8859-13',
      \ 'iso-8859-14' : '',
      \ 'iso-8859-15' : 'ISO-8859-15',
      \ 'koi8-r' : 'KOI8-R',
      \ 'koi8-u' : 'KOI8-U',
      \ 'macroman' : 'macintosh',
      \ 'cp437' : '',
      \ 'cp775' : '',
      \ 'cp850' : '',
      \ 'cp852' : '',
      \ 'cp855' : '',
      \ 'cp857' : '',
      \ 'cp860' : '',
      \ 'cp861' : '',
      \ 'cp862' : '',
      \ 'cp863' : '',
      \ 'cp865' : '',
      \ 'cp866' : 'IBM866',
      \ 'cp869' : '',
      \ 'cp874' : '',
      \ 'cp1250' : 'windows-1250',
      \ 'cp1251' : 'windows-1251',
      \ 'cp1253' : 'windows-1253',
      \ 'cp1254' : 'windows-1254',
      \ 'cp1255' : 'windows-1255',
      \ 'cp1256' : 'windows-1256',
      \ 'cp1257' : 'windows-1257',
      \ 'cp1258' : 'windows-1258',
      \ 'euc-jp' : 'EUC-JP',
      \ 'sjis' : 'Shift_JIS',
      \ 'cp932' : 'Shift_JIS',
      \ 'cp949' : '',
      \ 'euc-kr' : 'EUC-KR',
      \ 'cp936' : 'GBK',
      \ 'euc-cn' : 'GB2312',
      \ 'big5' : 'Big5',
      \ 'cp950' : 'Big5',
      \ 'utf-8' : 'UTF-8',
      \ 'ucs-2' : 'UTF-8',
      \ 'ucs-2le' : 'UTF-8',
      \ 'utf-16' : 'UTF-8',
      \ 'utf-16le' : 'UTF-8',
      \ 'ucs-4' : 'UTF-8',
      \ 'ucs-4le' : 'UTF-8',
      \ }
lockvar g:tohtml#encoding_to_charset
" Notes:
"   1. All UCS/UTF are converted to UTF-8 because it is much better supported
"   2. Any blank spaces are there because Vim supports it but at least one major
"      web browser does not according to http://wiki.whatwg.org/wiki/Web_Encodings.
" }}}

" Only automatically find encodings supported natively by Vim, let the user
" specify the encoding if it's not natively supported. This function is only
" used when the user specifies the charset, they better know what they are
" doing!
"
" Names in this list are from:
"   http://www.iana.org/assignments/character-sets
" g:tohtml#charset_to_encoding: {{{
let g:tohtml#charset_to_encoding = {
      \ 'iso_8859-1:1987' : 'latin1',
      \ 'iso-ir-100' : 'latin1',
      \ 'iso_8859-1' : 'latin1',
      \ 'iso-8859-1' : 'latin1',
      \ 'latin1' : 'latin1',
      \ 'l1' : 'latin1',
      \ 'ibm819' : 'latin1',
      \ 'cp819' : 'latin1',
      \ 'csisolatin1' : 'latin1',
      \ 'iso_8859-2:1987' : 'iso-8859-2',
      \ 'iso-ir-101' : 'iso-8859-2',
      \ 'iso_8859-2' : 'iso-8859-2',
      \ 'iso-8859-2' : 'iso-8859-2',
      \ 'latin2' : 'iso-8859-2',
      \ 'l2' : 'iso-8859-2',
      \ 'csisolatin2' : 'iso-8859-2',
      \ 'iso_8859-3:1988' : 'iso-8859-3',
      \ 'iso-ir-109' : 'iso-8859-3',
      \ 'iso_8859-3' : 'iso-8859-3',
      \ 'iso-8859-3' : 'iso-8859-3',
      \ 'latin3' : 'iso-8859-3',
      \ 'l3' : 'iso-8859-3',
      \ 'csisolatin3' : 'iso-8859-3',
      \ 'iso_8859-4:1988' : 'iso-8859-4',
      \ 'iso-ir-110' : 'iso-8859-4',
      \ 'iso_8859-4' : 'iso-8859-4',
      \ 'iso-8859-4' : 'iso-8859-4',
      \ 'latin4' : 'iso-8859-4',
      \ 'l4' : 'iso-8859-4',
      \ 'csisolatin4' : 'iso-8859-4',
      \ 'iso_8859-5:1988' : 'iso-8859-5',
      \ 'iso-ir-144' : 'iso-8859-5',
      \ 'iso_8859-5' : 'iso-8859-5',
      \ 'iso-8859-5' : 'iso-8859-5',
      \ 'cyrillic' : 'iso-8859-5',
      \ 'csisolatincyrillic' : 'iso-8859-5',
      \ 'iso_8859-6:1987' : 'iso-8859-6',
      \ 'iso-ir-127' : 'iso-8859-6',
      \ 'iso_8859-6' : 'iso-8859-6',
      \ 'iso-8859-6' : 'iso-8859-6',
      \ 'ecma-114' : 'iso-8859-6',
      \ 'asmo-708' : 'iso-8859-6',
      \ 'arabic' : 'iso-8859-6',
      \ 'csisolatinarabic' : 'iso-8859-6',
      \ 'iso_8859-7:1987' : 'iso-8859-7',
      \ 'iso-ir-126' : 'iso-8859-7',
      \ 'iso_8859-7' : 'iso-8859-7',
      \ 'iso-8859-7' : 'iso-8859-7',
      \ 'elot_928' : 'iso-8859-7',
      \ 'ecma-118' : 'iso-8859-7',
      \ 'greek' : 'iso-8859-7',
      \ 'greek8' : 'iso-8859-7',
      \ 'csisolatingreek' : 'iso-8859-7',
      \ 'iso_8859-8:1988' : 'iso-8859-8',
      \ 'iso-ir-138' : 'iso-8859-8',
      \ 'iso_8859-8' : 'iso-8859-8',
      \ 'iso-8859-8' : 'iso-8859-8',
      \ 'hebrew' : 'iso-8859-8',
      \ 'csisolatinhebrew' : 'iso-8859-8',
      \ 'iso_8859-9:1989' : 'iso-8859-9',
      \ 'iso-ir-148' : 'iso-8859-9',
      \ 'iso_8859-9' : 'iso-8859-9',
      \ 'iso-8859-9' : 'iso-8859-9',
      \ 'latin5' : 'iso-8859-9',
      \ 'l5' : 'iso-8859-9',
      \ 'csisolatin5' : 'iso-8859-9',
      \ 'iso-8859-10' : 'iso-8859-10',
      \ 'iso-ir-157' : 'iso-8859-10',
      \ 'l6' : 'iso-8859-10',
      \ 'iso_8859-10:1992' : 'iso-8859-10',
      \ 'csisolatin6' : 'iso-8859-10',
      \ 'latin6' : 'iso-8859-10',
      \ 'iso-8859-13' : 'iso-8859-13',
      \ 'iso-8859-14' : 'iso-8859-14',
      \ 'iso-ir-199' : 'iso-8859-14',
      \ 'iso_8859-14:1998' : 'iso-8859-14',
      \ 'iso_8859-14' : 'iso-8859-14',
      \ 'latin8' : 'iso-8859-14',
      \ 'iso-celtic' : 'iso-8859-14',
      \ 'l8' : 'iso-8859-14',
      \ 'iso-8859-15' : 'iso-8859-15',
      \ 'iso_8859-15' : 'iso-8859-15',
      \ 'latin-9' : 'iso-8859-15',
      \ 'koi8-r' : 'koi8-r',
      \ 'cskoi8r' : 'koi8-r',
      \ 'koi8-u' : 'koi8-u',
      \ 'macintosh' : 'macroman',
      \ 'mac' : 'macroman',
      \ 'csmacintosh' : 'macroman',
      \ 'ibm437' : 'cp437',
      \ 'cp437' : 'cp437',
      \ '437' : 'cp437',
      \ 'cspc8codepage437' : 'cp437',
      \ 'ibm775' : 'cp775',
      \ 'cp775' : 'cp775',
      \ 'cspc775baltic' : 'cp775',
      \ 'ibm850' : 'cp850',
      \ 'cp850' : 'cp850',
      \ '850' : 'cp850',
      \ 'cspc850multilingual' : 'cp850',
      \ 'ibm852' : 'cp852',
      \ 'cp852' : 'cp852',
      \ '852' : 'cp852',
      \ 'cspcp852' : 'cp852',
      \ 'ibm855' : 'cp855',
      \ 'cp855' : 'cp855',
      \ '855' : 'cp855',
      \ 'csibm855' : 'cp855',
      \ 'ibm857' : 'cp857',
      \ 'cp857' : 'cp857',
      \ '857' : 'cp857',
      \ 'csibm857' : 'cp857',
      \ 'ibm860' : 'cp860',
      \ 'cp860' : 'cp860',
      \ '860' : 'cp860',
      \ 'csibm860' : 'cp860',
      \ 'ibm861' : 'cp861',
      \ 'cp861' : 'cp861',
      \ '861' : 'cp861',
      \ 'cp-is' : 'cp861',
      \ 'csibm861' : 'cp861',
      \ 'ibm862' : 'cp862',
      \ 'cp862' : 'cp862',
      \ '862' : 'cp862',
      \ 'cspc862latinhebrew' : 'cp862',
      \ 'ibm863' : 'cp863',
      \ 'cp863' : 'cp863',
      \ '863' : 'cp863',
      \ 'csibm863' : 'cp863',
      \ 'ibm865' : 'cp865',
      \ 'cp865' : 'cp865',
      \ '865' : 'cp865',
      \ 'csibm865' : 'cp865',
      \ 'ibm866' : 'cp866',
      \ 'cp866' : 'cp866',
      \ '866' : 'cp866',
      \ 'csibm866' : 'cp866',
      \ 'ibm869' : 'cp869',
      \ 'cp869' : 'cp869',
      \ '869' : 'cp869',
      \ 'cp-gr' : 'cp869',
      \ 'csibm869' : 'cp869',
      \ 'windows-1250' : 'cp1250',
      \ 'windows-1251' : 'cp1251',
      \ 'windows-1253' : 'cp1253',
      \ 'windows-1254' : 'cp1254',
      \ 'windows-1255' : 'cp1255',
      \ 'windows-1256' : 'cp1256',
      \ 'windows-1257' : 'cp1257',
      \ 'windows-1258' : 'cp1258',
      \ 'extended_unix_code_packed_format_for_japanese' : 'euc-jp',
      \ 'cseucpkdfmtjapanese' : 'euc-jp',
      \ 'euc-jp' : 'euc-jp',
      \ 'shift_jis' : 'sjis',
      \ 'ms_kanji' : 'sjis',
      \ 'sjis' : 'sjis',
      \ 'csshiftjis' : 'sjis',
      \ 'ibm-thai' : 'cp874',
      \ 'csibmthai' : 'cp874',
      \ 'ks_c_5601-1987' : 'cp949',
      \ 'iso-ir-149' : 'cp949',
      \ 'ks_c_5601-1989' : 'cp949',
      \ 'ksc_5601' : 'cp949',
      \ 'korean' : 'cp949',
      \ 'csksc56011987' : 'cp949',
      \ 'euc-kr' : 'euc-kr',
      \ 'cseuckr' : 'euc-kr',
      \ 'gbk' : 'cp936',
      \ 'cp936' : 'cp936',
      \ 'ms936' : 'cp936',
      \ 'windows-936' : 'cp936',
      \ 'gb_2312-80' : 'euc-cn',
      \ 'iso-ir-58' : 'euc-cn',
      \ 'chinese' : 'euc-cn',
      \ 'csiso58gb231280' : 'euc-cn',
      \ 'big5' : 'big5',
      \ 'csbig5' : 'big5',
      \ 'utf-8' : 'utf-8',
      \ 'iso-10646-ucs-2' : 'ucs-2',
      \ 'csunicode' : 'ucs-2',
      \ 'utf-16' : 'utf-16',
      \ 'utf-16be' : 'utf-16',
      \ 'utf-16le' : 'utf-16le',
      \ 'utf-32' : 'ucs-4',
      \ 'utf-32be' : 'ucs-4',
      \ 'utf-32le' : 'ucs-4le',
      \ 'iso-10646-ucs-4' : 'ucs-4',
      \ 'csucs4' : 'ucs-4'
      \ }
lockvar g:tohtml#charset_to_encoding
"}}}

func! tohtml#Convert2HTML(line1, line2) "{{{
  let s:settings = tohtml#GetUserSettings()

  if !&diff || s:settings.diff_one_file "{{{
    if a:line2 >= a:line1
      let g:html_start_line = a:line1
      let g:html_end_line = a:line2
    else
      let g:html_start_line = a:line2
      let g:html_end_line = a:line1
    endif
    runtime syntax/2html.vim "}}}
  else "{{{
    let win_list = []
    let buf_list = []
    windo if &diff | call add(win_list, winbufnr(0)) | endif
    let s:settings.whole_filler = 1
    let g:html_diff_win_num = 0
    for window in win_list
      " switch to the next buffer to convert
      exe ":" . bufwinnr(window) . "wincmd w"

      " figure out whether current charset and encoding will work, if not
      " default to UTF-8
      if !exists('g:html_use_encoding') &&
	    \ (((&l:fileencoding=='' || (&l:buftype!='' && &l:buftype!=?'help'))
	    \      && &encoding!=?s:settings.vim_encoding)
	    \ || &l:fileencoding!='' && &l:fileencoding!=?s:settings.vim_encoding)
	echohl WarningMsg
	echomsg "TOhtml: mismatched file encodings in Diff buffers, using UTF-8"
	echohl None
	let s:settings.vim_encoding = 'utf-8'
	let s:settings.encoding = 'UTF-8'
      endif

      " set up for diff-mode conversion
      let g:html_start_line = 1
      let g:html_end_line = line('$')
      let g:html_diff_win_num += 1

      " convert this file
      runtime syntax/2html.vim

      " remember the HTML buffer for later combination
      call add(buf_list, bufnr('%'))
    endfor
    unlet g:html_diff_win_num
    call tohtml#Diff2HTML(win_list, buf_list)
  endif "}}}

  unlet g:html_start_line
  unlet g:html_end_line
  unlet s:settings
endfunc "}}}

func! tohtml#Diff2HTML(win_list, buf_list) "{{{
  let xml_line = ""
  let tag_close = '>'

  let s:old_paste = &paste
  set paste
  let s:old_magic = &magic
  set magic

  if s:settings.use_xhtml
    if s:settings.encoding != ""
      let xml_line = "<?xml version=\"1.0\" encoding=\"" . s:settings.encoding . "\"?>"
    else
      let xml_line = "<?xml version=\"1.0\"?>"
    endif
    let tag_close = ' />'
  endif

  let style = [s:settings.use_xhtml ? "" : '-->']
  let body_line = ''

  let html = []
  let s:html5 = 0
  if s:settings.use_xhtml
    call add(html, xml_line)
  endif
  if s:settings.use_xhtml
    call add(html, "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">")
    call add(html, '<html xmlns="http://www.w3.org/1999/xhtml">')
  elseif s:settings.use_css && !s:settings.no_pre
    call add(html, "<!DOCTYPE html>")
    call add(html, '<html>')
    let s:html5 = 1
  else
    call add(html, '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"')
    call add(html, '  "http://www.w3.org/TR/html4/loose.dtd">')
    call add(html, '<html>')
  endif
  call add(html, '<head>')

  " include encoding asp  p  p  p  p  p  p  p  p  p  p  p  p   q  q  q  q  q  q                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       close to the top as possible, but only if not already
  " contained in XML information
  if s:settings.encoding != "" && !s:settings.use_xhtml
    if s:html5
      call add(html, '<meta charset="' . s:settings.encoding . '"' . tag_close)
    else
      call add(html, "<meta http-equiv=\"content-type\" content=\"text/html; charset=" . s:settings.encoding . '"' . tag_close)
    endif
  endif

  call add(html, '<title>diff</title>')
  call add(html, '<meta name="Generator" content="Vim/'.v:version/100.'.'.v:version%100.'"'.tag_close)
  call add(html, '<meta name="plugin-version" content="'.g:loaded_2html_plugin.'"'.tag_close)
  call add(html, '<meta name="settings" content="'.
	\ join(filter(keys(s:settings),'s:settings[v:val]'),',').
	\ ',prevent_copy='.s:settings.prevent_copy.
	\ ',use_input_for_pc='.s:settings.use_input_for_pc.
	\ '"'.tag_close)
  call add(html, '<meta name="colorscheme" content="'.
	\ (exists('g:colors_name')
	\ ? g:colors_name
	\ : 'none'). '"'.tag_close)

  call add(html, '</head>')
  let body_line_num = len(html)
  call add(html, '<body'.(s:settings.line_ids ? ' onload="JumpToLine();"' : '').'>')
  call add(html, "<table ".(s:settings.use_css? "" : "border='1' width='100%' ")."id='vimCodeElement".s:settings.id_suffix."'>")

  call add(html, '<tr>')
  for buf in a:win_list
    call add(html, '<th>'.bufname(buf).'</th>')
  endfor
  call add(html, '</tr><tr>')

  let diff_style_start = 0
  let insert_index = 0

  for buf in a:buf_list
    let temp = []
    exe bufwinnr(buf) . 'wincmd w'

    " If text is folded because of user foldmethod settings, etc. we don't want
    " to act on everything in a fold by mistake.
    setlocal nofoldenable

    " When not using CSS or when using xhtml, the <body> line can be important.
    " Assume it will be the same for all buffers and grab it from the first
    " buffer. Similarly, need to grab the body end line as well.
    if body_line == ''
      1
      call search('<body')
      let body_line = getline('.')
      $
      call search('</body>', 'b')
      let s:body_end_line = getline('.')
    endif

    " Grab the style information. Some of this will be duplicated so only insert
    " it if it's not already there. {{{
    1
    let style_start = search('^<style\( type="text/css"\)\?>')
    1
    let style_end = search('^</style>')
    if style_start > 0 && style_end > 0
      let buf_styles = getline(style_start + 1, style_end - 1)
      for a_style in buf_styles
	if index(style, a_style) == -1
	  if diff_style_start == 0
	    if a_style =~ '\<Diff\(Change\|Text\|Add\|Delete\)'
	      let diff_style_start = len(style)-1
	    endif
	  endif
	  call insert(style, a_style, insert_index)
	  let insert_index += 1
	endif
      endfor
    endif " }}}

    " everything new will get added before the diff styles so diff highlight
    " properly overrides normal highlight
    if diff_style_start != 0
      let insert_index = diff_style_start
    endif

    " Delete those parts that are not needed so we can include the rest into the
    " resulting table.
    1,/^<body.*\%(\n<!--.*-->\_s\+.*id='oneCharWidth'.*\_s\+.*id='oneInputWidth'.*\_s\+.*id='oneEmWidth'\)\?\zs/d_
    $
    ?</body>?,$d_
    let temp = getline(1,'$')
    " clean out id on the main content container because we already set it on
    " the table
    let temp[0] = substitute(temp[0], " id='vimCodeElement[^']*'", "", "")
    " undo deletion of start and end part
    " so we can later save the file as valid html
    " TODO: restore using grabbed lines if undolevel is 1?
    normal! 2u
    if s:settings.use_css
      call add(html, '<td><div>')
    elseif s:settings.use_xhtml
      call add(html, '<td nowrap="nowrap" valign="top"><div>')
    else
      call add(html, '<td nowrap valign="top"><div>')
    endif
    let html += temp
    call add(html, '</div></td>')

    " Close this buffer
    " TODO: the comment above says we're going to allow saving the file
    " later...but here we discard it?
    quit!
  endfor

  let html[body_line_num] = body_line

  call add(html, '</tr>')
  call add(html, '</table>')
  call add(html, s:body_end_line)
  call add(html, '</html>')

  " The generated HTML is admittedly ugly and takes a LONG time to fold.
  " Make sure the user doesn't do syntax folding when loading a generated file,
  " using a modeline.
  call add(html, '<!-- vim: set foldmethod=manual : -->')

  let i = 1
  let name = "Diff" . (s:settings.use_xhtml ? ".xhtml" : ".html")
  " Find an unused file name if current file name is already in use
  while filereadable(name)
    let name = substitute(name, '\d*\.x\?html$', '', '') . i . '.' . fnamemodify(copy(name), ":t:e")
    let i += 1
  endwhile

  let s:ei_sav = &eventignore
  set eventignore+=FileType
  exe "topleft new " . name
  let &eventignore=s:ei_sav
  unlet s:ei_sav

  setlocal modifiable

  " just in case some user autocmd creates content in the new buffer, make sure
  " it is empty before proceeding
  %d

  " set the fileencoding to match the charset we'll be using
  let &l:fileencoding=s:settings.vim_encoding

  " According to http://www.w3.org/TR/html4/charset.html#doc-char-set, the byte
  " order mark is highly recommend on the web when using multibyte encodings. But,
  " it is not a good idea to include it on UTF-8 files. Otherwise, let Vim
  " determine when it is actually inserted.
  if s:settings.vim_encoding == 'utf-8'
    setlocal nobomb
  else
    setlocal bomb
  endif

  call append(0, html)

  if len(style) > 0
    1
    let style_start = search('^</head>')-1

    " add required javascript in reverse order so we can just call append again
    " and again without adjusting {{{

    let s:uses_script = s:settings.dynamic_folds || s:settings.line_ids

    " insert script closing tag if needed
    if s:uses_script
      call append(style_start, [
	    \ '',
	    \ s:settings.use_xhtml ? '//]]>' : '-->',
	    \ "</script>"
	    \ ])
    endif

    " insert javascript to get IDs from line numbers, and to open a fold before
    " jumping to any lines contained therein
    if s:settings.line_ids
      call append(style_start, [
	    \ "  /* Always jump to new location even if the line was hidden inside a fold, or",
	    \ "   * we corrected the raw number to a line ID.",
	    \ "   */",
	    \ "  if (lineElem) {",
	    \ "    lineElem.scrollIntoView(true);",
	    \ "  }",
	    \ "  return true;",
	    \ "}",
	    \ "if ('onhashchange' in window) {",
	    \ "  window.onhashchange = JumpToLine;",
	    \ "}"
	    \ ])

      if s:settings.dynamic_folds
	call append(style_start, [
	      \ "",
	      \ "  /* navigate upwards in the DOM tree to open all folds containing the line */",
	      \ "  var node = lineElem;",
	      \ "  while (node && node.id != 'vimCodeElement".s:settings.id_suffix."')",
	      \ "  {",
	      \ "    if (node.className == 'closed-fold')",
	      \ "    {",
	      \ "      /* toggle open the fold ID (remove window ID) */",
	      \ "      toggleFold(node.id.substr(4));",
	      \ "    }",
	      \ "    node = node.parentNode;",
	      \ "  }",
	      \ ])
      endif
    endif

    if s:settings.line_ids
      call append(style_start, [
	    \ "",
	    \ "/* function to open any folds containing a jumped-to line before jumping to it */",
	    \ "function JumpToLine()",
	    \ "{",
	    \ "  var lineNum;",
	    \ "  lineNum = window.location.hash;",
	    \ "  lineNum = lineNum.substr(1); /* strip off '#' */",
	    \ "",
	    \ "  if (lineNum.indexOf('L') == -1) {",
	    \ "    lineNum = 'L'+lineNum;",
	    \ "  }",
	    \ "  if (lineNum.indexOf('W') == -1) {",
	    \ "    lineNum = 'W1'+lineNum;",
	    \ "  }",
	    \ "  var lineElem = document.getElementById(lineNum);"
	    \ ])
    endif

    " Insert javascript to toggle matching folds open and closed in all windows,
    " if dynamic folding is active.
    if s:settings.dynamic_folds
      call append(style_start, [
	    \  "  function toggleFold(objID)",
	    \  "  {",
	    \  "    for (win_num = 1; win_num <= ".len(a:buf_list)."; win_num++)",
	    \  "    {",
	    \  "      var fold;",
	    \  '      fold = document.getElementById("win"+win_num+objID);',
	    \  "      if(fold.className == 'closed-fold')",
	    \  "      {",
	    \  "        fold.className = 'open-fold';",
	    \  "      }",
	    \  "      else if (fold.className == 'open-fold')",
	    \  "      {",
	    \  "        fold.className = 'closed-fold';",
	    \  "      }",
	    \  "    }",
	    \  "  }",
	    \ ])
    endif

    if s:uses_script
      " insert script tag if needed
      call append(style_start, [
	    \ "<script" . (s:html5 ? "" : " type='text/javascript'") . ">",
	    \ s:settings.use_xhtml ? '//<![CDATA[' : "<!--"])
    endif

    " Insert styles from all the generated html documents and additional styles
    " for the table-based layout of the side-by-side diff. The diff should take
    " up the full browser window (but not more), and be static in size,
    " horizontally scrollable when the lines are too long. Otherwise, the diff
    " is pretty useless for really long lines. {{{
    if s:settings.use_css
      call append(style_start,
	    \ ['<style' . (s:html5 ? '' : 'type="text/css"') . '>']+
	    \ style+
	    \ [ s:settings.use_xhtml ? '' : '<!--',
	    \   'table { table-layout: fixed; }',
	    \   'html, body, table, tbody { width: 100%; margin: 0; padding: 0; }',
	    \   'table, td, th { border: 1px solid; }',
	    \   'td { vertical-align: top; }',
	    \   'th, td { width: '.printf("%.1f",100.0/len(a:win_list)).'%; }',
	    \   'td div { overflow: auto; }',
	    \   s:settings.use_xhtml ? '' : '-->',
	    \   '</style>'
	    \])
    endif "}}}
  endif

  let &paste = s:old_paste
  let &magic = s:old_magic
endfunc "}}}

" Gets a single user option and sets it in the passed-in Dict, or gives it the
" default value if the option doesn't actually exist.
func! tohtml#GetOption(settings, option, default) "{{{
  if exists('g:html_'.a:option)
    let a:settings[a:option] = g:html_{a:option}
  else
    let a:settings[a:option] = a:default
  endif
endfunc "}}}

" returns a Dict containing the values of all user options for 2html, including
" default values for those not given an explicit value by the user. Discards the
" html_ prefix of the option for nicer looking code.
func! tohtml#GetUserSettings() "{{{
  if exists('s:settings')
    " just restore the known options if we've already retrieved them
    return s:settings
  else
    " otherwise figure out which options are set
    let user_settings = {}

    " Define the correct option if the old option name exists and we haven't
    " already defined the correct one. Maybe I'll put out a warning message about
    " this sometime and remove the old option entirely at some even later time,
    " but for now just silently accept the old option.
    if exists('g:use_xhtml') && !exists("g:html_use_xhtml")
      let g:html_use_xhtml = g:use_xhtml
    endif

    " get current option settings with appropriate defaults {{{
    call tohtml#GetOption(user_settings,       'no_progress', !has("statusline") )
    call tohtml#GetOption(user_settings,     'diff_one_file', 0 )
    call tohtml#GetOption(user_settings,      'number_lines', &number )
    call tohtml#GetOption(user_settings,          'pre_wrap', &wrap )
    call tohtml#GetOption(user_settings,           'use_css', 1 )
    call tohtml#GetOption(user_settings,    'ignore_conceal', 0 )
    call tohtml#GetOption(user_settings,    'ignore_folding', 0 )
    call tohtml#GetOption(user_settings,     'dynamic_folds', 0 )
    call tohtml#GetOption(user_settings,     'no_foldcolumn', user_settings.ignore_folding)
    call tohtml#GetOption(user_settings,      'hover_unfold', 0 )
    call tohtml#GetOption(user_settings,            'no_pre', 0 )
    call tohtml#GetOption(user_settings,        'no_invalid', 0 )
    call tohtml#GetOption(user_settings,      'whole_filler', 0 )
    call tohtml#GetOption(user_settings,         'use_xhtml', 0 )
    call tohtml#GetOption(user_settings,          'line_ids', user_settings.number_lines )
    call tohtml#GetOption(user_settings, 'use_input_for_pc', 'fallback')
    " }}}
    
    " override those settings that need it {{{

    " hover opening implies dynamic folding
    if user_settings.hover_unfold
      let user_settings.dynamic_folds = 1
    endif

    " ignore folding overrides dynamic folding
    if user_settings.ignore_folding && user_settings.dynamic_folds
      let user_settings.dynamic_folds = 0
      let user_settings.hover_unfold = 0
    endif

    " dynamic folding with no foldcolumn implies hover opens
    if user_settings.dynamic_folds && user_settings.no_foldcolumn
      let user_settings.hover_unfold = 1
    endif

    " dynamic folding implies css
    if user_settings.dynamic_folds
      let user_settings.use_css = 1
    else
      let user_settings.no_foldcolumn = 1 " won't do anything but for consistency and for the test suite
    endif

    " if we're not using CSS we cannot use a pre section because <font> tags
    " aren't allowed inside a <pre> block
    if !user_settings.use_css
      let user_settings.no_pre = 1
    endif

    " pre_wrap doesn't do anything if not using pre or not using CSS
    if user_settings.no_pre || !user_settings.use_css
      let user_settings.pre_wrap=