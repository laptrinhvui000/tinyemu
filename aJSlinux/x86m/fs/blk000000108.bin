ppress-uniques"
    \ , "-dsuppress-var-kinds"
    \ , "-dth-dec-file="
    \ , "-dunique-increment="
    \ , "-dverbose-core2core"
    \ , "-dverbose-stg2stg"
    \ , "-falignment-sanitisation"
    \ , "-fcatch-bottoms"
    \ , "-fllvm-fill-undef-with-garbage"
    \ , "-g,"
    \ , "-fexternal-interpreter"
    \ , "-fglasgow-exts"
    \ , "-fno-glasgow-exts"
    \ , "-ghcversion-file"
    \ , "-H"
    \ , "-j[]"
    \ ]

let s:commonModules =
    \ [ "Distribution.Backpack"
    \ , "Distribution.Backpack.ComponentsGraph"
    \ , "Distribution.Backpack.Configure"
    \ , "Distribution.Backpack.ConfiguredComponent"
    \ , "Distribution.Backpack.DescribeUnitId"
    \ , "Distribution.Backpack.FullUnitId"
    \ , "Distribution.Backpack.LinkedComponent"
    \ , "Distribution.Backpack.ModSubst"
    \ , "Distribution.Backpack.ModuleShape"
    \ , "Distribution.Backpack.PreModuleShape"
    \ , "Distribution.CabalSpecVersion"
    \ , "Distribution.Compat.Binary"
    \ , "Distribution.Compat.CharParsing"
    \ , "Distribution.Compat.CreatePipe"
    \ , "Distribution.Compat.DList"
    \ , "Distribution.Compat.Directory"
    \ , "Distribution.Compat.Environment"
    \ , "Distribution.Compat.Exception"
    \ , "Distribution.Compat.Graph"
    \ , "Distribution.Compat.Internal.TempFile"
    \ , "Distribution.Compat.Lens"
    \ , "Distribution.Compat.Map.Strict"
    \ , "Distribution.Compat.Newtype"
    \ , "Distribution.Compat.Parsing"
    \ , "Distribution.Compat.Prelude.Internal"
    \ , "Distribution.Compat.ReadP"
    \ , "Distribution.Compat.Semigroup"
    \ , "Distribution.Compat.Stack"
    \ , "Distribution.Compat.Time"
    \ , "Distribution.Compiler"
    \ , "Distribution.FieldGrammar"
    \ , "Distribution.FieldGrammar.Class"
    \ , "Distribution.FieldGrammar.FieldDescrs"
    \ , "Distribution.FieldGrammar.Parsec"
    \ , "Distribution.FieldGrammar.Pretty"
    \ , "Distribution.InstalledPackageInfo"
    \ , "Distribution.License"
    \ , "Distribution.Make"
    \ , "Distribution.ModuleName"
    \ , "Distribution.Package"
    \ , "Distribution.PackageDescription"
    \ , "Distribution.PackageDescription.Check"
    \ , "Distribution.PackageDescription.Configuration"
    \ , "Distribution.PackageDescription.FieldGrammar"
    \ , "Distribution.PackageDescription.Parsec"
    \ , "Distribution.PackageDescription.PrettyPrint"
    \ , "Distribution.PackageDescription.Quirks"
    \ , "Distribution.PackageDescription.Utils"
    \ , "Distribution.ParseUtils"
    \ , "Distribution.Parsec.Class"
    \ , "Distribution.Parsec.Common"
    \ , "Distribution.Parsec.ConfVar"
    \ , "Distribution.Parsec.Field"
    \ , "Distribution.Parsec.FieldLineStream"
    \ , "Distribution.Parsec.Lexer"
    \ , "Distribution.Parsec.LexerMonad"
    \ , "Distribution.Parsec.Newtypes"
    \ , "Distribution.Parsec.ParseResult"
    \ , "Distribution.Parsec.Parser"
    \ , "Distribution.Pretty"
    \ , "Distribution.PrettyUtils"
    \ , "Distribution.ReadE"
    \ , "Distribution.SPDX"
    \ , "Distribution.SPDX.License"
    \ , "Distribution.SPDX.LicenseExceptionId"
    \ , "Distribution.SPDX.LicenseExpression"
    \ , "Distribution.SPDX.LicenseId"
    \ , "Distribution.SPDX.LicenseReference"
    \ , "Distribution.Simple"
    \ , "Distribution.Simple.Bench"
    \ , "Distribution.Simple.Build"
    \ , "Distribution.Simple.Build.Macros"
    \ , "Distribution.Simple.Build.PathsModule"
    \ , "Distribution.Simple.BuildPaths"
    \ , "Distribution.Simple.BuildTarget"
    \ , "Distribution.Simple.BuildToolDepends"
    \ , "Distribution.Simple.CCompiler"
    \ , "Distribution.Simple.Command"
    \ , "Distribution.Simple.Compiler"
    \ , "Distribution.Simple.Configure"
    \ , "Distribution.Simple.Doctest"
    \ , "Distribution.Simple.GHC"
    \ , "Distribution.Simple.GHCJS"
    \ , "Distribution.Simple.Haddock"
    \ , "Distribution.Simple.HaskellSuite"
    \ , "Distribution.Simple.Hpc"
    \ , "Distribution.Simple.Install"
    \ , "Distribution.Simple.InstallDirs"
    \ , "Distribution.Simple.JHC"
    \ , "Distribution.Simple.LHC"
    \ , "Distribution.Simple.LocalBuildInfo"
    \ , "Distribution.Simple.PackageIndex"
    \ , "Distribution.Simple.PreProcess"
    \ , "Distribution.Simple.PreProcess.Unlit"
    \ , "Distribution.Simple.Program"
    \ , "Distribution.Simple.Program.Ar"
    \ , "Distribution.Simple.Program.Builtin"
    \ , "Distribution.Simple.Program.Db"
    \ , "Distribution.Simple.Program.Find"
    \ , "Distribution.Simple.Program.GHC"
    \ , "Distribution.Simple.Program.HcPkg"
    \ , "Distribution.Simple.Program.Hpc"
    \ , "Distribution.Simple.Program.Internal"
    \ , "Distribution.Simple.Program.Ld"
    \ , "Distribution.Simple.Program.ResponseFile"
    \ , "Distribution.Simple.Program.Run"
    \ , "Distribution.Simple.Program.Script"
    \ , "Distribution.Simple.Program.Strip"
    \ , "Distribution.Simple.Program.Types"
    \ , "Distribution.Simple.Register"
    \ , "Distribution.Simple.Setup"
    \ , "Distribution.Simple.SrcDist"
    \ , "Distribution.Simple.Test"
    \ , "Distribution.Simple.Test.ExeV10"
    \ , "Distribution.Simple.Test.LibV09"
    \ , "Distribution.Simple.Test.Log"
    \ , "Distribution.Simple.UHC"
    \ , "Distribution.Simple.UserHooks"
    \ , "Distribution.Simple.Utils"
    \ , "Distribution.System"
    \ , "Distribution.TestSuite"
    \ , "Distribution.Text"
    \ , "Distribution.Types.AbiDependency"
    \ , "Distribution.Types.AbiHash"
    \ , "Distribution.Types.AnnotatedId"
    \ , "Distribution.Types.Benchmark"
    \ , "Distribution.Types.Benchmark.Lens"
    \ , "Distribution.Types.BenchmarkInterface"
    \ , "Distribution.Types.BenchmarkType"
    \ , "Distribution.Types.BuildInfo"
    \ , "Distribution.Types.BuildInfo.Lens"
    \ , "Distribution.Types.BuildType"
    \ , "Distribution.Types.Component"
    \ , "Distribution.Types.ComponentId"
    \ , "Distribution.Types.ComponentInclude"
    \ , "Distribution.Types.ComponentLocalBuildInfo"
    \ , "Distribution.Types.ComponentName"
    \ , "Distribution.Types.ComponentRequestedSpec"
    \ , "Distribution.Types.CondTree"
    \ , "Distribution.Types.Condition"
    \ , "Distribution.Types.Dependency"
    \ , "Distribution.Types.DependencyMap"
    \ , "Distribution.Types.ExeDependency"
    \ , "Distribution.Types.Executable"
    \ , "Distribution.Types.Executable.Lens"
    \ , "Distribution.Types.ExecutableScope"
    \ , "Distribution.Types.ExposedModule"
    \ , "Distribution.Types.ForeignLib"
    \ , "Distribution.Types.ForeignLib.Lens"
    \ , "Distribution.Types.ForeignLibOption"
    \ , "Distribution.Types.ForeignLibType"
    \ , "Distribution.Types.GenericPackageDescription"
    \ , "Distribution.Types.GenericPackageDescription.Lens"
    \ , "Distribution.Types.HookedBuildInfo"
    \ , "Distribution.Types.IncludeRenaming"
    \ , "Distribution.Types.InstalledPackageInfo"
    \ , "Distribution.Types.InstalledPackageInfo.FieldGrammar"
    \ , "Distribution.Types.InstalledPackageInfo.Lens"
    \ , "Distribution.Types.LegacyExeDependency"
    \ , "Distribution.Types.Lens"
    \ , "Distribution.Types.Library"
    \ , "Distribution.Types.Library.Lens"
    \ , "Distribution.Types.LocalBuildInfo"
    \ , "Distribution.Types.Mixin"
    \ , "Distribution.Types.Module"
    \ , "Distribution.Types.ModuleReexport"
    \ , "Distribution.Types.ModuleRenaming"
    \ , "Distribution.Types.MungedPackageId"
    \ , "Distribution.Types.MungedPackageName"
    \ , "Distribution.Types.PackageDescription"
    \ , "Distribution.Types.PackageDescription.Lens"
    \ , "Distribution.Types.PackageId"
    \ , "Distribution.Types.PackageId.Lens"
    \ , "Distribution.Types.PackageName"
    \ , "Distribution.Types.PkgconfigDependency"
    \ , "Distribution.Types.PkgconfigName"
    \ , "Distribution.Types.SetupBuildInfo"
    \ , "Distribution.Types.SetupBuildInfo.Lens"
    \ , "Distribution.Types.SourceRepo"
    \ , "Distribution.Types.SourceRepo.Lens"
    \ , "Distribution.Types.TargetInfo"
    \ , "Distribution.Types.TestSuite"
    \ , "Distribution.Types.TestSuite.Lens"
    \ , "Distribution.Types.TestSuiteInterface"
    \ , "Distribution.Types.TestType"
    \ , "Distribution.Types.UnitId"
    \ , "Distribution.Types.UnqualComponentName"
    \ , "Distribution.Types.Version"
    \ , "Distribution.Types.VersionInterval"
    \ , "Distribution.Types.VersionRange"
    \ , "Distribution.Utils.Generic"
    \ , "Distribution.Utils.IOData"
    \ , "Distribution.Utils.LogProgress"
    \ , "Distribution.Utils.MapAccum"
    \ , "Distribution.Utils.NubList"
    \ , "Distribution.Utils.Progress"
    \ , "Distribution.Utils.ShortText"
    \ , "Distribution.Verbosity"
    \ , "Distribution.Version"
    \ , "Language.Haskell.Extension"
    \ , "Graphics.GLU"
    \ , "Graphics.GLU.Callbacks"
    \ , "Graphics.GLU.Functions"
    \ , "Graphics.GLU.Tokens"
    \ , "Graphics.GLU.Types"
    \ , "Graphics.UI.GLUT"
    \ , "Graphics.UI.GLUT.Begin"
    \ , "Graphics.UI.GLUT.Callbacks"
    \ , "Graphics.UI.GLUT.Callbacks.Global"
    \ , "Graphics.UI.GLUT.Callbacks.Window"
    \ , "Graphics.UI.GLUT.Colormap"
    \ , "Graphics.UI.GLUT.Debugging"
    \ , "Graphics.UI.GLUT.DeviceControl"
    \ , "Graphics.UI.GLUT.Fonts"
    \ , "Graphics.UI.GLUT.GameMode"
    \ , "Graphics.UI.GLUT.Initialization"
    \ , "Graphics.UI.GLUT.Menu"
    \ , "Graphics.UI.GLUT.Objects"
    \ , "Graphics.UI.GLUT.Overlay"
    \ , "Graphics.UI.GLUT.State"
    \ , "Graphics.UI.GLUT.Window"
    \ , "Network.Browser"
    \ , "Network.BufferType"
    \ , "Network.HTTP"
    \ , "Network.HTTP.Auth"
    \ , "Network.HTTP.Base"
    \ , "Network.HTTP.Cookie"
    \ , "Network.HTTP.HandleStream"
    \ , "Network.HTTP.Headers"
    \ , "Network.HTTP.Proxy"
    \ , "Network.HTTP.Stream"
    \ , "Network.Stream"
    \ , "Network.StreamDebugger"
    \ , "Network.StreamSocket"
    \ , "Network.TCP"
    \ , "Test.HUnit"
    \ , "Test.HUnit.Base"
    \ , "Test.HUnit.Lang"
    \ , "Test.HUnit.Terminal"
    \ , "Test.HUnit.Text"
    \ , "Data.ObjectName"
    \ , "Graphics.Rendering.OpenGL"
    \ , "Graphics.Rendering.OpenGL.GL"
    \ , "Graphics.Rendering.OpenGL.GL.Antialiasing"
    \ , "Graphics.Rendering.OpenGL.GL.BeginEnd"
    \ , "Graphics.Rendering.OpenGL.GL.Bitmaps"
    \ , "Graphics.Rendering.OpenGL.GL.BufferObjects"
    \ , "Graphics.Rendering.OpenGL.GL.Clipping"
    \ , "Graphics.Rendering.OpenGL.GL.ColorSum"
    \ , "Graphics.Rendering.OpenGL.GL.Colors"
    \ , "Graphics.Rendering.OpenGL.GL.ConditionalRendering"
    \ , "Graphics.Rendering.OpenGL.GL.CoordTrans"
    \ , "Graphics.Rendering.OpenGL.GL.DebugOutput"
    \ , "Graphics.Rendering.OpenGL.GL.DisplayLists"
    \ , "Graphics.Rendering.OpenGL.GL.Evaluators"
    \ , "Graphics.Rendering.OpenGL.GL.Feedback"
    \ , "Graphics.Rendering.OpenGL.GL.FlushFinish"
    \ , "Graphics.Rendering.OpenGL.GL.Fog"
    \ , "Graphics.Rendering.OpenGL.GL.Framebuffer"
    \ , "Graphics.Rendering.OpenGL.GL.FramebufferObjects"
    \ , "Graphics.Rendering.OpenGL.GL.FramebufferObjects.Attachments"
    \ , "Graphics.Rendering.OpenGL.GL.FramebufferObjects.FramebufferObjects"
    \ , "Graphics.Rendering.OpenGL.GL.FramebufferObjects.Queries"
    \ , "Graphics.Rendering.OpenGL.GL.FramebufferObjects.RenderbufferObjects"
    \ , "Graphics.Rendering.OpenGL.GL.Hints"
    \ , "Graphics.Rendering.OpenGL.GL.LineSegments"
    \ , "Graphics.Rendering.OpenGL.GL.PerFragment"
    \ , "Graphics.Rendering.OpenGL.GL.PixelRectangles"
    \ , "Graphics.Rendering.OpenGL.GL.PixelRectangles.ColorTable"
    \ , "Graphics.Rendering.OpenGL.GL.PixelRectangles.Convolution"
    \ , "Graphics.Rendering.OpenGL.GL.PixelRectangles.Histogram"
    \ , "Graphics.Rendering.OpenGL.GL.PixelRectangles.Minmax"
    \ , "Graphics.Rendering.OpenGL.GL.PixelRectangles.PixelMap"
    \ , "Graphics.Rendering.OpenGL.GL.PixelRectangles.PixelStorage"
    \ , "Graphics.Rendering.OpenGL.GL.PixelRectangles.PixelTransfer"
    \ , "Graphics.Rendering.OpenGL.GL.PixelRectangles.Rasterization"
    \ , "Graphics.Rendering.OpenGL.GL.PixellikeObject"
    \ , "Graphics.Rendering.OpenGL.GL.Points"
    \ , "Graphics.Rendering.OpenGL.GL.Polygons"
    \ , "Graphics.Rendering.OpenGL.GL.PrimitiveMode"
    \ , "Graphics.Rendering.OpenGL.GL.QueryObjects"
    \ , "Graphics.Rendering.OpenGL.GL.RasterPos"
    \ , "Graphics.Rendering.OpenGL.GL.ReadCopyPixels"
    \ , "Graphics.Rendering.OpenGL.GL.Rectangles"
    \ , "Graphics.Rendering.OpenGL.GL.SavingState"
    \ , "Graphics.Rendering.OpenGL.GL.Selection"
    \ , "Graphics.Rendering.OpenGL.GL.Shaders"
    \ , "Graphics.Rendering.OpenGL.GL.Shaders.Attribs"
    \ , "Graphics.Rendering.OpenGL.GL.Shaders.Limits"
    \ , "Graphics.Rendering.OpenGL.GL.Shaders.ProgramBinaries"
    \ , "Graphics.Rendering.OpenGL.GL.Shaders.ProgramObjects"
    \ , "Graphics.Rendering.OpenGL.GL.Shaders.ShaderBinaries"
    \ , "Graphics.Rendering.OpenGL.GL.Shaders.ShaderObjects"
    \ , "Graphics.Rendering.OpenGL.GL.Shaders.Uniform"
    \ , "Graphics.Rendering.OpenGL.GL.StringQueries"
    \ , "Graphics.Rendering.OpenGL.GL.SyncObjects"
    \ , "Graphics.Rendering.OpenGL.GL.Tensor"
    \ , "Graphics.Rendering.OpenGL.GL.Texturing"
    \ , "Graphics.Rendering.OpenGL.GL.Texturing.Application"
    \ , "Graphics.Rendering.OpenGL.GL.Texturing.Environments"
    \ , "Graphics.Rendering.OpenGL.GL.Texturing.Objects"
    \ , "Graphics.Rendering.OpenGL.GL.Texturing.Parameters"
    \ , "Graphics.Rendering.OpenGL.GL.Texturing.Queries"
    \ , "Graphics.Rendering.OpenGL.GL.Texturing.Specification"
    \ , "Graphics.Rendering.OpenGL.GL.TransformFeedback"
    \ , "Graphics.Rendering.OpenGL.GL.VertexArrayObjects"
    \ , "Graphics.Rendering.OpenGL.GL.VertexArrays"
    \ , "Graphics.Rendering.OpenGL.GL.VertexSpec"
    \ , "Graphics.Rendering.OpenGL.GLU"
    \ , "Graphics.Rendering.OpenGL.GLU.Errors"
    \ , "Graphics.Rendering.OpenGL.GLU.Initialization"
    \ , "Graphics.Rendering.OpenGL.GLU.Matrix"
    \ , "Graphics.Rendering.OpenGL.GLU.Mipmapping"
    \ , "Graphics.Rendering.OpenGL.GLU.NURBS"
    \ , "Graphics.Rendering.OpenGL.GLU.Quadrics"
    \ , "Graphics.Rendering.OpenGL.GLU.Tessellation"
    \ , "Graphics.GL"
    \ , "Graphics.GL.AMD"
    \ , "Graphics.GL.AMD.BlendMinmaxFactor"
    \ , "Graphics.GL.AMD.DebugOutput"
    \ , "Graphics.GL.AMD.DepthClampSeparate"
    \ , "Graphics.GL.AMD.DrawBuffersBlend"
    \ , "Graphics.GL.AMD.FramebufferMultisampleAdvanced"
    \ , "Graphics.GL.AMD.FramebufferSamplePositions"
    \ , "Graphics.GL.AMD.GPUShaderHalfFloat"
    \ , "Graphics.GL.AMD.GPUShaderInt64"
    \ , "Graphics.GL.AMD.InterleavedElements"
    \ , "Graphics.GL.AMD.MultiDrawIndirect"
    \ , "Graphics.GL.AMD.NameGenDelete"
    \ , "Graphics.GL.AMD.OcclusionQueryEvent"
    \ , "Graphics.GL.AMD.PerformanceMonitor"
    \ , "Graphics.GL.AMD.PinnedMemory"
    \ , "Graphics.GL.AMD.QueryBufferObject"
    \ , "Graphics.GL.AMD.SamplePositions"
    \ , "Graphics.GL.AMD.SeamlessCubemapPerTexture"
    \ , "Graphics.GL.AMD.SparseTexture"
    \ , "Graphics.GL.AMD.StencilOperationExtended"
    \ , "Graphics.GL.AMD.TransformFeedback4"
    \ , "Graphics.GL.AMD.VertexShaderTessellator"
    \ , "Graphics.GL.APPLE"
    \ , "Graphics.GL.APPLE.AuxDepthStencil"
    \ , "Graphics.GL.APPLE.ClientStorage"
    \ , "Graphics.GL.APPLE.ElementArray"
    \ , "Graphics.GL.APPLE.Fence"
    \ , "Graphics.GL.APPLE.FloatPixels"
    \ , "Graphics.GL.APPLE.FlushBufferRange"
    \ , "Graphics.GL.APPLE.ObjectPurgeable"
    \ , "Graphics.GL.APPLE.RGB422"
    \ , "Graphics.GL.APPLE.RowBytes"
    \ , "Graphics.GL.APPLE.SpecularVector"
    \ , "Graphics.GL.APPLE.TextureRange"
    \ , "Graphics.GL.APPLE.TransformHint"
    \ , "Graphics.GL.APPLE.VertexArrayObject"
    \ , "Graphics.GL.APPLE.VertexArrayRange"
    \ , "Graphics.GL.APPLE.VertexProgramEvaluators"
    \ , "Graphics.GL.APPLE.YCbCr422"
    \ , "Graphics.GL.ARB"
    \ , "Graphics.GL.ARB.BaseInstance"
    \ , "Graphics.GL.ARB.BindlessTexture"
    \ , "Graphics.GL.ARB.BlendFuncExtended"
    \ , "Graphics.GL.ARB.BufferStorage"
    \ , "Graphics.GL.ARB.CLEvent"
    \ , "Graphics.GL.ARB.ClearBufferObject"
    \ , "Graphics.GL.ARB.ClearTexture"
    \ , "Graphics.GL.ARB.ClipControl"
    \ , "Graphics.GL.ARB.ColorBufferFloat"
    \ , "Graphics.GL.ARB.CompressedTexturePixelStorage"
    \ , "Graphics.GL.ARB.ComputeShader"
    \ , "Graphics.GL.ARB.ComputeVariableGroupSize"
    \ , "Graphics.GL.ARB.ConditionalRenderInverted"
    \ , "Graphics.GL.ARB.CopyBuffer"
    \ , "Graphics.GL.ARB.CopyImage"
    \ , "Graphics.GL.ARB.CullDistance"
    \ , "Graphics.GL.ARB.DebugOutput"
    \ , "Graphics.GL.ARB.DepthBufferFloat"
    \ , "Graphics.GL.ARB.DepthClamp"
    \ , "Graphics.GL.ARB.DepthTexture"
    \ , "Graphics.GL.ARB.DirectStateAccess"
    \ , "Graphics.GL.ARB.DrawBuffers"
    \ , "Graphics.GL.ARB.DrawBuffersBlend"
    \ , "Graphics.GL.ARB.DrawElementsBaseVertex"
    \ , "Graphics.GL.ARB.DrawIndirect"
    \ , "Graphics.GL.ARB.DrawInstanced"
    \ , "Graphics.GL.ARB.ES2Compatibility"
    \ , "Graphics.GL.ARB.ES31Compatibility"
    \ , "Graphics.GL.ARB.ES32Compatibility"
    \ , "Graphics.GL.ARB.ES3Compatibility"
    \ , "Graphics.GL.ARB.EnhancedLayouts"
    \ , "Graphics.GL.ARB.ExplicitUniformLocation"
    \ , "Graphics.GL.ARB.FragmentProgram"
    \ , "Graphics.GL.ARB.FragmentShader"
    \ , "Graphics.GL.ARB.FramebufferNoAttachments"
    \ , "Graphics.GL.ARB.FramebufferObjectCompatibility"
    \ , "Graphics.GL.ARB.FramebufferObjectCore"
    \ , "Graphics.GL.ARB.FramebufferSRGB"
    \ , "Graphics.GL.ARB.GPUShader5"
    \ , "Graphics.GL.ARB.GPUShaderFP64"
    \ , "Graphics.GL.ARB.GPUShaderInt64"
    \ , "Graphics.GL.ARB.GeometryShader4"
    \ , "Graphics.GL.ARB.GetProgramBinary"
    \ , "Graphics.GL.ARB.GetTextureSubImage"
    \ , "Graphics.GL.ARB.GlSpirv"
    \ , "Graphics.GL.ARB.HalfFloatPixel"
    \ , "Graphics.GL.ARB.HalfFloatVertex"
    \ , "Graphics.GL.ARB.ImagingCompatibility"
    \ , "Graphics.GL.ARB.ImagingCore"
    \ , "Graphics.GL.ARB.IndirectParameters"
    \ , "Graphics.GL.ARB.InstancedArrays"
    \ , "Graphics.GL.ARB.InternalformatQuery"
    \ , "Graphics.GL.ARB.InternalformatQuery2"
    \ , "Graphics.GL.ARB.InvalidateSubdata"
    \ , "Graphics.GL.ARB.MapBufferAlignment"
    \ , "Graphics.GL.ARB.MapBufferRange"
    \ , "Graphics.GL.ARB.MatrixPalette"
    \ , "Graphics.GL.ARB.MultiBind"
    \ , "Graphics.GL.ARB.MultiDrawIndirect"
    \ , "Graphics.GL.ARB.Multisample"
    \ , "Graphics.GL.ARB.Multitexture"
    \ , "Graphics.GL.ARB.OcclusionQuery"
    \ , "Graphics.GL.ARB.OcclusionQuery2"
    \ , "Graphics.GL.ARB.ParallelShaderCompile"
    \ , "Graphics.GL.ARB.PipelineStatisticsQuery"
    \ , "Graphics.GL.ARB.PixelBufferObject"
    \ , "Graphics.GL.ARB.PointParameters"
    \ , "Graphics.GL.ARB.PointSprite"
    \ , "Graphics.GL.ARB.PolygonOffsetClamp"
    \ , "Graphics.GL.ARB.ProgramInterfaceQuery"
    \ , "Graphics.GL.ARB.ProvokingVertex"
    \ , "Graphics.GL.ARB.QueryBufferObject"
    \ , "Graphics.GL.ARB.RobustnessCompatibility"
    \ , "Graphics.GL.ARB.RobustnessCore"
    \ , "Graphics.GL.ARB.SampleLocations"
    \ , "Graphics.GL.ARB.SampleShading"
    \ , "Graphics.GL.ARB.SamplerObjects"
    \ , "Graphics.GL.ARB.SeamlessCubeMap"
    \ , "Graphics.GL.ARB.SeamlessCubemapPerTexture"
    \ , "Graphics.GL.ARB.SeparateShaderObjects"
    \ , "Graphics.GL.ARB.ShaderAtomicCounters"
    \ , "Graphics.GL.ARB.ShaderImageLoadStore"
    \ , "Graphics.GL.ARB.ShaderObjects"
    \ , "Graphics.GL.ARB.ShaderStorageBufferObject"
    \ , "Graphics.GL.ARB.ShaderSubroutine"
    \ , "Graphics.GL.ARB.ShadingLanguage100"
    \ , "Graphics.GL.ARB.ShadingLanguageInclude"
    \ , "Graphics.GL.ARB.Shadow"
    \ , "Graphics.GL.ARB.ShadowAmbient"
    \ , "Graphics.GL.ARB.SparseBuffer"
    \ , "Graphics.GL.ARB.SparseTexture"
    \ , "Graphics.GL.ARB.SpirvExtensions"
    \ , "Graphics.GL.ARB.StencilTexturing"
    \ , "Graphics.GL.ARB.Sync"
    \ , "Graphics.GL.ARB.TessellationShader"
    \ , "Graphics.GL.ARB.TextureBarrier"
    \ , "Graphics.GL.ARB.TextureBorderClamp"
    \ , "Graphics.GL.ARB.TextureBufferObject"
    \ , "Graphics.GL.ARB.TextureBufferObjectRGB32"
    \ , "Graphics.GL.ARB.TextureBufferRange"
    \ , "Graphics.GL.ARB.TextureCompression"
    \ , "Graphics.GL.ARB.TextureCompressionBPTC"
    \ , "Graphics.GL.ARB.TextureCompressionRGTC"
    \ , "Graphics.GL.ARB.TextureCubeMap"
    \ , "Graphics.GL.ARB.TextureCubeMapArray"
    \ , "Graphics.GL.ARB.TextureEnvCombine"
    \ , "Graphics.GL.ARB.TextureEnvDot3"
    \ , "Graphics.GL.ARB.TextureFilterAnisotropic"
    \ , "Graphics.GL.ARB.TextureFilterMinmax"
    \ , "Graphics.GL.ARB.TextureFloat"
    \ , "Graphics.GL.ARB.TextureGather"
    \ , "Graphics.GL.ARB.TextureMirrorClampToEdge"
    \ , "Graphics.GL.ARB.TextureMirroredRepeat"
    \ , "Graphics.GL.ARB.TextureMultisample"
    \ , "Graphics.GL.ARB.TextureRG"
    \ , "Graphics.GL.ARB.TextureRGB10A2UI"
    \ , "Graphics.GL.ARB.TextureRectangle"
    \ , "Graphics.GL.ARB.TextureStencil8"
    \ , "Graphics.GL.ARB.TextureStorage"
    \ , "Graphics.GL.ARB.TextureStorageMultisample"
    \ , "Graphics.GL.ARB.TextureSwizzle"
    \ , "Graphics.GL.ARB.TextureView"
    \ , "Graphics.GL.ARB.TimerQuery"
    \ , "Graphics.GL.ARB.TransformFeedback2"
    \ , "Graphics.GL.ARB.TransformFeedback3"
    \ , "Graphics.GL.ARB.TransformFeedbackInstanced"
    \ , "Graphics.GL.ARB.TransformFeedbackOverflowQuery"
    \ , "Graphics.GL.ARB.TransposeMatrix"
    \ , "Graphics.GL.ARB.UniformBufferObject"
    \ , "Graphics.GL.ARB.VertexArrayBGRA"
    \ , "Graphics.GL.ARB.VertexArrayObject"
    \ , "Graphics.GL.ARB.VertexAttrib64Bit"
    \ , "Graphics.GL.ARB.VertexAttribBinding"
    \ , "Graphics.GL.ARB.VertexBlend"
    \ , "Graphics.GL.ARB.VertexBufferObject"
    \ , "Graphics.GL.ARB.VertexProgram"
    \ , "Graphics.GL.ARB.VertexShader"
    \ , "Graphics.GL.ARB.VertexType10f11f11fRev"
    \ , "Graphics.GL.ARB.VertexType2101010RevCompatibility"
    \ , "Graphics.GL.ARB.VertexType2101010RevCore"
    \ , "Graphics.GL.ARB.ViewportArray"
    \ , "Graphics.GL.ARB.WindowPos"
    \ , "Graphics.GL.ATI"
    \ , "Graphics.GL.ATI.DrawBuffers"
    \ , "Graphics.GL.ATI.ElementArray"
    \ , "Graphics.GL.ATI.EnvmapBumpmap"
    \ , "Graphics.GL.ATI.FragmentShader"
    \ , "Graphics.GL.ATI.MapObjectBuffer"
    \ , "Graphics.GL.ATI.Meminfo"
    \ , "Graphics.GL.ATI.PNTriangles"
    \ , "Graphics.GL.ATI.PixelFormatFloat"
    \ , "Graphics.GL.ATI.SeparateStencil"
    \ , "Graphics.GL.ATI.TextFragmentShader"
    \ , "Graphics.GL.ATI.TextureEnvCombine3"
    \ , "Graphics.GL.ATI.TextureFloat"
    \ , "Graphics.GL.ATI.TextureMirrorOnce"
    \ , "Graphics.GL.ATI.VertexArrayObject"
    \ , "Graphics.GL.ATI.VertexAttribArrayObject"
    \ , "Graphics.GL.ATI.VertexStreams"
    \ , "Graphics.GL.Compatibility30"
    \ , "Graphics.GL.Compatibility31"
    \ , "Graphics.GL.Compatibility32"
    \ , "Graphics.GL.Compatibility33"
    \ , "Graphics.GL.Compatibility40"
    \ , "Graphics.GL.Compatibility41"
    \ , "Graphics.GL.Compatibility42"
    \ , "Graphics.GL.Compatibility43"
    \ , "Graphics.GL.Compatibility44"
    \ , "Graphics.GL.Compatibility45"
    \ , "Graphics.GL.Compatibility46"
    \ , "Graphics.GL.Core30"
    \ , "Graphics.GL.Core31"
    \ , "Graphics.GL.Core32"
    \ , "Graphics.GL.Core33"
    \ , "Graphics.GL.Core40"
    \ , "Graphics.GL.Core41"
    \ , "Graphics.GL.Core42"
    \ , "Graphics.GL.Core43"
    \ , "Graphics.GL.Core44"
    \ , "Graphics.GL.Core45"
    \ , "Graphics.GL.Core46"
    \ , "Graphics.GL.EXT"
    \ , "Graphics.GL.EXT.ABGR"
    \ , "Graphics.GL.EXT.BGRA"
    \ , "Graphics.GL.EXT.BindableUniform"
    \ , "Graphics.GL.EXT.BlendColor"
    \ , "Graphics.GL.EXT.BlendEquationSeparate"
    \ , "Graphics.GL.EXT.BlendFuncSeparate"
    \ , "Graphics.GL.EXT.BlendMinmax"
    \ , "Graphics.GL.EXT.BlendSubtract"
    \ , "Graphics.GL.EXT.CMYKA"
    \ , "Graphics.GL.EXT.ClipVolumeHint"
    \ , "Graphics.GL.EXT.ColorSubtable"
    \ , "Graphics.GL.EXT.CompiledVertexArray"
    \ , "Graphics.GL.EXT.Convolution"
    \ , "Graphics.GL.EXT.CoordinateFrame"
    \ , "Graphics.GL.EXT.CopyTexture"
    \ , "Graphics.GL.EXT.CullVertex"
    \ , "Graphics.GL.EXT.DebugLabel"
    \ , "Graphics.GL.EXT.DebugMarker"
    \ , "Graphics.GL.EXT.DepthBoundsTest"
    \ , "Graphics.GL.EXT.DirectStateAccess"
    \ , "Graphics.GL.EXT.DrawBuffers2"
    \ , "Graphics.GL.EXT.DrawInstanced"
    \ , "Graphics.GL.EXT.DrawRangeElements"
    \ , "Graphics.GL.EXT.EglImageStorage"
    \ , "Graphics.GL.EXT.ExternalBuffer"
    \ , "Graphics.GL.EXT.FogCoord"
    \ , "Graphics.GL.EXT.FourTwoTwoPixels"
    \ , "Graphics.GL.EXT.FramebufferBlit"
    \ , "Graphics.GL.EXT.FramebufferMultisample"
    \ , "Graphics.GL.EXT.FramebufferMultisampleBlitScaled"
    \ , "Graphics.GL.EXT.FramebufferObject"
    \ , "Graphics.GL.EXT.FramebufferSRGB"
    \ , "Graphics.GL.EXT.GPUProgramParameters"
    \ , "Graphics.GL.EXT.GPUShader4"
    \ , "Graphics.GL.EXT.GeometryShader4"
    \ , "Graphics.GL.EXT.Histogram"
    \ , "Graphics.GL.EXT.IndexArrayFormats"
    \ , "Graphics.GL.EXT.IndexFunc"
    \ , "Graphics.GL.EXT.IndexMaterial"
    \ , "Graphics.GL.EXT.LightTexture"
    \ , "Graphics.GL.EXT.MemoryObject"
    \ , "Graphics.GL.EXT.MemoryObjectFd"
    \ , "Graphics.GL.EXT.MemoryObjectWin32"
    \ , "Graphics.GL.EXT.MultiDrawArrays"
    \ , "Graphics.GL.EXT.Multisample"
    \ , "Graphics.GL.EXT.PackedDepthStencil"
    \ , "Graphics.GL.EXT.PackedFloat"
    \ , "Graphics.GL.EXT.PackedPixels"
    \ , "Graphics.GL.EXT.PalettedTexture"
    \ , "Graphics.GL.EXT.PixelBufferObject"
    \ , "Graphics.GL.EXT.PixelTransform"
    \ , "Graphics.GL.EXT.PointParameters"
    \ , "Graphics.GL.EXT.PolygonOffset"
    \ , "Graphics.GL.EXT.PolygonOffsetClamp"
    \ , "Graphics.GL.EXT.ProvokingVertex"
    \ , "Graphics.GL.EXT.RasterMultisample"
    \ , "Graphics.GL.EXT.RescaleNormal"
    \ , "Graphics.GL.EXT.SecondaryColor"
    \ , "Graphics.GL.EXT.Semaphore"
    \ , "Graphics.GL.EXT.SemaphoreFd"
    \ , "Graphics.GL.EXT.SemaphoreWin32"
    \ , "Graphics.GL.EXT.SeparateShaderObjects"
    \ , "Graphics.GL.EXT.SeparateSpecularColor"
    \ , "Graphics.GL.EXT.ShaderFramebufferFetch"
    \ , "Graphics.GL.EXT.ShaderFramebufferFetchNonCoherent"
    \ , "Graphics.GL.EXT.ShaderImageLoadStore"
    \ , "Graphics.GL.EXT.SharedTexturePalette"
    \ , "Graphics.GL.EXT.StencilClearTag"
    \ , "Graphics.GL.EXT.StencilTwoSide"
    \ , "Graphics.GL.EXT.StencilWrap"
    \ , "Graphics.GL.EXT.Subtexture"
    \ , "Graphics.GL.EXT.Texture"
    \ , "Graphics.GL.EXT.Texture3D"
    \ , "Graphics.GL.EXT.TextureArray"
    \ , "Graphics.GL.EXT.TextureBufferObject"
    \ , "Graphics.GL.EXT.TextureCompressionLATC"
    \ , "Graphics.GL.EXT.TextureCompressionRGTC"
    \ , "Graphics.GL.EXT.TextureCompressionS3TC"
    \ , "Graphics.GL.EXT.TextureCubeMap"
    \ , "Graphics.GL.EXT.TextureEnvCombine"
    \ , "Graphics.GL.EXT.TextureEnvDot3"
    \ , "Graphics.GL.EXT.TextureFilterAnisotropic"
    \ , "Graphics.GL.EXT.TextureFilterMinmax"
    \ , "Graphics.GL.EXT.TextureInteger"
    \ , "Graphics.GL.EXT.TextureLODBias"
    \ , "Graphics.GL.EXT.TextureMirrorClamp"
    \ , "Graphics.GL.EXT.TextureObject"
    \ , "Graphics.GL.EXT.TexturePerturbNormal"
    \ , "Graphics.GL.EXT.TextureSNorm"
    \ , "Graphics.GL.EXT.TextureSRGB"
    \ , "Graphics.GL.EXT.TextureSRGBDecode"
    \ , "Graphics.GL.EXT.TextureSharedExponent"
    \ , "Graphics.GL.EXT.TextureSwizzle"
    \ , "Graphics.GL.EXT.TimerQuery"
    \ , "Graphics.GL.EXT.TransformFeedback"
    \ , "Graphics.GL.EXT.VertexArray"
    \ , "Graphics.GL.EXT.VertexArrayBGRA"
    \ , "Graphics.GL.EXT.VertexAttrib64Bit"
    \ , "Graphics.GL.EXT.VertexShader"
    \ , "Graphics.GL.EXT.VertexWeighting"
    \ , "Graphics.GL.EXT.Win32KeyedMutex"
    \ , "Graphics.GL.EXT.WindowRectangles"
    \ , "Graphics.GL.EXT.X11SyncObject"
    \ , "Graphics.GL.Functions"
    \ , "Graphics.GL.GREMEDY"
    \ , "Graphics.GL.GREMEDY.FrameTerminator"
    \ , "Graphics.GL.GREMEDY.StringMarker"
    \ , "Graphics.GL.GetProcAddress"
    \ , "Graphics.GL.Groups"
    \ , "Graphics.GL.HP"
    \ , "Graphics.GL.HP.ConvolutionBorderModes"
    \ , "Graphics.GL.HP.ImageTransform"
    \ , "Graphics.GL.HP.OcclusionTest"
    \ , "Graphics.GL.HP.TextureLighting"
    \ , "Graphics.GL.IBM"
    \ , "Graphics.GL.IBM.CullVertex"
    \ , "Graphics.GL.IBM.MultimodeDrawArrays"
    \ , "Graphics.GL.IBM.RasterposClip"
    \ , "Graphics.GL.IBM.StaticData"
    \ , "Graphics.GL.IBM.TextureMirroredRepeat"
    \ , "Graphics.GL.IBM.VertexArrayLists"
    \ , "Graphics.GL.INGR"
    \ , "Graphics.GL.INGR.BlendFuncSeparate"
    \ , "Graphics.GL.INGR.ColorClamp"
    \ , "Graphics.GL.INGR.InterlaceRead"
    \ , "Graphics.GL.INTEL"
    \ , "Graphics.GL.INTEL.BlackholeRender"
    \ , "Graphics.GL.INTEL.ConservativeRasterization"
    \ , "Graphics.GL.INTEL.FramebufferCmaa"
    \ , "Graphics.GL.INTEL.MapTexture"
    \ , "Graphics.GL.INTEL.ParallelArrays"
    \ , "Graphics.GL.INTEL.PerformanceQuery"
    \ , "Graphics.GL.KHR"
    \ , "Graphics.GL.KHR.BlendEquationAdvanced"
    \ , "Graphics.GL.KHR.BlendEquationAdvancedCoherent"
    \ , "Graphics.GL.KHR.ContextFlushControl"
    \ , "Graphics.GL.KHR.DebugCompatibility"
    \ , "Graphics.GL.KHR.DebugCore"
    \ , "Graphics.GL.KHR.NoError"
    \ , "Graphics.GL.KHR.ParallelShaderCompile"
    \ , "Graphics.GL.KHR.Robustness"
    \ , "Graphics.GL.KHR.TextureCompressionASTCHDR"
    \ , "Graphics.GL.KHR.TextureCompressionASTCLDR"
    \ , "Graphics.GL.MESA"
    \ , "Graphics.GL.MESA.PackInvert"
    \ , "Graphics.GL.MESA.ProgramBinaryFormats"
    \ , "Graphics.GL.MESA.ResizeBuffers"
    \ , "Graphics.GL.MESA.TileRasterOrder"
    \ , "Graphics.GL.MESA.WindowPos"
    \ , "Graphics.GL.MESA.YCbCrTexture"
    \ , "Graphics.GL.MESAX"
    \ , "Graphics.GL.MESAX.TextureStack"
    \ , "Graphics.GL.NV"
    \ , "Graphics.GL.NV.AlphaToCoverageDitherControl"
    \ , "Graphics.GL.NV.BindlessMultiDrawIndirect"
    \ , "Graphics.GL.NV.BindlessMultiDrawIndirectCount"
    \ , "Graphics.GL.NV.BindlessTexture"
    \ , "Graphics.GL.NV.BlendEquationAdvanced"
    \ , "Graphics.GL.NV.BlendEquationAdvancedCoherent"
    \ , "Graphics.GL.NV.BlendMinmaxFactor"
    \ , "Graphics.GL.NV.ClipSpaceWScaling"
    \ , "Graphics.GL.NV.CommandList"
    \ , "Graphics.GL.NV.ComputeProgram5"
    \ , "Graphics.GL.NV.ConditionalRender"
    \ , "Graphics.GL.NV.ConservativeRaster"
    \ , "Graphics.GL.NV.ConservativeRasterDilate"
    \ , "Graphics.GL.NV.ConservativeRasterPreSnap"
    \ , "Graphics.GL.NV.ConservativeRasterPreSnapTriangles"
    \ , "Graphics.GL.NV.CopyDepthToColor"
    \ , "Graphics.GL.NV.CopyImage"
    \ , "Graphics.GL.NV.DeepTexture3D"
    \ , "Graphics.GL.NV.DepthBufferFloat"
    \ , "Graphics.GL.NV.DepthClamp"
    \ , "Graphics.GL.NV.DrawTexture"
    \ , "Graphics.GL.NV.DrawVulkanImage"
    \ , "Graphics.GL.NV.Evaluators"
    \ , "Graphics.GL.NV.ExplicitMultisample"
    \ , "Graphics.GL.NV.Fence"
    \ , "Graphics.GL.NV.FillRectangle"
    \ , "Graphics.GL.NV.FloatBuffer"
    \ , "Graphics.GL.NV.FogDistance"
    \ , "Graphics.GL.NV.FragmentCoverageToColor"
    \ , "Graphics.GL.NV.FragmentProgram"
    \ , "Graphics.GL.NV.FragmentProgram2"
    \ , "Graphics.GL.NV.FramebufferMixedSamples"
    \ , "Graphics.GL.NV.FramebufferMultisampleCoverage"
    \ , "Graphics.GL.NV.GPUMulticast"
    \ , "Graphics.GL.NV.GPUProgram4"
    \ , "Graphics.GL.NV.GPUProgram5"
    \ , "Graphics.GL.NV.GPUShader5"
    \ , "Graphics.GL.NV.GeometryProgram4"
    \ , "Graphics.GL.NV.HalfFloat"
    \ , "Graphics.GL.NV.InternalformatSampleQuery"
    \ , "Graphics.GL.NV.LightMaxExponent"
    \ , "Graphics.GL.NV.MultisampleCoverage"
    \ , "Graphics.GL.NV.MultisampleFilterHint"
    \ , "Graphics.GL.NV.OcclusionQuery"
    \ , "Graphics.GL.NV.PackedDepthStencil"
    \ , "Graphics.GL.NV.ParameterBufferObject"
    \ , "Graphics.GL.NV.PathRenderingCompatibility"
    \ , "Graphics.GL.NV.PathRenderingCore"
    \ , "Graphics.GL.NV.PathRenderingSharedEdge"
    \ , "Graphics.GL.NV.PixelDataRange"
    \ , "Graphics.GL.NV.PointSprite"
    \ , "Graphics.GL.NV.PresentVideo"
    \ , "Graphics.GL.NV.PrimitiveRestart"
    \ , "Graphics.GL.NV.QueryResource"
    \ , "Graphics.GL.NV.QueryResourceTag"
    \ , "Graphics.GL.NV.RegisterCombiners"
    \ , "Graphics.GL.NV.RegisterCombiners2"
    \ , "Graphics.GL.NV.RobustnessVideoMemoryPurge"
    \ , "Graphics.GL.NV.SampleLocations"
    \ , "Graphics.GL.NV.ShaderBufferLoad"
    \ , "Graphics.GL.NV.ShaderBufferStore"
    \ , "Graphics.GL.NV.ShaderThreadGroup"
    \ , "Graphics.GL.NV.TessellationProgram5"
    \ , "Graphics.GL.NV.TexgenEmboss"
    \ , "Graphics.GL.NV.TexgenReflection"
    \ , "Graphics.GL.NV.TextureBarrier"
    \ , "Graphics.GL.NV.TextureEnvCombine4"
    \ , "Graphics.GL.NV.TextureExpandNormal"
    \ , "Graphics.GL.NV.TextureMultisample"
    \ , "Graphics.GL.NV.TextureRectangle"
    \ , "Graphics.GL.NV.TextureShader"
    \ , "Graphics.GL.NV.TextureShader2"
    \ , "Graphics.GL.NV.TextureShader3"
    \ , "Graphics.GL.NV.TransformFeedback"
    \ , "Graphics.GL.NV.TransformFeedback2"
    \ , "Graphics.GL.NV.UniformBufferUnifiedMemory"
    \ , "Graphics.GL.NV.VDPAUInterop"
    \ , "Graphics.GL.NV.VertexArrayRange"
    \ , "Graphics.GL.NV.VertexArrayRange2"
    \ , "Graphics.GL.NV.VertexAttribInteger64Bit"
    \ , "Graphics.GL.NV.VertexBufferUnifiedMemory"
    \ , "Graphics.GL.NV.VertexProgram"
    \ , "Graphics.GL.NV.VertexProgram2Option"
    \ , "Graphics.GL.NV.VertexProgram3"
    \ , "Graphics.GL.NV.VertexProgram4"
    \ , "Graphics.GL.NV.VideoCapture"
    \ , "Graphics.GL.NV.ViewportSwizzle"
    \ , "Graphics.GL.NVX"
    \ , "Graphics.GL.NVX.ConditionalRender"
    \ , "Graphics.GL.NVX.GPUMemoryInfo"
    \ , "Graphics.GL.NVX.LinkedGPUMulticast"
    \ , "Graphics.GL.OES"
    \ , "Graphics.GL.OES.ByteCoordinates"
    \ , "Graphics.GL.OES.CompressedPalettedTexture"
    \ , "Graphics.GL.OES.FixedPoint"
    \ , "Graphics.GL.OES.QueryMatrix"
    \ , "Graphics.GL.OES.ReadFormat"
    \ , "Graphics.GL.OES.SinglePrecision"
    \ , "Graphics.GL.OML"
    \ , "Graphics.GL.OML.Interlace"
    \ , "Graphics.GL.OML.Resample"
    \ , "Graphics.GL.OML.Subsample"
    \ , "Graphics.GL.OVR"
    \ , "Graphics.GL.OVR.Multiview"
    \ , "Graphics.GL.PGI"
    \ , "Graphics.GL.PGI.MiscHints"
    \ , "Graphics.GL.PGI.VertexHints"
    \ , "Graphics.GL.REND"
    \ , "Graphics.GL.REND.ScreenCoordinates"
    \ , "Graphics.GL.S3"
    \ , "Graphics.GL.S3.S3TC"
    \ , "Graphics.GL.SGI"
    \ , "Graphics.GL.SGI.ColorMatrix"
    \ , "Graphics.GL.SGI.ColorTable"
    \ , "Graphics.GL.SGI.TextureColorTable"
    \ , "Graphics.GL.SGIS"
    \ , "Graphics.GL.SGIS.DetailTexture"
    \ , "Graphics.GL.SGIS.FogFunction"
    \ , "Graphics.GL.SGIS.GenerateMipmap"
    \ , "Graphics.GL.SGIS.Multisample"
    \ , "Graphics.GL.SGIS.PixelTexture"
    \ , "Graphics.GL.SGIS.PointLineTexgen"
    \ , "Graphics.GL.SGIS.PointParameters"
    \ , "Graphics.GL.SGIS.SharpenTexture"
    \ , "Graphics.GL.SGIS.Texture4D"
    \ , "Graphics.GL.SGIS.TextureBorderClamp"
    \ , "Graphics.GL.SGIS.TextureColorMask"
    \ , "Graphics.GL.SGIS.TextureEdgeClamp"
    \ , "Graphics.GL.SGIS.TextureFilter4"
    \ , "Graphics.GL.SGIS.TextureLOD"
    \ , "Graphics.GL.SGIS.TextureSelect"
    \ , "Graphics.GL.SGIX"
    \ , "Graphics.GL.SGIX.Async"
    \ , "Graphics.GL.SGIX.AsyncHistogram"
    \ , "Graphics.GL.SGIX.AsyncPixel"
    \ , "Graphics.GL.SGIX.BlendAlphaMinmax"
    \ , "Graphics.GL.SGIX.CalligraphicFragment"
    \ , "Graphics.GL.SGIX.Clipmap"
    \ , "Graphics.GL.SGIX.ConvolutionAccuracy"
    \ , "Graphics.GL.SGIX.DepthTexture"
    \ , "Graphics.GL.SGIX.FlushRaster"
    \ , "Graphics.GL.SGIX.FogOffset"
    \ , "Graphics.GL.SGIX.FragmentLighting"
    \ , "Graphics.GL.SGIX.Framezoom"
    \ , "Graphics.GL.SGIX.IglooInterface"
    \ , "Graphics.GL.SGIX.Instruments"
    \ , "Graphics.GL.SGIX.Interlace"
    \ , "Graphics.GL.SGIX.IrInstrument1"
    \ , "Graphics.GL.SGIX.ListPriority"
    \ , "Graphics.GL.SGIX.PixelTexture"
    \ , "Graphics.GL.SGIX.PixelTiles"
    \ , "Graphics.GL.SGIX.PolynomialFFD"
    \ , "Graphics.GL.SGIX.ReferencePlane"
    \ , "Graphics.GL.SGIX.Resample"
    \ , "Graphics.GL.SGIX.ScalebiasHint"
    \ , "Graphics.GL.SGIX.Shadow"
    \ , "Graphics.GL.SGIX.ShadowAmbient"
    \ , "Graphics.GL.SGIX.Sprite"
    \ , "Graphics.GL.SGIX.Subsample"
    \ , "Graphics.GL.SGIX.TagSampleBuffer"
    \ , "Graphics.GL.SGIX.TextureAddEnv"
    \ , "Graphics.GL.SGIX.TextureCoordinateClamp"
    \ , "Graphics.GL.SGIX.TextureLODBias"
    \ , "Graphics.GL.SGIX.TextureMultiBuffer"
    \ , "Graphics.GL.SGIX.TextureScaleBias"
    \ , "Graphics.GL.SGIX.VertexPreclip"
    \ , "Graphics.GL.SGIX.YCrCb"
    \ , "Graphics.GL.SGIX.YCrCbA"
    \ , "Graphics.GL.SUN"
    \ , "Graphics.GL.SUN.ConvolutionBorderModes"
    \ , "Graphics.GL.SUN.GlobalAlpha"
    \ , "Graphics.GL.SUN.MeshArray"
    \ , "Graphics.GL.SUN.SliceAccum"
    \ , "Graphics.GL.SUN.TriangleList"
    \ , "Graphics.GL.SUN.Vertex"
    \ , "Graphics.GL.SUNX"
    \ , "Graphics.GL.SUNX.ConstantData"
    \ , "Graphics.GL.ThreeDFX"
    \ , "Graphics.GL.ThreeDFX.Multisample"
    \ , "Graphics.GL.ThreeDFX.Tbuffer"
    \ , "Graphics.GL.ThreeDFX.TextureCompressionFXT1"
    \ , "Graphics.GL.Tokens"
    \ , "Graphics.GL.Types"
    \ , "Graphics.GL.Version10"
    \ , "Graphics.GL.Version11"
    \ , "Graphics.GL.Version12"
    \ , "Graphics.GL.Version13"
    \ , "Graphics.GL.Version14"
    \ , "Graphics.GL.Version15"
    \ , "Graphics.GL.Version20"
    \ , "Graphics.GL.Version21"
    \ , "Graphics.GL.WIN"
    \ , "Graphics.GL.WIN.PhongShading"
    \ , "Graphics.GL.WIN.SpecularFog"
    \ , "Test.QuickCheck"
    \ , "Test.QuickCheck.All"
    \ , "Test.QuickCheck.Arbitrary"
    \ , "Test.QuickCheck.Exception"
    \ , "Test.QuickCheck.Function"
    \ , "Test.QuickCheck.Gen"
    \ , "Test.QuickCheck.Gen.Unsafe"
    \ , "Test.QuickCheck.Modifiers"
    \ , "Test.QuickCheck.Monadic"
    \ , "Test.QuickCheck.Poly"
    \ , "Test.QuickCheck.Property"
    \ , "Test.QuickCheck.Random"
    \ , "Test.QuickCheck.State"
    \ , "Test.QuickCheck.Test"
    \ , "Test.QuickCheck.Text"
    \ , "Data.StateVar"
    \ , "Graphics.Win32"
    \ , "Graphics.Win32.Control"
    \ , "Graphics.Win32.Dialogue"
    \ , "Graphics.Win32.GDI"
    \ , "Graphics.Win32.GDI.AlphaBlend"
    \ , "Graphics.Win32.GDI.Bitmap"
    \ , "Graphics.Win32.GDI.Brush"
    \ , "Graphics.Win32.GDI.Clip"
    \ , "Graphics.Win32.GDI.Font"
    \ , "Graphics.Win32.GDI.Graphics2D"
    \ , "Graphics.Win32.GDI.HDC"
    \ , "Graphics.Win32.GDI.Palette"
    \ , "Graphics.Win32.GDI.Path"
    \ , "Graphics.Win32.GDI.Pen"
    \ , "Graphics.Win32.GDI.Region"
    \ , "Graphics.Win32.GDI.Types"
    \ , "Graphics.Win32.Icon"
    \ , "Graphics.Win32.Key"
    \ , "Graphics.Win32.LayeredWindow"
    \ , "Graphics.Win32.Menu"
    \ , "Graphics.Win32.Message"
    \ , "Graphics.Win32.Misc"
    \ , "Graphics.Win32.Resource"
    \ , "Graphics.Win32.Window"
    \ , "Graphics.Win32.Window.AnimateWindow"
    \ , "Graphics.Win32.Window.ForegroundWindow"
    \ , "Graphics.Win32.Window.HotKey"
    \ , "Graphics.Win32.Window.IMM"
    \ , "Graphics.Win32.Window.PostMessage"
    \ , "Media.Win32"
    \ , "System.Win32"
    \ , "System.Win32.Automation"
    \ , "System.Win32.Automation.Input"
    \ , "System.Win32.Automation.Input.Key"
    \ , "System.Win32.Automation.Input.Mouse"
    \ , "System.Win32.Console"
    \ , "System.Win32.Console.CtrlHandler"
    \ , "System.Win32.Console.HWND"
    \ , "System.Win32.Console.Title"
    \ , "System.Win32.DLL"
    \ , "System.Win32.DebugApi"
    \ , "System.Win32.Encoding"
    \ , "System.Win32.Exception.Unsupported"
    \ , "System.Win32.File"
    \ , "System.Win32.FileMapping"
    \ , "System.Win32.HardLink"
    \ , "System.Win32.Info"
    \ , "System.Win32.Info.Computer"
    \ , "System.Win32.Info.Version"
    \ , "System.Win32.Mem"
    \ , "System.Win32.MinTTY"
    \ , "System.Win32.NLS"
    \ , "System.Win32.Path"
    \ , "System.Win32.Process"
    \ , "System.Win32.Registry"
    \ , "System.Win32.Security"
    \ , "System.Win32.Shell"
    \ , "System.Win32.SimpleMAPI"
    \ , "System.Win32.String"
    \ , "System.Win32.SymbolicLink"
    \ , "System.Win32.Thread"
    \ , "System.Win32.Time"
    \ , "System.Win32.Types"
    \ , "System.Win32.Utils"
    \ , "System.Win32.Word"
    \ , "Data.Array"
    \ , "Data.Array.Base"
    \ , "Data.Array.IArray"
    \ , "Data.Array.IO"
    \ , "Data.Array.IO.Internals"
    \ , "Data.Array.IO.Safe"
    \ , "Data.Array.MArray"
    \ , "Data.Array.MArray.Safe"
    \ , "Data.Array.ST"
    \ , "Data.Array.ST.Safe"
    \ , "Data.Array.Storable"
    \ , "Data.Array.Storable.Internals"
    \ , "Data.Array.Storable.Safe"
    \ , "Data.Array.Unboxed"
    \ , "Data.Array.Unsafe"
    \ , "Control.Concurrent.Async"
    \ , "Data.Attoparsec"
    \ , "Data.Attoparsec.ByteString"
    \ , "Data.Attoparsec.ByteString.Char8"
    \ , "Data.Attoparsec.ByteString.Lazy"
    \ , "Data.Attoparsec.Char8"
    \ , "Data.Attoparsec.Combinator"
    \ , "Data.Attoparsec.Internal"
    \ , "Data.Attoparsec.Internal.Types"
    \ , "Data.Attoparsec.Lazy"
    \ , "Data.Attoparsec.Number"
    \ , "Data.Attoparsec.Text"
    \ , "Data.Attoparsec.Text.Lazy"
    \ , "Data.Attoparsec.Types"
    \ , "Data.Attoparsec.Zepto"
    \ , "Control.Applicative"
    \ , "Control.Arrow"
    \ , "Control.Category"
    \ , "Control.Concurrent"
    \ , "Control.Concurrent.Chan"
    \ , "Control.Concurrent.MVar"
    \ , "Control.Concurrent.QSem"
    \ , "Control.Concurrent.QSemN"
    \ , "Control.Exception"
    \ , "Control.Exception.Base"
    \ , "Control.Monad"
    \ , "Control.Monad.Fail"
    \ , "Control.Monad.Fix"
    \ , "Control.Monad.IO.Class"
    \ , "Control.Monad.Instances"
    \ , "Control.Monad.ST"
    \ , "Control.Monad.ST.Lazy"
    \ , "Control.Monad.ST.Lazy.Safe"
    \ , "Control.Monad.ST.Lazy.Unsafe"
    \ , "Control.Monad.ST.Safe"
    \ , "Control.Monad.ST.Strict"
    \ , "Control.Monad.ST.Unsafe"
    \ , "Control.Monad.Zip"
    \ , "Data.Bifoldable"
    \ , "Data.Bifunctor"
    \ , "Data.Bitraversable"
    \ , "Data.Bits"
    \ , "Data.Bool"
    \ , "Data.Char"
    \ , "Data.Coerce"
    \ , "Data.Complex"
    \ , "Data.Data"
    \ , "Data.Dynamic"
    \ , "Data.Either"
    \ , "Data.Eq"
    \ , "Data.Fixed"
    \ , "Data.Foldable"
    \ , "Data.Function"
    \ , "Data.Functor"
    \ , "Data.Functor.Classes"
    \ , "Data.Functor.Compose"
    \ , "Data.Functor.Const"
    \ , "Data.Functor.Identity"
    \ , "Data.Functor.Product"
    \ , "Data.Functor.Sum"
    \ , "Data.IORef"
    \ , "Data.Int"
    \ , "Data.Ix"
    \ , "Data.Kind"
    \ , "Data.List"
    \ , "Data.List.NonEmpty"
    \ , "Data.Maybe"
    \ , "Data.Monoid"
    \ , "Data.Ord"
    \ , "Data.Proxy"
    \ , "Data.Ratio"
    \ , "Data.STRef"
    \ , "Data.STRef.Lazy"
    \ , "Data.STRef.Strict"
    \ , "Data.Semigroup"
    \ , "Data.String"
    \ , "Data.Traversable"
    \ , "Data.Tuple"
    \ , "Data.Type.Bool"
    \ , "Data.Type.Coercion"
    \ , "Data.Type.Equality"
    \ , "Data.Typeable"
    \ , "Data.Unique"
    \ , "Data.Version"
    \ , "Data.Void"
    \ , "Data.Word"
    \ , "Debug.Trace"
    \ , "Foreign"
    \ , "Foreign.C"
    \ , "Foreign.C.Error"
    \ , "Foreign.C.String"
    \ , "Foreign.C.Types"
    \ , "Foreign.Concurrent"
    \ , "Foreign.ForeignPtr"
    \ , "Foreign.ForeignPtr.Safe"
    \ , "Foreign.ForeignPtr.Unsafe"
    \ , "Foreign.Marshal"
    \ , "Foreign.Marshal.Alloc"
    \ , "Foreign.Marshal.Array"
    \ , "Foreign.Marshal.Error"
    \ , "Foreign.Marshal.Pool"
    \ , "Foreign.Marshal.Safe"
    \ , "Foreign.Marshal.Unsafe"
    \ , "Foreign.Marshal.Utils"
    \ , "Foreign.Ptr"
    \ , "Foreign.Safe"
    \ , "Foreign.StablePtr"
    \ , "Foreign.Storable"
    \ , "GHC.Arr"
    \ , "GHC.Base"
    \ , "GHC.ByteOrder"
    \ , "GHC.Char"
    \ , "GHC.Clock"
    \ , "GHC.Conc"
    \ , "GHC.Conc.IO"
    \ , "GHC.Conc.Signal"
    \ , "GHC.Conc.Sync"
    \ , "GHC.ConsoleHandler"
    \ , "GHC.Constants"
    \ , "GHC.Desugar"
    \ , "GHC.Enum"
    \ , "GHC.Environment"
    \ , "GHC.Err"
    \ , "GHC.Event"
    \ , "GHC.Exception"
    \ , "GHC.ExecutionStack"
    \ , "GHC.ExecutionStack.Internal"
    \ , "GHC.Exts"
    \ , "GHC.Fingerprint"
    \ , "GHC.Fingerprint.Type"
    \ , "GHC.Float"
    \ , "GHC.Float.ConversionUtils"
    \ , "GHC.Float.RealFracMethods"
    \ , "GHC.Foreign"
    \ , "GHC.ForeignPtr"
    \ , "GHC.GHCi"
    \ , "GHC.Generics"
    \ , "GHC.IO"
    \ , "GHC.IO.Buffer"
    \ , "GHC.IO.BufferedIO"
    \ , "GHC.IO.Device"
    \ , "GHC.IO.Encoding"
    \ , "GHC.IO.Encoding.CodePage"
    \ , "GHC.IO.Encoding.Failure"
    \ , "GHC.IO.Encoding.Iconv"
    \ , "GHC.IO.Encoding.Latin1"
    \ , "GHC.IO.Encoding.Types"
    \ , "GHC.IO.Encoding.UTF16"
    \ , "GHC.IO.Encoding.UTF32"
    \ , "GHC.IO.Encoding.UTF8"
    \ , "GHC.IO.Exception"
    \ , "GHC.IO.FD"
    \ , "GHC.IO.Handle"
    \ , "GHC.IO.Handle.FD"
    \ , "GHC.IO.Handle.Internals"
    \ , "GHC.IO.Handle.Lock"
    \ , "GHC.IO.Handle.Text"
    \ , "GHC.IO.Handle.Types"
    \ , "GHC.IO.IOMode"
    \ , "GHC.IO.Unsafe"
    \ , "GHC.IOArray"
    \ , "GHC.IORef"
    \ , "GHC.Int"
    \ , "GHC.List"
    \ , "GHC.MVar"
    \ , "GHC.Natural"
    \ , "GHC.Num"
    \ , "GHC.OldList"
    \ , "GHC.OverloadedLabels"
    \ , "GHC.PArr"
    \ , "GHC.Pack"
    \ , "GHC.Profiling"
    \ , "GHC.Ptr"
    \ , "GHC.RTS.Flags"
    \ , "GHC.Read"
    \ , "GHC.Real"
    \ , "GHC.Records"
    \ , "GHC.ST"
    \ , "GHC.STRef"
    \ , "GHC.Show"
    \ , "GHC.Stable"
    \ , "GHC.Stack"
    \ , "GHC.Stack.CCS"
    \ , "GHC.Stack.Types"
    \ , "GHC.StaticPtr"
    \ , "GHC.Stats"
    \ , "GHC.Storable"
    \ , "GHC.TopHandler"
    \ , "GHC.TypeLits"
    \ , "GHC.TypeNats"
    \ , "GHC.Unicode"
    \ , "GHC.Weak"
    \ , "GHC.Word"
    \ , "Numeric"
    \ , "Numeric.Natural"
    \ , "Prelude"
    \ , "System.CPUTime"
    \ , "System.Console.GetOpt"
    \ , "System.Environment"
    \ , "System.Environment.Blank"
    \ , "System.Exit"
    \ , "System.IO"
    \ , "System.IO.Error"
    \ , "System.IO.Unsafe"
    \ , "System.Info"
    \ , "System.Mem"
    \ , "System.Mem.StableName"
    \ , "System.Mem.Weak"
    \ , "System.Posix.Internals"
    \ , "System.Posix.Types"
    \ , "System.Timeout"
    \ , "Text.ParserCombinators.ReadP"
    \ , "Text.ParserCombinators.ReadPrec"
    \ , "Text.Printf"
    \ , "Text.Read"
    \ , "Text.Read.Lex"
    \ , "Text.Show"
    \ , "Text.Show.Functions"
    \ , "Type.Reflection"
    \ , "Type.Reflection.Unsafe"
    \ , "Unsafe.Coerce"
    \ , "Data.ByteString"
    \ , "Data.ByteString.Builder"
    \ , "Data.ByteString.Builder.Extra"
    \ , "Data.ByteString.Builder.Internal"
    \ , "Data.ByteString.Builder.Prim"
    \ , "Data.ByteString.Builder.Prim.Internal"
    \ , "Data.ByteString.Char8"
    \ , "Data.ByteString.Internal"
    \ , "Data.ByteString.Lazy"
    \ , "Data.ByteString.Lazy.Builder"
    \ , "Data.ByteString.Lazy.Builder.ASCII"
    \ , "Data.ByteString.Lazy.Builder.Extras"
    \ , "Data.ByteString.Lazy.Char8"
    \ , "Data.ByteString.Lazy.Internal"
    \ , "Data.ByteString.Short"
    \ , "Data.ByteString.Short.Internal"
    \ , "Data.ByteString.Unsafe"
    \ , "Data.CallStack"
    \ , "Data.CaseInsensitive"
    \ , "Data.CaseInsensitive.Unsafe"
    \ , "Network.CGI"
    \ , "Network.CGI.Compat"
    \ , "Network.CGI.Cookie"
    \ , "Network.CGI.Monad"
    \ , "Network.CGI.Protocol"
    \ , "Data.Graph"
    \ , "Data.IntMap"
    \ , "Data.IntMap.Internal"
    \ , "Data.IntMap.Internal.Debug"
    \ , "Data.IntMap.Lazy"
    \ , "Data.IntMap.Merge.Lazy"
    \ , "Data.IntMap.Merge.Strict"
    \ , "Data.IntMap.Strict"
    \ , "Data.IntSet"
    \ , "Data.IntSet.Internal"
    \ , "Data.Map"
    \ , "Data.Map.Internal"
    \ , "Data.Map.Internal.Debug"
    \ , "Data.Map.Lazy"
    \ , "Data.Map.Lazy.Merge"
    \ , "Data.Map.Merge.Lazy"
    \ , "Data.Map.Merge.Strict"
    \ , "Data.Map.Strict"
    \ , "Data.Map.Strict.Internal"
    \ , "Data.Map.Strict.Merge"
    \ , "Data.Sequence"
    \ , "Data.Sequence.Internal"
    \ , "Data.Sequence.Internal.Sorting"
    \ , "Data.Set"
    \ , "Data.Set.Internal"
    \ , "Data.Tree"
    \ , "Utils.Containers.Internal.BitQueue"
    \ , "Utils.Containers.Internal.BitUtil"
    \ , "Utils.Containers.Internal.StrictPair"
    \ , "Control.DeepSeq"
    \ , "System.Directory"
    \ , "System.Directory.Internal"
    \ , "System.Directory.Internal.Prelude"
    \ , "Control.Monad.Catch"
    \ , "Control.Monad.Catch.Pure"
    \ , "Control.Exception.Extensible"
    \ , "Data.Graph.Inductive"
    \ , "Data.Graph.Inductive.Basic"
    \ , "Data.Graph.Inductive.Example"
    \ , "Data.Graph.Inductive.Graph"
    \ , "Data.Graph.Inductive.Internal.Heap"
    \ , "Data.Graph.Inductive.Internal.Queue"
    \ , "Data.Graph.Inductive.Internal.RootPath"
    \ , "Data.Graph.Inductive.Internal.Thread"
    \ , "Data.Graph.Inductive.Monad"
    \ , "Data.Graph.Inductive.Monad.IOArray"
    \ , "Data.Graph.Inductive.Monad.STArray"
    \ , "Data.Graph.Inductive.NodeMap"
    \ , "Data.Graph.Inductive.PatriciaTree"
    \ , "Data.Graph.Inductive.Query"
    \ , "Data.Graph.Inductive.Query.ArtPoint"
    \ , "Data.Graph.Inductive.Query.BCC"
    \ , "Data.Graph.Inductive.Query.BFS"
    \ , "Data.Graph.Inductive.Query.DFS"
    \ , "Data.Graph.Inductive.Query.Dominators"
    \ , "Data.Graph.Inductive.Query.GVD"
    \ , "Data.Graph.Inductive.Query.Indep"
    \ , "Data.Graph.Inductive.Query.MST"
    \ , "Data.Graph.Inductive.Query.MaxFlow"
    \ , "Data.Graph.Inductive.Query.MaxFlow2"
    \ , "Data.Graph.Inductive.Query.Monad"
    \ , "Data.Graph.Inductive.Query.SP"
    \ , "Data.Graph.Inductive.Query.TransClos"
    \ , "Data.Graph.Inductive.Tree"
    \ , "System.FilePath"
    \ , "System.FilePath.Posix"
    \ , "System.FilePath.Windows"
    \ , "Numeric.Fixed"
    \ , "Annotations"
    \ , "ApiAnnotation"
    \ , "Ar"
    \ , "AsmCodeGen"
    \ , "AsmUtils"
    \ , "Avail"
    \ , "Bag"
    \ , "BasicTypes"
    \ , "BinFingerprint"
    \ , "BinIface"
    \ , "Binary"
    \ , "Bitmap"
    \ , "BkpSyn"
    \ , "BlockId"
    \ , "BooleanFormula"
    \ , "BufWrite"
    \ , "BuildTyCl"
    \ , "ByteCodeAsm"
    \ , "ByteCodeGen"
    \ , "ByteCodeInstr"
    \ , "ByteCodeItbls"
    \ , "ByteCodeLink"
    \ , "ByteCodeTypes"
    \ , "CLabel"
    \ , "CPrim"
    \ , "CSE"
    \ , "CallArity"
    \ , "CgUtils"
    \ , "Check"
    \ , "Class"
    \ , "CmdLineParser"
    \ , "Cmm"
    \ , "CmmBuildInfoTables"
    \ , "CmmCallConv"
    \ , "CmmCommonBlockElim"
    \ , "CmmContFlowOpt"
    \ , "CmmExpr"
    \ , "CmmImplementSwitchPlans"
    \ , "CmmInfo"
    \ , "CmmLayoutStack"
    \ , "CmmLex"
    \ , "CmmLint"
    \ , "CmmLive"
    \ , "CmmMachOp"
    \ , "CmmMonad"
    \ , "CmmNode"
    \ , "CmmOpt"
    \ , "CmmParse"
    \ , "CmmPipeline"
    \ , "CmmProcPoint"
    \ , "CmmSink"
    \ , "CmmSwitch"
    \ , "CmmType"
    \ , "CmmUtils"
    \ , "CoAxiom"
    \ , "CodeGen.Platform"
    \ , "CodeGen.Platform.ARM"
    \ , "CodeGen.Platform.ARM64"
    \ , "CodeGen.Platform.NoRegs"
    \ , "CodeGen.Platform.PPC"
    \ , "CodeGen.Platform.PPC_Darwin"
    \ , "CodeGen.Platform.SPARC"
    \ , "CodeGen.Platform.X86"
    \ , "CodeGen.Platform.X86_64"
    \ , "CodeOutput"
    \ , "Coercion"
    \ , "ConLike"
    \ , "Config"
    \ , "Constants"
    \ , "Convert"
    \ , "CoreArity"
    \ , "CoreFVs"
    \ , "CoreLint"
    \ , "CoreMonad"
    \ , "CoreOpt"
    \ , "CorePrep"
    \ , "CoreSeq"
    \ , "CoreStats"
    \ , "CoreSubst"
    \ , "CoreSyn"
    \ , "CoreTidy"
    \ , "CoreToStg"
    \ , "CoreUnfold"
    \ , "CoreUtils"
    \ , "CostCentre"
    \ , "Coverage"
    \ , "Ctype"
    \ , "DataCon"
    \ , "Debug"
    \ , "Debugger"
    \ , "DebuggerUtils"
    \ , "Demand"
    \ , "Desugar"
    \ , "Digraph"
    \ , "DmdAnal"
    \ , "DriverBkp"
    \ , "DriverMkDepend"
    \ , "DriverPhases"
    \ , "DriverPipeline"
    \ , "DsArrows"
    \ , "DsBinds"
    \ , "DsCCall"
    \ , "DsExpr"
    \ , "DsForeign"
    \ , "DsGRHSs"
    \ , "DsListComp"
    \ , "DsMeta"
    \ , "DsMonad"
    \ , "DsUsage"
    \ , "DsUtils"
    \ , "Dwarf"
    \ , "Dwarf.Constants"
    \ , "Dwarf.Types"
    \ , "DynFlags"
    \ , "DynamicLoading"
    \ , "Elf"
    \ , "Encoding"
    \ , "EnumSet"
    \ , "ErrUtils"
    \ , "Exception"
    \ , "Exitify"
    \ , "FV"
    \ , "FamInst"
    \ , "FamInstEnv"
    \ , "FastFunctions"
    \ , "FastMutInt"
    \ , "FastString"
    \ , "FastStringEnv"
    \ , "FieldLabel"
    \ , "FileCleanup"
    \ , "Finder"
    \ , "Fingerprint"
    \ , "FiniteMap"
    \ , "FlagChecker"
    \ , "FloatIn"
    \ , "FloatOut"
    \ , "ForeignCall"
    \ , "Format"
    \ , "FunDeps"
    \ , "GHC"
    \ , "GHCi"
    \ , "GhcMake"
    \ , "GhcMonad"
    \ , "GhcPlugins"
    \ , "GraphBase"
    \ , "GraphColor"
    \ , "GraphOps"
    \ , "GraphPpr"
    \ , "HaddockUtils"
    \ , "HeaderInfo"
    \ , "Hooks"
    \ , "Hoopl.Block"
    \ , "Hoopl.Collections"
    \ , "Hoopl.Dataflow"
    \ , "Hoopl.Graph"
    \ , "Hoopl.Label"
    \ , "Hoopl.Unique"
    \ , "HsBinds"
    \ , "HsDecls"
    \ , "HsDoc"
    \ , "HsDumpAst"
    \ , "HsExpr"
    \ , "HsExtension"
    \ , "HsImpExp"
    \ , "HsLit"
    \ , "HsPat"
    \ , "HsSyn"
    \ , "HsTypes"
    \ , "HsUtils"
    \ , "HscMain"
    \ , "HscStats"
    \ , "HscTypes"
    \ , "IOEnv"
    \ , "Id"
    \ , "IdInfo"
    \ , "IfaceEnv"
    \ , "IfaceSyn"
    \ , "IfaceType"
    \ , "Inst"
    \ , "InstEnv"
    \ , "Instruction"
    \ , "InteractiveEval"
    \ , "InteractiveEvalTypes"
    \ , "Json"
    \ , "Kind"
    \ , "KnownUniques"
    \ , "Lexeme"
    \ , "Lexer"
    \ , "LiberateCase"
    \ , "Linker"
    \ , "ListSetOps"
    \ , "ListT"
    \ , "Literal"
    \ , "Llvm"
    \ , "Llvm.AbsSyn"
    \ , "Llvm.MetaData"
    \ , "Llvm.PpLlvm"
    \ , "Llvm.Types"
    \ , "LlvmCodeGen"
    \ , "LlvmCodeGen.Base"
    \ , "LlvmCodeGen.CodeGen"
    \ , "LlvmCodeGen.Data"
    \ , "LlvmCodeGen.Ppr"
    \ , "LlvmCodeGen.Regs"
    \ , "LlvmMangler"
    \ , "LoadIface"
    \ , "Match"
    \ , "MatchCon"
    \ , "MatchLit"
    \ , "Maybes"
    \ , "MkCore"
    \ , "MkGraph"
    \ , "MkId"
    \ , "MkIface"
    \ , "Module"
    \ , "MonadUtils"
    \ , "NCGMonad"
    \ , "Name"
    \ , "NameCache"
    \ , "NameEnv"
    \ , "NameSet"
    \ , "NameShape"
    \ , "OccName"
    \ , "OccurAnal"
    \ , "OptCoercion"
    \ , "OrdList"
    \ , "Outputable"
    \ , "PIC"
    \ , "PPC.CodeGen"
    \ , "PPC.Cond"
    \ , "PPC.Instr"
    \ , "PPC.Ppr"
    \ , "PPC.RegInfo"
    \ , "PPC.Regs"
    \ , "PackageConfig"
    \ , "Packages"
    \ , "Pair"
    \ , "Panic"
    \ , "Parser"
    \ , "PatSyn"
    \ , "PipelineMonad"
    \ , "PlaceHolder"
    \ , "Platform"
    \ , "PlatformConstants"
    \ , "Plugins"
    \ , "PmExpr"
    \ , "PprBase"
    \ , "PprC"
    \ , "PprCmm"
    \ , "PprCmmDecl"
    \ , "PprCmmExpr"
    \ , "PprColour"
    \ , "PprCore"
    \ , "PprTyThing"
    \ , "PrelInfo"
    \ , "PrelNames"
    \ , "PrelRules"
    \ , "Pretty"
    \ , "PrimOp"
    \ , "ProfInit"
    \ , "RdrHsSyn"
    \ , "RdrName"
    \ , "Reg"
    \ , "RegAlloc.Graph.ArchBase"
    \ , "RegAlloc.Graph.ArchX86"
    \ , "RegAlloc.Graph.Coalesce"
    \ , "RegAlloc.Graph.Main"
    \ , "RegAlloc.Graph.Spill"
    \ , "RegAlloc.Graph.SpillClean"
    \ , "RegAlloc.Graph.SpillCost"
    \ , "RegAlloc.Graph.Stats"
    \ , "RegAlloc.Graph.TrivColorable"
    \ , "RegAlloc.Linear.Base"
    \ , "RegAlloc.Linear.FreeRegs"
    \ , "RegAlloc.Linear.JoinToTargets"
    \ , "RegAlloc.Linear.Main"
    \ , "RegAlloc.Linear.PPC.FreeRegs"
    \ , "RegAlloc.Linear.SPARC.FreeRegs"
    \ , "RegAlloc.Linear.StackMap"
    \ , "RegAlloc.Linear.State"
    \ , "RegAlloc.Linear.Stats"
    \ , "RegAlloc.Linear.X86.FreeRegs"
    \ , "RegAlloc.Linear.X86_64.FreeRegs"
    \ , "RegAlloc.Liveness"
    \ , "RegClass"
    \ , "RepType"
    \ , "RnBinds"
    \ , "RnEnv"
    \ , "RnExpr"
    \ , "RnFixity"
    \ , "RnHsDoc"
    \ , "RnModIface"
    \ , "RnNames"
    \ , "RnPat"
    \ , "RnSource"
    \ , "RnSplice"
    \ , "RnTypes"
    \ , "RnUnbound"
    \ , "RnUtils"
    \ , "RtClosureInspect"
    \ , "Rules"
    \ , "SAT"
    \ , "SMRep"
    \ , "SPARC.AddrMode"
    \ , "SPARC.Base"
    \ , "SPARC.CodeGen"
    \ , "SPARC.CodeGen.Amode"
    \ , "SPARC.CodeGen.Base"
    \ , "SPARC.CodeGen.CondCode"
    \ , "SPARC.CodeGen.Expand"
    \ , "SPARC.CodeGen.Gen32"
    \ , "SPARC.CodeGen.Gen64"
    \ , "SPARC.CodeGen.Sanity"
    \ , "SPARC.Cond"
    \ , "SPARC.Imm"
    \ , "SPARC.Instr"
    \ , "SPARC.Ppr"
    \ , "SPARC.Regs"
    \ , "SPARC.ShortcutJump"
    \ , "SPARC.Stack"
    \ , "SetLevels"
    \ , "SimplCore"
    \ , "SimplEnv"
    \ , "SimplMonad"
    \ , "SimplStg"
    \ , "SimplUtils"
    \ , "Simplify"
    \ , "SpecConstr"
    \ , "Specialise"
    \ , "SrcLoc"
    \ , "State"
    \ , "StaticPtrTable"
    \ , "StgCmm"
    \ , "StgCmmArgRep"
    \ , "StgCmmBind"
    \ , "StgCmmClosure"
    \ , "StgCmmCon"
    \ , "StgCmmEnv"
    \ , "StgCmmExpr"
    \ , "StgCmmExtCode"
    \ , "StgCmmForeign"
    \ , "StgCmmHeap"
    \ , "StgCmmHpc"
    \ , "StgCmmLayout"
    \ , "StgCmmMonad"
    \ , "StgCmmPrim"
    \ , "StgCmmProf"
    \ , "StgCmmTicky"
    \ , "StgCmmUtils"
    \ , "StgCse"
    \ , "StgLint"
    \ , "StgStats"
    \ , "StgSyn"
    \ , "Stream"
    \ , "StringBuffer"
    \ , "SysTools"
    \ , "SysTools.BaseDir"
    \ , "SysTools.ExtraObj"
    \ , "SysTools.Info"
    \ , "SysTools.Process"
    \ , "SysTools.Tasks"
    \ , "SysTools.Terminal"
    \ , "THNames"
    \ , "TargetReg"
    \ , "TcAnnotations"
    \ , "TcArrows"
    \ , "TcBackpack"
    \ , "TcBinds"
    \ , "TcCanonical"
    \ , "TcClassDcl"
    \ , "TcDefaults"
    \ , "TcDeriv"
    \ , "TcDerivInfer"
    \ , "TcDerivUtils"
    \ , "TcEnv"
    \ , "TcErrors"
    \ , "TcEvidence"
    \ , "TcExpr"
    \ , "TcFlatten"
    \ , "TcForeign"
    \ , "TcGenDeriv"
    \ , "TcGenFunctor"
    \ , "TcGenGenerics"
    \ , "TcHsSyn"
    \ , "TcHsType"
    \ , "TcIface"
    \ , "TcInstDcls"
    \ , "TcInteract"
    \ , "TcMType"
    \ , "TcMatches"
    \ , "TcPat"
    \ , "TcPatSyn"
    \ , "TcPluginM"
    \ , "TcRnDriver"
    \ , "TcRnExports"
    \ , "TcRnMonad"
    \ , "TcRnTypes"
    \ , "TcRules"
    \ , "TcSMonad"
    \ , "TcSigs"
    \ , "TcSimplify"
    \ , "TcSplice"
    \ , "TcTyClsDecls"
    \ , "TcTyDecls"
    \ , "TcType"
    \ , "TcTypeNats"
    \ , "TcTypeable"
    \ , "TcUnify"
    \ , "TcValidity"
    \ , "TidyPgm"
    \ , "TmOracle"
    \ , "ToIface"
    \ , "TrieMap"
    \ , "TyCoRep"
    \ , "TyCon"
    \ , "Type"
    \ , "TysPrim"
    \ , "TysWiredIn"
    \ , "UnVarGraph"
    \ , "UnariseStg"
    \ , "Unify"
    \ , "UniqDFM"
    \ , "UniqDSet"
    \ , "UniqFM"
    \ , "UniqMap"
    \ , "UniqSet"
    \ , "UniqSupply"
    \ , "Unique"
    \ , "Util"
    \ , "Var"
    \ , "VarEnv"
    \ , "VarSet"
    \ , "Vectorise"
    \ , "Vectorise.Builtins"
    \ , "Vectorise.Builtins.Base"
    \ , "Vectorise.Builtins.Initialise"
    \ , "Vectorise.Convert"
    \ , "Vectorise.Env"
    \ , "Vectorise.Exp"
    \ , "Vectorise.Generic.Description"
    \ , "Vectorise.Generic.PADict"
    \ , "Vectorise.Generic.PAMethods"
    \ , "Vectorise.Generic.PData"
    \ , "Vectorise.Monad"
    \ , "Vectorise.Monad.Base"
    \ , "Vectorise.Monad.Global"
    \ , "Vectorise.Monad.InstEnv"
    \ , "Vectorise.Monad.Local"
    \ , "Vectorise.Monad.Naming"
    \ , "Vectorise.Type.Classify"
    \ , "Vectorise.Type.Env"
    \ , "Vectorise.Type.TyConDecl"
    \ , "Vectorise.Type.Type"
    \ , "Vectorise.Utils"
    \ , "Vectorise.Utils.Base"
    \ , "Vectorise.Utils.Closure"
    \ , "Vectorise.Utils.Hoisting"
    \ , "Vectorise.Utils.PADict"
    \ , "Vectorise.Utils.Poly"
    \ , "Vectorise.Var"
    \ , "Vectorise.Vect"
    \ , "WorkWrap"
    \ , "WwLib"
    \ , "X86.CodeGen"
    \ , "X86.Cond"
    \ , "X86.Instr"
    \ , "X86.Ppr"
    \ , "X86.RegInfo"
    \ , "X86.Regs"
    \ , "Numeric.Half"
    \ , "Data.Hashable"
    \ , "Data.Hashable.Lifted"
    \ , "Language.Haskell.Lexer"
    \ , "Language.Haskell.ParseMonad"
    \ , "Language.Haskell.ParseUtils"
    \ , "Language.Haskell.Parser"
    \ , "Language.Haskell.Pretty"
    \ , "Language.Haskell.Syntax"
    \ , "Control.Monad"
    \ , "Data.Array"
    \ , "Data.Bits"
    \ , "Data.Char"
    \ , "Data.Complex"
    \ , "Data.Int"
    \ , "Data.Ix"
    \ , "Data.List"
    \ , "Data.Maybe"
    \ , "Data.Ratio"
    \ , "Data.Word"
    \ , "Foreign"
    \ , "Foreign.C"
    \ , "Foreign.C.Error"
    \ , "Foreign.C.String"
    \ , "Foreign.C.Types"
    \ , "Foreign.ForeignPtr"
    \ , "Foreign.Marshal"
    \ , "Foreign.Marshal.Alloc"
    \ , "Foreign.Marshal.Array"
    \ , "Foreign.Marshal.Error"
    \ , "Foreign.Marshal.Utils"
    \ , "Foreign.Ptr"
    \ , "Foreign.StablePtr"
    \ , "Foreign.Storable"
    \ , "Numeric"
    \ , "Prelude"
    \ , "System.Environment"
    \ , "System.Exit"
    \ , "System.IO"
    \ , "System.IO.Error"
    \ , "Array"
    \ , "Bits"
    \ , "CError"
    \ , "CForeign"
    \ , "CPUTime"
    \ , "CString"
    \ , "CTypes"
    \ , "Char"
    \ , "Complex"
    \ , "Directory"
    \ , "ForeignPtr"
    \ , "IO"
    \ , "Int"
    \ , "Ix"
    \ , "List"
    \ , "Locale"
    \ , "MarshalAlloc"
    \ , "MarshalArray"
    \ , "MarshalError"
    \ , "MarshalUtils"
    \ , "Maybe"
    \ , "Monad"
    \ , "Numeric"
    \ , "Prelude"
    \ , "Ptr"
    \ , "Random"
    \ , "Ratio"
    \ , "StablePtr"
    \ , "Storable"
    \ , "System"
    \ , "Time"
    \ , "Word"
    \ , "Trace.Hpc.Mix"
    \ , "Trace.Hpc.Reflect"
    \ , "Trace.Hpc.Tix"
    \ , "Trace.Hpc.Util"
    \ , "Text.Html"
    \ , "Text.Html.BlockTable"
    \ , "GHC.Integer.Logarithms.Compat"
    \ , "Math.NumberTheory.Logarithms"
    \ , "Math.NumberTheory.Powers.Integer"
    \ , "Math.NumberTheory.Powers.Natural"
    \ , "Control.Monad.Cont"
    \ , "Control.Monad.Cont.Class"
    \ , "Control.Monad.Error"
    \ , "Control.Monad.Error.Class"
    \ , "Control.Monad.Except"
    \ , "Control.Monad.Identity"
    \ , "Control.Monad.List"
    \ , "Control.Monad.RWS"
    \ , "Control.Monad.RWS.Class"
    \ , "Control.Monad.RWS.Lazy"
    \ , "Control.Monad.RWS.Strict"
    \ , "Control.Monad.Reader"
    \ , "Control.Monad.Reader.Class"
    \ , "Control.Monad.State"
    \ , "Control.Monad.State.Class"
    \ , "Control.Monad.State.Lazy"
    \ , "Control.Monad.State.Strict"
    \ , "Control.Monad.Trans"
    \ , "Control.Monad.Writer"
    \ , "Control.Monad.Writer.Class"
    \ , "Control.Monad.Writer.Lazy"
    \ , "Control.Monad.Writer.Strict"
    \ , "Network.Multipart"
    \ , "Network.Multipart.Header"
    \ , "Network"
    \ , "Network.BSD"
    \ , "Network.Socket"
    \ , "Network.Socket.ByteString"
    \ , "Network.Socket.ByteString.Lazy"
    \ , "Network.Socket.Internal"
    \ , "Network.URI"
    \ , "System.Locale"
    \ , "System.Time"
    \ , "Control.Parallel"
    \ , "Control.Parallel.Strategies"
    \ , "Control.Seq"
    \ , "Text.Parsec"
    \ , "Text.Parsec.ByteString"
    \ , "Text.Parsec.ByteString.Lazy"
    \ , "Text.Parsec.Char"
    \ , "Text.Parsec.Combinator"
    \ , "Text.Parsec.Error"
    \ , "Text.Parsec.Expr"
    \ , "Text.Parsec.Language"
    \ , "Text.Parsec.Perm"
    \ , "Text.Parsec.Pos"
    \ , "Text.Parsec.Prim"
    \ , "Text.Parsec.String"
    \ , "Text.Parsec.Text"
    \ , "Text.Parsec.Text.Lazy"
    \ , "Text.Parsec.Token"
    \ , "Text.ParserCombinators.Parsec"
    \ , "Text.ParserCombinators.Parsec.Char"
    \ , "Text.ParserCombinators.Parsec.Combinator"
    \ , "Text.ParserCombinators.Parsec.Error"
    \ , "Text.ParserCombinators.Parsec.Expr"
    \ , "Text.ParserCombinators.Parsec.Language"
    \ , "Text.ParserCombinators.Parsec.Perm"
    \ , "Text.ParserCombinators.Parsec.Pos"
    \ , "Text.ParserCombinators.Parsec.Prim"
    \ , "Text.ParserCombinators.Parsec.Token"
    \ , "Text.PrettyPrint"
    \ , "Text.PrettyPrint.Annotated"
    \ , "Text.PrettyPrint.Annotated.HughesPJ"
    \ , "Text.PrettyPrint.Annotated.HughesPJClass"
    \ , "Text.PrettyPrint.HughesPJ"
    \ , "Text.PrettyPrint.HughesPJClass"
    \ , "Control.Monad.Primitive"
    \ , "Data.Primitive"
    \ , "Data.Primitive.Addr"
    \ , "Data.Primitive.Array"
    \ , "Data.Primitive.ByteArray"
    \ , "Data.Primitive.MVar"
    \ , "Data.Primitive.MachDeps"
    \ , "Data.Primitive.MutVar"
    \ , "Data.Primitive.PrimArray"
    \ , "Data.Primitive.Ptr"
    \ , "Data.Primitive.SmallArray"
    \ , "Data.Primitive.Types"
    \ , "Data.Primitive.UnliftedArray"
    \ , "System.Cmd"
    \ , "System.Process"
    \ , "System.Process.Internals"
    \ , "System.Random"
    \ , "Text.Regex.Base"
    \ , "Text.Regex.Base.Context"
    \ , "Text.Regex.Base.Impl"
    \ , "Text.Regex.Base.RegexLike"
    \ , "Text.Regex"
    \ , "Text.Regex.Posix"
    \ , "Text.Regex.Posix.ByteString"
    \ , "Text.Regex.Posix.ByteString.Lazy"
    \ , "Text.Regex.Posix.Sequence"
    \ , "Text.Regex.Posix.String"
    \ , "Text.Regex.Posix.Wrap"
    \ , "Data.ByteString.Builder.Scientific"
    \ , "Data.Scientific"
    \ , "Data.Text.Lazy.Builder.Scientific"
    \ , "Data.List.Split"
    \ , "Data.List.Split.Internals"
    \ , "Control.Concurrent.STM"
    \ , "Control.Concurrent.STM.TArray"
    \ , "Control.Concurrent.STM.TBQueue"
    \ , "Control.Concurrent.STM.TChan"
    \ , "Control.Concurrent.STM.TMVar"
    \ , "Control.Concurrent.STM.TQueue"
    \ , "Control.Concurrent.STM.TSem"
    \ , "Control.Concurrent.STM.TVar"
    \ , "Control.Monad.STM"
    \ , "Data.Generics"
    \ , "Data.Generics.Aliases"
    \ , "Data.Generics.Basics"
    \ , "Data.Generics.Builders"
    \ , "Data.Generics.Instances"
    \ , "Data.Generics.Schemes"
    \ , "Data.Generics.Text"
    \ , "Data.Generics.Twins"
    \ , "Generics.SYB"
    \ , "Generics.SYB.Aliases"
    \ , "Generics.SYB.Basics"
    \ , "Generics.SYB.Builders"
    \ , "Generics.SYB.Instances"
    \ , "Generics.SYB.Schemes"
    \ , "Generics.SYB.Text"
    \ , "Generics.SYB.Twins"
    \ , "Language.Haskell.TH"
    \ , "Language.Haskell.TH.LanguageExtensions"
    \ , "Language.Haskell.TH.Lib"
    \ , "Language.Haskell.TH.Lib.Internal"
    \ , "Language.Haskell.TH.Ppr"
    \ , "Language.Haskell.TH.PprLib"
    \ , "Language.Haskell.TH.Quote"
    \ , "Language.Haskell.TH.Syntax"
    \ , "Data.Text"
    \ , "Data.Text.Array"
    \ , "Data.Text.Encoding"
    \ , "Data.Text.Encoding.Error"
    \ , "Data.Text.Foreign"
    \ , "Data.Text.IO"
    \ , "Data.Text.Internal"
    \ , "Data.Text.Internal.Builder"
    \ , "Data.Text.Internal.Builder.Functions"
    \ , "Data.Text.Internal.Builder.Int.Digits"
    \ , "Data.Text.Internal.Builder.RealFloat.Functions"
    \ , "Data.Text.Internal.Encoding.Fusion"
    \ , "Data.Text.Internal.Encoding.Fusion.Common"
    \ , "Data.Text.Internal.Encoding.Utf16"
    \ , "Data.Text.Internal.Encoding.Utf32"
    \ , "Data.Text.Internal.Encoding.Utf8"
    \ , "Data.Text.Internal.Functions"
    \ , "Data.Text.Internal.Fusion"
    \ , "Data.Text.Internal.Fusion.CaseMapping"
    \ , "Data.Text.Internal.Fusion.Common"
    \ , "Data.Text.Internal.Fusion.Size"
    \ , "Data.Text.Internal.Fusion.Types"
    \ , "Data.Text.Internal.IO"
    \ , "Data.Text.Internal.Lazy"
    \ , "Data.Text.Internal.Lazy.Encoding.Fusion"
    \ , "Data.Text.Internal.Lazy.Fusion"
    \ , "Data.Text.Internal.Lazy.Search"
    \ , "Data.Text.Internal.Private"
    \ , "Data.Text.Internal.Read"
    \ , "Data.Text.Internal.Search"
    \ , "Data.Text.Internal.Unsafe"
    \ , "Data.Text.Internal.Unsafe.Char"
    \ , "Data.Text.Internal.Unsafe.Shift"
    \ , "Data.Text.Lazy"
    \ , "Data.Text.Lazy.Builder"
    \ , "Data.Text.Lazy.Builder.Int"
    \ , "Data.Text.Lazy.Builder.RealFloat"
    \ , "Data.Text.Lazy.Encoding"
    \ , "Data.Text.Lazy.IO"
    \ , "Data.Text.Lazy.Internal"
    \ , "Data.Text.Lazy.Read"
    \ , "Data.Text.Read"
    \ , "Data.Text.Unsafe"
    \ , "System.Random.TF"
    \ , "System.Random.TF.Gen"
    \ , "System.Random.TF.Init"
    \ , "System.Random.TF.Instances"
    \ , "Data.Time"
    \ , "Data.Time.Calendar"
    \ , "Data.Time.Calendar.Easter"
    \ , "Data.Time.Calendar.Julian"
    \ , "Data.Time.Calendar.MonthDay"
    \ , "Data.Time.Calendar.OrdinalDate"
    \ , "Data.Time.Calendar.WeekDate"
    \ , "Data.Time.Clock"
    \ , "Data.Time.Clock.POSIX"
    \ , "Data.Time.Clock.System"
    \ , "Data.Time.Clock.TAI"
    \ , "Data.Time.Format"
    \ , "Data.Time.LocalTime"
    \ , "Control.Applicative.Backwards"
    \ , "Control.Applicative.Lift"
    \ , "Control.Monad.Signatures"
    \ , "Control.Monad.Trans.Accum"
    \ , "Control.Monad.Trans.Class"
    \ , "Control.Monad.Trans.Cont"
    \ , "Control.Monad.Trans.Error"
    \ , "Control.Monad.Trans.Except"
    \ , "Control.Monad.Trans.Identity"
    \ , "Control.Monad.Trans.List"
    \ , "Control.Monad.Trans.Maybe"
    \ , "Control.Monad.Trans.RWS"
    \ , "Control.Monad.Trans.RWS.Lazy"
    \ , "Control.Monad.Trans.RWS.Strict"
    \ , "Control.Monad.Trans.Reader"
    \ , "Control.Monad.Trans.Select"
    \ , "Control.Monad.Trans.State"
    \ , "Control.Monad.Trans.State.Lazy"
    \ , "Control.Monad.Trans.State.Strict"
    \ , "Control.Monad.Trans.Writer"
    \ , "Control.Monad.Trans.Writer.Lazy"
    \ , "Control.Monad.Trans.Writer.Strict"
    \ , "Data.Functor.Constant"
    \ , "Data.Functor.Reverse"
    \ , "Control.Monad.Trans.Instances"
    \ , "Data.Functor.Classes.Generic"
    \ , "Data.Functor.Classes.Generic.Internal"
    \ , "System.Posix"
    \ , "System.Posix.ByteString"
    \ , "System.Posix.ByteString.FilePath"
    \ , "System.Posix.Directory"
    \ , "System.Posix.Directory.ByteString"
    \ , "System.Posix.DynamicLinker"
    \ , "System.Posix.DynamicLinker.ByteString"
    \ , "System.Posix.DynamicLinker.Module"
    \ , "System.Posix.DynamicLinker.Module.ByteString"
    \ , "System.Posix.DynamicLinker.Prim"
    \ , "System.Posix.Env"
    \ , "System.Posix.Env.ByteString"
    \ , "System.Posix.Error"
    \ , "System.Posix.Fcntl"
    \ , "System.Posix.Files"
    \ , "System.Posix.Files.ByteString"
    \ , "System.Posix.IO"
    \ , "System.Posix.IO.ByteString"
    \ , "System.Posix.Process"
    \ , "System.Posix.Process.ByteString"
    \ , "System.Posix.Process.Internals"
    \ , "System.Posix.Resource"
    \ , "System.Posix.Semaphore"
    \ , "System.Posix.SharedMem"
    \ , "System.Posix.Signals"
    \ , "System.Posix.Signals.Exts"
    \ , "System.Posix.Temp"
    \ , "System.Posix.Temp.ByteString"
    \ , "System.Posix.Terminal"
    \ , "System.Posix.Terminal.ByteString"
    \ , "System.Posix.Time"
    \ , "System.Posix.Unistd"
    \ , "System.Posix.User"
    \ , "Data.HashMap.Lazy"
    \ , "Data.HashMap.Strict"
    \ , "Data.HashSet"
    \ , "Data.Vector"
    \ , "Data.Vector.Fusion.Bundle"
    \ , "Data.Vector.Fusion.Bundle.Monadic"
    \ , "Data.Vector.Fusion.Bundle.Size"
    \ , "Data.Vector.Fusion.Stream.Monadic"
    \ , "Data.Vector.Fusion.Util"
    \ , "Data.Vector.Generic"
    \ , "Data.Vector.Generic.Base"
    \ , "Data.Vector.Generic.Mutable"
    \ , "Data.Vector.Generic.Mutable.Base"
    \ , "Data.Vector.Generic.New"
    \ , "Data.Vector.Internal.Check"
    \ , "Data.Vector.Mutable"
    \ , "Data.Vector.Primitive"
    \ , "Data.Vector.Primitive.Mutable"
    \ , "Data.Vector.Storable"
    \ , "Data.Vector.Storable.Internal"
    \ , "Data.Vector.Storable.Mutable"
    \ , "Data.Vector.Unboxed"
    \ , "Data.Vector.Unboxed.Base"
    \ , "Data.Vector.Unboxed.Mutable"
    \ , "Text.XHtml"
    \ , "Text.XHtml.Debug"
    \ , "Text.XHtml.Frameset"
    \ , "Text.XHtml.Strict"
    \ , "Text.XHtml.Table"
    \ , "Text.XHtml.Transitional"
    \ , "Codec.Compression.GZip"
    \ , "Codec.Compression.Zlib"
    \ , "Codec.Compression.Zlib.Internal"
    \ , "Codec.Compression.Zlib.Raw"
    \ , "Web.Spock"
    \ , "Web.Spock.Config"
    \ , "Web.Spock.Internal.SessionManager"
    \ , "Web.Spock.Internal.SessionVault"
    \ , "Web.Spock.SessionActions"
    \ , "Web.Spock.Api"
    \ , "Web.Spock.Auth"
    \ , "Web.Spock.Action"
    \ , "Web.Spock.Core"
    \ , "Web.Spock.Internal.Cookies"
    \ , "Web.Spock.Internal.Util"
    \ , "Web.Spock.Routing"
    \ , "Web.Spock.Digestive"
    \ , "Database.Esqueleto"
    \ , "Database.Esqueleto.Internal.Language"
    \ , "Database.Esqueleto.Internal.Sql"
    \ , "Database.Esqueleto.PostgreSQL"
    \ , "Database.Persist"
    \ , "Database.Persist.Class"
    \ , "Database.Persist.Quasi"
    \ , "Database.Persist.Sql"
    \ , "Database.Persist.Sql.Types.Internal"
    \ , "Database.Persist.Sql.Util"
    \ , "Database.Persist.Types"
    \ , "Database.Persist.MySQL"
    \ , "Database.Persist.Postgresql"
    \ , "Database.Persist.Postgresql.JSON"
    \ , "Database.Persist.Redis"
    \ , "Database.Persist.Sqlite"
    \ , "Database.Sqlite"
    \ , "Servant.API"
    \ , "Servant.API.Alternative"
    \ , "Servant.API.BasicAuth"
    \ , "Servant.API.Capture"
    \ , "Servant.API.ContentTypes"
    \ , "Servant.API.Description"
    \ , "Servant.API.Empty"
    \ , "Servant.API.Experimental.Auth"
    \ , "Servant.API.Generic"
    \ , "Servant.API.Header"
    \ , "Servant.API.HttpVersion"
    \ , "Servant.API.Internal.Test.ComprehensiveAPI"
    \ , "Servant.API.IsSecure"
    \ , "Servant.API.Modifiers"
    \ , "Servant.API.QueryParam"
    \ , "Servant.API.Raw"
    \ , "Servant.API.RemoteHost"
    \ , "Servant.API.ReqBody"
    \ , "Servant.API.ResponseHeaders"
    \ , "Servant.API.Stream"
    \ , "Servant.API.Sub"
    \ , "Servant.API.TypeLevel"
    \ , "Servant.API.Vault"
    \ , "Servant.API.Verbs"
    \ , "Servant.API.WithNamedContext"
    \ , "Servant.Links"
    \ , "Servant.Utils.Enter"
    \ , "Servant.Utils.Links"
    \ , "Servant.Auth"
    \ , "Servant.Client"
    \ , "Servant.Client.Internal.HttpClient"
    \ , "Servant"
    \ , "Servant.Server"
    \ , "Servant.Server.Experimental.Auth"
    \ , "Servant.Server.Generic"
    \ , "Servant.Server.Internal"
    \ , "Servant.Server.Internal.BasicAuth"
    \ , "Servant.Server.Internal.Context"
    \ , "Servant.Server.Internal.Handler"
    \ , "Servant.Server.Internal.Router"
    \ , "Servant.Server.Internal.RoutingApplication"
    \ , "Servant.Server.Internal.ServantErr"
    \ , "Servant.Server.StaticFiles"
    \ , "Servant.Utils.StaticFiles"
    \ ]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                " Vim completion script
" Language:	HTML and XHTML
" Maintainer:	Mikolaj Machowski ( mikmach AT wp DOT pl )
" Last Change:	2019 Sep 27

" Distinguish between HTML versions.
" To use with other HTML versions add another "elseif" condition to match
" proper DOCTYPE.
function! htmlcomplete#DetectOmniFlavor()
  if &filetype == 'xhtml'
    let b:html_omni_flavor = 'xhtml10s'
  else
    let b:html_omni_flavor = 'html401t'
  endif
  let i = 1
  let line = ""
  while i < 10 && i < line("$")
    let line = getline(i)
    if line =~ '<!DOCTYPE.*\<DTD '
      break
    endif
    let i += 1
  endwhile
  if line =~ '<!DOCTYPE.*\<DTD '  " doctype line found above
    if line =~ ' HTML 3\.2'
      let b:html_omni_flavor = 'html32'
    elseif line =~ ' XHTML 1\.1'
      let b:html_omni_flavor = 'xhtml11'
    else    " two-step detection with strict/frameset/transitional
      if line =~ ' XHTML 1\.0'
	let b:html_omni_flavor = 'xhtml10'
      elseif line =~ ' HTML 4\.01'
	let b:html_omni_flavor = 'html401'
      elseif line =~ ' HTML 4.0\>'
	let b:html_omni_flavor = 'html40'
      endif
      if line =~ '\<Transitional\>'
	let b:html_omni_flavor .= 't'
      elseif line =~ '\<Frameset\>'
	let b:html_omni_flavor .= 'f'
      else
	let b:html_omni_flavor .= 's'
      endif
    endif
  endif
endfunction

function! htmlcomplete#CompleteTags(findstart, base)
  if a:findstart
    " locate the start of the word
    let line = getline('.')
    let start = col('.') - 1
	let curline = line('.')
	let compl_begin = col('.') - 2
    while start >= 0 && line[start - 1] =~ '\(\k\|[!:.-]\)'
		let start -= 1
    endwhile
	" Handling of entities {{{
	if start >= 0 && line[start - 1] =~ '&'
		let b:entitiescompl = 1
		let b:compl_context = ''
		return start
	endif
	" }}}
	" Handling of <style> tag {{{
	let stylestart = searchpair('<style\>', '', '<\/style\>', "bnW")
	let styleend   = searchpair('<style\>', '', '<\/style\>', "nW")
	if stylestart != 0 && styleend != 0
		if stylestart <= curline && styleend >= curline
			let start = col('.') - 1
			let b:csscompl = 1
			while start >= 0 && line[start - 1] =~ '\(\k\|-\)'
				let start -= 1
			endwhile
		endif
	endif
	" }}}
	" Handling of <script> tag {{{
	let scriptstart = searchpair('<script\>', '', '<\/script\>', "bnW")
	let scriptend   = searchpair('<script\>', '', '<\/script\>', "nW")
	if scriptstart != 0 && scriptend != 0
		if scriptstart <= curline && scriptend >= curline
			let start = col('.') - 1
			let b:jscompl = 1
			let b:jsrange = [scriptstart, scriptend]
			while start >= 0 && line[start - 1] =~ '\k'
				let start -= 1
			endwhile
			" We are inside of <script> tag. But we should also get contents
			" of all linked external files and (secondary, less probably) other <script> tags
			" This logic could possible be done in separate function - may be
			" reused in events scripting (also with option could be reused for
			" CSS
			let b:js_extfiles = []
			let l = line('.')
			let c = col('.')
			call cursor(1,1)
			while search('<\@<=script\>', 'W') && line('.') <= l
				if synIDattr(synID(line('.'),col('.')-1,0),"name") !~? 'comment'
					let sname = matchstr(getline('.'), '<script[^>]*src\s*=\s*\([''"]\)\zs.\{-}\ze\1')
					if filereadable(sname)
						let b:js_extfiles += readfile(sname)
					endif
				endif
			endwhile
			call cursor(1,1)
			let js_scripttags = []
			while search('<script\>', 'W') && line('.') < l
				if matchstr(getline('.'), '<script[^>]*src') == ''
					let js_scripttag = getline(line('.'), search('</script>', 'W'))
					let js_scripttags += js_scripttag
				endif
			endwhile
			let b:js_extfiles += js_scripttags
			call cursor(l,c)
			unlet! l c
		endif
	endif
	" }}}
	if !exists("b:csscompl") && !exists("b:jscompl")
		let b:compl_context = getline('.')[0:(compl_begin)]
		if b:compl_context !~ '<[^>]*$'
			" Look like we may have broken tag. Check previous lines.
			let i = 1
			while 1
				let context_line = getline(curline-i)
				if context_line =~ '<[^>]*$'
					" Yep, this is this line
					let context_lines = getline(curline-i, curline-1) + [b:compl_context]
					let b:compl_context = join(context_lines, ' ')
					break
				elseif context_line =~ '>[^<]*$' || i == curline
					" We are in normal tag line, no need for completion at all
					" OR reached first line without tag at all
					let b:compl_context = ''
					break
				endif
				let i += 1
			endwhile
			" Make sure we don't have counter
			unlet! i
		endif
		let b:compl_context = matchstr(b:compl_context, '.*\zs<.*')

		" Return proper start for on-events. Without that beginning of
		" completion will be badly reported
		if b:compl_context =~? 'on[a-z]*\s*=\s*\(''[^'']*\|"[^"]*\)$'
			let start = col('.') - 1
			while start >= 0 && line[start - 1] =~ '\k'
				let start -= 1
			endwhile
		endif
		" If b:compl_context begins with <? we are inside of PHP code. It
		" wasn't closed so PHP completion passed it to HTML
		if &filetype =~? 'php' && b:compl_context =~ '^<?'
			let b:phpcompl = 1
			let start = col('.') - 1
			while start >= 0 && line[start - 1] =~ '[a-zA-Z_0-9\x7f-\xff$]'
				let start -= 1
			endwhile
		endif
	else
		let b:compl_context = getline('.')[0:compl_begin]
	endif
    return start
  else
	" Initialize base return lists
    let res = []
    let res2 = []
	" a:base is very short - we need context
	let context = b:compl_context
	" Check if we should do CSS completion inside of <style> tag
	" or JS completion inside of <script> tag or PHP completion in case of <?
	" tag AND &ft==php
	if exists("b:csscompl")
		unlet! b:csscompl
		let context = b:compl_context
		unlet! b:compl_context
		return csscomplete#CompleteCSS(0, context)
	elseif exists("b:jscompl")
		unlet! b:jscompl
		return javascriptcomplete#CompleteJS(0, a:base)
	elseif exists("b:phpcompl")
		unlet! b:phpcompl
		let context = b:compl_context
		return phpcomplete#CompletePHP(0, a:base)
	else
		if len(b:compl_context) == 0 && !exists("b:entitiescompl")
			return []
		endif
		let context = matchstr(b:compl_context, '.\zs.*')
	endif
	unlet! b:compl_context
	" Entities completion {{{
	if exists("b:entitiescompl")
		unlet! b:entitiescompl

		if !exists("b:html_doctype")
			call htmlcomplete#CheckDoctype()
		endif
		if !exists("b:html_omni")
			"runtime! autoload/xml/xhtml10s.vim
			call htmlcomplete#LoadData()
		endif

	    let entities =  b:html_omni['vimxmlentities']

		if len(a:base) == 1
			for m in entities
				if m =~ '^'.a:base
					call add(res, m.';')
				endif
			endfor
			return res
		else
			for m in entities
				if m =~? '^'.a:base
					call add(res, m.';')
				elseif m =~? a:base
					call add(res2, m.';')
				endif
			endfor

			return res + res2
		endif


	endif
	" }}}
	if context =~ '>'
		" Generally if context contains > it means we are outside of tag and
		" should abandon action - with one exception: <style> span { bo
		if context =~ 'style[^>]\{-}>[^<]\{-}$'
			return csscomplete#CompleteCSS(0, context)
		elseif context =~ 'script[^>]\{-}>[^<]\{-}$'
			let b:jsrange = [line('.'), search('<\/script\>', 'nW')]
			return javascriptcomplete#CompleteJS(0, context)
		else
			return []
		endif
	endif

	" If context contains > it means we are already outside of tag and we
	" should abandon action
	" If context contains white space it is attribute.
	" It can be also value of attribute.
	" We have to get first word to offer proper completions
	if context =~ '^\s*$'
		" empty or whitespace line
		let tag = ''
	else
		let tag = split(context)[0]
		" Detect if tag is uppercase to return in proper case,
		" we need to make it lowercase for processing
		if tag =~ '^[A-Z]*$'
			let uppercase_tag = 1
			let tag = tolower(tag)
		else
			let uppercase_tag = 0
		endif
	endif
	" Get last word, it should be attr name
	let attr = matchstr(context, '.*\s\zs.*')
	" Possible situations where any prediction would be difficult:
	" 1. Events attributes
	if context =~ '\s'
		" Sort out style, class, and on* cases
		if context =~? "\\(on[a-z]*\\|id\\|style\\|class\\)\\s*=\\s*[\"']"
			" Id, class completion {{{
			if context =~? "\\(id\\|class\\)\\s*=\\s*[\"'][a-zA-Z0-9_ -]*$"
				if context =~? "class\\s*=\\s*[\"'][a-zA-Z0-9_ -]*$"
					let search_for = "class"
				elseif context =~? "id\\s*=\\s*[\"'][a-zA-Z0-9_ -]*$"
					let search_for = "id"
				endif
				" Handle class name completion
				" 1. Find lines of <link stylesheet>
				" 1a. Check file for @import
				" 2. Extract filename(s?) of stylesheet,
				call cursor(1,1)
				let head = getline(search('<head\>'), search('<\/head>'))
				let headjoined = join(copy(head), ' ')
				if headjoined =~ '<style'
					" Remove possibly confusing CSS operators
					let stylehead = substitute(headjoined, '+>\*[,', ' ', 'g')
					if search_for == 'class'
						let styleheadlines = split(stylehead)
						let headclasslines = filter(copy(styleheadlines), "v:val =~ '\\([a-zA-Z0-9:]\\+\\)\\?\\.[a-zA-Z0-9_-]\\+'")
					else
						let stylesheet = split(headjoined, '[{}]')
						" Get all lines which fit id syntax
						let classlines = filter(copy(stylesheet), "v:val =~ '#[a-zA-Z0-9_-]\\+'")
						" Filter out possible color definitions
						call filter(classlines, "v:val !~ ':\\s*#[a-zA-Z0-9_-]\\+'")
						" Filter out complex border definitions
						call filter(classlines, "v:val !~ '\\(none\\|hidden\\|dotted\\|dashed\\|solid\\|double\\|groove\\|ridge\\|inset\\|outset\\)\\s*#[a-zA-Z0-9_-]\\+'")
						let templines = join(classlines, ' ')
						let headclasslines = split(templines)
						call filter(headclasslines, "v:val =~ '#[a-zA-Z0-9_-]\\+'")
					endif
					let internal = 1
				else
					let internal = 0
				endif
				let styletable = []
				let secimportfiles = []
				let filestable = filter(copy(head), "v:val =~ '\\(@import\\|link.*stylesheet\\)'")
				for line in filestable
					if line =~ "@import"
						let styletable += [matchstr(line, "import\\s\\+\\(url(\\)\\?[\"']\\?\\zs\\f\\+\\ze")]
					elseif line =~ "<link"
						let styletable += [matchstr(line, "href\\s*=\\s*[\"']\\zs\\f\\+\\ze")]
					endif
				endfor
				for file in styletable
					if filereadable(file)
						let stylesheet = readfile(file)
						let secimport = filter(copy(stylesheet), "v:val =~ '@import'")
						if len(secimport) > 0
							for line in secimport
								let secfile = matchstr(line, "import\\s\\+\\(url(\\)\\?[\"']\\?\\zs\\f\\+\\ze")
								let secfile = fnamemodify(file, ":p:h").'/'.secfile
								let secimportfiles += [secfile]
							endfor
						endif
					endif
				endfor
				let cssfiles = styletable + secimportfiles
				let classes = []
				for file in cssfiles
				  	let classlines = []
					if filereadable(file)
						let stylesheet = readfile(file)
						let stylefile = join(stylesheet, ' ')
						let stylefile = substitute(stylefile, '+>\*[,', ' ', 'g')
						if search_for == 'class'
							let stylesheet = split(stylefile)
							let classlines = filter(copy(stylesheet), "v:val =~ '\\([a-zA-Z0-9:]\\+\\)\\?\\.[a-zA-Z0-9_-]\\+'")
						else
							let stylesheet = split(stylefile, '[{}]')
							" Get all lines which fit id syntax
							let classlines = filter(copy(stylesheet), "v:val =~ '#[a-zA-Z0-9_-]\\+'")
							" Filter out possible color definitions
							call filter(classlines, "v:val !~ ':\\s*#[a-zA-Z0-9_-]\\+'")
							" Filter out complex border definitions
							call filter(classlines, "v:val !~ '\\(none\\|hidden\\|dotted\\|dashed\\|solid\\|double\\|groove\\|ridge\\|inset\\|outset\\)\\s*#[a-zA-Z0-9_-]\\+'")
							let templines = join(classlines, ' ')
							let stylelines = split(templines)
							let classlines = filter(stylelines, "v:val =~ '#[a-zA-Z0-9_-]\\+'")

						endif
					endif
					" We gathered classes definitions from all external files
					let classes += classlines
				endfor
				if internal == 1
					let classes += headclasslines
				endif

				if search_for == 'class'
					let elements = {}
					for element in classes
						if element =~ '^\.'
							let class = matchstr(element, '^\.\zs[a-zA-Z][a-zA-Z0-9_-]*\ze')
							let class = substitute(class, ':.*', '', '')
							if has_key(elements, 'common')
								let elements['common'] .= ' '.class
							else
								let elements['common'] = class
							endif
						else
							let class = matchstr(element, '[a-zA-Z1-6]*\.\zs[a-zA-Z][a-zA-Z0-9_-]*\ze')
							letVl  Wl  Xl  Yl  Zl  [l  \l  ]l  ^l  _l  `l  al  bl                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               tagname = tolower(matchstr(element, '[a-zA-Z1-6]*\ze.'))
							if tagname != ''
								if has_key(elements, tagname)
									let elements[tagname] .= ' '.class
								else
									let elements[tagname] = class
								endif
							endif
						endif
					endfor

					if has_key(elements, tag) && has_key(elements, 'common')
						let values = split(elements[tag]." ".elements['common'])
					elseif has_key(elements, tag) && !has_key(elements, 'common')
						let values = split(elements[tag])
					elseif !has_key(elements, tag) && has_key(elements, 'common')
						let values = split(elements['common'])
					else
						return []
					endif

				elseif search_for == 'id'
					" Find used IDs
					" 1. Catch whole file
					let filelines = getline(1, line('$'))
					" 2. Find lines with possible id
					let used_id_lines = filter(filelines, 'v:val =~ "id\\s*=\\s*[\"''][a-zA-Z0-9_-]\\+"')
					" 3a. Join all filtered lines
					let id_string = join(used_id_lines, ' ')
					" 3b. And split them to be sure each id is in separate item
					let id_list = split(id_string, 'id\s*=\s*')
					" 4. Extract id values
					let used_id = map(id_list, 'matchstr(v:val, "[\"'']\\zs[a-zA-Z0-9_-]\\+\\ze")')
					let joined_used_id = ','.join(used_id, ',').','

					let allvalues = map(classes, 'matchstr(v:val, ".*#\\zs[a-zA-Z0-9_-]\\+")')

					let values = []

					for element in classes
						if joined_used_id !~ ','.element.','
							let values += [element]
						endif

					endfor

				endif

				" We need special version of sbase
				let classbase = matchstr(context, ".*[\"']")
				let classquote = matchstr(classbase, '.$')

				let entered_class = matchstr(attr, ".*=\\s*[\"']\\zs.*")

				for m in sort(values)
					if m =~? '^'.entered_class
						call add(res, m . classquote)
					elseif m =~? entered_class
						call add(res2, m . classquote)
					endif
				endfor

				return res + res2

			elseif context =~? "style\\s*=\\s*[\"'][^\"']*$"
				return csscomplete#CompleteCSS(0, context)

			endif
			" }}}
			" Complete on-events {{{
			if context =~? 'on[a-z]*\s*=\s*\(''[^'']*\|"[^"]*\)$'
				" We have to:
				" 1. Find external files
				let b:js_extfiles = []
				let l = line('.')
				let c = col('.')
				call cursor(1,1)
				while search('<\@<=script\>', 'W') && line('.') <= l
					if synIDattr(synID(line('.'),col('.')-1,0),"name") !~? 'comment'
						let sname = matchstr(getline('.'), '<script[^>]*src\s*=\s*\([''"]\)\zs.\{-}\ze\1')
						if filereadable(sname)
							let b:js_extfiles += readfile(sname)
						endif
					endif
				endwhile
				" 2. Find at least one <script> tag
				call cursor(1,1)
				let js_scripttags = []
				while search('<script\>', 'W') && line('.') < l
					if matchstr(getline('.'), '<script[^>]*src') == ''
						let js_scripttag = getline(line('.'), search('</script>', 'W'))
						let js_scripttags += js_scripttag
					endif
				endwhile
				let b:js_extfiles += js_scripttags

				" 3. Proper call for javascriptcomplete#CompleteJS
				call cursor(l,c)
				let js_context = matchstr(a:base, '\k\+$')
				let js_shortcontext = substitute(a:base, js_context.'$', '', '')
				let b:compl_context = context
				let b:jsrange = [l, l]
				unlet! l c
				return javascriptcomplete#CompleteJS(0, js_context)

			endif

			" }}}
			let stripbase = matchstr(context, ".*\\(on[a-zA-Z]*\\|style\\|class\\)\\s*=\\s*[\"']\\zs.*")
			" Now we have context stripped from all chars up to style/class.
			" It may fail with some strange style value combinations.
			if stripbase !~ "[\"']"
				return []
			endif
		endif
		" Value of attribute completion {{{
		" If attr contains =\s*[\"'] we match value of attribute
		if attr =~ "=\s*[\"']" || attr =~ "=\s*$"
			" Let do attribute specific completion
			let attrname = matchstr(attr, '.*\ze\s*=')
			let entered_value = matchstr(attr, ".*=\\s*[\"']\\?\\zs.*")
			let values = []
			" Load data {{{
			if !exists("b:html_doctype")
				call htmlcomplete#CheckDoctype()
			endif
			if !exists("b:html_omni")
				"runtime! autoload/xml/xhtml10s.vim
				call htmlcomplete#LoadData()
			endif
			" }}}
			if attrname == 'href'
				" Now we are looking for local anchors defined by name or id
				if entered_value =~ '^#'
					let file = join(getline(1, line('$')), ' ')
					" Split it be sure there will be one id/name element in
					" item, it will be also first word [a-zA-Z0-9_-] in element
					let oneelement = split(file, "\\(meta \\)\\@<!\\(name\\|id\\)\\s*=\\s*[\"']")
					for i in oneelement
						let values += ['#'.matchstr(i, "^[a-zA-Z][a-zA-Z0-9%_-]*")]
					endfor
				endif
			else
				if has_key(b:html_omni, tag) && has_key(b:html_omni[tag][1], attrname)
					let values = b:html_omni[tag][1][attrname]
				else
					return []
				endif
			endif

			if len(values) == 0
				return []
			endif

			" We need special version of sbase
			let attrbase = matchstr(context, ".*[\"']")
			let attrquote = matchstr(attrbase, '.$')
			if attrquote !~ "['\"]"
				let attrquoteopen = '"'
				let attrquote = '"'
			else
				let attrquoteopen = ''
			endif

			for m in values
				" This if is needed to not offer all completions as-is
				" alphabetically but sort them. Those beginning with entered
				" part will be as first choices
				if m =~ '^'.entered_value
					call add(res, attrquoteopen . m . attrquote)
				elseif m =~ entered_value
					call add(res2, attrquoteopen . m . attrquote)
				endif
			endfor

			return res + res2

		endif
		" }}}
		" Attribute completion {{{
		" Shorten context to not include last word
		let sbase = matchstr(context, '.*\ze\s.*')

		" Load data {{{
		if !exists("b:html_doctype")
			call htmlcomplete#CheckDoctype()
		endif
		if !exists("b:html_omni")
			call htmlcomplete#LoadData()
		endif
		" }}}

		if has_key(b:html_omni, tag)
			let attrs = keys(b:html_omni[tag][1])
		else
			return []
		endif

		for m in sort(attrs)
			if m =~ '^'.attr
				call add(res, m)
			elseif m =~ attr
				call add(res2, m)
			endif
		endfor
		let menu = res + res2
		if has_key(b:html_omni, 'vimxmlattrinfo')
			let final_menu = []
			for i in range(len(menu))
				let item = menu[i]
				if has_key(b:html_omni['vimxmlattrinfo'], item)
					let m_menu = b:html_omni['vimxmlattrinfo'][item][0]
					let m_info = b:html_omni['vimxmlattrinfo'][item][1]
				else
					let m_menu = ''
					let m_info = ''
				endif
				if len(b:html_omni[tag][1][item]) > 0 && b:html_omni[tag][1][item][0] =~ '^\(BOOL\|'.item.'\)$'
					let item = item
					let m_menu = 'Bool'
				else
					let item .= '="'
				endif
				let final_menu += [{'word':item, 'menu':m_menu, 'info':m_info}]
			endfor
		else
			let final_menu = []
			for i in range(len(menu))
				let item = menu[i]
				if len(b:html_omni[tag][1][item]) > 0 && b:html_omni[tag][1][item][0] =~ '^\(BOOL\|'.item.'\)$'
					let item = item
				else
					let item .= '="'
				endif
				let final_menu += [item]
			endfor
			return final_menu

		endif
		return final_menu

	endif
	" }}}
	" Close tag {{{
	let b:unaryTagsStack = "base meta link hr br param img area input col"
	if context =~ '^\/'
		if context =~ '^\/.'
			return []
		else
			let opentag = xmlcomplete#GetLastOpenTag("b:unaryTagsStack")
			return [opentag.">"]
		endif
	endif
	" }}}
	" Load data {{{
	if !exists("b:html_doctype")
		call htmlcomplete#CheckDoctype()
	endif
	if !exists("b:html_omni")
		"runtime! autoload/xml/xhtml10s.vim
		call htmlcomplete#LoadData()
	endif
	" }}}
	" Tag completion {{{
	" Deal with tag completion.
	let opentag = tolower(xmlcomplete#GetLastOpenTag("b:unaryTagsStack"))
	" MM: TODO: GLOT works always the same but with some weird situation it
	" behaves as intended in HTML but screws in PHP
	if opentag == '' || &filetype == 'php' && !has_key(b:html_omni, opentag)
		" Hack for sometimes failing GetLastOpenTag.
		" As far as I tested fail isn't GLOT fault but problem
		" of invalid document - not properly closed tags and other mish-mash.
		" Also when document is empty. Return list of *all* tags.
	    let tags = keys(b:html_omni)
		call filter(tags, 'v:val !~ "^vimxml"')
	else
		if has_key(b:html_omni, opentag)
			let tags = b:html_omni[opentag][0]
		else
			return []
		endif
	endif
	" }}}

	if exists("uppercase_tag") && uppercase_tag == 1
		let context = tolower(context)
	endif
	" Handle XML keywords: DOCTYPE
	if opentag == ''
		let tags += [
				\ '!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">',
				\ '!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">',
				\ '!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">',
				\ '!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN" "http://www.w3.org/TR/REC-html40/frameset.dtd">',
				\ '!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">',
				\ '!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">',
				\ '!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd">',
				\ '!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">',
				\ '!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">',
				\ '!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">',
				\ '!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/1999/xhtml">'
				\ ]
	endif

	for m in sort(tags)
		if m =~ '^'.context
			call add(res, m)
		elseif m =~ context
			call add(res2, m)
		endif
	endfor
	let menu = res + res2
	if has_key(b:html_omni, 'vimxmltaginfo')
		let final_menu = []
		for i in range(len(menu))
			let item = menu[i]
			if has_key(b:html_omni['vimxmltaginfo'], item)
				let m_menu = b:html_omni['vimxmltaginfo'][item][0]
				let m_info = b:html_omni['vimxmltaginfo'][item][1]
			else
				let m_menu = ''
				let m_info = ''
			endif
			if &filetype == 'html' && exists("uppercase_tag") && uppercase_tag == 1 && item !~ 'DOCTYPE'
				let item = toupper(item)
			endif
			if item =~ 'DOCTYPE'
				let abbr = 'DOCTYPE '.matchstr(item, 'DTD \zsX\?HTML .\{-}\ze\/\/')
			else
				let abbr = item
			endif
			let final_menu += [{'abbr':abbr, 'word':item, 'menu':m_menu, 'info':m_info}]
		endfor
	else
		let final_menu = menu
	endif
	return final_menu

	" }}}
  endif
endfunction

function! htmlcomplete#LoadData() " {{{
	if !exists("b:html_omni_flavor")
		if &filetype == 'html'
			let b:html_omni_flavor = 'html401t'
		else
			let b:html_omni_flavor = 'xhtml10s'
		endif
	endif
	" With that if we still have bloated memory but create new buffer
	" variables only by linking to existing g:variable, not sourcing whole
	" file.
	if exists('g:xmldata_'.b:html_omni_flavor)
		exe 'let b:html_omni = g:xmldata_'.b:html_omni_flavor
	else
		exe 'runtime! autoload/xml/'.b:html_omni_flavor.'.vim'
		exe 'let b:html_omni = g:xmldata_'.b:html_omni_flavor
	endif
endfunction
" }}}
function! htmlcomplete#CheckDoctype() " {{{
	if exists('b:html_omni_flavor')
		let old_flavor = b:html_omni_flavor
	else
		let old_flavor = ''
	endif
	let i = 1
	while i < 10 && i < line("$")
		let line = getline(i)
		if line =~ '<!DOCTYPE.*\<DTD HTML 3\.2'
			let b:html_omni_flavor = 'html32'
			let b:html_doctype = 1
			break
		elseif line =~ '<!DOCTYPE.*\<DTD HTML 4\.0 Transitional'
			let b:html_omni_flavor = 'html40t'
			let b:html_doctype = 1
			break
		elseif line =~ '<!DOCTYPE.*\<DTD HTML 4\.0 Frameset'
			let b:html_omni_flavor = 'html40f'
			let b:html_doctype = 1
			break
		elseif line =~ '<!DOCTYPE.*\<DTD HTML 4\.0'
			let b:html_omni_flavor = 'html40s'
			let b:html_doctype = 1
			break
		elseif line =~ '<!DOCTYPE.*\<DTD HTML 4\.01 Transitional'
			let b:html_omni_flavor = 'html401t'
			let b:html_doctype = 1
			break
		elseif line =~ '<!DOCTYPE.*\<DTD HTML 4\.01 Frameset'
			let b:html_omni_flavor = 'html401f'
			let b:html_doctype = 1
			break
		elseif line =~ '<!DOCTYPE.*\<DTD HTML 4\.01'
			let b:html_omni_flavor = 'html401s'
			let b:html_doctype = 1
			break
		elseif line =~ '<!DOCTYPE.*\<DTD XHTML 1\.0 Transitional'
			let b:html_omni_flavor = 'xhtml10t'
			let b:html_doctype = 1
			break
		elseif line =~ '<!DOCTYPE.*\<DTD XHTML 1\.0 Frameset'
			let b:html_omni_flavor = 'xhtml10f'
			let b:html_doctype = 1
			break
		elseif line =~ '<!DOCTYPE.*\<DTD XHTML 1\.0 Strict'
			let b:html_omni_flavor = 'xhtml10s'
			let b:html_doctype = 1
			break
		elseif line =~ '<!DOCTYPE.*\<DTD XHTML 1\.1'
			let b:html_omni_flavor = 'xhtml11'
			let b:html_doctype = 1
			break
		endif
		let i += 1
	endwhile
	if !exists("b:html_doctype")
		return
	else
		" Tie g:xmldata with b:html_omni this way we need to sourca data file only
		" once, not every time per buffer.
		if old_flavor == b:html_omni_flavor
			return
		else
			if exists('g:xmldata_'.b:html_omni_flavor)
				exe 'let b:html_omni = g:xmldata_'.b:html_omni_flavor
			else
				exe 'runtime! autoload/xml/'.b:html_omni_flavor.'.vim'
				exe 'let b:html_omni = g:xmldata_'.b:html_omni_flavor
			endif
			return
		endif
	endif
endfunction
" }}}
" vim:set foldmethod=marker:
                                                                                                                      " Vim completion script
" Language:	Java Script
" Maintainer:	Jay Sitter (jay@jaysitter.com)
" URL: https://github.com/jsit/javascriptcomplete.vim/
" Previous Maintainer:	Mikolaj Machowski ( mikmach AT wp DOT pl )
" Last Change:	2020 Jul 30

function! javascriptcomplete#CompleteJS(findstart, base)
  if a:findstart
	" locate the start of the word
	let line = getline('.')
	let start = col('.') - 1
	let curline = line('.')
	let compl_begin = col('.') - 2
	" Bit risky but JS is rather limited language and local chars shouldn't
	" fint way into names
	while start >= 0 && line[start - 1] =~ '\k'
		let start -= 1
	endwhile
	let b:compl_context = getline('.')[0:compl_begin]
	return start
  else
	" Initialize base return lists
	let res = []
	let res2 = []
	" a:base is very short - we need context
	" Shortcontext is context without a:base, useful for checking if we are
	" looking for objects and for what objects we are looking for
	let context = b:compl_context
	let shortcontext = substitute(context, a:base.'$', '', '')
	unlet! b:compl_context

	if exists("b:jsrange")
		let file = getline(b:jsrange[0],b:jsrange[1])
		unlet! b:jsrange

		if len(b:js_extfiles) > 0
			let file = b:js_extfiles + file
		endif

	else
		let file = getline(1, '$')
	endif


	" Completion of properties, methods, etc. {{{
	if shortcontext =~ '\.$'
		" Complete methods and properties for objects
		" DOM separate
		let doms = ['style.']
		" Arrays
		let arrayprop = ['constructor', 'index', 'input', 'length', 'prototype']
		let arraymeth = ['concat', 'join', 'pop', 'push', 'reverse', 'shift',
					\ 'splice', 'sort', 'toSource', 'toString', 'unshift', 'valueOf',
					\ 'watch', 'unwatch']
		call map(arraymeth, 'v:val."("')
		let arrays = arrayprop + arraymeth

		" Boolean - complete subset of array values
		" properties - constructor, prototype
		" methods    - toSource, toString, valueOf

		" Date
		" properties - constructor, prototype
		let datemeth = ['getDate', 'getDay', 'getFullYear', 'getHours', 'getMilliseconds',
					\ 'getMinutes', 'getMonth', 'getSeconds', 'getTime', 'getTimezoneOffset',
					\ 'getUTCDate', 'getUTCDay', 'getUTCFullYear', 'getUTCHours', 'getUTCMilliseconds',
					\ 'getUTCMinutes', 'getUTCMonth', 'getUTCSeconds',
					\ 'getYear', 'parse', 'parse',
					\ 'setDate', 'setDay', 'setFullYear', 'setHours', 'setMilliseconds',
					\ 'setMinutes', 'setMonth', 'setSeconds',
					\ 'setUTCDate', 'setUTCDay', 'setUTCFullYear', 'setUTCHours', 'setUTCMilliseconds',
					\ 'setUTCMinutes', 'setUTCMonth', 'setUTCSeconds', 'setYear', 'setTime',
					\ 'toGMTString', 'toLocaleString', 'toLocaleDateString', 'toLocaleTimeString',
					\ 'toSource', 'toString', 'toUTCString', 'UTC', 'valueOf', 'watch', 'unwatch']
		call map(datemeth, 'v:val."("')
		let dates = datemeth

		" Function
		let funcprop = ['arguments', 'arguments.callee', 'arguments.caller', 'arguments.length',
					\ 'arity', 'constructor', 'length', 'prototype']
		let funcmeth = ['apply', 'call', 'toSource', 'toString', 'valueOf']
		call map(funcmeth, 'v:val."("')
		let funcs = funcprop + funcmeth

		" Math
		let mathprop = ['E', 'LN2', 'LN10', 'LOG2E', 'LOG10E', 'PI', 'SQRT1_2', 'SQRT']
		let mathmeth = ['abs', 'acos', 'asin', 'atan', 'atan2', 'ceil', 'cos', 'exp', 'floor',
					\ 'log', 'max', 'min', 'pow', 'random', 'round', 'sin', 'sqrt', 'tan',
					\ 'watch', 'unwatch']
		call map(mathmeth, 'v:val."("')
		let maths = mathprop + mathmeth

		" Number
		let numbprop = ['MAX_VALUE', 'MIN_VALUE', 'NaN', 'NEGATIVE_INFINITY', 'POSITIVE_INFINITY', 
					\ 'constructor', 'prototype']
		let numbmeth = ['toExponential', 'toFixed', 'toPrecision', 'toSource', 'toString', 'valueOf',
					\ 'watch', 'unwatch']
		call map(numbmeth, 'v:val."("')
		let numbs = numbprop + numbmeth

		" Object
		let objeprop = ['constructor', 'prototype']
		let objemeth = ['eval', 'toSource', 'toString', 'unwatch', 'watch', 'valueOf']
		call map(objemeth, 'v:val."("')
		let objes = objeprop + objemeth

		" RegExp
		let regeprop = ['constructor', 'global', 'ignoreCase', 'lastIndex', 'multiline', 'source', 'prototype']
		let regemeth = ['exec', 'test', 'toSource', 'toString', 'watch', 'unwatch']
		call map(regemeth, 'v:val."("')
		let reges = regeprop + regemeth

		" String
		let striprop = ['constructor', 'length', 'prototype']
		let strimeth = ['anchor', 'big', 'blink', 'bold', 'charAt', 'charCodeAt', 'concat',
					\ 'fixed', 'fontcolor', 'fontsize', 'fromCharCode', 'indexOf', 'italics',
					\ 'lastIndexOf', 'link', 'match', 'replace', 'search', 'slice', 'small',
					\ 'split', 'strike', 'sub', 'substr', 'substring', 'sup', 'toLowerCase',
					\ 'toSource', 'toString', 'toUpperCase', 'watch', 'unwatch']
		call map(strimeth, 'v:val."("')
		let stris = striprop + strimeth

		" User created properties
		let user_props1 = filter(copy(file), 'v:val =~ "this\\.\\k"')
		let juser_props1 = join(user_props1, ' ')
		let user_props1 = split(juser_props1, '\zethis\.')
		unlet! juser_props1
		call map(user_props1, 'matchstr(v:val, "this\\.\\zs\\k\\+\\ze")')

		let user_props2 = filter(copy(file), 'v:val =~ "\\.prototype\\.\\k"')
		let juser_props2 = join(user_props2, ' ')
		let user_props2 = split(juser_props2, '\zeprototype\.')
		unlet! juser_props2
		call map(user_props2, 'matchstr(v:val, "prototype\\.\\zs\\k\\+\\ze")')
		let user_props = user_props1 + user_props2

		" HTML DOM properties
		" Anchors - anchor.
		let anchprop = ['accessKey', 'charset', 'coords', 'href', 'hreflang', 'id', 'innerHTML',
					\ 'name', 'rel', 'rev', 'shape', 'tabIndex', 'target', 'type', 'onBlur', 'onFocus']
		let anchmeth = ['blur', 'focus']
		call map(anchmeth, 'v:val."("')
		let anths = anchprop + anchmeth
		" Area - area.
		let areaprop = ['accessKey', 'alt', 'coords', 'hash', 'host', 'hostname', 'href', 'id',
					\ 'noHref', 'pathname', 'port', 'protocol', 'search', 'shape', 'tabIndex', 'target']
		let areameth = ['onClick', 'onDblClick', 'onMouseOut', 'onMouseOver']
		call map(areameth, 'v:val."("')
		let areas = areaprop + areameth
		" Base - base.
		let baseprop = ['href', 'id', 'target']
		let bases = baseprop
		" Body - body.
		let bodyprop = ['aLink', 'background', 'gbColor', 'id', 'link', 'scrollLeft', 'scrollTop',
					\ 'text', 'vLink']
		let bodys = bodyprop
		" Document - document.
		let docuprop = ['anchors', 'body', 'characterSet', 'doctype',
					\ 'documentElement', 'documentURI', 'embeds', 'fonts', 'forms',
					\ 'head', 'hidden', 'images', 'implementation', 'lastStyleSheetSet',
					\ 'links', 'plugins', 'preferredStyleSheetSet', 'scripts',
					\ 'scrollingElement', 'selectedStyleSheetSet', 'styleSheetSets',
					\ 'timeline', 'visibilityState', 'cookie', 'defaultView',
					\ 'designMode', 'dir', 'domain', 'lastModified', 'location',
					\ 'readyState', 'referrer', 'title', 'URL', 'activeElement',
					\ 'fullscreenElement', 'styleSheets']
		let documeth = ['adoptNode', 'close', 'createAttribute',
					\ 'createAttributeNS', 'createCDATASection', 'createComment',
					\ 'createDocumentFragment', 'createElement', 'createElementNS',
					\ 'createEvent', 'createExpression', 'createNSResolver',
					\ 'createNodeIterator', 'createProcessingInstruction', 'createRange',
					\ 'createTextNode', 'createTouchList', 'createTreeWalker',
					\ 'enableStyleSheetsForSet', 'evaluate', 'focus', 'getElementById',
					\ 'getElementById', 'getElementsByClassName', 'getElementsByName',
					\ 'getElementsByTagName', 'getElementsByTagNameNS',
					\ 'hasStorageAccess', 'importNode', 'onClick', 'onDblClick',
					\ 'onFocus', 'onKeyDown', 'onKeyPress', 'onKeyUp', 'onMouseDown',
					\ 'onMouseMove', 'onMouseOut', 'onMouseOver', 'onMouseUp',
					\ 'onResize', 'open', 'querySelector', 'querySelectorAll',
					\ 'requestStorageAccess', 'write', 'writeln']

		call map(documeth, 'v:val."("')
		let docuxprop = ['attributes', 'childNodes', 'doctype', 'documentElement', 'firstChild',
					\ 'implementation', 'namespaceURI', 'nextSibling', 'nodeName', 'nodeType',
					\ 'nodeValue', 'ownerDocument', 'parentNode', 'previousSibling']
		let docuxmeth = ['createAttribute', 'createCDATASection',
					\ 'createComment', 'createDocument', 'createDocumentFragment',
					\ 'createElement', 'createEntityReference', 'createProcessingInstruction',
					\ 'createTextNode']
		call map(docuxmeth, 'v:val."("')
		let docus = docuprop + docuxprop + documeth + docuxmeth
		" Form - form.
		let formprop = ['elements', 'acceptCharset', 'action', 'encoding', 'enctype', 'id', 'length',
					\ 'method', 'name', 'tabIndex', 'target']
		let formmeth = ['reset', 'submit', 'onReset', 'onSubmit']
		call map(formmeth, 'v:val."("')
		let forms = formprop + formmeth
		" Frame - frame.
		let framprop = ['contentDocument', 'frameBorder', 'id', 'longDesc', 'marginHeight', 'marginWidth',
					\ 'name', 'noResize', 'scrolling', 'src']
		let frammeth = ['blur', 'focus']
		call map(frammeth, 'v:val."("')
		let frams = framprop + frammeth
		" Frameset - frameset.
		let fsetprop = ['cols', 'id', 'rows']
		let fsetmeth = ['blur', 'focus']
		call map(fsetmeth, 'v:val."("')
		let fsets = fsetprop + fsetmeth
		" History - history.
		let histprop = ['length']
		let histmeth = ['back', 'forward', 'go']
		call map(histmeth, 'v:val."("')
		let hists = histprop + histmeth
		" Iframe - iframe.
		let ifraprop = ['align', 'frameBorder', 'height', 'id', 'longDesc', 'marginHeight', 'marginWidth',
					\ 'name', 'scrolling', 'src', 'width']
		let ifras = ifraprop
		" Image - image.
		let imagprop = ['align', 'alt', 'border', 'complete', 'height', 'hspace', 'id', 'isMap', 'longDesc',
					\ 'lowSrc', 'name', 'src', 'useMap', 'vspace', 'width']
		let imagmeth = ['onAbort', 'onError', 'onLoad']
		call map(imagmeth, 'v:val."("')
		let imags = histprop + imagmeth
		" Button - accessible only by other properties
		let buttprop = ['accessKey', 'disabled', 'form', 'id', 'name', 'tabIndex', 'type', 'value']
		let buttmeth = ['blur', 'click', 'focus', 'onBlur', 'onClick', 'onFocus', 'onMouseDown', 'onMouseUp']
		call map(buttmeth, 'v:val."("')
		let butts = buttprop + buttmeth
		" Checkbox - accessible only by other properties
		let checprop = ['accept', 'accessKey', 'align', 'alt', 'checked', 'defaultChecked', 
					\ 'disabled', 'form', 'id', 'name', 'tabIndex', 'type', 'value'] 
		let checmeth = ['blur', 'click', 'focus', 'onBlur', 'onClick', 'onFocus', 'onMouseDown', 'onMouseUp']
		call map(checmeth, 'v:val."("')
		let checs = checprop + checmeth
		" File upload - accessible only by other properties
		let fileprop = ['accept', 'accessKey', 'align', 'alt', 'defaultValue', 
					\ 'disabled', 'form', 'id', 'name', 'tabIndex', 'type', 'value'] 
		let filemeth = ['blur', 'focus', 'onBlur', 'onClick', 'onFocus', 'onMouseDown', 'onMouseUp']
		call map(filemeth, 'v:val."("')
		let files = fileprop + filemeth
		" Hidden - accessible only by other properties
		let hiddprop = ['defaultValue', 'form', 'id', 'name', 'type', 'value'] 
		let hidds = hiddprop
		" Password - accessible only by other properties
		let passprop = ['accept', 'accessKey', 'defaultValue', 
					\ 'disabled', 'form', 'id', 'maxLength', 'name', 'readOnly', 'size', 'tabIndex', 
					\ 'type', 'value'] 
		let passmeth = ['blur', 'click', 'focus', 'select', 'onBlur', 'onFocus', 'onKeyDown', 
					\ 'onKeyPress', 'onKeyUp']
		call map(passmeth, 'v:val."("')
		let passs = passprop + passmeth
		" Radio - accessible only by other properties
		let radiprop = ['accept', 'accessKey', 'align', 'alt', 'checked', 'defaultChecked', 
					\ 'disabled', 'form', 'id', 'name', 'tabIndex', 'type', 'value'] 
		let radimeth = ['blur', 'click', 'focus', 'select', 'onBlur', 'onFocus']
		call map(radimeth, 'v:val."("')
		let radis = radiprop + radimeth
		" Reset - accessible only by other properties
		let reseprop = ['accept', 'accessKey', 'align', 'alt', 'defaultValue', 
					\ 'disabled', 'form', 'id', 'name', 'size', 'tabIndex', 'type', 'value'] 
		let resemeth = ['blur', 'click', 'focus', 'select', 'onBlur', 'onFocus']
		call map(resemeth, 'v:val."("')
		let reses = reseprop + resemeth
		" Submit - accessible only by other properties
		let submprop = ['accept', 'accessKey', 'align', 'alt', 'defaultValue', 
					\ 'disabled', 'form', 'id', 'name', 'size', 'tabIndex', 'type', 'value'] 
		let submmeth =pl  ql  rl  sl  tl  ul  vl  wl  xl  yl  zl  {l  |l  }l  ~l  l                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ['blur', 'click', 'focus', 'select', 'onClick', 'onSelectStart']
		call map(submmeth, 'v:val."("')
		let subms = submprop + submmeth
		" Text - accessible only by other properties
		let textprop = ['accept', 'accessKey', 'align', 'alt', 'defaultValue', 
					\ 'disabled', 'form', 'id', 'maxLength', 'name', 'readOnly', 
					\ 'size', 'tabIndex', 'type', 'value'] 
		let textmeth = ['blur', 'focus', 'select', 'onBlur', 'onChange', 'onFocus', 'onKeyDown',
					\ 'onKeyPress', 'onKeyUp', 'onSelect']
		call map(textmeth, 'v:val."("')
		let texts = textprop + textmeth
		" Link - link.
		let linkprop = ['charset', 'disabled', 'href', 'hreflang', 'id', 'media',
					\ 'rel', 'rev', 'target', 'type']
		let linkmeth = ['onLoad']
		call map(linkmeth, 'v:val."("')
		let links = linkprop + linkmeth
		" Location - location.
		let locaprop = ['href', 'hash', 'host', 'hostname', 'pathname', 'port', 'protocol',
					\ 'search']
		let locameth = ['assign', 'reload', 'replace']
		call map(locameth, 'v:val."("')
		let locas = locaprop + locameth
		" Meta - meta.
		let metaprop = ['charset', 'content', 'disabled', 'httpEquiv', 'name', 'scheme']
		let metas = metaprop
		" Navigator - navigator.
		let naviprop = ['plugins', 'appCodeName', 'appName', 'appVersion', 'cookieEnabled',
					\ 'platform', 'userAgent']
		let navimeth = ['javaEnabled', 'taintEnabled']
		call map(navimeth, 'v:val."("')
		let navis = naviprop + navimeth
		" Object - object.
		let objeprop = ['align', 'archive', 'border', 'code', 'codeBase', 'codeType', 'data',
					\ 'declare', 'form', 'height', 'hspace', 'id', 'name', 'standby', 'tabIndex',
					\ 'type', 'useMap', 'vspace', 'width']
		let objes = objeprop
		" Option - accessible only by other properties
		let optiprop = ['defaultSelected', 
					\ 'disabled', 'form', 'id', 'index', 'label', 'selected', 'text', 'value']
		let optis = optiprop
		" Screen - screen.
		let screprop = ['availHeight', 'availWidth', 'colorDepth', 'height', 'width']
		let scres = screprop
		" Select - accessible only by other properties
		let seleprop = ['options', 'disabled', 'form', 'id', 'length', 'multiple', 'name', 
					\ 'selectedIndex', 'size', 'tabIndex', 'type', 'value'] 
		let selemeth = ['blur', 'focus', 'remove', 'onBlur', 'onChange', 'onFocus']
		call map(selemeth, 'v:val."("')
		let seles = seleprop + selemeth
		" Style - style.
		let stylprop = ['background', 'backgroundAttachment', 'backgroundColor', 'backgroundImage',
					\ 'backgroundPosition', 'backgroundRepeat',
					\ 'border', 'borderBottom', 'borderLeft', 'borderRight', 'borderTop',
					\ 'borderBottomColor', 'borderLeftColor', 'borderRightColor', 'borderTopColor',
					\ 'borderBottomStyle', 'borderLeftStyle', 'borderRightStyle', 'borderTopStyle',
					\ 'borderBottomWidth', 'borderLeftWidth', 'borderRightWidth', 'borderTopWidth',
					\ 'borderColor', 'borderStyle', 'borderWidth', 'margin', 'marginBottom',
					\ 'marginLeft', 'marginRight', 'marginTop', 'outline', 'outlineStyle', 'outlineWidth',
					\ 'outlineColor', 'outlineStyle', 'outlineWidth', 'padding', 'paddingBottom',
					\ 'paddingLeft', 'paddingRight', 'paddingTop',
					\ 'clear', 'clip', 'clipBottom', 'clipLeft', 'clipRight', 'clipTop', 'content',
					\ 'counterIncrement', 'counterReset', 'cssFloat', 'cursor', 'direction',
					\ 'display', 'markerOffset', 'marks', 'maxHeight', 'maxWidth', 'minHeight',
					\ 'minWidth', 'overflow', 'overflowX', 'overflowY', 'verticalAlign', 'visibility',
					\ 'width',
					\ 'listStyle', 'listStyleImage', 'listStylePosition', 'listStyleType',
					\ 'cssText', 'bottom', 'height', 'left', 'position', 'right', 'top', 'width', 'zindex',
					\ 'orphans', 'widows', 'page', 'pageBreakAfter', 'pageBreakBefore', 'pageBreakInside',
					\ 'borderCollapse', 'borderSpacing', 'captionSide', 'emptyCells', 'tableLayout',
					\ 'color', 'font', 'fontFamily', 'fontSize', 'fontSizeAdjust', 'fontStretch',
					\ 'fontStyle', 'fontVariant', 'fontWeight', 'letterSpacing', 'lineHeight', 'quotes',
					\ 'textAlign', 'textIndent', 'textShadow', 'textTransform', 'textUnderlinePosition',
					\ 'unicodeBidi', 'whiteSpace', 'wordSpacing']
		let styls = stylprop
		" Table - table.
		let tablprop = ['rows', 'tBodies', 'align', 'bgColor', 'border', 'caption', 'cellPadding',
					\ 'cellSpacing', 'frame', 'height', 'rules', 'summary', 'tFoot', 'tHead', 'width']
		let tablmeth = ['createCaption', 'createTFoot', 'createTHead', 'deleteCaption', 'deleteRow',
					\ 'deleteTFoot', 'deleteTHead', 'insertRow']
		call map(tablmeth, 'v:val."("')
		let tabls = tablprop + tablmeth
		" Table data - TableData.
		let tdatprop = ['abbr', 'align', 'axis', 'bgColor', 'cellIndex', 'ch', 'chOff',
					\ 'colSpan', 'headers', 'noWrap', 'rowSpan', 'scope', 'vAlign', 'width']
		let tdats = tdatprop
		" Table row - TableRow.
		let trowprop = ['cells', 'align', 'bgColor', 'ch', 'chOff', 'rowIndex', 'sectionRowIndex',
					\ 'vAlign']
		let trowmeth = ['deleteCell', 'insertCell']
		call map(trowmeth, 'v:val."("')
		let trows = trowprop + trowmeth
		" Textarea - accessible only by other properties
		let tareprop = ['accessKey', 'cols', 'defaultValue', 
					\ 'disabled', 'form', 'id', 'name', 'readOnly', 'rows', 
					\ 'tabIndex', 'type', 'value', 'selectionStart', 'selectionEnd'] 
		let taremeth = ['blur', 'focus', 'select', 'onBlur', 'onChange', 'onFocus']
		call map(taremeth, 'v:val."("')
		let tares = tareprop + taremeth
		" Window - window.
		let windprop = ['frames', 'closed', 'defaultStatus', 'encodeURI', 'event', 'history',
					\ 'length', 'location', 'name', 'onload', 'opener', 'parent', 'screen', 'self',
					\ 'status', 'top', 'XMLHttpRequest', 'ActiveXObject']
		let windmeth = ['alert', 'blur', 'clearInterval', 'clearTimeout', 'close', 'confirm', 'focus',
					\ 'moveBy', 'moveTo', 'open', 'print', 'prompt', 'scrollBy', 'scrollTo', 'setInterval',
					\ 'setTimeout']
		call map(windmeth, 'v:val."("')
		let winds = windprop + windmeth
		" XMLHttpRequest - access by new xxx()
		let xmlhprop = ['onreadystatechange', 'readyState', 'responseText', 'responseXML',
					\ 'status', 'statusText', 'parseError']
		let xmlhmeth = ['abort', 'getAllResponseHeaders', 'getResponseHeaders', 'open',
					\ 'send', 'setRequestHeader']
		call map(xmlhmeth, 'v:val."("')
		let xmlhs = xmlhprop + xmlhmeth

		" XML DOM
		" Attributes - element.attributes[x].
		let xdomattrprop = ['name', 'specified', 'value']
		" Element - anyelement.
		let xdomelemprop = ['attributes', 'childNodes', 'firstChild', 'lastChild', 
					\ 'namespaceURI', 'nextSibling', 'nodeName', 'nodeType', 'nodeValue',
					\ 'ownerDocument', 'parentNode', 'prefix', 'previousSibling', 'tagName']
		let xdomelemmeth = ['appendChild', 'addEventListener', 'cloneNode',
					\ 'dispatchEvent', 'getAttribute', 'getAttributeNode',
					\ 'getElementsByTagName', 'hasChildNodes', 'insertBefore',
					\ 'normalize', 'removeAttribute', 'removeAttributeNode',
					\ 'removeChild', 'removeEventListener', 'replaceChild',
					\ 'setAttribute', 'setAttributeNode']
		call map(xdomelemmeth, 'v:val."("')
		let xdomelems = xdomelemprop + xdomelemmeth
		" Node - anynode.
		let xdomnodeprop = ['attributes', 'childNodes', 'firstChild', 'lastChild', 
					\ 'namespaceURI', 'nextSibling', 'nodeName', 'nodeType', 'nodeValue',
					\ 'ownerDocument', 'parentNode', 'prefix', 'previousSibling']
		let xdomnodemeth = ['appendChild', 'cloneNode',
					\ 'hasChildNodes', 'insertBefore', 'removeChild', 'replaceChild']
		call map(xdomnodemeth, 'v:val."("')
		let xdomnodes = xdomnodeprop + xdomnodemeth
		" NodeList 
		let xdomnliss = ['length', 'item(']
		" Error - parseError.
		let xdomerror = ['errorCode', 'reason', 'line', 'linepos', 'srcText', 'url', 'filepos']

		" Find object type declaration to reduce number of suggestions. {{{
		" 1. Get object name
		" 2. Find object declaration line
		" 3. General declaration follows "= new Type" syntax, additional else
		"    for regexp "= /re/"
		" 4. Make correction for Microsoft.XMLHTTP ActiveXObject
		" 5. Repeat for external files
		let object = matchstr(shortcontext, '\zs\k\+\ze\(\[.\{-}\]\)\?\.$')
		if len(object) > 0
			let decl_line = search(object.'.\{-}=\s*new\s*', 'bn')
			if decl_line > 0
				let object_type = matchstr(getline(decl_line), object.'.\{-}=\s*new\s*\zs\k\+\ze')
				if object_type == 'ActiveXObject' && matchstr(getline(decl_line), object.'.\{-}=\s*new\s*ActiveXObject\s*(.Microsoft\.XMLHTTP.)') != ''
						let object_type = 'XMLHttpRequest'
				endif
			else
				let decl_line = search('var\s*'.object.'\s*=\s*\/', 'bn')
				if decl_line > 0
					let object_type = 'RegExp'
				endif
			endif
			" We didn't find var declaration in current file but we may have
			" something in external files.
			if decl_line == 0 && exists("b:js_extfiles")
				let dext_line = filter(copy(b:js_extfiles), 'v:val =~ "'.object.'.\\{-}=\\s*new\\s*"')
				if len(dext_line) > 0
					let object_type = matchstr(dext_line[-1], object.'.\{-}=\s*new\s*\zs\k\+\ze')
					if object_type == 'ActiveXObject' && matchstr(dext_line[-1], object.'.\{-}=\s*new\s*ActiveXObject\s*(.Microsoft\.XMLHTTP.)') != ''
							let object_type = 'XMLHttpRequest'
					endif
				else
					let dext_line = filter(copy(b:js_extfiles), 'v:val =~ "var\s*'.object.'\\s*=\\s*\\/"')
					if len(dext_line) > 0
						let object_type = 'RegExp'
					endif
				endif
			endif
		endif
		" }}}

		if !exists('object_type')
			let object_type = ''
		endif

		if object_type == 'Date'
			let values = dates
		elseif object_type == 'Image'
			let values = imags
		elseif object_type == 'Array'
			let values = arrays
		elseif object_type == 'Boolean'
			" TODO: a bit more than real boolean
			let values = arrays
		elseif object_type == 'XMLHttpRequest'
			let values = xmlhs
		elseif object_type == 'String'
			let values = stris
		elseif object_type == 'RegExp'
			let values = reges
		elseif object_type == 'Math'
			let values = maths
		endif

		if !exists('values')
		" List of properties
		if shortcontext =~ 'Math\.$'
			let values = maths
		elseif shortcontext =~ 'anchors\(\[.\{-}\]\)\?\.$'
			let values = anths
		elseif shortcontext =~ 'area\.$'
			let values = areas
		elseif shortcontext =~ 'base\.$'
			let values = bases
		elseif shortcontext =~ 'body\.$'
			let values = bodys
		elseif shortcontext =~ 'document\.$'
			let values = docus
		elseif shortcontext =~ 'forms\(\[.\{-}\]\)\?\.$'
			let values = forms
		elseif shortcontext =~ 'frameset\.$'
			let values = fsets
		elseif shortcontext =~ 'history\.$'
			let values = hists
		elseif shortcontext =~ 'iframe\.$'
			let values = ifras
		elseif shortcontext =~ 'images\(\[.\{-}\]\)\?\.$'
			let values = imags
		elseif shortcontext =~ 'links\(\[.\{-}\]\)\?\.$'
			let values = links
		elseif shortcontext =~ 'location\.$'
			let values = locas
		elseif shortcontext =~ 'meta\.$'
			let values = metas
		elseif shortcontext =~ 'navigator\.$'
			let values = navis
		elseif shortcontext =~ 'object\.$'
			let values = objes
		elseif shortcontext =~ 'screen\.$'
			let values = scres
		elseif shortcontext =~ 'style\.$'
			let values = styls
		elseif shortcontext =~ 'table\.$'
			let values = tabls
		elseif shortcontext =~ 'TableData\.$'
			let values = tdats
		elseif shortcontext =~ 'TableRow\.$'
			let values = trows
		elseif shortcontext =~ 'window\.$'
			let values = winds
		elseif shortcontext =~ 'parseError\.$'
			let values = xdomerror
		elseif shortcontext =~ 'attributes\[\d\+\]\.$'
			let values = xdomattrprop
		else
			let values = user_props + arrays + dates + funcs + maths + numbs + objes + reges + stris
			let values += doms + anths + areas + bases + bodys + docus + forms + frams + fsets + hists
			let values += ifras + imags + links + locas + metas + navis + objes + scres
			let values += tabls + trows + tares + winds
			let values += xdomnodes + xdomnliss + xdomelems
		endif
		endif

		for m in values
			if m =~? '^'.a:base
				call add(res, m)
			elseif m =~? a:base
				call add(res2, m)
			endif
		endfor

		unlet! values
		return res + res2

	endif
	" }}}

	" Get variables data.
	let variables = filter(copy(file), 'v:val =~ "var\\s"')
	call map(variables, 'matchstr(v:val, ".\\{-}var\\s\\+\\zs.*\\ze")')
	call map(variables, 'substitute(v:val, ";\\|$", ",", "g")')
	let vars = []
	" This loop (and next one) is necessary to get variable names from
	" constructs like: var var1, var2, var3 = "something";
	for i in range(len(variables))
		let comma_separated = split(variables[i], ',\s*')
		call map(comma_separated, 'matchstr(v:val, "\\k\\+")')
		let vars += comma_separated
	endfor

	let variables = sort(vars)
	unlet! vars

	" Add "no var" variables.
	let undeclared_variables = filter(copy(file), 'v:val =~ "^\\s*\\k\\+\\s*="')
	let u_vars = []
	for i in range(len(undeclared_variables))
		let  split_equal = split(undeclared_variables[i], '\s*=')
		call map(split_equal, 'matchstr(v:val, "\\k\\+$")')
		let u_vars += split_equal
	endfor

	let variables += sort(u_vars)
	unlet! u_vars

	" Get functions
	let functions = filter(copy(file), 'v:val =~ "^\\s*function\\s"')
	let arguments = copy(functions)
	call map(functions, 'matchstr(v:val, "^\\s*function\\s\\+\\zs\\k\\+")')
	call map(functions, 'v:val."("')
	let functions = sort(functions)

	" Create table to keep arguments for additional 'menu' info
	let b:js_menuinfo = {}
	for i in arguments
		let g:ia = i
		let f_elements = matchlist(i, 'function\s\+\(\k\+\)\s*(\(.\{-}\))')
		if len(f_elements) >= 3
			let b:js_menuinfo[f_elements[1].'('] = f_elements[2]
		endif
	endfor

	" Get functions arguments
	call map(arguments, 'matchstr(v:val, "function.\\{-}(\\zs.\\{-}\\ze)")')
	let jargs = join(arguments, ',')
	let jargs = substitute(jargs, '\s', '', 'g')
	let arguments = split(jargs, ',')
	let arguments = sort(arguments)

	" Built-in functions
	let builtin = ['alert(', 'confirm(']

	" Top-level HTML DOM objects
	let htmldom = ['document', 'anchor', 'area', 'base', 'body', 'document', 'event', 'form', 'frame', 'frameset', 'history', 'iframe', 'image', 'input', 'link', 'location', 'meta', 'navigator', 'object', 'option', 'screen', 'select', 'table', 'tableData', 'tableHeader', 'tableRow', 'textarea', 'window']
	call map(htmldom, 'v:val."."')

	" Top-level properties
	let properties = ['decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent',
				\ 'eval', 'Infinity', 'isFinite', 'isNaN', 'NaN', 'Number', 'parseFloat',
				\ 'parseInt', 'String', 'undefined', 'escape', 'unescape']

	" Keywords
	let keywords = ["Array", "Boolean", "Date", "Function", "Math", "Number", "Object", "RegExp", "String", "XMLHttpRequest", "ActiveXObject", "abstract", "boolean", "break", "byte", "case", "catch", "char", "class", "const", "continue", "debugger", "default", "delete", "do", "double ", "else", "enum", "export", "extends", "false", "final", "finally", "float", "for", "function", "goto", "if", "implements", "import", "in ", "instanceof", "int", "interface", "long", "native", "new", "null", "package", "private", "protected", "public", "return", "short", "static", "super ", "switch", "synchronized", "this", "throw", "throws", "transient", "true", "try", "typeof", "var", "void", "volatile", "while", "with"]

	let values = variables + functions + htmldom + arguments + builtin + properties + keywords

	for m in values
		if m =~? '^'.a:base
			call add(res, m)
		elseif m =~? a:base
			call add(res2, m)
		endif
	endfor

	let menu = res + res2
	let final_menu = []
	for i in range(len(menu))
		let item = menu[i]
		if item =~ '($'
			let kind = 'f'
			if has_key(b:js_menuinfo, item)
				let m_info = b:js_menuinfo[item]
			else
				let m_info = ''
			endif
		else
			let kind = 'v'
			let m_info = ''
		endif
		let final_menu += [{'word':item, 'menu':m_info, 'kind':kind}]
	endfor
	let g:fm = final_menu
	return final_menu

endfunction

" vim:set foldmethod=marker:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    " netrw.vim: Handles file transfer and remote directory listing across
"            AUTOLOAD SECTION
" Date:		Aug 16, 2021
" Version:	171
" Maintainer:	Charles E Campbell <NcampObell@SdrPchip.AorgM-NOSPAM>
" GetLatestVimScripts: 1075 1 :AutoInstall: netrw.vim
" Copyright:    Copyright (C) 2016 Charles E. Campbell {{{1
"               Permission is hereby granted to use and distribute this code,
"               with or without modifications, provided that this copyright
"               notice is copied with it. Like anything else that's free,
"               netrw.vim, netrwPlugin.vim, and netrwSettings.vim are provided
"               *as is* and come with no warranty of any kind, either
"               expressed or implied. By using this plugin, you agree that
"               in no event will the copyright holder be liable for any damages
"               resulting from the use of this software.
"
" Note: the code here was started in 1999 under a much earlier version of vim.  The directory browsing
"       code was written using vim v6, which did not have Lists (Lists were first offered with vim-v7).
"
"redraw!|call DechoSep()|call inputsave()|call input("Press <cr> to continue")|call inputrestore()
"
"  But be doers of the Word, and not only hearers, deluding your own selves {{{1
"  (James 1:22 RSV)
" =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
" Load Once: {{{1
if &cp || exists("g:loaded_netrw")
  finish
endif

" Check that vim has patches that netrw requires.
" Patches needed for v7.4: 1557, and 213.
" (netrw will benefit from vim's having patch#656, too)
let s:needspatches=[1557,213]
if exists("s:needspatches")
 for ptch in s:needspatches
  if v:version < 704 || (v:version == 704 && !has("patch".ptch))
   if !exists("s:needpatch{ptch}")
    unsilent echomsg "***sorry*** this version of netrw requires vim v7.4 with patch#".ptch
   endif
   let s:needpatch{ptch}= 1
   finish
  endif
 endfor
endif

let g:loaded_netrw = "v171"
if !exists("s:NOTE")
 let s:NOTE    = 0
 let s:WARNING = 1
 let s:ERROR   = 2
endif

let s:keepcpo= &cpo
setl cpo&vim
"DechoFuncName 1
"DechoRemOn
"call Decho("doing autoload/netrw.vim version ".g:loaded_netrw,'~'.expand("<slnum>"))

" ======================
"  Netrw Variables: {{{1
" ======================

" ---------------------------------------------------------------------
" netrw#ErrorMsg: {{{2
"   0=note     = s:NOTE
"   1=warning  = s:WARNING
"   2=error    = s:ERROR
"   Usage: netrw#ErrorMsg(s:NOTE | s:WARNING | s:ERROR,"some message",error-number)
"          netrw#ErrorMsg(s:NOTE | s:WARNING | s:ERROR,["message1","message2",...],error-number)
"          (this function can optionally take a list of messages)
"  Dec 2, 2019 : max errnum currently is 106
fun! netrw#ErrorMsg(level,msg,errnum)
"  call Dfunc("netrw#ErrorMsg(level=".a:level." msg<".a:msg."> errnum=".a:errnum.") g:netrw_use_errorwindow=".g:netrw_use_errorwindow)

  if a:level < g:netrw_errorlvl
"   call Dret("netrw#ErrorMsg : suppressing level=".a:level." since g:netrw_errorlvl=".g:netrw_errorlvl)
   return
  endif

  if a:level == 1
   let level= "**warning** (netrw) "
  elseif a:level == 2
   let level= "**error** (netrw) "
  else
   let level= "**note** (netrw) "
  endif
"  call Decho("level=".level,'~'.expand("<slnum>"))

  if g:netrw_use_errorwindow == 2 && (v:version > 802 || (v:version == 802 && has("patch486")))
   " use popup window
   if type(a:msg) == 3
    let msg = [level]+a:msg
   else
    let msg= level.a:msg
   endif
   let s:popuperr_id  = popup_atcursor(msg,{})
   let s:popuperr_text= ""
 elseif g:netrw_use_errorwindow
   " (default) netrw creates a one-line window to show error/warning
   " messages (reliably displayed)

   " record current window number
   let s:winBeforeErr= winnr()
"   call Decho("s:winBeforeErr=".s:winBeforeErr,'~'.expand("<slnum>"))

   " getting messages out reliably is just plain difficult!
   " This attempt splits the current window, creating a one line window.
   if bufexists("NetrwMessage") && bufwinnr("NetrwMessage") > 0
"    call Decho("write to NetrwMessage buffer",'~'.expand("<slnum>"))
    exe bufwinnr("NetrwMessage")."wincmd w"
"    call Decho("setl ma noro",'~'.expand("<slnum>"))
    setl ma noro
    if type(a:msg) == 3
     for msg in a:msg
      NetrwKeepj call setline(line("$")+1,level.msg)
     endfor
    else
     NetrwKeepj call setline(line("$")+1,level.a:msg)
    endif
    NetrwKeepj $
   else
"    call Decho("create a NetrwMessage buffer window",'~'.expand("<slnum>"))
    bo 1split
    sil! call s:NetrwEnew()
    sil! NetrwKeepj call s:NetrwOptionsSafe(1)
    setl bt=nofile
    NetrwKeepj file NetrwMessage
"    call Decho("setl ma noro",'~'.expand("<slnum>"))
    setl ma noro
    if type(a:msg) == 3
     for msg in a:msg
      NetrwKeepj call setline(line("$")+1,level.msg)
     endfor
    else
     NetrwKeepj call setline(line("$"),level.a:msg)
    endif
    NetrwKeepj $
   endif
"   call Decho("wrote msg<".level.a:msg."> to NetrwMessage win#".winnr(),'~'.expand("<slnum>"))
   if &fo !~ '[ta]'
    syn clear
    syn match netrwMesgNote	"^\*\*note\*\*"
    syn match netrwMesgWarning	"^\*\*warning\*\*"
    syn match netrwMesgError	"^\*\*error\*\*"
    hi link netrwMesgWarning WarningMsg
    hi link netrwMesgError   Error
   endif
"   call Decho("setl noma ro bh=wipe",'~'.expand("<slnum>"))
   setl ro nomod noma bh=wipe

  else
   " (optional) netrw will show messages using echomsg.  Even if the
   " message doesn't appear, at least it'll be recallable via :messages
"   redraw!
   if a:level == s:WARNING
    echohl WarningMsg
   elseif a:level == s:ERROR
    echohl Error
   endif

   if type(a:msg) == 3
     for msg in a:msg
      unsilent echomsg level.msg
     endfor
   else
    unsilent echomsg level.a:msg
   endif

"   call Decho("echomsg ***netrw*** ".a:msg,'~'.expand("<slnum>"))
   echohl None
  endif

"  call Dret("netrw#ErrorMsg")
endfun

" ---------------------------------------------------------------------
" s:NetrwInit: initializes variables if they haven't been defined {{{2
"            Loosely,  varname = value.
fun s:NetrwInit(varname,value)
" call Decho("varname<".a:varname."> value=".a:value,'~'.expand("<slnum>"))
  if !exists(a:varname)
   if type(a:value) == 0
    exe "let ".a:varname."=".a:value
   elseif type(a:value) == 1 && a:value =~ '^[{[]'
    exe "let ".a:varname."=".a:value
   elseif type(a:value) == 1
    exe "let ".a:varname."="."'".a:value."'"
   else
    exe "let ".a:varname."=".a:value
   endif
  endif
endfun

" ---------------------------------------------------------------------
"  Netrw Constants: {{{2
call s:NetrwInit("g:netrw_dirhistcnt",0)
if !exists("s:LONGLIST")
 call s:NetrwInit("s:THINLIST",0)
 call s:NetrwInit("s:LONGLIST",1)
 call s:NetrwInit("s:WIDELIST",2)
 call s:NetrwInit("s:TREELIST",3)
 call s:NetrwInit("s:MAXLIST" ,4)
endif

" ---------------------------------------------------------------------
" Default option values: {{{2
let g:netrw_localcopycmdopt    = ""
let g:netrw_localcopydircmdopt = ""
let g:netrw_localmkdiropt      = ""
let g:netrw_localmovecmdopt    = ""
let g:netrw_localrmdiropt      = ""

" ---------------------------------------------------------------------
" Default values for netrw's global protocol variables {{{2
if (v:version > 802 || (v:version == 802 && has("patch486"))) && has("balloon_eval") && !exists("s:initbeval") && !exists("g:netrw_nobeval") && has("syntax") && exists("g:syntax_on") && has("mouse")
  call s:NetrwInit("g:netrw_use_errorwindow",2)
else
  call s:NetrwInit("g:netrw_use_errorwindow",1)
endif

if !exists("g:netrw_dav_cmd")
 if executable("cadaver")
  let g:netrw_dav_cmd	= "cadaver"
 elseif executable("curl")
  let g:netrw_dav_cmd	= "curl"
 else
  let g:netrw_dav_cmd   = ""
 endif
endif
if !exists("g:netrw_fetch_cmd")
 if executable("fetch")
  let g:netrw_fetch_cmd	= "fetch -o"
 else
  let g:netrw_fetch_cmd	= ""
 endif
endif
if !exists("g:netrw_file_cmd")
 if executable("elinks")
  call s:NetrwInit("g:netrw_file_cmd","elinks")
 elseif executable("links")
  call s:NetrwInit("g:netrw_file_cmd","links")
 endif
endif
if !exists("g:netrw_ftp_cmd")
  let g:netrw_ftp_cmd	= "ftp"
endif
let s:netrw_ftp_cmd= g:netrw_ftp_cmd
if !exists("g:netrw_ftp_options")
 let g:netrw_ftp_options= "-i -n"
endif
if !exists("g:netrw_http_cmd")
 if executable("wget")
  let g:netrw_http_cmd	= "wget"
  call s:NetrwInit("g:netrw_http_xcmd","-q -O")
 elseif executable("curl")
  let g:netrw_http_cmd	= "curl"
  call s:NetrwInit("g:netrw_http_xcmd","-L -o")
 elseif executable("elinks")
  let g:netrw_http_cmd = "elinks"
  call s:NetrwInit("g:netrw_http_xcmd","-source >")
 elseif executable("fetch")
  let g:netrw_http_cmd	= "fetch"
  call s:NetrwInit("g:netrw_http_xcmd","-o")
 elseif executable("links")
  let g:netrw_http_cmd = "links"
  call s:NetrwInit("g:netrw_http_xcmd","-http.extra-header ".shellescape("Accept-Encoding: identity", 1)." -source >")
 else
  let g:netrw_http_cmd	= ""
 endif
endif
call s:NetrwInit("g:netrw_http_put_cmd","curl -T")
call s:NetrwInit("g:netrw_keepj","keepj")
call s:NetrwInit("g:netrw_rcp_cmd"  , "rcp")
call s:NetrwInit("g:netrw_rsync_cmd", "rsync")
call s:NetrwInit("g:netrw_rsync_sep", "/")
if !exists("g:netrw_scp_cmd")
 if executable("scp")
  call s:NetrwInit("g:netrw_scp_cmd" , "scp -q")
 elseif executable("pscp")
  if (has("win32") || has("win95") || has("win64") || has("win16")) && filereadable('c:\private.ppk')
   call s:NetrwInit("g:netrw_scp_cmd", 'pscp -i c:\private.ppk')
  else
   call s:NetrwInit("g:netrw_scp_cmd", 'pscp -q')
  endif
 else
  call s:NetrwInit("g:netrw_scp_cmd" , "scp -q")
 endif
endif

call s:NetrwInit("g:netrw_sftp_cmd" , "sftp")
call s:NetrwInit("g:netrw_ssh_cmd"  , "ssh")

if (has("win32") || has("win95") || has("win64") || has("win16"))
  \ && exists("g:netrw_use_nt_rcp")
  \ && g:netrw_use_nt_rcp
  \ && executable( $SystemRoot .'/system32/rcp.exe')
 let s:netrw_has_nt_rcp = 1
 let s:netrw_rcpmode    = '-b'
else
 let s:netrw_has_nt_rcp = 0
 let s:netrw_rcpmode    = ''
endif

" ---------------------------------------------------------------------
" Default values for netrw's global variables {{{2
" Cygwin Detection ------- {{{3
if !exists("g:netrw_cygwin")
 if has("win32") || has("win95") || has("win64") || has("win16")
  if  has("win32unix") && &shell =~ '\%(\<bash\>\|\<zsh\>\)\%(\.exe\)\=$'
   let g:netrw_cygwin= 1
  else
   let g:netrw_cygwin= 0
  endif
 else
  let g:netrw_cygwin= 0
 endif
endif
" Default values - a-c ---------- {{{3
call s:NetrwInit("g:netrw_alto"        , &sb)
call s:NetrwInit("g:netrw_altv"        , &spr)
call s:NetrwInit("g:netrw_banner"      , 1)
call s:NetrwInit("g:netrw_browse_split", 0)
call s:NetrwInit("g:netrw_bufsettings" , "noma nomod nonu nobl nowrap ro nornu")
call s:NetrwInit("g:netrw_chgwin"      , -1)
call s:NetrwInit("g:netrw_clipboard"   , 1)
call s:NetrwInit("g:netrw_compress"    , "gzip")
call s:NetrwInit("g:netrw_ctags"       , "ctags")
if exists("g:netrw_cursorline") && !exists("g:netrw_cursor")
 call netrw#ErrorMsg(s:NOTE,'g:netrw_cursorline is deprecated; use g:netrw_cursor instead',77)
 let g:netrw_cursor= g:netrw_cursorline
endif
call s:NetrwInit("g:netrw_cursor"      , 2)
let s:netrw_usercul = &cursorline
let s:netrw_usercuc = &cursorcolumn
"call Decho("(netrw) COMBAK: cuc=".&l:cuc." cul=".&l:cul." initialization of s:netrw_cu[cl]")
call s:NetrwInit("g:netrw_cygdrive","/cygdrive")
" Default values - d-g ---------- {{{3
call s:NetrwInit("s:didstarstar",0)
call s:NetrwInit("g:netrw_dirhistcnt"      , 0)
call s:NetrwInit("g:netrw_decompress"       , '{ ".gz" : "gunzip", ".bz2" : "bunzip2", ".zip" : "unzip", ".tar" : "tar -xf", ".xz" : "unxz" }')
call s:NetrwInit("g:netrw_dirhistmax"       , 10)
call s:NetrwInit("g:netrw_errorlvl"  , s:NOTE)
call s:NetrwInit("g:netrw_fastbrowse"       , 1)
call s:NetrwInit("g:netrw_ftp_browse_reject", '^total\s\+\d\+$\|^Trying\s\+\d\+.*$\|^KERBEROS_V\d rejected\|^Security extensions not\|No such file\|: connect to address [0-9a-fA-F:]*: No route to host$')
if !exists("g:netrw_ftp_list_cmd")
 if has("unix") || (exists("g:netrw_cygwin") && g:netrw_cygwin)
  let g:netrw_ftp_list_cmd     = "ls -lF"
  let g:netrw_ftp_timelist_cmd = "ls -tlF"
  let g:netrw_ftp_sizelist_cmd = "ls -slF"
 else
l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l  l   m  m  m  m  m  m  m  m  m  	m  
m  m  m  m  m  m  m  m  m  m  m  m  m  m  m  m  m  m  m  m  m  m   m  !m  "m  #m  $m  %m  &m  'm  (m  )m  *m  +m  ,m  -m  .m  /m  0m  1m  2m  3m  4m  5m  6m  7m  8m  9m  :m  ;m  <m  =m  >m  ?m  @m  Am  Bm  Cm  Dm  Em  Fm  Gm  Hm  Im  Jm  Km  Lm  Mm  Nm  Om  Pm  Qm  Rm  Sm  Tm  Um  Vm  Wm  Xm  Ym  Zm  [m  \m  ]m  ^m  _m  `m  am  bm  cm  dm  em  fm  gm  hm  im  jm  km  lm  mm  nm  om  pm  qm  rm  sm  tm  um  vm  wm  xm  ym  zm  {m  |m  }m  ~m  m  m  m  m  m  m  m  m  m  m  m  m  m  m    let g:netrw_ftp_list_cmd     = "dir"
  let g:netrw_ftp_timelist_cmd = "dir"
  let g:netrw_ftp_sizelist_cmd = "dir"
 endif
endif
call s:NetrwInit("g:netrw_ftpmode",'binary')
" Default values - h-lh ---------- {{{3
call s:NetrwInit("g:netrw_hide",1)
if !exists("g:netrw_ignorenetrc")
 if &shell =~ '\c\<\%(cmd\|4nt\)\.exe$'
  let g:netrw_ignorenetrc= 1
 else
  let g:netrw_ignorenetrc= 0
 endif
endif
call s:NetrwInit("g:netrw_keepdir",1)
if !exists("g:netrw_list_cmd")
 if g:netrw_scp_cmd =~ '^pscp' && executable("pscp")
  if (has("win32") || has("win95") || has("win64") || has("win16")) && filereadable("c:\\private.ppk")
   " provide a pscp-based listing command
   let g:netrw_scp_cmd ="pscp -i C:\\private.ppk"
  endif
  if exists("g:netrw_list_cmd_options")
   let g:netrw_list_cmd= g:netrw_scp_cmd." -ls USEPORT HOSTNAME: ".g:netrw_list_cmd_options
  else
   let g:netrw_list_cmd= g:netrw_scp_cmd." -ls USEPORT HOSTNAME:"
  endif
 elseif executable(g:netrw_ssh_cmd)
  " provide a scp-based default listing command
  if exists("g:netrw_list_cmd_options")
   let g:netrw_list_cmd= g:netrw_ssh_cmd." USEPORT HOSTNAME ls -FLa ".g:netrw_list_cmd_options
  else
   let g:netrw_list_cmd= g:netrw_ssh_cmd." USEPORT HOSTNAME ls -FLa"
  endif
 else
"  call Decho(g:netrw_ssh_cmd." is not executable",'~'.expand("<slnum>"))
  let g:netrw_list_cmd= ""
 endif
endif
call s:NetrwInit("g:netrw_list_hide","")
" Default values - lh-lz ---------- {{{3
if exists("g:netrw_local_copycmd")
 let g:netrw_localcopycmd= g:netrw_local_copycmd
 call netrw#ErrorMsg(s:NOTE,"g:netrw_local_copycmd is deprecated in favor of g:netrw_localcopycmd",84)
endif
if !exists("g:netrw_localcmdshell")
 let g:netrw_localcmdshell= ""
endif
if !exists("g:netrw_localcopycmd")
 if has("win32") || has("win95") || has("win64") || has("win16")
  if g:netrw_cygwin
   let g:netrw_localcopycmd= "cp"
  else
   let g:netrw_localcopycmd   = expand("$COMSPEC")
   let g:netrw_localcopycmdopt= " /c copy"
  endif
 elseif has("unix") || has("macunix")
  let g:netrw_localcopycmd= "cp"
 else
  let g:netrw_localcopycmd= ""
 endif
endif
if !exists("g:netrw_localcopydircmd")
 if has("win32") || has("win95") || has("win64") || has("win16")
  if g:netrw_cygwin
   let g:netrw_localcopydircmd   = "cp"
   let g:netrw_localcopydircmdopt= " -R"
  else
   let g:netrw_localcopydircmd   = expand("$COMSPEC")
   let g:netrw_localcopydircmdopt= " /c xcopy /e /c /h /i /k"
  endif
 elseif has("unix")
  let g:netrw_localcopydircmd   = "cp"
  let g:netrw_localcopydircmdopt= " -R"
 elseif has("macunix")
  let g:netrw_localcopydircmd   = "cp"
  let g:netrw_localcopydircmdopt= " -R"
 else
  let g:netrw_localcopydircmd= ""
 endif
endif
if exists("g:netrw_local_mkdir")
 let g:netrw_localmkdir= g:netrw_local_mkdir
 call netrw#ErrorMsg(s:NOTE,"g:netrw_local_mkdir is deprecated in favor of g:netrw_localmkdir",87)
endif
if has("win32") || has("win95") || has("win64") || has("win16")
  if g:netrw_cygwin
   call s:NetrwInit("g:netrw_localmkdir","mkdir")
  else
   let g:netrw_localmkdir   = expand("$COMSPEC")
   let g:netrw_localmkdiropt= " /c mkdir"
  endif
else
 call s:NetrwInit("g:netrw_localmkdir","mkdir")
endif
call s:NetrwInit("g:netrw_remote_mkdir","mkdir")
if exists("g:netrw_local_movecmd")
 let g:netrw_localmovecmd= g:netrw_local_movecmd
 call netrw#ErrorMsg(s:NOTE,"g:netrw_local_movecmd is deprecated in favor of g:netrw_localmovecmd",88)
endif
if !exists("g:netrw_localmovecmd")
 if has("win32") || has("win95") || has("win64") || has("win16")
  if g:netrw_cygwin
   let g:netrw_localmovecmd= "mv"
  else
   let g:netrw_localmovecmd   = expand("$COMSPEC")
   let g:netrw_localmovecmdopt= " /c move"
  endif
 elseif has("unix") || has("macunix")
  let g:netrw_localmovecmd= "mv"
 else
  let g:netrw_localmovecmd= ""
 endif
endif
" following serves as an example for how to insert a version&patch specific test
"if v:version < 704 || (v:version == 704 && !has("patch1107"))
"endif
call s:NetrwInit("g:netrw_liststyle"  , s:THINLIST)
" sanity checks
if g:netrw_liststyle < 0 || g:netrw_liststyle >= s:MAXLIST
 let g:netrw_liststyle= s:THINLIST
endif
if g:netrw_liststyle == s:LONGLIST && g:netrw_scp_cmd !~ '^pscp'
 let g:netrw_list_cmd= g:netrw_list_cmd." -l"
endif
" Default values - m-r ---------- {{{3
call s:NetrwInit("g:netrw_markfileesc"   , '*./[\~')
call s:NetrwInit("g:netrw_maxfilenamelen", 32)
call s:NetrwInit("g:netrw_menu"          , 1)
call s:NetrwInit("g:netrw_mkdir_cmd"     , g:netrw_ssh_cmd." USEPORT HOSTNAME mkdir")
call s:NetrwInit("g:netrw_mousemaps"     , (exists("+mouse") && &mouse =~# '[anh]'))
call s:NetrwInit("g:netrw_retmap"        , 0)
if has("unix") || (exists("g:netrw_cygwin") && g:netrw_cygwin)
 call s:NetrwInit("g:netrw_chgperm"       , "chmod PERM FILENAME")
elseif has("win32") || has("win95") || has("win64") || has("win16")
 call s:NetrwInit("g:netrw_chgperm"       , "cacls FILENAME /e /p PERM")
else
 call s:NetrwInit("g:netrw_chgperm"       , "chmod PERM FILENAME")
endif
call s:NetrwInit("g:netrw_preview"       , 0)
call s:NetrwInit("g:netrw_scpport"       , "-P")
call s:NetrwInit("g:netrw_servername"    , "NETRWSERVER")
call s:NetrwInit("g:netrw_sshport"       , "-p")
call s:NetrwInit("g:netrw_rename_cmd"    , g:netrw_ssh_cmd." USEPORT HOSTNAME mv")
call s:NetrwInit("g:netrw_rm_cmd"        , g:netrw_ssh_cmd." USEPORT HOSTNAME rm")
call s:NetrwInit("g:netrw_rmdir_cmd"     , g:netrw_ssh_cmd." USEPORT HOSTNAME rmdir")
call s:NetrwInit("g:netrw_rmf_cmd"       , g:netrw_ssh_cmd." USEPORT HOSTNAME rm -f ")
" Default values - q-s ---------- {{{3
call s:NetrwInit("g:netrw_quickhelp",0)
let s:QuickHelp= ["-:go up dir  D:delete  R:rename  s:sort-by  x:special",
   \              "(create new)  %:file  d:directory",
   \              "(windows split&open) o:horz  v:vert  p:preview",
   \              "i:style  qf:file info  O:obtain  r:reverse",
   \              "(marks)  mf:mark file  mt:set target  mm:move  mc:copy",
   \              "(bookmarks)  mb:make  mB:delete  qb:list  gb:go to",
   \              "(history)  qb:list  u:go up  U:go down",
   \              "(targets)  mt:target Tb:use bookmark  Th:use history"]
" g:netrw_sepchr: picking a character that doesn't appear in filenames that can be used to separate priority from filename
call s:NetrwInit("g:netrw_sepchr"        , (&enc == "euc-jp")? "\<Char-0x01>" : "\<Char-0xff>")
if !exists("g:netrw_keepj") || g:netrw_keepj == "keepj"
 call s:NetrwInit("s:netrw_silentxfer"    , (exists("g:netrw_silent") && g:netrw_silent != 0)? "sil keepj " : "keepj ")
else
 call s:NetrwInit("s:netrw_silentxfer"    , (exists("g:netrw_silent") && g:netrw_silent != 0)? "sil " : " ")
endif
call s:NetrwInit("g:netrw_sort_by"       , "name") " alternatives: date                                      , size
call s:NetrwInit("g:netrw_sort_options"  , "")
call s:NetrwInit("g:netrw_sort_direction", "normal") " alternative: reverse  (z y x ...)
if !exists("g:netrw_sort_sequence")
 if has("unix")
  let g:netrw_sort_sequence= '[\/]$,\<core\%(\.\d\+\)\=\>,\.h$,\.c$,\.cpp$,\~\=\*$,*,\.o$,\.obj$,\.info$,\.swp$,\.bak$,\~$'
 else
  let g:netrw_sort_sequence= '[\/]$,\.h$,\.c$,\.cpp$,*,\.o$,\.obj$,\.info$,\.swp$,\.bak$,\~$'
 endif
endif
call s:NetrwInit("g:netrw_special_syntax"   , 0)
call s:NetrwInit("g:netrw_ssh_browse_reject", '^total\s\+\d\+$')
call s:NetrwInit("g:netrw_suppress_gx_mesg",  1)
call s:NetrwInit("g:netrw_use_noswf"        , 1)
call s:NetrwInit("g:netrw_sizestyle"        ,"b")
" Default values - t-w ---------- {{{3
call s:NetrwInit("g:netrw_timefmt","%c")
if !exists("g:netrw_xstrlen")
 if exists("g:Align_xstrlen")
  let g:netrw_xstrlen= g:Align_xstrlen
 elseif exists("g:drawit_xstrlen")
  let g:netrw_xstrlen= g:drawit_xstrlen
 elseif &enc == "latin1" || !has("multi_byte")
  let g:netrw_xstrlen= 0
 else
  let g:netrw_xstrlen= 1
 endif
endif
call s:NetrwInit("g:NetrwTopLvlMenu","Netrw.")
call s:NetrwInit("g:netrw_win95ftp",1)
call s:NetrwInit("g:netrw_winsize",50)
call s:NetrwInit("g:netrw_wiw",1)
if g:netrw_winsize > 100|let g:netrw_winsize= 100|endif
" ---------------------------------------------------------------------
" Default values for netrw's script variables: {{{2
call s:NetrwInit("g:netrw_fname_escape",' ?&;%')
if has("win32") || has("win95") || has("win64") || has("win16")
 call s:NetrwInit("g:netrw_glob_escape",'*?`{[]$')
else
 call s:NetrwInit("g:netrw_glob_escape",'*[]?`{~$\')
endif
call s:NetrwInit("g:netrw_menu_escape",'.&? \')
call s:NetrwInit("g:netrw_tmpfile_escape",' &;')
call s:NetrwInit("s:netrw_map_escape","<|\n\r\\\<C-V>\"")
if has("gui_running") && (&enc == 'utf-8' || &enc == 'utf-16' || &enc == 'ucs-4')
 let s:treedepthstring= " "
else
 let s:treedepthstring= "| "
endif
call s:NetrwInit("s:netrw_posn",'{}')

" BufEnter event ignored by decho when following variable is true
"  Has a side effect that doau BufReadPost doesn't work, so
"  files read by network transfer aren't appropriately highlighted.
"let g:decho_bufenter = 1	"Decho

" ======================
"  Netrw Initialization: {{{1
" ======================
if v:version >= 700 && has("balloon_eval") && !exists("s:initbeval") && !exists("g:netrw_nobeval") && has("syntax") && exists("g:syntax_on")
" call Decho("installed beval events",'~'.expand("<slnum>"))
 let &l:bexpr = "netrw#BalloonHelp()"
" call Decho("&l:bexpr<".&l:bexpr."> buf#".bufnr())
 au FileType netrw	setl beval
 au WinLeave *		if &ft == "netrw" && exists("s:initbeval")|let &beval= s:initbeval|endif
 au VimEnter * 		let s:initbeval= &beval
"else " Decho
" if v:version < 700           | call Decho("did not install beval events: v:version=".v:version." < 700","~".expand("<slnum>"))     | endif
" if !has("balloon_eval")      | call Decho("did not install beval events: does not have balloon_eval","~".expand("<slnum>"))        | endif
" if exists("s:initbeval")     | call Decho("did not install beval events: s:initbeval exists","~".expand("<slnum>"))                | endif
" if exists("g:netrw_nobeval") | call Decho("did not install beval events: g:netrw_nobeval exists","~".expand("<slnum>"))            | endif
" if !has("syntax")            | call Decho("did not install beval events: does not have syntax highlighting","~".expand("<slnum>")) | endif
" if exists("g:syntax_on")     | call Decho("did not install beval events: g:syntax_on exists","~".expand("<slnum>"))                | endif
endif
au WinEnter *	if &ft == "netrw"|call s:NetrwInsureWinVars()|endif

if g:netrw_keepj =~# "keepj"
 com! -nargs=*	NetrwKeepj	keepj <args>
else
 let g:netrw_keepj= ""
 com! -nargs=*	NetrwKeepj	<args>
endif

" ==============================
"  Netrw Utility Functions: {{{1
" ==============================

" ---------------------------------------------------------------------
" netrw#BalloonHelp: {{{2
if v:version >= 700 && has("balloon_eval") && has("syntax") && exists("g:syntax_on") && !exists("g:netrw_nobeval")
" call Decho("loading netrw#BalloonHelp()",'~'.expand("<slnum>"))
 fun! netrw#BalloonHelp()
   if &ft != "netrw"
    return ""
   endif
   if exists("s:popuperr_id") && popup_getpos(s:popuperr_id) != {}
    " popup error window is still showing
    " s:pouperr_id and s:popuperr_text are set up in netrw#ErrorMsg()
    if exists("s:popuperr_text") && s:popuperr_text != "" && v:beval_text != s:popuperr_text
     " text under mouse hasn't changed; only close window when it changes
     call popup_close(s:popuperr_id)
     unlet s:popuperr_text
    else
     let s:popuperr_text= v:beval_text
    endif
    let mesg= ""
   elseif !exists("w:netrw_bannercnt") || v:beval_lnum >= w:netrw_bannercnt || (exists("g:netrw_nobeval") && g:netrw_nobeval)
    let mesg= ""
   elseif     v:beval_text == "Netrw" || v:beval_text == "Directory" || v:beval_text == "Listing"
    let mesg = "i: thin-long-wide-tree  gh: quick hide/unhide of dot-files   qf: quick file info  %:open new file"
   elseif     getline(v:beval_lnum) =~ '^"\s*/'
    let mesg = "<cr>: edit/enter   o: edit/enter in horiz window   t: edit/enter in new tab   v:edit/enter in vert window"
   elseif     v:beval_text == "Sorted" || v:beval_text == "by"
    let mesg = 's: sort by name, time, file size, extension   r: reverse sorting order   mt: mark target'
   elseif v:beval_text == "Sort"   || v:beval_text == "sequence"
    let mesg = "S: edit sorting sequence"
   elseif v:beval_text == "Hiding" || v:beval_text == "Showing"
    let mesg = "a: hiding-showing-all   ctrl-h: editing hiding list   mh: hide/show by suffix"
   elseif v:beval_text == "Quick" || v:beval_text == "Help"
    let mesg = "Help: press <F1>"
   elseif v:beval_text == "Copy/Move" || v:beval_text == "Tgt"
    let mesg = "mt: mark target   mc: copy marked file to target   mm: move marked file to target"
   else
    let mesg= ""
   endif
   return mesg
 endfun
"else " Decho
" if v:version < 700            |call Decho("did not load netrw#BalloonHelp(): vim version ".v:version." < 700 -","~".expand("<slnum>"))|endif
" if !has("balloon_eval")       |call Decho("did not load netrw#BalloonHelp(): does not have balloon eval","~".expand("<slnum>"))       |endif
" if !has("syntax")             |call Decho("did not load netrw#BalloonHelp(): syntax disabled","~".expand("<slnum>"))                  |endif
" if !exists("g:syntax_on")     |call Decho("did not load netrw#BalloonHelp(): g:syntax_on n/a","~".expand("<slnum>"))                  |endif
" if  exists("g:netrw_nobeval") |call Decho("did not load netrw#BalloonHelp(): g:netrw_nobeval exists","~".expand("<slnum>"))           |endif
endif

" ------------------------------------------------------------------------
" netrw#Explore: launch the local browser in the directory of the current file {{{2
"          indx:  == -1: Nexplore
"                 == -2: Pexplore
"                 ==  +: this is overloaded:
"                      * If Nexplore/Pexplore is in use, then this refers to the
"                        indx'th item in the w:netrw_explore_list[] of items which
"                        matched the */pattern **/pattern *//pattern **//pattern
"                      * If Hexplore or Vexplore, then this will override
"                        g:netrw_winsize to specify the qty of rows or columns the
"                        newly split window should have.
"          dosplit==0: the window will be split iff the current file has been modified and hidden not set
"          dosplit==1: the window will be split before running the local browser
"          style == 0: Explore     style == 1: Explore!
"                == 2: Hexplore    style == 3: Hexplore!
"                == 4: Vexplore    style == 5: Vexplore!
"                == 6: Texplore
fun! netrw#Explore(indx,dosplit,style,...)
"  call Dfunc("netrw#Explore(indx=".a:indx." dosplit=".a:dosplit." style=".a:style.",a:1<".a:1.">) &modified=".&modified." modifiable=".&modifiable." a:0=".a:0." win#".winnr()." buf#".bufnr("%")." ft=".&ft)
"  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
  if !exists("b:netrw_curdir")
   let b:netrw_curdir= getcwd()
"   call Decho("set b:netrw_curdir<".b:netrw_curdir."> (used getcwd)",'~'.expand("<slnum>"))
  endif

  " record current file for Rexplore's benefit
  if &ft != "netrw"
   let w:netrw_rexfile= expand("%:p")
  endif

  " record current directory
  let curdir     = simplify(b:netrw_curdir)
  let curfiledir = substitute(expand("%:p"),'^\(.*[/\\]\)[^/\\]*$','\1','e')
  if !exists("g:netrw_cygwin") && (has("win32") || has("win95") || has("win64") || has("win16"))
   let curdir= substitute(curdir,'\','/','g')
  endif
"  call Decho("curdir<".curdir.">  curfiledir<".curfiledir.">",'~'.expand("<slnum>"))

  " using completion, directories with spaces in their names (thanks, Bill Gates, for a truly dumb idea)
  " will end up with backslashes here.  Solution: strip off backslashes that precede white space and
  " try Explore again.
  if a:0 > 0
"   call Decho('considering retry: a:1<'.a:1.'>: '.
     \ ((a:1 =~ "\\\s")?                   'has backslash whitespace' : 'does not have backslash whitespace').', '.
     \ ((filereadable(s:NetrwFile(a:1)))?  'is readable'              : 'is not readable').', '.
     \ ((isdirectory(s:NetrwFile(a:1))))?  'is a directory'           : 'is not a directory',
     \ '~'.expand("<slnum>"))
   if a:1 =~ "\\\s" && !filereadable(s:NetrwFile(a:1)) && !isdirectory(s:NetrwFile(a:1))
"    call Decho("re-trying Explore with <".substitute(a:1,'\\\(\s\)','\1','g').">",'~'.expand("<slnum>"))
    call netrw#Explore(a:indx,a:dosplit,a:style,substitute(a:1,'\\\(\s\)','\1','g'))
"    call Dret("netrw#Explore : returning from retry")
    return
"   else " Decho
"    call Decho("retry not needed",'~'.expand("<slnum>"))
   endif
  endif

  " save registers
  if has("clipboard") && g:netrw_clipboard
"   call Decho("(netrw#Explore) save @* and @+",'~'.expand("<slnum>"))
   sil! let keepregstar = @*
   sil! let keepregplus = @+
  endif
  sil! let keepregslash= @/

  " if   dosplit
  " -or- file has been modified AND file not hidden when abandoned
  " -or- Texplore used
  if a:dosplit || (&modified && &hidden == 0 && &bufhidden != "hide") || a:style == 6
"   call Decho("case dosplit=".a:dosplit." modified=".&modified." a:style=".a:style.": dosplit or file has been modified",'~'.expand("<slnum>"))
   call s:SaveWinVars()
   let winsz= g:netrw_winsize
   if a:indx > 0
    let winsz= a:indx
   endif

   if a:style == 0      " Explore, Sexplore
"    call Decho("style=0: Explore or Sexplore",'~'.expand("<slnum>"))
    let winsz= (winsz > 0)? (winsz*winheight(0))/100 : -winsz
    if winsz == 0|let winsz= ""|endif
    exe "noswapfile ".winsz."wincmd s"
"    call Decho("exe noswapfile ".winsz."wincmd s",'~'.expand("<slnum>"))

   elseif a:style == 1  "Explore!, Sexplore!
"    call Decho("style=1: Explore! or Sexplore!",'~'.expand("<slnum>"))
    let winsz= (winsz > 0)? (winsz*winwidth(0))/100 : -winsz
    if winsz == 0|let winsz= ""|endif
    exe "keepalt noswapfile ".winsz."wincmd v"
"    call Decho("exe keepalt noswapfile ".winsz."wincmd v",'~'.expand("<slnum>"))

   elseif a:style == 2  " Hexplore
"    call Decho("style=2: Hexplore",'~'.expand("<slnum>"))
    let winsz= (winsz > 0)? (winsz*winheight(0))/100 : -winsz
    if winsz == 0|let winsz= ""|endif
    exe "keepalt noswapfile bel ".winsz."wincmd s"
"    call Decho("exe keepalt noswapfile bel ".winsz."wincmd s",'~'.expand("<slnum>"))

   elseif a:style == 3  " Hexplore!
"    call Decho("style=3: Hexplore!",'~'.expand("<slnum>"))
    let winsz= (winsz > 0)? (winsz*winheight(0))/100 : -winsz
    if winsz == 0|let winsz= ""|endif
    exe "keepalt noswapfile abo ".winsz."wincmd s"
"    call Decho("exe keepalt noswapfile abo ".winsz."wincmd s",'~'.expand("<slnum>"))

   elseif a:style == 4  " Vexplore
"    call Decho("style=4: Vexplore",'~'.expand("<slnum>"))
    let winsz= (winsz > 0)? (winsz*winwidth(0))/100 : -winsz
    if winsz == 0|let winsz= ""|endif
    exe "keepalt noswapfile lefta ".winsz."wincmd v"
"    call Decho("exe keepalt noswapfile lefta ".winsz."wincmd v",'~'.expand("<slnum>"))

   elseif a:style == 5  " Vexplore!
"    call Decho("style=5: Vexplore!",'~'.expand("<slnum>"))
    let winsz= (winsz > 0)? (winsz*winwidth(0))/100 : -winsz
    if winsz == 0|let winsz= ""|endif
    exe "keepalt noswapfile rightb ".winsz."wincmd v"
"    call Decho("exe keepalt noswapfile rightb ".winsz."wincmd v",'~'.expand("<slnum>"))

   elseif a:style == 6  " Texplore
    call s:SaveBufVars()
"    call Decho("style  = 6: Texplore",'~'.expand("<slnum>"))
    exe "keepalt tabnew ".fnameescape(curdir)
"    call Decho("exe keepalt tabnew ".fnameescape(curdir),'~'.expand("<slnum>"))
    call s:RestoreBufVars()
   endif
   call s:RestoreWinVars()
"  else " Decho
"   call Decho("case a:dosplit=".a:dosplit." AND modified=".&modified." AND a:style=".a:style." is not 6",'~'.expand("<slnum>"))
  endif
  NetrwKeepj norm! 0

  if a:0 > 0
"   call Decho("case [a:0=".a:0."] > 0: a:1<".a:1.">",'~'.expand("<slnum>"))
   if a:1 =~ '^\~' && (has("unix") || (exists("g:netrw_cygwin") && g:netrw_cygwin))
"    call Decho("..case a:1<".a:1.">: starts with ~ and unix or cygwin",'~'.expand("<slnum>"))
    let dirname= simplify(substitute(a:1,'\~',expand("$HOME"),''))
"    call Decho("..using dirname<".dirname.">  (case: ~ && unix||cygwin)",'~'.expand("<slnum>"))
   elseif a:1 == '.'
"    call Decho("..case a:1<".a:1.">: matches .",'~'.expand("<slnum>"))
    let dirname= simplify(exists("b:netrw_curdir")? b:netrw_curdir : getcwd())
    if dirname !~ '/$'
     let dirname= dirname."/"
    endif
"    call Decho("..using dirname<".dirname.">  (case: ".(exists("b:netrw_curdir")? "b:netrw_curdir" : "getcwd()").")",'~'.expand("<slnum>"))
   elseif a:1 =~ '\$'
"    call Decho("..case a:1<".a:1.">: matches ending $",'~'.expand("<slnum>"))
    let dirname= simplify(expand(a:1))
"    call Decho("..using user-specified dirname<".dirname."> with $env-var",'~'.expand("<slnum>"))
   elseif a:1 !~ '^\*\{1,2}/' && a:1 !~ '^\a\{3,}://'
"    call Decho("..case a:1<".a:1.">: other, not pattern or filepattern",'~'.expand("<slnum>"))
    let dirname= simplify(a:1)
"    call Decho("..using user-specified dirname<".dirname.">",'~'.expand("<slnum>"))
   else
"    call Decho("..case a:1: pattern or filepattern",'~'.expand("<slnum>"))
    let dirname= a:1
   endif
  else
   " clear explore
"   call Decho("case a:0=".a:0.": clearing Explore list",'~'.expand("<slnum>"))
   call s:NetrwClearExplore()
"   call Dret("netrw#Explore : cleared list")
   return
  endif

"  call Decho("dirname<".dirname.">",'~'.expand("<slnum>"))
  if dirname =~ '\.\./\=$'
   let dirname= simplify(fnamemodify(dirname,':p:h'))
  elseif dirname =~ '\.\.' || dirname == '.'
   let dirname= simplify(fnamemodify(dirname,':p'))
  endif
"  call Decho("dirname<".dirname.">  (after simplify)",'~'.expand("<slnum>"))

  if dirname =~ '^\*//'
   " starpat=1: Explore *//pattern   (current directory only search for files containing pattern)
"   call Decho("case starpat=1: Explore *//pattern",'~'.expand("<slnum>"))
   let pattern= substitute(dirname,'^\*//\(.*\)$','\1','')
   let starpat= 1
"   call Decho("..Explore *//pat: (starpat=".starpat.") dirname<".dirname."> -> pattern<".pattern.">",'~'.expand("<slnum>"))
   if &hls | let keepregslash= s:ExplorePatHls(pattern) | endif

  elseif dirname =~ '^\*\*//'
   " starpat=2: Explore **//pattern  (recursive descent search for files containing pattern)
"   call Decho("case starpat=2: Explore **//pattern",'~'.expand("<slnum>"))
   let pattern= substitute(dirname,'^\*\*//','','')
   let starpat= 2
"   call Decho("..Explore **//pat: (starpat=".starpat.") dirname<".dirname."> -> pattern<".pattern.">",'~'.expand("<slnum>"))

  elseif dirname =~ '/\*\*/'
   " handle .../**/.../filepat
"   call Decho("case starpat=4: Explore .../**/.../filepat",'~'.expand("<slnum>"))
   let prefixdir= substitute(dirname,'^\(.\{-}\)\*\*.*$','\1','')
   if prefixdir =~ '^/' || (prefixdir =~ '^\a:/' && (has("win32") || has("win95") || has("win64") || has("win16")))
    let b:netrw_curdir = prefixdir
   else
    let b:netrw_curdir= getcwd().'/'.prefixdir
   endif
   let dirname= substitute(dirname,'^.\{-}\(\*\*/.*\)$','\1','')
   let starpat= 4
"   call Decho("..pwd<".getcwd()."> dirname<".dirname.">",'~'.expand("<slnum>"))
"   call Decho("..case Explore ../**/../filepat (starpat=".starpat.")",'~'.expand("<slnum>"))

  elseif dirname =~ '^\*/'
   " case starpat=3: Explore */filepat   (search in current directory for filenames matching filepat)
   let starpat= 3
"   call Decho("case starpat=3: Explore */filepat (starpat=".starpat.")",'~'.expand("<slnum>"))

  elseif dirname=~ '^\*\*/'
   " starpat=4: Explore **/filepat  (recursive descent search for filenames matching filepat)
   let starpat= 4
"   call Decho("case starpat=4: Explore **/filepat (starpat=".starpat.")",'~'.expand("<slnum>"))

  else
   let starpat= 0
"   call Decho("case starpat=0: default",'~'.expand("<slnum>"))
  endif

  if starpat == 0 && a:indx >= 0
   " [Explore Hexplore Vexplore Sexplore] [dirname]
"   call Decho("case starpat==0 && a:indx=".a:indx.": dirname<".dirname.">, handles Explore Hexplore Vexplore Sexplore",'~'.expand("<slnum>"))
   if dirname == ""
    let dirname= curfiledir
"    call Decho("..empty dirname, using current file's directory<".dirname.">",'~'.expand("<slnum>"))
   endif
   if dirname =~# '^scp://' || dirname =~ '^ftp://'
    call netrw#Nread(2,dirname)
   else
    if dirname == ""
     let dirname= getcwd()
    elseif (has("win32") || has("win95") || has("win64") || has("win16")) && !g:netrw_cygwin
     " Windows : check for a drive specifier, or else for a remote share name ('\\Foo' or '//Foo',
     " depending on whether backslashes have been converted to forward slashes by earlier code).
     if dirname !~ '^[a-zA-Z]:' && dirname !~ '^\\\\\w\+' && dirname !~ '^//\w\+'
      let dirname= b:netrw_curdir."/".dirname
     endif
    elseif dirname !~ '^/'
     let dirname= b:netrw_curdir."/".dirname
    endif
"    call Decho("..calling LocalBrowseCheck(dirname<".dirname.">)",'~'.expand("<slnum>"))
    call netrw#LocalBrowseCheck(dirname)
"    call Decho(" modified=".&modified." modifiable=".&modifiable." readonly=".&readonly,'~'.expand("<slnum>"))
"    call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol(),'~'.expand("<slnum>"))
   endif
   if exists("w:netrw_bannercnt")
    " done to handle P08-Ingelrest. :Explore will _Always_ go to the line just after the banner.
    " If one wants to return the same place in the netrw window, use :Rex instead.
    exe w:netrw_bannercnt
   endif

"   call Decho("curdir<".curdir.">",'~'.expand("<slnum>"))
   " ---------------------------------------------------------------------
   " Jan 24, 2013: not sure why the following was present.  See P08-Ingelrest
"   if has("win32") || has("win95") || has("win64") || has("win16")
"    NetrwKeepj call search('\<'.substitute(curdir,'^.*[/\\]','','e').'\>','cW')
"   else
"    NetrwKeepj call search('\<'.substitute(curdir,'^.*/','','e').'\>','cW')
"   endif
   " ---------------------------------------------------------------------

  " starpat=1: Explore *//pattern  (current directory only search for files containing pattern)
  " starpat=2: Explore **//pattern (recursive descent search for files containing pattern)
  " starpat=3: Explore */filepat   (search in current directory for filenames matching filepat)
  " starpat=4: Explore **/filepat  (recursive descent search for filenames matching filepat)
  elseif a:indx <= 0
   " Nexplore, Pexplore, Explore: handle starpat
"   call Decho("case a:indx<=0: Nexplore, Pexplore, <s-down>, <s-up> starpat=".starpat." a:indx=".a:indx,'~'.expand("<slnum>"))
   if !mapcheck("<s-up>","n") && !mapcheck("<s-down>","n") && exists("b:netrw_curdir")
"    call Decho("..set up <s-up> and <s-down> maps",'~'.expand("<slnum>"))
    let s:didstarstar= 1
    nnoremap <buffer> <silent> <s-up>	:Pexplore<cr>
    nnoremap <buffer> <silent> <s-down>	:Nexplore<cr>
   endif

   if has("path_extra")
"    call Decho("..starpat=".starpat.": has +path_extra",'~'.expand("<slnum>"))
    if !exists("w:netrw_explore_indx")
     let w:netrw_explore_indx= 0
    endif

    let indx = a:indx
"    call Decho("..starpat=".starpat.": set indx= [a:indx=".indx."]",'~'.expand("<slnum>"))

    if indx == -1
     " Nexplore
"     call Decho("..case Nexplore with starpat=".starpat.": (indx=".indx.")",'~'.expand("<slnum>"))
     if !exists("w:netrw_explore_list") " sanity check
      NetrwKeepj call netrw#ErrorMsg(s:WARNING,"using Nexplore or <s-down> improperly; see help for netrw-starstar",40)
      if has("clipboard") && g:netrw_clipboard
"       call Decho("(netrw#Explore) restore @* and @+",'~'.expand("<slnum>"))
       if @* != keepregstar | sil! let @* = keepregstar | endif
       if @+ != keepregplus | sil! let @+ = keepregplus | endif
      endif
      sil! let @/ = keepregslash
"      call Dret("netrw#Explore")
      return
     endif
     let indx= w:netrw_explore_indx
     if indx < 0                        | let indx= 0                           | endif
     if indx >= w:netrw_explore_listlen | let indx= w:netrw_explore_listlen - 1 | endif
     let curfile= w:netrw_explore_list[indx]
"     call Decho("....indx=".indx." curfile<".curfile.">",'~'.expand("<slnum>"))
     while indx < w:netrw_explore_listlen && curfile == w:netrw_explore_list[indx]
      let indx= indx + 1
"      call Decho("....indx=".indx." (Nexplore while loop)",'~'.expand("<slnum>"))
     endwhile
     if indx >= w:netrw_explore_listlen | let indx= w:netrw_explore_listlen - 1 | endif
"     call Decho("....Nexplore: indx= [w:netrw_explore_indx=".w:netrw_explore_indx."]=".indx,'~'.expand("<slnum>"))

    elseif indx == -2
     " Pexplore
"     call Decho("case Pexplore with starpat=".starpat.": (indx=".indx.")",'~'.expand("<slnum>"))
     if !exists("w:netrw_explore_list") " sanity check
      NetrwKeepj call netrw#ErrorMsg(s:WARNING,"using Pexplore or <s-up> improperly; see help for netrw-starstar",41)
      if has("clipboard") && g:netrw_clipboard
"       call Decho("(netrw#Explore) restore @* and @+",'~'.expand("<slnum>"))
       if @* != keepregstar | sil! let @* = keepregstar | endif
       if @+ != keepregplus | sil! let @+ = keepregplus | endif
      endif
      sil! let @/ = keepregslash
"      call Dret("netrw#Explore")
      return
     endif
     let indx= w:netrw_explore_indx
     if indx < 0                        | let indx= 0                           | endif
     if indx >= w:netrw_explore_listlen | let indx= w:netrw_explore_listlen - 1 | endif
     let curfile= w:netrw_explore_list[indx]
"     call Decho("....indx=".indx." curfile<".curfile.">",'~'.expand("<slnum>"))
     while indx >= 0 && curfile == w:netrw_explore_list[indx]
      let indx= indx - 1
"      call Decho("....indx=".indx." (Pexplore while loop)",'~'.expand("<slnum>"))
     endwhile
     if indx < 0                        | let indx= 0                           | endif
"     call Decho("....Pexplore: indx= [w:netrw_explore_indx=".w:netrw_explore_indx."]=".indx,'~'.expand("<slnum>"))

    else
     " Explore -- initialize
     " build list of files to Explore with Nexplore/Pexplore
"     call Decho("..starpat=".starpat.": case Explore: initialize (indx=".indx.")",'~'.expand("<slnum>"))
     NetrwKeepj keepalt call s:NetrwClearExplore()
     let w:netrw_explore_indx= 0
     if !exists("b:netrw_curdir")
      let b:netrw_curdir= getcwd()
     endif
"     call Decho("....starpat=".starpat.": b:netrw_curdir<".b:netrw_curdir.">",'~'.expand("<slnum>"))

     " switch on starpat to build the w:netrw_explore_list of files
     if starpat == 1
      " starpat=1: Explore *//pattern  (current directory only search for files containing pattern)
"      call Decho("..case starpat=".starpat.": build *//pattern list  (curdir-only srch for files containing pattern)  &hls=".&hls,'~'.expand("<slnum>"))
"      call Decho("....pattern<".pattern.">",'~'.expand("<slnum>"))
      try
       exe "NetrwKeepj noautocmd vimgrep /".pattern."/gj ".fnameescape(b:netrw_curdir)."/*"
      catch /^Vim\%((\a\+)\)\=:E480/
       keepalt call netrw#ErrorMsg(s:WARNING,"no match with pattern<".pattern.">",76)
"       call Dret("netrw#Explore : unable to find pattern<".pattern.">")
       return
      endtry
      let w:netrw_explore_list = s:NetrwExploreListUniq(map(getqflist(),'bufname(v:val.bufnr)'))
      if &hls | let keepregslash= s:ExplorePatHls(pattern) | endif

     elseif starpat == 2
      " starpat=2: Explore **//pattern (recursive descent search for files containing pattern)
"      call Decho("..case starpat=".starpat.": build **//pattern list  (recursive descent files containing pattern)",'~'.expand("<slnum>"))
"      call Decho("....pattern<".pattern.">",'~'.expand("<slnum>"))
      try
       exe "sil NetrwKeepj noautocmd keepalt vimgrep /".pattern."/gj "."**/*"
      catch /^Vim\%((\a\+)\)\=:E480/
       keepalt call netrw#ErrorMsg(s:WARNING,'no files matched pattern<'.pattern.'>',45)
       if &hls | let keepregslash= s:ExplorePatHls(pattern) | endif
       if has("clipboard") && g:netrw_clipboard
"        call Decho("(netrw#Explore) restore @* and @+",'~'.expand("<slnum>"))
        if @* != keepregstar | sil! let @* = keepregstar | endif
        if @+ != keepregplus | sil! let @+ = keepregplus | endif
       endif
       sil! let @/ = keepregslash
"       call Dret("netrw#Explore : no files matched pattern")
       return
      endtry
      let s:netrw_curdir       = b:netrw_curdir
      let w:netrw_explore_list = getqflist()
      let w:netrw_explore_list = s:NetrwExploreListUniq(map(w:netrw_explore_list,'s:netrw_curdir."/".bufname(v:val.bufnr)'))
      if &hls | let keepregslash= s:ExplorePatHls(pattern) | endif

     elseif starpat == 3
      " starpat=3: Explore */filepat   (search in current directory for filenames matching filepat)
"      call Decho("..case starpat=".starpat.": build */filepat list  (curdir-only srch filenames matching filepat)  &hls=".&hls,'~'.expand("<slnum>"))
      let filepat= substitute(dirname,'^\*/','','')
      let filepat= substitute(filepat,'^[%#<]','\\&','')
"      call Decho("....b:netrw_curdir<".b:netrw_curdir.">",'~'.expand("<slnum>"))
"      call Decho("....filepat<".filepat.">",'~'.expand("<slnum>"))
      let w:netrw_explore_list= s:NetrwExploreListUniq(split(expand(b:netrw_curdir."/".filepat),'\n'))
      if &hls | let keepregslash= s:ExplorePatHls(filepat) | endif

     elseif starpat == 4
      " starpat=4: Explore **/filepat  (recursive descent search for filenames matching filepat)
"      call Decho("..case starpat=".starpat.": build **/filepat list  (recursive descent srch filenames matching filepat)  &hls=".&hls,'~'.expand("<slnum>"))
      let w:netrw_explore_list= s:NetrwExploreListUniq(split(expand(b:netrw_curdir."/".dirname),'\n'))
      if &hls | let keepregslash= s:ExplorePatHls(dirname) | endif
     endif " switch on starpat to build w:netrw_explore_list

     let w:netrw_explore_listlen = len(w:netrw_explore_list)
"     call Decho("....w:netrw_explore_list<".string(w:netrw_explore_list).">",'~'.expand("<slnum>"))
"     call Decho("....w:netrw_explore_listlen=".w:netrw_explore_listlen,'~'.expand("<slnum>"))

     if w:netrw_explore_listlen == 0 || (w:netrw_explore_listlen == 1 && w:netrw_explore_list[0] =~ '\*\*\/')
      keepalt NetrwKeepj call netrw#ErrorMsg(s:WARNING,"no files matched",42)
      if has("clipboard") && g:netrw_clipboard
"       call Decho("(netrw#Explore) restore @* and @+",'~'.expand("<slnum>"))
        if @* != keepregstar | sil! let @* = keepregstar | endif
        if @+ != keepregplus | sil! let @+ = keepregplus | endif
      endif
      sil! let @/ = keepregslash
"      call Dret("netrw#Explore : no files matched")
      return
     endif
    endif  " if indx ... endif

    " NetrwStatusLine support - for exploring support
    let w:netrw_explore_indx= indx
"    call Decho("....w:netrw_explore_list<".join(w:netrw_explore_list,',')."> len=".w:netrw_explore_listlen,'~'.expand("<slnum>"))

    " wrap the indx around, but issue a note
    if indx >= w:netrw_explore_listlen || indx < 0
"     call Decho("....wrap indx (indx=".indx." listlen=".w:netrw_explore_listlen.")",'~'.expand("<slnum>"))
     let indx                = (indx < 0)? ( w:netrw_explore_listlen - 1 ) : 0
     let w:netrw_explore_indx= indx
     keepalt NetrwKeepj call netrw#ErrorMsg(s:NOTE,"no more files match Explore pattern",43)
    endif

    exe "let dirfile= w:netrw_explore_list[".indx."]"
"    call Decho("....dirfile=w:netrw_explore_list[indx=".indx."]= <".dirfile.">",'~'.expand("<slnum>"))
    let newdir= substitute(dirfile,'/[^/]*$','','e')
"    call Decho("....newdir<".newdir.">",'~'.expand("<slnum>"))

"    call Decho("....calling LocalBrowseCheck(newdir<".newdir.">)",'~'.expand("<slnum>"))
    call netrw#LocalBrowseCheck(newdir)
    if !exists("w:netrw_liststyle")
     let w:netrw_liststyle= g:netrw_liststyle
    endif
    if w:netrw_liststyle == s:THINLIST || w:netrw_liststyle == s:LONGLIST
     keepalt NetrwKeepj call search('^'.substitute(dirfile,"^.*/","","").'\>',"W")
    else
     keepalt NetrwKeepj call search('\<'.substitute(dirfile,"^.*/","","").'\>',"w")
    endif
    let w:netrw_explore_mtchcnt = indx + 1
    let w:netrw_explore_bufnr   = bufnr("%")
    let w:netrw_explore_line    = line(".")
    keepalt NetrwKeepj call s:SetupNetrwStatusLine('%f %h%m%r%=%9*%{NetrwStatusLine()}')
"    call Decho("....explore: mtchcnt=".w:netrw_explore_mtchcnt." bufnr=".w:netrw_explore_bufnr." line#".w:netrw_explore_line,'~'.expand("<slnum>"))

   else
"    call Decho("..your vim does not have +path_extra",'~'.expand("<slnum>"))
    if !exists("g:netrw_quiet")
     keepalt NetrwKeepj call netrw#ErrorMsg(s:WARNING,"your vim needs the +path_extra feature for Exploring with **!",44)
    endif
    if has("clipboard") && g:netrw_clipboard
"     call Decho("(netrw#Explore) restore @* and @+",'~'.expand("<slnum>"))
      if @* != keepregstar | sil! let @* = keepregstar | endif
      if @+ != keepregplus | sil! let @+ = keepregplus | endif
    endif
    sil! let @/ = keepregslash
"    call Dret("netrw#Explore : missing +path_extra")
    return
   endif

  else
"   call Decho("..default case: Explore newdir<".dirname.">",'~'.expand("<slnum>"))
   if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && dirname =~ '/'
    sil! unlet w:netrw_treedict
    sil! unlet w:netrw_treetop
   endif
   let newdir= dirname
   if !exists("b:netrw_curdir")
    NetrwKeepj call netrw#LocalBrowseCheck(getcwd())
   else
    NetrwKeepj call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,newdir))
   endif
  endif

  " visual display of **/ **// */ Exploration files
"  call Decho("w:netrw_explore_indx=".(exists("w:netrw_explore_indx")? w:netrw_explore_indx : "doesn't exist"),'~'.expand("<slnum>"))
"  call Decho("b:netrw_curdir<".(exists("b:netrw_curdir")? b:netrw_curdir : "n/a").">",'~'.expand("<slnum>"))
  if exists("w:netrw_explore_indx") && exists("b:netrw_curdir")
"   call Decho("s:explore_prvdir<".(exists("s:explore_prvdir")? s:explore_prvdir : "-doesn't exist-"),'~'.expand("<slnum>"))
   if !exists("s:explore_prvdir") || s:explore_prvdir != b:netrw_curdir
    " only update match list when current directory isn't the same as before
"    call Decho("only update match list when current directory not the same as before",'~'.expand("<slnum>"))
    let s:explore_prvdir = b:netrw_curdir
    let s:explore_match  = ""
    let dirlen           = strlen(b:netrw_curdir)
    if b:netrw_curdir !~ '/$'
     let dirlen= dirlen + 1
    endif
    let prvfname= ""
    for fname in w:netrw_explore_list
"     call Decho("fname<".fname.">",'~'.expand("<slnum>"))
     if fname =~ '^'.b:netrw_curdir
      if s:explore_match == ""
       let s:explore_match= '\<'.escape(strpart(fname,dirlen),g:netrw_markfileesc).'\>'
      else
       let s:explore_match= s:explore_match.'\|\<'.escape(strpart(fname,dirlen),g:netrw_markfileesc).'\>'
      endif
     elseif fname !~ '^/' && fname != prvfname
      if s:explore_match == ""
       let s:explore_match= '\<'.escape(fname,g:netrw_markfileesc).'\>'
      else
       let s:explore_match= s:explore_match.'\|\<'.escape(fname,g:netrw_markfileesc).'\>'
      endif
     endif
     let prvfname= fname
    endfor
"    call Decho("explore_match<".s:explore_match.">",'~'.expand("<slnum>"))
    if has("syntax") && exists("g:syntax_on") && g:syntax_on
     exe "2match netrwMarkFile /".s:explore_match."/"
    endif
   endif
   echo "<s-up>==Pexplore  <s-down>==Nexplore"
  else
   2match none
   if exists("s:explore_match")  | unlet s:explore_match  | endif
   if exists("s:explore_prvdir") | unlet s:explore_prvdir | endif
   echo " "
"   call Decho("cleared explore match list",'~'.expand("<slnum>"))
  endif

  " since Explore may be used to initialize netrw's browser,
  " there's no danger of a late FocusGained event on initialization.
  " Consequently, set s:netrw_events to 2.
  let s:netrw_events= 2
  if has("clipboard") && g:netrw_clipboard
"   call Decho("(netrw#Explore) restore @* and @+",'~'.expand("<slnum>"))
   if @* != keepregstar | sil! let @* = keepregstar | endif
   if @+ != keepregplus | sil! let @+ = keepregplus | endif
  endif
  sil! let @/ = keepregslash
"  call Dret("netrw#Explore : @/<".@/.">")
endfun

" ---------------------------------------------------------------------
" netrw#Lexplore: toggle Explorer window, keeping it on the left of the current tab {{{2
fun! netrw#Lexplore(count,rightside,...)
"  call Dfunc("netrw#Lexplore(count=".a:count." rightside=".a:rightside.",...) a:0=".a:0." ft=".&ft)
  let curwin= winnr()

  if a:0 > 0 && a:1 != ""
   " if a netrw window is already on the left-side of the tab
   " and a directory has been specified, explore with that
   " directory.
"   call Decho("case has input argument(s) (a:1<".a:1.">)")
   let a1 = expand(a:1)
"   call Decho("a:1<".a:1.">  curwin#".curwin,'~'.expand("<slnum>"))
   exe "1wincmd w"
   if &ft == "netrw"
"    call Decho("exe Explore ".fnameescape(a:1),'~'.expand("<slnum>"))
    exe "Explore ".fnameescape(a1)
    exe curwin."wincmd w"
    if exists("t:netrw_lexposn")
"     call Decho("forgetting t:netrw_lexposn",'~'.expand("<slnum>"))
     unlet t:netrw_lexposn
    endif
"    call Dret("netrw#Lexplore")
    return
   endif
   exe curwin."wincmd w"
  else
   let a1= ""
"   call Decho("no input arguments")
  endif

  if exists("t:netrw_lexbufnr")
   " check if t:netrw_lexbufnr refers to a netrw window
   let lexwinnr = bufwinnr(t:netrw_lexbufnr)
"   call Decho("lexwinnr= bufwinnr(t:netrw_lexbufnr#".t:netrw_lexbufnr.")=".lexwinnr)
  else
   let lexwinnr= 0
"   call Decho("t:netrw_lexbufnr doesn't exist")
  endif
"  call Decho("lexwinnr=".lexwinnr,'~'.expand("<slnum>"))

  if lexwinnr > 0
   " close down netrw explorer window
"   call Decho("t:netrw_lexbufnr#".t:netrw_lexbufnr.": close down netrw window",'~'.expand("<slnum>"))
   exe lexwinnr."wincmd w"
   let g:netrw_winsize = -winwidth(0)
   let t:netrw_lexposn = winsaveview()
"   call Decho("saving posn to t:netrw_lexposn<".string(t:netrw_lexposn).">",'~'.expand("<slnum>"))
"   call Decho("saving t:netrw_lexposn",'~'.expand("<slnum>"))
   close
   if lexwinnr < curwin
    let curwin= curwin - 1
   endif
   if lexwinnr != curwin
    exe curwin."wincmd w"
   endif
   unlet t:netrw_lexbufnr
"   call Decho("unlet t:netrw_lexbufnr")

  else
   " open netrw explorer window
"   call Decho("t:netrw_lexbufnr<n/a>: open netrw explorer window",'~'.expand("<slnum>"))
   exe "1wincmd w"
   let keep_altv    = g:netrw_altv
   let g:netrw_altv = 0
   if a:count != 0
    let netrw_winsize   = g:netrw_winsize
    let g:netrw_winsize = a:count
   endif
   let curfile= expand("%")
"   call Decho("curfile<".curfile.">",'~'.expand("<slnum>"))
   exe (a:rightside? "botright" : "topleft")." vertical ".((g:netrw_winsize > 0)? (g:netrw_winsize*winwidth(0))/100 : -g:netrw_winsize) . " new"
"   call Decho("new buf#".bufnr("%")." win#".winnr())
   if a:0 > 0 && a1 != ""
"    call Decho("case 1: Explore ".a1,'~'.expand("<slnum>"))
    call netrw#Explore(0,0,0,a1)
    exe "Explore ".fnameescape(a1)
   elseif curfile =~ '^\a\{3,}://'
"    call Decho("case 2: Explore ".substitute(curfile,'[^/\\]*$','',''),'~'.expand("<slnum>"))
    call netrw#Explore(0,0,0,substitute(curfile,'[^/\\]*$','',''))
   else
"    call Decho("case 3: Explore .",'~'.expand("<slnum>"))
    call netrw#Explore(0,0,0,".")
   endif
   if a:count != 0
    let g:netrw_winsize = netrw_winsize
   endif
   setlocal winfixwidth
   let g:netrw_altv     = keep_altv
   let t:netrw_lexbufnr = bufnr("%")
   " done to prevent build-up of hidden buffers due to quitting and re-invocation of :Lexplore.
   " Since the intended use of :Lexplore is to have an always-present explorer window, the extra
   " effort to mis-use :Lex is warranted.
   set bh=wipe
"   call Decho("let t:netrw_lexbufnr=".t:netrw_lexbufnr) 
"   call Decho("t:netrw_lexposn".(exists("t:netrw_lexposn")? string(t:netrw_lexposn) : " n/a"))
   if exists("t:netrw_lexposn")
"    call Decho("restoring to t:netrw_lexposn",'~'.expand("<slnum>"))
"    call Decho("restoring posn to t:netrw_lexposn<".string(t:netrw_lexposn).">",'~'.expand("<slnum>"))
    call winrestview(t:netrw_lexposn)
    unlet t:netrw_lexposn
   endif
  endif

  " set up default window for editing via <cr>
  if exists("g:netrw_chgwin") && g:netrw_chgwin == -1
   if a:rightside
    let g:netrw_chgwin= 1
   else
    let g:netrw_chgwin= 2
   endif
"   call Decho("let g:netrw_chgwin=".g:netrw_chgwin)
  endif

"  call Dret("netrw#Lexplore")
endfun

" ---------------------------------------------------------------------
" netrw#Clean: remove netrw {{{2
" supports :NetrwClean  -- remove netrw from first directory on runtimepath
"          :NetrwClean! -- remove netrw from all directories on runtimepath
fun! netrw#Clean(sys)
"  call Dfunc("netrw#Clean(sys=".a:sys.")")

  if a:sys
   let choice= confirm("Remove personal and system copies of netrw?","&Yes\n&No")
  else
   let choice= confirm("Remove personal copy of netrw?","&Yes\n&No")
  endif
"  call Decho("choice=".choice,'~'.expand("<slnum>"))
  let diddel= 0
  let diddir= ""

  if choice == 1
   for dir in split(&rtp,',')
    if filereadable(dir."/plugin/netrwPlugin.vim")
"     call Decho("removing netrw-related files from ".dir,'~'.expand("<slnum>"))
     if s:NetrwDelete(dir."/plugin/netrwPlugin.vim")        |call netrw#ErrorMsg(1,"unable to remove ".dir."/plugin/netrwPlugin.vim",55)        |endif
     if s:NetrwDelete(dir."/autoload/netrwFileHandlers.vim")|call netrw#ErrorMsg(1,"unable to remove ".dir."/autoload/netrwFileHandlers.vim",55)|endif
     if s:NetrwDelete(dir."/autoload/netrwSettings.vim")    |call netrw#ErrorMsg(1,"unable to remove ".dir."/autoload/netrwSettings.vim",55)    |endif
     if s:NetrwDelete(dir."/autoload/netrw.vim")            |call netrw#ErrorMsg(1,"unable to remove ".dir."/autoload/netrw.vim",55)            |endif
     if s:NetrwDelete(dir."/syntax/netrw.vim")              |call netrw#ErrorMsg(1,"unable to remove ".dir."/syntax/netrw.vim",55)              |endif
     if s:NetrwDelete(dir."/syntax/netrwlist.vim")          |call netrw#ErrorMsg(1,"unable to remove ".dir."/syntax/netrwlist.vim",55)          |endif
     let diddir= dir
     let diddel= diddel + 1
     if !a:sys|break|endif
    endif
   endfor
  endif

   echohl WarningMsg
  if diddel == 0
   echomsg "netrw is either not installed or not removable"
  elseif diddel == 1
   echomsg "removed one copy of netrw from <".diddir.">"
  else
   echomsg "removed ".diddel." copies of netrw"
  endif
   echohl None

"  call Dret("netrw#Clean")
endfun

" ---------------------------------------------------------------------
" netrw#MakeTgt: make a target out of the directory name provided {{{2
fun! netrw#MakeTgt(dname)
"  call Dfunc("netrw#MakeTgt(dname<".a:dname.">)")
   " simplify the target (eg. /abc/def/../ghi -> /abc/ghi)
  let svpos               = winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  let s:netrwmftgt_islocal= (a:dname !~ '^\a\{3,}://')
"  call Decho("s:netrwmftgt_islocal=".s:netrwmftgt_islocal,'~'.expand("<slnum>"))
  if s:netrwmftgt_islocal
   let netrwmftgt= simplify(a:dname)
  else
   let netrwmftgt= a:dname
  endif
  if exists("s:netrwmftgt") && netrwmftgt == s:netrwmftgt
   " re-selected target, so just clear it
   unlet s:netrwmftgt s:netrwmftgt_islocal
  else
   let s:netrwmftgt= netrwmftgt
  endif
  if g:netrw_fastbrowse <= 1
   call s:NetrwRefresh((b:netrw_curdir !~ '\a\{3,}://'),b:netrw_curdir)
  endif
"  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))"
  call winrestview(svpos)
"  call Dret("netrw#MakeTgt")
endfun

" ---------------------------------------------------------------------
" netrw#Obtain: {{{2
"   netrw#Obtain(islocal,fname[,tgtdirectory])
"     islocal=0  obtain from remote source
"            =1  obtain from local source
"     fname  :   a filename or a list of filenames
"     tgtdir :   optional place where files are to go  (not present, uses getcwd())
fun! netrw#Obtain(islocal,fname,...)
"  call Dfunc("netrw#Obtain(islocal=".a:islocal." fname<".((type(a:fname) == 1)? a:fname : string(a:fname)).">) a:0=".a:0)
  " NetrwStatusLine support - for obtaining support

  if type(a:fname) == 1
   let fnamelist= [ a:fname ]
  elseif type(a:fname) == 3
   let fnamelist= a:fname
  else
   call netrw#ErrorMsg(s:ERROR,"attempting to use NetrwObtain on something not a filename or a list",62)
"   call Dret("netrw#Obtain")
   return
  endif
"  call Decho("fnamelist<".string(fnamelist).">",'~'.expand("<slnum>"))
  if a:0 > 0
   let tgtdir= a:1
  else
   let tgtdir= getcwd()
  endif
"  call Decho("tgtdir<".tgtdir.">",'~'.expand("<slnum>"))

  if exists("b:netrw_islocal") && b:netrw_islocal
   " obtain a file from local b:netrw_curdir to (local) tgtdir
"   call Decho("obtain a file from local ".b:netrw_curdir." to ".tgtdir,'~'.expand("<slnum>"))
   if exists("b:netrw_curdir") && getcwd() != b:netrw_curdir
    let topath= s:ComposePath(tgtdir,"")
    if (has("win32") || has("win95") || has("win64") || has("win16"))
     " transfer files one at time
"     call Decho("transfer files one at a time",'~'.expand("<slnum>"))
     for fname in fnamelist
"      call Decho("system(".g:netrw_localcopycmd." ".s:ShellEscape(fname)." ".s:ShellEscape(topath).")",'~'.expand("<slnum>"))
      call system(g:netrw_localcopycmd.g:netrw_localcopycmdopt." ".s:ShellEscape(fname)." ".s:ShellEscape(topath))
      if v:shell_error != 0
       call netrw#ErrorMsg(s:WARNING,"consider setting g:netrw_localcopycmd<".g:netrw_localcopycmd."> to something that works",80)
"       call Dret("s:NetrwObtain 0 : failed: ".g:netrw_localcopycmd." ".s:ShellEscape(fname)." ".s:ShellEscape(topath))
       return
      endif
     endfor
    else
     " transfer files with one command
"     call Decho("transfer files with one command",'~'.expand("<slnum>"))
     let filelist= join(map(deepcopy(fnamelist),"s:ShellEscape(v:val)"))
"     call Decho("system(".g:netrw_localcopycmd." ".filelist." ".s:ShellEscape(topath).")",'~'.expand("<slnum>"))
     call system(g:netrw_localcopycmd.g:netrw_localcopycmdopt." ".filelist." ".s:ShellEscape(topath))
     if v:shell_error != 0
      call netrw#ErrorMsg(s:WARNING,"consider setting g:netrw_localcopycmd<".g:netrw_localcopycmd."> to something that works",80)
"      call Dret("s:NetrwObtain 0 : failed: ".g:netrw_localcopycmd." ".filelist." ".s:ShellEscape(topath))
      return
     endif
    endif
   elseif !exists("b:netrw_curdir")
    call netrw#ErrorMsg(s:ERROR,"local browsing directory doesn't exist!",36)
   else
    call netrw#ErrorMsg(s:WARNING,"local browsing directory and current directory are identical",37)
   endif

  else
   " obtain files from remote b:netrw_curdir to local tgtdir
"   call Decho("obtain a file from remote ".b:netrw_curdir." to ".tgtdir,'~'.expand("<slnum>"))
   if type(a:fname) == 1
    call s:SetupNetrwStatusLine('%f %h%m%r%=%9*Obtaining '.a:fname)
   endif
   call s:NetrwMethod(b:netrw_curdir)

   if b:netrw_method == 4
    " obtain file using scp
"    call Decho("obtain via scp (method#4)",'~'.expand("<slnum>"))
    if exists("g:netrw_port") && g:netrw_port != ""
     let useport= " ".g:netrw_scpport." ".g:netrw_port
    else
     let useport= ""
    endif
    if b:netrw_fname =~ '/'
     let path= substitute(b:netrw_fname,'^\(.*/\).\{-}$','\1','')
    else
     let path= ""
    endif
    let filelist= join(map(deepcopy(fnamelist),'escape(s:ShellEscape(g:netrw_machine.":".path.v:val,1)," ")'))
    call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_scp_cmd.s:ShellEscape(useport,1)." ".filelist." ".s:ShellEscape(tgtdir,1))

   elseif b:netrw_method == 2
    " obtain file using ftp + .netrc
"     call Decho("obtain via ftp+.netrc (method #2)",'~'.expand("<slnum>"))
     call s:SaveBufVars()|sil NetrwKeepj new|call s:RestoreBufVars()
     let tmpbufnr= bufnr("%")
     setl ff=unix
     if exists("g:netrw_ftpmode") && g:netrw_ftpmode != ""
      NetrwKeepj put =g:netrw_ftpmode
"      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
     endif

     if exists("b:netrw_fname") && b:netrw_fname != ""
      call setline(line("$")+1,'cd "'.b:netrw_fname.'"')
"      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
     endif

     if exists("g:netrw_ftpextracmd")
      NetrwKeepj put =g:netrw_ftpextracmd
"      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
     endif
     for fname in fnamelist
      call setline(line("$")+1,'get "'.fname.'"')
"      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
     endfor
     if exists("g:netrw_port") && g:netrw_port != ""
      call s:NetrwExe(s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".s:ShellEscape(g:netrw_machine,1)." ".s:ShellEscape(g:netrw_port,1))
     else
      call s:NetrwExe(s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".s:ShellEscape(g:netrw_machine,1))
     endif
     " If the result of the ftp operation isn't blank, show an error message (tnx to Doug Claar)
     if getline(1) !~ "^$" && !exists("g:netrw_quiet") && getline(1) !~ '^Trying '
      let debugkeep= &debug
      setl debug=msg
      call netrw#ErrorMsg(s:ERROR,getline(1),4)
      let &debug= debugkeep
     endif

   elseif b:netrw_method == 3
    " obtain with ftp + machine, id, passwd, and fname (ie. no .netrc)
"    call Decho("obtain via ftp+mipf (method #3)",'~'.expand("<slnum>"))
    call s:SaveBufVars()|sil NetrwKeepj new|call s:RestoreBufVars()
    let tmpbufnr= bufnr("%")
    setl ff=unix

    if exists("g:netrw_port") && g:netrw_port != ""
     NetrwKeepj put ='open '.g:netrw_machine.' '.g:netrw_port
"     call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
    else
     NetrwKeepj put ='open '.g:netrw_machine
"     call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
    endif

    if exists("g:netrw_uid") && g:netrw_uid != ""
     if exists("g:netrw_ftp") && g:netrw_ftp == 1
      NetrwKeepj put =g:netrw_uid
"      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
      if exists("s:netrw_passwd") && s:netrw_passwd != ""
       NetrwKeepj put ='\"'.s:netrw_passwd.'\"'
      endif
"      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
     elseif exists("s:netrw_passwd")
      NetrwKeepj put ='user \"'.g:netrw_uid.'\" \"'.s:netrw_passwd.'\"'
"      call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
     endif
    endif

    if exists("g:netrw_ftpmode") && g:netrw_ftpmode != ""
     NetrwKeepj put =g:netrw_ftpmode
"     call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
    endif

    if exists("b:netrw_fname") && b:netrw_fname != ""
     NetrwKeepj call setline(line("$")+1,'cd "'.b:netrw_fname.'"')
"     call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
    endif

    if exists("g:netrw_ftpextracmd")
     NetrwKeepj put =g:netrw_ftpextracmd
"     call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
    endif

    if exists("g:netrw_ftpextracmd")
     NetrwKeepj put =g:netrw_ftpextracmd
"     call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
    endif
    for fname in fnamelist
     NetrwKeepj call setline(line("$")+1,'get "'.fname.'"')
    endfor
"    call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))

    " perform ftp:
    " -i       : turns off interactive prompting from ftp
    " -n  unix : DON'T use <.netrc>, even though it exists
    " -n  win32: quit being obnoxious about password
    "  Note: using "_dd to delete to the black hole register; avoids messing up @@
    NetrwKeepj norm! 1G"_dd
    call s:NetrwExe(s:netrw_silentxfer."%!".s:netrw_ftp_cmd." ".g:netrw_ftp_options)
    " If the result of the ftp operation isn't blank, show an error message (tnx to Doug Claar)
    if getline(1) !~ "^$"
"     call Decho("error<".getline(1).">",'~'.expand("<slnum>"))
     if !exists("g:netrw_quiet")
      NetrwKeepj call netrw#ErrorMsg(s:ERROR,getline(1),5)
     endif
    endif

   elseif b:netrw_method == 9
    " obtain file using sftp
"    call Decho("obtain via sftp (method #9)",'~'.expand("<slnum>"))
    if a:fname =~ '/'
     let localfile= substitute(a:fname,'^.*/','','')
    else
     let localfile= a:fname
    endif
    call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_sftp_cmd." ".s:ShellEscape(g:netrw_machine.":".b:netrw_fname,1).s:ShellEscape(localfile)." ".s:ShellEscape(tgtdir))

   elseif !exists("b:netrw_method") || b:netrw_method < 0
    " probably a badly formed url; protocol not recognized
"    call Dret("netrw#Obtain : unsupported method")
    return

   else
    " protocol recognized but not supported for Obtain (yet?)
    if !exists("g:netrw_quiet")
     NetrwKeepj call netrw#ErrorMsg(s:ERROR,"current protocol not supported for obtaining file",97)
    endif
"    call Dret("netrw#Obtain : current protocol not supported for obtaining file")
    return
   endif

   " restore status line
   if type(a:fname) == 1 && exists("s:netrw_users_stl")
    NetrwKeepj call s:SetupNetrwStatusLine(s:netrw_users_stl)
   endif

  endif

  " cleanup
  if exists("tmpbufnr")
   if bufnr("%") != tmpbufnr
    exe tmpbufnr."bw!"
   else
    q!
   endif
  endif

"  call Dret("netrw#Obtain")
endfun

" ---------------------------------------------------------------------
" netrw#Nread: save position, call netrw#NetRead(), and restore position {{{2
fun! netrw#Nread(mode,fname)
"  call Dfunc("netrw#Nread(mode=".a:mode." fname<".a:fname.">)")
  let svpos= winsaveview()
"  call Decho("saving posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  call netrw#NetRead(a:mode,a:fname)
"  call Decho("restoring posn to svpos<".string(svpos).">",'~'.expand("<slnum>"))
  call winrestview(svpos)

  if exists("w:netrw_liststyle") && w:netrw_liststyle != s:TREELIST
   if exists("w:netrw_bannercnt")
    " start with cursor just after the banner
    exe w:netrw_bannercnt
   endif
  endif
"  call Dret("netrw#Nread")
endfun

" ------------------------------------------------------------------------
" s:NetrwOptionsSave: save options prior to setting to "netrw-buffer-standard" form {{{2
"             Options get restored by s:NetrwOptionsRestore()
"
"             Option handling:
"              * save user's options                                     (s:NetrwOptionsSave)
"              * set netrw-safe options                                  (s:NetrwOptionsSafe)
"                - change an option only when user option != safe option (s:netrwSetSafeSetting)
"              * restore user's options                                  (s:netrwOPtionsRestore)
"                - restore a user option when != safe option             (s:NetrwRestoreSetting)
"             vt: (variable type) normally its either "w:" or "s:"
fun! s:NetrwOptionsSave(vt)
"  call Dfunc("s:NetrwOptionsSave(vt<".a:vt.">) win#".winnr()." buf#".bufnr("%")."<".bufname(bufnr("%")).">"." winnr($)=".winnr("$")." mod=".&mod." ma=".&ma)
"  call Decho(a:vt."netrw_optionsave".(exists("{a:vt}netrw_optionsave")? ("=".{a:vt}netrw_optionsave) : " doesn't exist"),'~'.expand("<slnum>"))
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt." hid=".&hid,'~'.expand("<slnum>"))
"  call Decho("(s:NetrwOptionsSave) lines=".&lines)

  if !exists("{a:vt}netrw_optionsave")
   let {a:vt}netrw_optionsave= 1
  else
"   call Dret("s:NetrwOptionsSave : options already saved")
   return
  endif
"  call Decho("prior to save: fo=".&fo.(exists("+acd")? " acd=".&acd : " acd doesn't exist")." diff=".&l:diff,'~'.expand("<slnum>"))

  " Save current settings and current directory
"  call Decho("saving current settings and current directory",'~'.expand("<slnum>"))
  let s:yykeep          = @@
  if exists("&l:acd")|let {a:vt}netrw_acdkeep  = &l:acd|endif
  let {a:vt}netrw_aikeep    = &l:ai
  let {a:vt}netrw_awkeep    = &l:aw
  let {a:vt}netrw_bhkeep    = &l:bh
  let {a:vt}netrw_blkeep    = &l:bl
  let {a:vt}netrw_btkeep    = &l:bt
  let {a:vt}netrw_bombkeep  = &l:bomb
  let {a:vt}netrw_cedit     = &cedit
  let {a:vt}netrw_cikeep    = &l:ci
  let {a:vt}netrw_cinkeep   = &l:cin
  let {a:vt}netrw_cinokeep  = &l:cino
  let {a:vt}netrw_comkeep   = &l:com
  let {a:vt}netrw_cpokeep   = &l:cpo
  let {a:vt}netrw_cuckeep   = &l:cuc
  let {a:vt}netrw_culkeep   = &l:cul
"  call Decho("(s:NetrwOptionsSave) COMBAK: cuc=".&l:cuc." cul=".&l:cul)
  let {a:vt}netrw_diffkeep  = &l:diff
  let {a:vt}netrw_fenkeep   = &l:fen
  if !exists("g:netrw_ffkeep") || g:netrw_ffkeep
   let {a:vt}netrw_ffkeep    = &l:ff
  endif
  let {a:vt}netrw_fokeep    = &l:fo           " formatoptions
  let {a:vt}netrw_gdkeep    = &l:gd           " gdefault
  let {a:vt}netrw_gokeep    = &l:go           " guioptions
  let {a:vt}netrw_hidkeep   = &l:hidden
  let {a:vt}netrw_imkeep    = &l:im
  let {a:vt}netrw_iskkeep   = &l:isk
  let {a:vt}netrw_lines     = &lines
  let {a:vt}netrw_lskeep    = &l:ls
  let {a:vt}netrw_makeep    = &l:ma
  let {a:vt}netrw_magickeep = &l:magic
  let {a:vt}netrw_modkeep   = &l:mod
  let {a:vt}netrw_nukeep    = &l:nu
  let {a:vt}netrw_rnukeep   = &l:rnu
  let {a:vt}netrw_repkeep   = &l:report
  let {a:vt}netrw_rokeep    = &l:ro
  let {a:vt}netrw_selkeep   = &l:sel
  let {a:vt}netrw_spellkeep = &l:spell
  if !g:netrw_use_noswf
   let {a:vt}netrw_swfkeep  = &l:swf
  endif
  let {a:vt}netrw_tskeep    = &l:ts
  let {a:vt}netrw_twkeep    = &l:tw           " textwidth
  let {a:vt}netrw_wigkeep   = &l:wig          " wildignore
  let {a:vt}netrw_wrapkeep  = &l:wrap
  let {a:vt}netrw_writekeep = &l:write

  " save a few selected netrw-related variables
"  call Decho("saving a few selected netrw-related variables",'~'.expand("<slnum>"))
  if g:netrw_keepdir
   let {a:vt}netrw_dirkeep  = getcwd()
"   call Decho("saving to ".a:vt."netrw_dirkeep<".{a:vt}netrw_dirkeep.">",'~'.expand("<slnum>"))
  endif
  if has("clipboard") && g:netrw_clipboard
   sil! let {a:vt}netrw_starkeep = @*
   sil! let {a:vt}netrw_pluskeep = @+
  endif
  sil! let {a:vt}netrw_slashkeep= @/

"  call Decho("(s:NetrwOptionsSave) lines=".&lines)
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt,'~'.expand("<slnum>"))
"  call Dret("s:NetrwOptionsSave : tab#".tabpagenr()." win#".winnr())
endfun

" ---------------------------------------------------------------------
" s:NetrwOptionsSafe: sets options to help netrw do its job {{{2
"                     Use  s:NetrwSaveOptions() to save user settings
"                     Use  s:NetrwOptionsRestore() to restore user settings
fun! s:NetrwOptionsSafe(islocal)
"  call Dfunc("s:NetrwOptionsSafe(islocal=".a:islocal.") win#".winnr()." buf#".bufnr("%")."<".bufname(bufnr("%"))."> winnr($)=".winnr("$"))
"  call Decho("win#".winnr()."'s ft=".&ft,'~'.expand("<slnum>"))
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
  if exists("+acd") | call s:NetrwSetSafeSetting("&l:acd",0)|endif
  call s:NetrwSetSafeSetting("&l:ai",0)
  call s:NetrwSetSafeSetting("&l:aw",0)
  call s:NetrwSetSafeSetting("&l:bl",0)
  call s:NetrwSetSafeSetting("&l:bomb",0)
  if a:islocal
   call s:NetrwSetSafeSetting("&l:bt","nofile")
  else
   call s:NetrwSetSafeSetting("&l:bt","acwrite")
  endif
  call s:NetrwSetSafeSetting("&l:ci",0)
  call s:NetrwSetSafeSetting("&l:cin",0)
  if g:netrw_fastbrowse > a:islocal
   call s:NetrwSetSafeSetting("&l:bh","hide")
  else
   call s:NetrwSetSafeSetting("&l:bh","delete")
  endif
  call s:NetrwSetSafeSetting("&l:cino","")
  call s:NetrwSetSafeSetting("&l:com","")
  if &cpo =~ 'a' | call s:NetrwSetSafeSetting("&cpo",substitute(&cpo,'a','','g')) | endif
  if &cpo =~ 'A' | call s:NetrwSetSafeSetting("&cpo",substitute(&cpo,'A','','g')) | endif
  setl fo=nroql2
  " call s:NetrwSetSafeSetting("&go","begmr")
  if &go =~ '\ca' | call s:NetrwSetSafeSetting("&go",substitute(&go,'\ca','','g')) | endif
  call s:NetrwSetSafeSetting("&l:hid",0)
  call s:NetrwSetSafeSetting("&l:im",0)
  setl isk+=@ isk+=* isk+=/
  call s:NetrwSetSafeSetting("&l:magic",1)
  if g:netrw_use_noswf
   call s:NetrwSetSafeSetting("swf",0)
  endif
  call s:NetrwSetSafeSetting("&l:report",10000)
  call s:NetrwSetSafeSetting("&l:sel","inclusive")
  call s:NetrwSetSafeSetting("&l:spell",0)
  call s:NetrwSetSafeSetting("&l:tw",0)
  call s:NetrwSetSafeSetting("&l:wig","")
  setl cedit&

  " set up cuc and cul based on g:netrw_cursor and listing style
  " COMBAK -- cuc cul related
  call s:NetrwCursor(0)

  " allow the user to override safe options
"  call Decho("ft<".&ft."> ei=".&ei,'~'.expand("<slnum>"))
  if &ft == "netrw"
"   call Decho("do any netrw FileType autocmds (doau FileType netrw)",'~'.expand("<slnum>"))
   keepalt NetrwKeepj doau FileType netrw
  endif

"  call Decho("fo=".&fo.(exists("+acd")? " acd=".&acd : " acd doesn't exist")." bh=".&l:bh." bt<".&bt.">",'~'.expand("<slnum>"))
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo,'~'.expand("<slnum>"))
"  call Dret("s:NetrwOptionsSafe")
endfun

" ---------------------------------------------------------------------
" s:NetrwOptionsRestore: restore options (based on prior s:NetrwOptionsSave) {{{2
fun! s:NetrwOptionsRestore(vt)
"  call Dfunc("s:NetrwOptionsRestore(vt<".a:vt.">) win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> winnr($)=".winnr("$"))
"  call Decho("(s:NetrwOptionsRestore) lines=".&lines)
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt,'~'.expand("<slnum>"))
  if !exists("{a:vt}netrw_optionsave")
"   call Decho("case ".a:vt."netrw_optionsave : doesn't exist",'~'.expand("<slnum>"))
"   call Decho("..doing filetype detect anyway")
   filetype detect
"   call Decho("..settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt,'~'.expand("<slnum>"))
"   call Decho("..ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
"   call Dret("s:NetrwOptionsRestore : ".a:vt."netrw_optionsave doesn't exist")
   return
  endif
  unlet {a:vt}netrw_optionsave

  if exists("+acd")
   if exists("{a:vt}netrw_acdkeep")
"    call Decho("g:netrw_keepdir=".g:netrw_keepdir.": getcwd<".getcwd()."> acd=".&acd,'~'.expand("<slnum>"))
    let curdir = getcwd()
    let &l:acd = {a:vt}netrw_acdkeep
    unlet {a:vt}netrw_acdkeep
    if &l:acd
     call s:NetrwLcd(curdir)
    endif
   endif
  endif
"  call Decho("(s:NetrwOptionsRestore) #1 lines=".&lines)
  call s:NetrwRestoreSetting(a:vt."netrw_aikeep","&l:ai")
  call s:NetrwRestoreSetting(a:vt."netrw_awkeep","&l:aw")
  call s:NetrwRestoreSetting(a:vt."netrw_blkeep","&l:bl")
  call s:NetrwRestoreSetting(a:vt."netrw_btkeep","&l:bt")
  call s:NetrwRestoreSetting(a:vt."netrw_bombkeep","&l:bomb")
"  call Decho("(s:NetrwOptionsRestore) #2 lines=".&lines)
  call s:NetrwRestoreSetting(a:vt."netrw_cedit","&cedit")
  call s:NetrwRestoreSetting(a:vt."netrw_cikeep","&l:ci")
  call s:NetrwRestoreSetting(a:vt."netrw_cinkeep","&l:cin")
  call s:NetrwRestoreSetting(a:vt."netrw_cinokeep","&l:cino")
  call s:NetrwRestoreSetting(a:vt."netrw_comkeep","&l:com")
"  call Decho("(s:NetrwOptionsRestore) #3 lines=".&lines)
  call s:NetrwRestoreSetting(a:vt."netrw_cpokeep","&l:cpo")
  call s:NetrwRestoreSetting(a:vt."netrw_diffkeep","&l:diff")
  call s:NetrwRestoreSetting(a:vt."netrw_fenkeep","&l:fen")
  if exists("g:netrw_ffkeep") && g:netrw_ffkeep
   call s:NetrwRestoreSetting(a:vt."netrw_ffkeep")","&l:ff")
  endif
"  call Decho("(s:NetrwOptionsRestore) #4 lines=".&lines)
  call s:NetrwRestoreSetting(a:vt."netrw_fokeep"   ,"&l:fo")
  call s:NetrwRestoreSetting(a:vt."netrw_gdkeep"   ,"&l:gd")
  call s:NetrwRestoreSetting(a:vt."netrw_gokeep"   ,"&l:go")
  call s:NetrwRestoreSetting(a:vt."netrw_hidkeep"  ,"&l:hidden")
"  call Decho("(s:NetrwOptionsRestore) #5 lines=".&lines)
  call s:NetrwRestoreSetting(a:vt."netrw_imkeep"   ,"&l:im")
  call s:NetrwRestoreSetting(a:vt."netrw_iskkeep"  ,"&l:isk")
"  call Decho("(s:NetrwOptionsRestore) #6 lines=".&lines)
  call s:NetrwRestoreSetting(a:vt."netrw_lines"    ,"&lines")
"  call Decho("(s:NetrwOptionsRestore) #7 lines=".&lines)
  call s:NetrwRestoreSetting(a:vt."netrw_lskeep"   ,"&l:ls")
  call s:NetrwRestoreSetting(a:vt."netrw_makeep"   ,"&l:ma")
  call s:NetrwRestoreSetting(a:vt."netrw_magickeep","&l:magic")
  call s:NetrwRestoreSetting(a:vt."netrw_modkeep"  ,"&l:mod")
  call s:NetrwRestoreSetting(a:vt."netrw_nukeep"   ,"&l:nu")
"  call Decho("(s:NetrwOptionsRestore) #8 lines=".&lines)
  call s:NetrwRestoreSetting(a:vt."netrw_rnukeep"  ,"&l:rnu")
  call s:NetrwRestoreSetting(a:vt."netrw_repkeep"  ,"&l:report")
  call s:NetrwRestoreSetting(a:vt."netrw_rokeep"   ,"&l:ro")
  call s:NetrwRestoreSetting(a:vt."netrw_selkeep"  ,"&l:sel")
"  call Decho("(s:NetrwOptionsRestore) #9 lines=".&lines)
  call s:NetrwRestoreSetting(a:vt."netrw_spellkeep","&l:spell")
  call s:NetrwRestoreSetting(a:vt."netrw_twkeep"   ,"&l:tw")
  call s:NetrwRestoreSetting(a:vt."netrw_wigkeep"  ,"&l:wig")
  call s:NetrwRestoreSetting(a:vt."netrw_wrapkeep" ,"&l:wrap")
  call s:NetrwRestoreSetting(a:vt."netrw_writekeep","&l:write")
"  call Decho("(s:NetrwOptionsRestore) #10 lines=".&lines)
  call s:NetrwRestoreSetting("s:yykeep","@@")
  " former problem: start with liststyle=0; press <i> : result, following line resets l:ts.
  " Fixed; in s:PerformListing, when w:netrw_liststyle is s:LONGLIST, will use a printf to pad filename with spaces
  "        rather than by appending a tab which previously was using "&ts" to set the desired spacing.  (Sep 28, 2018)
  call s:NetrwRestoreSetting(a:vt."netrw_tskeep","&l:ts")

  if exists("{a:vt}netrw_swfkeep")
   if &directory == ""
    " user hasn't specified a swapfile directory;
    " netrw will temporarily set the swapfile directory
    " to the current directory as returned by getcwd().
    let &l:directory= getcwd()
    sil! let &l:swf = {a:vt}netrw_swfkeep
    setl directory=
    unlet {a:vt}netrw_swfkeep
   elseif &l:swf != {a:vt}netrw_swfkeep
    if !g:netrw_use_noswf
     " following line causes a Press ENTER in windows -- can't seem to work around it!!!
     sil! let &l:swf= {a:vt}netrw_swfkeep
    endif
    unlet {a:vt}netrw_swfkeep
   endif
  endif
  if exists("{a:vt}netrw_dirkeep") && isdirectory(s:NetrwFile({a:vt}netrw_dirkeep)) && g:netrw_keepdir
   let dirkeep = substitute({a:vt}netrw_dirkeep,'\\','/','g')
   if exists("{a:vt}netrw_dirkeep")
    call s:NetrwLcd(dirkeep)
    unlet {a:vt}netrw_dirkeep
   endif
  endif
  if has("clipboard") && g:netrw_clipboard
"   call Decho("has clipboard",'~'.expand("<slnum>"))
   call s:NetrwRestoreSetting(a:vt."netrw_starkeep","@*")
   call s:NetrwRestoreSetting(a:vt."netrw_pluskeep","@+")
  endif
  call s:NetrwRestoreSetting(a:vt."netrw_slashkeep","@/")

"  call Decho("g:netrw_keepdir=".g:netrw_keepdir.": getcwd<".getcwd()."> acd=".&acd,'~'.expand("<slnum>"))
"  call Decho("fo=".&fo.(exists("+acd")? " acd=".&acd : " acd doesn't exist"),'~'.expand("<slnum>"))
"  call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
"  call Decho("diff=".&l:diff." win#".winnr()." w:netrw_diffkeep=".(exists("w:netrw_diffkeep")? w:netrw_diffkeep : "doesn't exist"),'~'.expand("<slnum>"))
"  call Decho("ts=".&l:ts,'~'.expand("<slnum>"))
  " Moved the filetype detect here from NetrwGetFile() because remote files
  " were having their filetype detect-generated settings overwritten by
  " NetrwOptionRestore.
  if &ft != "netrw"
"   call Decho("before: filetype detect  (ft=".&ft.")",'~'.expand("<slnum>"))
   filetype detect
"   call Decho("after : filetype detect  (ft=".&ft.")",'~'.expand("<slnum>"))
  endif
"  call Decho("(s:NetrwOptionsRestore) lines=".&lines)
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt,'~'.expand("<slnum>"))
"  call Dret("s:NetrwOptionsRestore : tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> modified=".&modified." modifiable=".&modifiable." readonly=".&readonly)
endfun

" ---------------------------------------------------------------------
" s:NetrwSetSafeSetting: sets an option to a safe setting {{{2
"                        but only when the options' value and the safe setting differ
"                        Doing this means that netrw will not come up as having changed a
"                        setting last when it really didn't actually change it.
"
"                        Called from s:NetrwOptionsSafe
"                          ex. call s:NetrwSetSafeSetting("&l:sel","inclusive")
fun! s:NetrwSetSafeSetting(setting,safesetting)
"  call Dfunc("s:NetrwSetSafeSetting(setting<".a:setting."> safesetting<".a:safesetting.">)")

  if a:setting =~ '^&'
"   call Decho("fyi: a:setting starts with &")
   exe "let settingval= ".a:setting
"   call Decho("fyi: settingval<".settingval.">")

   if settingval != a:safesetting
"    call Decho("set setting<".a:setting."> to option value<".a:safesetting.">")
    if type(a:safesetting) == 0
     exe "let ".a:setting."=".a:safesetting
    elseif type(a:safesetting) == 1
     exe "let ".a:setting."= '".a:safesetting."'"
    else
     call netrw#ErrorMsg(s:ERROR,"(s:NetrwRestoreSetting) doesn't know how to restore ".a:setting." with a safesetting of type#".type(a:safesetting),105)
    endif
   endif
  endif

"  call Dret("s:NetrwSetSafeSetting")
endfun

" ------------------------------------------------------------------------
" s:NetrwRestoreSetting: restores specified setting using associated keepvar, {{{2
"                        but only if the setting value differs from the associated keepvar.
"                        Doing this means that netrw will not come up as having changed a
"                        setting last when it really didn't actually change it.
"
"                        Used by s:NetrwOptionsRestore() to restore each netrw-senstive setting
"                        keepvars are set up by s:NetrwOptionsSave
fun! s:NetrwRestoreSetting(keepvar,setting)
"""  call Dfunc("s:NetrwRestoreSetting(a:keepvar<".a:keepvar."> a:setting<".a:setting.">)")

  " typically called from s:NetrwOptionsRestore
  "   call s:NetrwRestoreSettings(keep-option-variable-name,'associated-option')
  "   ex. call s:NetrwRestoreSetting(a:vt."netrw_selkeep","&l:sel")
  "  Restores option (but only if different) from a:keepvar
  if exists(a:keepvar)
   exe "let keepvarval= ".a:keepvar
   exe "let setting= ".a:setting

""   call Decho("fyi: a:keepvar<".a:keepvar."> exists")
""   call Decho("fyi: keepvarval=".keepvarval)
""   call Decho("fyi: a:setting<".a:setting."> setting<".setting.">")

   if setting != keepvarval
""    call Decho("restore setting<".a:setting."> (currently=".setting.") to keepvarval<".keepvarval.">")
    if type(a:setting) == 0
     exe "let ".a:setting."= ".keepvarval
    elseif type(a:setting) == 1
     exe "let ".a:setting."= '".substitute(keepvarval,"'","''","g")."'"
    else
     call netrw#ErrorMsg(s:ERROR,"(s:NetrwRestoreSetting) doesn't know how to restore ".a:keepvar." with a setting of type#".type(a:setting),105)
    endif
   endif

   exe "unlet ".a:keepvar
  endif

""  call Dret("s:NetrwRestoreSetting")
endfun

" ---------------------------------------------------------------------
" NetrwStatusLine: {{{2
fun! NetrwStatusLine()

" vvv NetrwStatusLine() debugging vvv
"  let g:stlmsg=""
"  if !exists("w:netrw_explore_bufnr")
"   let g:stlmsg="!X<explore_bufnr>"
"  elseif w:netrw_explore_bufnr != bufnr("%")
"   let g:stlmsg="explore_bufnr!=".bufnr("%")
"  endif
"  if !exists("w:netrw_explore_line")
"   let g:stlmsg=" !X<explore_line>"
"  elseif w:netrw_explore_line != line(".")
"   let g:stlmsg=" explore_line!={line(.)<".line(".").">"
"  endif
"  if !exists("w:netrw_explore_list")
"   let g:stlmsg=" !X<explore_list>"
"  endif
" ^^^ NetrwStatusLine() debugging ^^^

  if !exists("w:netrw_explore_bufnr") || w:netrw_explore_bufnr != bufnr("%") || !exists("w:netrw_explore_line") || w:netrw_explore_line != line(".") || !exists("w:netrw_explore_list")
   " restore user's status line
   let &stl        = s:netrw_users_stl
   let &laststatus = s:netrw_users_ls
   if exists("w:netrw_explore_bufnr")|unlet w:netrw_explore_bufnr|endif
   if exists("w:netrw_explore_line") |unlet w:netrw_explore_line |endif
   return ""
  else
   return "Match ".w:netrw_explore_mtchcnt." of ".w:netrw_explore_listlen
  endif
endfun

" ===============================
"  Netrw Transfer Functions: {{{1
" ===============================

" ------------------------------------------------------------------------
" netrw#NetRead: responsible for reading a file over the net {{{2
"   mode: =0 read remote file and insert before current line
"         =1 read remote file and insert after current line
"         =2 replace with remote file
"         =3 obtain file, but leave in temporary format
fun! netrw#NetRead(mode,...)
"  call Dfunc("netrw#NetRead(mode=".a:mode.",...) a:0=".a:0." ".g:loaded_netrw.((a:0 > 0)? " a:1<".a:1.">" : ""))

  " NetRead: save options {{{3
  call s:NetrwOptionsSave("w:")
  call s:NetrwOptionsSafe(0)
  call s:RestoreCursorline()
  " NetrwSafeOptions sets a buffer up for a netrw listing, which includes buflisting off.
  " However, this setting is not wanted for a remote editing session.  The buffer should be "nofile", still.
  setl bl
"  call Decho("buf#".bufnr("%")."<".bufname("%")."> bl=".&bl." bt=".&bt." bh=".&bh,'~'.expand("<slnum>"))

  " NetRead: interpret mode into a readcmd {{{3
  if     a:mode == 0 " read remote file before current line
   let readcmd = "0r"
  elseif a:mode == 1 " read file after current line
   let readcmd = "r"
  elseif a:mode == 2 " replace with remote file
   let readcmd = "%r"
  elseif a:mode == 3 " skip read of file (leave as temporary)
   let readcmd = "t"
  else
   exe a:mode
   let readcmd = "r"
  endif
  let ichoice = (a:0 == 0)? 0 : 1
"  call Decho("readcmd<".readcmd."> ichoice=".ichoice,'~'.expand("<slnum>"))

  " NetRead: get temporary filename {{{3
  let tmpfile= s:GetTempfile("")
  if tmpfile == ""
"   call Dret("netrw#NetRead : unable to get a tempfile!")
   return
  endif

  while ichoice <= a:0

   " attempt to repeat with previous host-file-etc
   if exists("b:netrw_lastfile") && a:0 == 0
"    call Decho("using b:netrw_lastfile<" . b:netrw_lastfile . ">",'~'.expand("<slnum>"))
    let choice = b:netrw_lastfile
    let ichoice= ichoice + 1

   else
    exe "let choice= a:" . ichoice
"    call Decho("no lastfile: choice<" . choice . ">",'~'.expand("<slnum>"))

    if match(choice,"?") == 0
     " give help
     echomsg 'NetRead Usage:'
     echomsg ':Nread machine:path                         uses rcp'
     echomsg ':Nread "machine path"                       uses ftp   with <.netrc>'
     echomsg ':Nread "machine id password path"           uses ftp'
     echomsg ':Nread dav://machine[:port]/path            uses cadaver'
     echomsg ':Nread fetch://machine/path                 uses fetch'
     echomsg ':Nread ftp://[user@]machine[:port]/path     uses ftp   autodetects <.netrc>'
     echomsg ':Nread http://[user@]machine/path           uses http  wget'
     echomsg ':Nread file:///path           		  uses elinks'
     echomsg ':Nread https://[user@]machine/path          uses http  wget'
     echomsg ':Nread rcp://[user@]machine/path            uses rcp'
     echomsg ':Nread rsync://machine[:port]/path          uses rsync'
     echomsg ':Nread scp://[user@]machine[[:#]port]/path  uses scp'
     echomsg ':Nread sftp://[user@]machine[[:#]port]/path uses sftp'
     sleep 4
     break

    elseif match(choice,'^"') != -1
     " Reconstruct Choice if choice starts with '"'
"     call Decho("reconstructing choice",'~'.expand("<slnum>"))
     if match(choice,'"$') != -1
      " case "..."
      let choice= strpart(choice,1,strlen(choice)-2)
     else
       "  case "... ... ..."
      let choice      = strpart(choice,1,strlen(choice)-1)
      let wholechoice = ""

      while match(choice,'"$') == -1
       let wholechoice = wholechoice . " " . choice
       let ichoice     = ichoice + 1
       if ichoice > a:0
       	if !exists("g:netrw_quiet")
	 call netrw#ErrorMsg(s:ERROR,"Unbalanced string in filename '". wholechoice ."'",3)
	endif
"        call Dret("netrw#NetRead :2 getcwd<".getcwd().">")
        return
       endif
       let choice= a:{ichoice}
      endwhile
      let choice= strpart(wholechoice,1,strlen(wholechoice)-1) . " " . strpart(choice,0,strlen(choice)-1)
     endif
    endif
   endif

"   call Decho("choice<" . choice . ">",'~'.expand("<slnum>"))
   let ichoice= ichoice + 1

   " NetRead: Determine method of read (ftp, rcp, etc) {{{3
   call s:NetrwMethod(choice)
   if !exists("b:netrw_method") || b:netrw_method < 0
"    call Dret("netrw#NetRead : unsupported method")
    return
   endif
   let tmpfile= s:GetTempfile(b:netrw_fname) " apply correct suffix

   " Check whether or not NetrwBrowse() should be handling this request
"   call Decho("checking if NetrwBrowse() should handle choice<".choice."> with netrw_list_cmd<".g:netrw_list_cmd.">",'~'.expand("<slnum>"))
   if choice =~ "^.*[\/]$" && b:netrw_method != 5 && choice !~ '^https\=://'
"    call Decho("yes, choice matches '^.*[\/]$'",'~'.expand("<slnum>"))
    NetrwKeepj call s:NetrwBrowse(0,choice)
"    call Dret("netrw#NetRead :3 getcwd<".getcwd().">")
    return
   endif

   " ============
   " NetRead: Perform Protocol-Based Read {{{3
   " ===========================
   if exists("g:netrw_silent") && g:netrw_silent == 0 && &ch >= 1
    echo "(netrw) Processing your read request..."
   endif

   ".........................................
   " NetRead: (rcp)  NetRead Method #1 {{{3
   if  b:netrw_method == 1 " read with rcp
"    call Decho("read via rcp (method #1)",'~'.expand("<slnum>"))
   " ER: nothing done with g:netrw_uid yet?
   " ER: on Win2K" rcp machine[.user]:file tmpfile
   " ER: when machine contains '.' adding .user is required (use $USERNAME)
   " ER: the tmpfile is full path: rcp sees C:\... as host C
   if s:netrw_has_nt_rcp == 1
    if exists("g:netrw_uid") &&	( g:netrw_uid != "" )
     let uid_machine = g:netrw_machine .'.'. g:netrw_uid
    else
     " Any way needed it machine contains a '.'
     let uid_machine = g:netrw_machine .'.'. $USERNAME
    endif
   else
    if exists("g:netrw_uid") &&	( g:netrw_uid != "" )
     let uid_machine = g:netrw_uid .'@'. g:netrw_machine
    else
     let uid_machine = g:netrw_machine
    endif
   endif
   call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_rcp_cmd." ".s:netrw_rcpmode." ".s:ShellEscape(uid_machine.":".b:netrw_fname,1)." ".s:ShellEscape(tmpfile,1))
   let result           = s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)
   let b:netrw_lastfile = choice

   ".........................................
   " NetRead: (ftp + <.netrc>)  NetRead Method #2 {{{3
   elseif b:netrw_method  == 2		" read with ftp + <.netrc>
"     call Decho("read via ftp+.netrc (method #2)",'~'.expand("<slnum>"))
     let netrw_fname= b:netrw_fname
     NetrwKeepj call s:SaveBufVars()|new|NetrwKeepj call s:RestoreBufVars()
     let filtbuf= bufnr("%")
     setl ff=unix
     NetrwKeepj put =g:netrw_ftpmode
"     call Decho("filter input: ".getline(line("$")),'~'.expand("<slnum>"))
     if exists("g:netrw_ftpextracmd")
      NetrwKeepj put =g:netrw_ftpextracmd
"      call Decho("filter input: ".getline(line("$")),'~'.expand("<slnum>"))
     endif
     call setline(line("$")+1,'get "'.netrw_fname.'" '.tmpfile)
"     call Decho("filter input: ".getline(line("$")),'~'.expand("<slnum>"))
     if exists("g:netrw_port") && g:netrw_port != ""
      call s:NetrwExe(s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".s:ShellEscape(g:netrw_machine,1)." ".s:ShellEscape(g:netrw_port,1))
     else
      call s:NetrwExe(s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".s:ShellEscape(g:netrw_machine,1))
     endif
     " If the result of the ftp operation isn't blank, show an error message (tnx to Doug Claar)
     if getline(1) !~ "^$" && !exists("g:netrw_quiet") && getline(1) !~ '^Trying '
      let debugkeep = &debug
      setl debug=msg
      NetrwKeepj call netrw#ErrorMsg(s:ERROR,getline(1),4)
      let &debug    = debugkeep
     endif
     call s:SaveBufVars()
     keepj bd!
     if bufname("%") == "" && getline("$") == "" && line('$') == 1
      " needed when one sources a file in a nolbl setting window via ftp
      q!
     endif
     call s:RestoreBufVars()
     let result           = s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)
     let b:netrw_lastfile = choice

   ".........................................
   " NetRead: (ftp + machine,id,passwd,filename)  NetRead Method #3 {{{3
   elseif b:netrw_method == 3		" read with ftp + machine, id, passwd, and fname
    " Construct execution string (four lines) which will be passed through filter
"    call Decho("read via ftp+mipf (method #3)",'~'.expand("<slnum>"))
    let netrw_fname= escape(b:netrw_fname,g:netrw_fname_escape)
    NetrwKeepj call s:SaveBufVars()|new|NetrwKeepj call s:RestoreBufVars()
    let filtbuf= bufnr("%")
    setl ff=unix
    if exists("g:netrw_port") && g:netrw_port != ""
     NetrwKeepj put ='open '.g:netrw_machine.' '.g:netrw_port
"     call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
    else
     NetrwKeepj put ='open '.g:netrw_machine
"     call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
    endif

    if exists("g:netrw_uid") && g:netrw_uid != ""
     if exists("g:netrw_ftp") && g:netrw_ftp == 1
      NetrwKeepj put =g:netrw_uid
"       call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
      if exists("s:netrw_passwd")
       NetrwKeepj put ='\"'.s:netrw_passwd.'\"'
      endif
"      call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
     elseif exists("s:netrw_passwd")
      NetrwKeepj put ='user \"'.g:netrw_uid.'\" \"'.s:netrw_passwd.'\"'
"      call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
     endif
    endif

    if exists("g:netrw_ftpmode") && g:netrw_ftpmode != ""
     NetrwKeepj put =g:netrw_ftpmode
"     call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
    endif
    if exists("g:netrw_ftpextracmd")
     NetrwKeepj put =g:netrw_ftpextracmd
"     call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
    endif
    NetrwKeepj put ='get \"'.netrw_fname.'\" '.tmpfile
"    call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))

    " perform ftp:
    " -i       : turns off interactive prompting from ftp
    " -n  unix : DON'T use <.netrc>, even though it exists
    " -n  win32: quit being obnoxious about password
    NetrwKeepj norm! 1G"_dd
    call s:NetrwExe(s:netrw_silentxfer."%!".s:netrw_ftp_cmd." ".g:netrw_ftp_options)
    " If the result of the ftp operation isn't blank, show an error message (tnx to Doug Claar)
    if getline(1) !~ "^$"
"     call Decho("error<".getline(1).">",'~'.expand("<slnum>"))
     if !exists("g:netrw_quiet")
      call netrw#ErrorMsg(s:ERROR,getline(1),5)
     endif
    endif
    call s:SaveBufVars()|keepj bd!|call s:RestoreBufVars()
    let result           = s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)
    let b:netrw_lastfile = choice

   ".........................................
   " NetRead: (scp) NetRead Method #4 {{{3
   elseif     b:netrw_method  == 4	" read with scp
"    call Decho("read via scp (method #4)",'~'.expand("<slnum>"))
    if exists("g:netrw_port") && g:netrw_port != ""
     let useport= " ".g:netrw_scpport." ".g:netrw_port
    else
     let useport= ""
    endif
    " 'C' in 'C:\path\to\file' is handled as hostname on windows.
    " This is workaround to avoid mis-handle windows local-path:
    if g:netrw_scp_cmd =~ '^scp' && (has("win32") || has("win95") || has("win64") || has("win16"))
      let tmpfile_get = substitute(tr(tmpfile, '\', '/'), '^\(\a\):[/\\]\(.*\)$', '/\1/\2', '')
    else
      let tmpfile_get = tmpfile
    endif
    call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_scp_cmd.useport." ".escape(s:ShellEscape(g:netrw_machine.":".b:netrw_fname,1),' ')." ".s:ShellEscape(tmpfile_get,1))
    let result           = s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)
    let b:netrw_lastfile = choice

   ".........................................
   " NetRead: (http) NetRead Method #5 (wget) {{{3
   elseif     b:netrw_method  == 5
"    call Decho("read via http (method #5)",'~'.expand("<slnum>"))
    if g:netrw_http_cmd == ""
     if !exists("g:netrw_quiet")
      call netrw#ErrorMsg(s:ERROR,"neither the wget nor the fetch command is available",6)
     endif
"     call Dret("netrw#NetRead :4 getcwd<".getcwd().">")
     return
    endif

    if match(b:netrw_fname,"#") == -1 || exists("g:netrw_http_xcmd")
     " using g:netrw_http_cmd (usually elinks, links, curl, wget, or fetch)
"     call Decho('using '.g:netrw_http_cmd.' (# not in b:netrw_fname<'.b:netrw_fname.">)",'~'.expand("<slnum>"))
     if exists("g:netrw_http_xcmd")
      call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_http_cmd." ".s:ShellEscape(b:netrw_http."://".g:netrw_machine.b:netrw_fname,1)." ".g:netrw_http_xcmd." ".s:ShellEscape(tmpfile,1))
     else
      call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_http_cmd." ".s:ShellEscape(tmpfile,1)." ".s:ShellEscape(b:netrw_http."://".g:netrw_machine.b:netrw_fname,1))
     endif
     let result = s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)

    else
     " wget/curl/fetch plus a jump to an in-page marker (ie. http://abc/def.html#aMarker)
"     call Decho("wget/curl plus jump (# in b:netrw_fname<".b:netrw_fname.">)",'~'.expand("<slnum>"))
     let netrw_html= substitute(b:netrw_fname,"#.*$","","")
     let netrw_tag = substitute(b:netrw_fname,"^.*#","","")
"     call Decho("netrw_html<".netrw_html.">",'~'.expand("<slnum>"))
"     call Decho("netrw_tag <".netrw_tag.">",'~'.expand("<slnum>"))
     call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_http_cmd." ".s:ShellEscape(tmpfile,1)." ".s:ShellEscape(b:netrw_http."://".g:netrw_machine.netrw_html,1))
     let result = s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)
"     call Decho('<\s*a\s*name=\s*"'.netrw_tag.'"/','~'.expand("<slnum>"))
     exe 'NetrwKeepj norm! 1G/<\s*a\s*name=\s*"'.netrw_tag.'"/'."\<CR>"
    endif
    let b:netrw_lastfile = choice
"    call Decho("setl ro",'~'.expand("<slnum>"))
    setl ro nomod

   ".........................................
   " NetRead: (dav) NetRead Method #6 {{{3
   elseif     b:netrw_method  == 6
"    call Decho("read via cadaver (method #6)",'~'.expand("<slnum>"))

    if !executable(g:netrw_dav_cmd)
     call netrw#ErrorMsg(s:ERROR,g:netrw_dav_cmd." is not executable",73)
"     call Dret("netrw#NetRead : ".g:netrw_dav_cmd." not executable")
     return
    endif
    if g:netrw_dav_cmd =~ "curl"
     call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_dav_cmd." ".s:ShellEscape("dav://".g:netrw_machine.b:netrw_fname,1)." ".s:ShellEscape(tmpfile,1))
    else
     " Construct execution string (four lines) which will be passed through filter
     let netrw_fname= escape(b:netrw_fname,g:netrw_fname_escape)
     new
     setl ff=unix
     if exists("g:netrw_port") && g:netrw_port != ""
      NetrwKeepj put ='open '.g:netrw_machine.' '.g:netrw_port
     else
      NetrwKeepj put ='open '.g:netrw_machine
     endif
     if exists("g:netrw_uid") && exists("s:netrw_passwd") && g:netrw_uid != ""
      NetrwKeepj put ='user '.g:netrw_uid.' '.s:netrw_passwd
     endif
     NetrwKeepj put ='get '.netrw_fname.' '.tmpfile
     NetrwKeepj put ='quit'

     " perform cadaver operation:
     NetrwKeepj norm! 1G"_dd
     call s:NetrwExe(s:netrw_silentxfer."%!".g:netrw_dav_cmd)
     keepj bd!
    endif
    let result           = s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)
    let b:netrw_lastfile = choice

   ".........................................
   " NetRead: (rsync) NetRead Method #7 {{{3
   elseif     b:netrw_method  == 7
"    call Decho("read via rsync (method #7)",'~'.expand("<slnum>"))
    call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_rsync_cmd." ".s:ShellEscape(g:netrw_machine.g:netrw_rsync_sep.b:netrw_fname,1)." ".s:ShellEscape(tmpfile,1))
    let result		 = s:NetrwGetFile(readcmd,tmpfile, b:netrw_method)
    let b:netrw_lastfile = choice

   ".........................................
   " NetRead: (fetch) NetRead Method #8 {{{3
   "    fetch://[user@]host[:http]/path
   elseif     b:netrw_method  == 8
"    call Decho("read via fetch (method #8)",'~'.expand("<slnum>"))
    if g:netrw_fetch_cmd == ""
     if !exists("g:netrw_quiet")
      NetrwKeepj call netrw#ErrorMsg(s:ERROR,"fetch command not available",7)
     endif
"     call Dret("NetRead")
     return
    endif
    if exists("g:netrw_option") && g:netrw_option =~ ":https\="
     let netrw_option= "http"
    else
     let netrw_option= "ftp"
    endif
"    call Decho("read via fetch for ".netrw_option,'~'.expand("<slnum>"))

    if exists("g:netrw_uid") && g:netrw_uid != "" && exists("s:netrw_passwd") && s:netrw_passwd != ""
     call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_fetch_cmd." ".s:ShellEscape(tmpfile,1)." ".s:ShellEscape(netrw_option."://".g:netrw_uid.':'.s:netrw_passwd.'@'.g:netrw_machine."/".b:netrw_fname,1))
    else
     call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_fetch_cmd." ".s:ShellEscape(tmpfile,1)." ".s:ShellEscape(netrw_option."://".g:netrw_machine."/".b:netrw_fname,1))
    endif

    let result		= s:NetrwGetFile(readcmd,tmpfile, b:netrw_method)
    let b:netrw_lastfile = choice
"    call Decho("setl ro",'~'.expand("<slnum>"))
    setl ro nomod

   ".........................................
   " NetRead: (sftp) NetRead Method #9 {{{3
   elseif     b:netrw_method  == 9
"    call Decho("read via sftp (method #9)",'~'.expand("<slnum>"))
    call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_sftp_cmd." ".s:ShellEscape(g:netrw_machine.":".b:netrw_fname,1)." ".tmpfile)
    let result		= s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)
    let b:netrw_lastfile = choice

   ".........................................
   " NetRead: (file) NetRead Method #10 {{{3
  elseif      b:netrw_method == 10 && exists("g:netrw_file_cmd")
"   "    call Decho("read via ".b:netrw_file_cmd." (method #10)",'~'.expand("<slnum>"))
   call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_file_cmd." ".s:ShellEscape(b:netrw_fname,1)." ".tmpfile)
   let result		= s:NetrwGetFile(readcmd, tmpfile, b:netrw_method)
   let b:netrw_lastfile = choice

   ".........................................
   " NetRead: Complain {{{3
   else
    call netrw#ErrorMsg(s:WARNING,"unable to comply with your request<" . choice . ">",8)
   endif
  endwhile

  " NetRead: cleanup {{{3
  if exists("b:netrw_method")
"   call Decho("cleanup b:netrw_method and b:netrw_fname",'~'.expand("<slnum>"))
   unlet b:netrw_method
   unlet b:netrw_fname
  endif
  if s:FileReadable(tmpfile) && tmpfile !~ '.tar.bz2$' && tmpfile !~ '.tar.gz$' && tmpfile !~ '.zip' && tmpfile !~ '.tar' && readcmd != 't' && tmpfile !~ '.tar.xz$' && tmpfile !~ '.txz'
"   call Decho("cleanup by deleting tmpfile<".tmpfile.">",'~'.expand("<slnum>"))
   NetrwKeepj call s:NetrwDelete(tmpfile)
  endif
  NetrwKeepj call s:NetrwOptionsRestore("w:")

"  call Dret("netrw#NetRead :5 getcwd<".getcwd().">")
endfun

" ------------------------------------------------------------------------
" netrw#NetWrite: responsible for writing a file over the net {{{2
fun! netrw#NetWrite(...) range
"  call Dfunc("netrw#NetWrite(a:0=".a:0.") ".g:loaded_netrw)

  " NetWrite: option handling {{{3
  let mod= 0
  call s:NetrwOptionsSave("w:")
  call s:NetrwOptionsSafe(0)

  " NetWrite: Get Temporary Filename {{{3
  let tmpfile= s:GetTempfile("")
  if tmpfile == ""
"   call Dret("netrw#NetWrite : unable to get a tempfile!")
   return
  endif

  if a:0 == 0
   let ichoice = 0
  else
   let ichoice = 1
  endif

  let curbufname= expand("%")
"  call Decho("curbufname<".curbufname.">",'~'.expand("<slnum>"))
  if &binary
   " For binary writes, always write entire file.
   " (line numbers don't really make sense for that).
   " Also supports the writing of tar and zip files.
"   call Decho("(write entire file) sil exe w! ".fnameescape(v:cmdarg)." ".fnameescape(tmpfile),'~'.expand("<slnum>"))
   exe "sil NetrwKeepj w! ".fnameescape(v:cmdarg)." ".fnameescape(tmpfile)
  elseif g:netrw_cygwin
   " write (selected portion of) file to temporary
   let cygtmpfile= substitute(tmpfile,g:netrw_cygdrive.'/\(.\)','\1:','')
"   call Decho("(write selected portion) sil exe ".a:firstline."," . a:lastline . "w! ".fnameescape(v:cmdarg)." ".fnameescape(cygtmpfile),'~'.expand("<slnum>"))
   exe "sil NetrwKeepj ".a:firstline."," . a:lastline . "w! ".fnameescape(v:cmdarg)." ".fnameescape(cygtmpfile)
  else
   " write (selected portion of) file to temporary
"   call Decho("(write selected portion) sil exe ".a:firstline."," . a:lastline . "w! ".fnameescape(v:cmdarg)." ".fnameescape(tmpfile),'~'.expand("<slnum>"))
   exe "sil NetrwKeepj ".a:firstline."," . a:lastline . "w! ".fnameescape(v:cmdarg)." ".fnameescape(tmpfile)
  endif

  if curbufname == ""
   " when the file is [No Name], and one attempts to Nwrite it, the buffer takes
   " on the temporary file's name.  Deletion of the temporary file during
   " cleanup then causes an error message.
   0file!
  endif

  " NetWrite: while choice loop: {{{3
  while ichoice <= a:0

   " Process arguments: {{{4
   " attempt to repeat with previous host-file-etc
   if exists("b:netrw_lastfile") && a:0 == 0
"    call Decho("using b:netrw_lastfile<" . b:netrw_lastfile . ">",'~'.expand("<slnum>"))
    let choice = b:netrw_lastfile
    let ichoice= ichoice + 1
   else
    exe "let choice= a:" . ichoice

    " Reconstruct Choice when choice starts with '"'
    if match(choice,"?") == 0
     echomsg 'NetWrite Usage:"'
     echomsg ':Nwrite machine:path                        uses rcp'
     echomsg ':Nwrite "machine path"                      uses ftp with <.netrc>'
     echomsg ':Nwrite "machine id password path"          uses ftp'
     echomsg ':Nwrite dav://[user@]machine/path           uses cadaver'
     echomsg ':Nwrite fetch://[user@]machine/path         uses fetch'
     echomsg ':Nwrite ftp://machine[#port]/path           uses ftp  (autodetects <.netrc>)'
     echomsg ':Nwrite rcp://machine/path                  uses rcp'
     echomsg ':Nwrite rsync://[user@]machine/path         uses rsync'
     echomsg ':Nwrite scp://[user@]machine[[:#]port]/path uses scp'
     echomsg ':Nwrite sftp://[user@]machine/path          uses sftp'
     sleep 4
     break

    elseif match(choice,"^\"") != -1
     if match(choice,"\"$") != -1
       " case "..."
      let choice=strpart(choice,1,strlen(choice)-2)
     else
      "  case "... ... ..."
      let choice      = strpart(choice,1,strlen(choice)-1)
      let wholechoice = ""

      while match(choice,"\"$") == -1
       let wholechoice= wholechoice . " " . choice
       let ichoice    = ichoice + 1
       if choice > a:0
       	if !exists("g:netrw_quiet")
	 call netrw#ErrorMsg(s:ERROR,"Unbalanced string in filename '". wholechoice ."'",13)
	endif
"        call Dret("netrw#NetWrite")
        return
       endif
       let choice= a:{ichoice}
      endwhile
      let choice= strpart(wholechoice,1,strlen(wholechoice)-1) . " " . strpart(choice,0,strlen(choice)-1)
     endif
    endif
   endif
   let ichoice= ichoice + 1
"   call Decho("choice<" . choice . "> ichoice=".ichoice,'~'.expand("<slnum>"))

   " Determine method of write (ftp, rcp, etc) {{{4
   NetrwKeepj call s:NetrwMethod(choice)
   if !exists("b:netrw_method") || b:netrw_method < 0
"    call Dfunc("netrw#NetWrite : unsupported method")
    return
   endif

   " =============
   " NetWrite: Perform Protocol-Based Write {{{3
   " ============================
   if exists("g:netrw_silent") && g:netrw_silent == 0 && &ch >= 1
    echo "(netrw) Processing your write request..."
"    call Decho("Processing your write request...",'~'.expand("<slnum>"))
   endif

   ".........................................
   " NetWrite: (rcp) NetWrite Method #1 {{{3
   if  b:netrw_method == 1
"    call Decho("write via rcp (method #1)",'~'.expand("<slnum>"))
    if s:netrw_has_nt_rcp == 1
     if exists("g:netrw_uid") &&  ( g:netrw_uid != "" )
      let uid_machine = g:netrw_machine .'.'. g:netrw_uid
     else
      let uid_machine = g:netrw_machine .'.'. $USERNAME
     endif
    else
     if exists("g:netrw_uid") &&  ( g:netrw_uid != "" )
      let uid_machine = g:netrw_uid .'@'. g:netrw_machine
     else
      let uid_machine = g:netrw_machine
     endif
    endif
    call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_rcp_cmd." ".s:netrw_rcpmode." ".s:ShellEscape(tmpfile,1)." ".s:ShellEscape(uid_machine.":".b:netrw_fname,1))
    let b:netrw_lastfile = choice

   ".........................................
   " NetWrite: (ftp + <.netrc>) NetWrite Method #2 {{{3
   elseif b:netrw_method == 2
"    call Decho("write via ftp+.netrc (method #2)",'~'.expand("<slnum>"))
    let netrw_fname = b:netrw_fname

    " formerly just a "new...bd!", that changed the window sizes when equalalways.  Using enew workaround instead
    let bhkeep      = &l:bh
    let curbuf      = bufnr("%")
    setl bh=hide
    keepj keepalt enew

"    call Decho("filter input window#".winnr(),'~'.expand("<slnum>"))
    setl ff=unix
    NetrwKeepj put =g:netrw_ftpmode
"    call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
    if exists("g:netrw_ftpextracmd")
     NetrwKeepj put =g:netrw_ftpextracmd
"     call Decho("filter input: ".getline("$"),'~'.expand("<slnum>"))
    endif
    NetrwKeepj call setline(line("$")+1,'put "'.tmpfile.'" "'.netrw_fname.'"')
"    call Decho("filter input: ".getline("$"),'~'.expand("<slnum>"))
    if exists("g:netrw_port") && g:netrw_port != ""
     call s:NetrwExe(s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".s:ShellEscape(g:netrw_machine,1)." ".s:ShellEscape(g:netrw_port,1))
    else
"     call Decho("filter input window#".winnr(),'~'.expand("<slnum>"))
     call s:NetrwExe(s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".s:ShellEscape(g:netrw_machine,1))
    endif
    " If the result of the ftp operation isn't blank, show an error message (tnx to Doug Claar)
    if getline(1) !~ "^$"
     if !exists("g:netrw_quiet")
      NetrwKeepj call netrw#ErrorMsg(s:ERROR,getline(1),14)
     endif
     let mod=1
    endif

    " remove enew buffer (quietly)
    let filtbuf= bufnr("%")
    exe curbuf."b!"
    let &l:bh            = bhkeep
    exe filtbuf."bw!"

    let b:netrw_lastfile = choice

   ".........................................
   " NetWrite: (ftp + machine, id, passwd, filename) NetWrite Method #3 {{{3
   elseif b:netrw_method == 3
    " Construct execution string (three or more lines) which will be passed through filter
"    call Decho("read via ftp+mipf (method #3)",'~'.expand("<slnum>"))
    let netrw_fname = b:netrw_fname
    let bhkeep      = &l:bh

    " formerly just a "new...bd!", that changed the window sizes when equalalways.  Using enew workaround instead
    let curbuf      = bufnr("%")
    setl bh=hide
    keepj keepalt enew
    setl ff=unix

    if exists("g:netrw_port") && g:netrw_port != ""
     NetrwKeepj put ='open '.g:netrw_machine.' '.g:netrw_port
"     call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
    else
     NetrwKeepj put ='open '.g:netrw_machine
"     call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
    endif
    if exists("g:netrw_uid") && g:netrw_uid != ""
     if exists("g:netrw_ftp") && g:netrw_ftp == 1
      NetrwKeepj put =g:netrw_uid
"      call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
      if exists("s:netrw_passwd") && s:netrw_passwd != ""
       NetrwKeepj put ='\"'.s:netrw_passwd.'\"'
      endif
"      call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
     elseif exists("s:netrw_passwd") && s:netrw_passwd != ""
      NetrwKeepj put ='user \"'.g:netrw_uid.'\" \"'.s:netrw_passwd.'\"'
"      call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
     endif
    endif
    NetrwKeepj put =g:netrw_ftpmode
"    call Decho("filter input: ".getline('$'),'~'.expand("<slnum>"))
    if exists("g:netrw_ftpextracmd")
     NetrwKeepj put =g:netrw_ftpextracmd
"     call Decho("filter input: ".getline("$"),'~'.expand("<slnum>"))
    endif
    NetrwKeepj put ='put \"'.tmpfile.'\" \"'.netrw_fname.'\"'
"    call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
    " save choice/id/password for future use
    let b:netrw_lastfile = choice

    " perform ftp:
    " -i       : turns off interactive prompting from ftp
    " -n  unix : DON'T use <.netrc>, even though it exists
    " -n  win32: quit being obnoxious about password
    NetrwKeepj norm! 1G"_dd
    call s:NetrwExe(s:netrw_silentxfer."%!".s:netrw_ftp_cmd." ".g:netrw_ftp_options)
    " If the result of the ftp operation isn't blank, show an error message (tnx to Doug Claar)
    if getline(1) !~ "^$"
     if  !exists("g:netrw_quiet")
      call netrw#ErrorMsg(s:ERROR,getline(1),15)
     endif
     let mod=1
    endif

    " remove enew buffer (quietly)
    let filtbuf= bufnr("%")
    exe curbuf."b!"
    let &l:bh= bhkeep
    exe filtbuf."bw!"

   ".........................................
   " NetWrite: (scp) NetWrite Method #4 {{{3
   elseif     b:netrw_method == 4
"    call Decho("write via scp (method #4)",'~'.expand("<slnum>"))
    if exists("g:netrw_port") && g:netrw_port != ""
     let useport= " ".g:netrw_scpport." ".fnameescape(g:netrw_port)
    else
     let useport= ""
    endif
    call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_scp_cmd.useport." ".s:ShellEscape(tmpfile,1)." ".s:ShellEscape(g:netrw_machine.":".b:netrw_fname,1))
    let b:netrw_lastfile = choice

   ".........................................
   " NetWrite: (http) NetWrite Method #5 {{{3
   elseif     b:netrw_method == 5
"    call Decho("write via http (method #5)",'~'.expand("<slnum>"))
    let curl= substitute(g:netrw_http_put_cmd,'\s\+.*$',"","")
    if executable(curl)
     let url= g:netrw_choice
     call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_http_put_cmd." ".s:ShellEscape(tmpfile,1)." ".s:ShellEscape(url,1) )
    elseif !exists("g:netrw_quiet")
     call netrw#ErrorMsg(s:ERROR,"can't write to http using <".g:netrw_http_put_cmd.">".",16)
    endif

   ".........................................
   " NetWrite: (dav) NetWrite Method #6 (cadaver) {{{3
   elseif     b:netrw_method == 6
"    call Decho("write via cadaver (method #6)",'~'.expand("<slnum>"))

    " Construct execution string (four lines) which will be passed through filter
    let netrw_fname = escape(b:netrw_fname,g:netrw_fname_escape)
    let bhkeep      = &l:bh

    " formerly just a "new...bd!", that changed the window sizes when equalalways.  Using enew workaround instead
    let curbuf      = bufnr("%")
    setl bh=hide
    keepj keepalt enew

    setl ff=unix
    if exists("g:netrw_port") && g:netrw_port != ""
     NetrwKeepj put ='open '.g:netrw_machine.' '.g:netrw_port
    else
     NetrwKeepj put ='open '.g:netrw_machine
    endif
    if exists("g:netrw_uid") && exists("s:netrw_passwd") && g:netrw_uid != ""
     NetrwKeepj put ='user '.g:netrw_uid.' '.s:netrw_passwd
    endif
    NetrwKeepj put ='put '.tmpfile.' '.netrw_fname

    " perform cadaver operation:
    NetrwKeepj norm! 1G"_dd
    call s:NetrwExe(s:netrw_silentxfer."%!".g:netrw_dav_cmd)

    " remove enew buffer (quietly)
    let filtbuf= bufnr("%")
    exe curbuf."b!"
    let &l:bh            = bhkeep
    exe filtbuf."bw!"

    let b:netrw_lastfile = choice

   ".........................................
   " NetWrite: (rsync) NetWrite Method #7 {{{3
   elseif     b:netrw_method == 7
"    call Decho("write via rsync (method #7)",'~'.expand("<slnum>"))
    call s:NetrwExe(s:netrw_silentxfer."!".g:netrw_rsync_cmd." ".s:ShellEscape(tmpfile,1)." ".s:ShellEscape(g:netrw_machine.g:netrw_rsync_sep.b:netrw_fname,1))
    let b:netrw_lastfile = choice

   ".........................................
   " NetWrite: (sftp) NetWrite Method #9 {{{3
   elseif     b:netrw_method == 9
"    call Decho("write via sftp (method #9)",'~'.expand("<slnum>"))
    let netrw_fname= escape(b:netrw_fname,g:netrw_fname_escape)
    if exists("g:netrw_uid") &&  ( g:netrw_uid != "" )
     let uid_machine = g:netrw_uid .'@'. g:netrw_machine
    else
     let uid_machine = g:netrw_machine
    endif

    " formerly just a "new...bd!", that changed the window sizes when equalalways.  Using enew workaround instead
    let bhkeep = &l:bh
    let curbuf = bufnr("%")
    setl bh=hide
    keepj keepalt enew

    setl ff=unix
    call setline(1,'put "'.escape(tmpfile,'\').'" '.netrw_fname)
"    call Decho("filter input: ".getline('.'),'~'.expand("<slnum>"))
    let sftpcmd= substitute(g:netrw_sftp_cmd,"%TEMPFILE%",escape(tmpfile,'\'),"g")
    call s:NetrwExe(s:netrw_silentxfer."%!".sftpcmd.' '.s:ShellEscape(uid_machine,1))
    let filtbuf= bufnr("%")
    exe curbuf."b!"
    let &l:bh            = bhkeep
    exe filtbuf."bw!"
    let b:netrw_lastfile = choice

   ".........................................
   " NetWrite: Complain {{{3
   else
    call netrw#ErrorMsg(s:WARNING,"unable to comply with your request<" . choice . ">",17)
    let leavemod= 1
   endif
  endwhile

  " NetWrite: Cleanup: {{{3
"  call Decho("cleanup",'~'.expand("<slnum>"))
  if s:FileReadable(tmpfile)
"   call Decho("tmpfile<".tmpfile."> readable, will now delete it",'~'.expand("<slnum>"))
   call s:NetrwDelete(tmpfile)
  endif
  call s:NetrwOptionsRestore("w:")

  if a:firstline == 1 && a:lastline == line("$")
   " restore modifiability; usually equivalent to set nomod
   let &mod= mod
"   call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
  elseif !exists("leavemod")
   " indicate that the buffer has not been modified since last written
"   call Decho("set nomod",'~'.expand("<slnum>"))
   setl nomod
"   call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
  endif

"  call Dret("netrw#NetWrite")
endfun

" ---------------------------------------------------------------------
" netrw#NetSource: source a remotely hosted vim script {{{2
" uses NetRead to get a copy of the file into a temporarily file,
"              then sources that file,
"              then removes that file.
fun! netrw#NetSource(...)
"  call Dfunc("netrw#NetSource() a:0=".a:0)
  if a:0 > 0 && a:1 == '?'
   " give help
   echomsg 'NetSource Usage:'
   echomsg ':Nsource dav://machine[:port]/path            uses cadaver'
   echomsg ':Nsource fetch://machine/path                 uses fetch'
   echomsg ':Nsource ftp://[user@]machine[:port]/path     uses ftp   autodetects <.netrc>'
   echomsg ':Nsource http[s]://[user@]machine/path        uses http  wget'
   echomsg ':Nsource rcp://[user@]machine/path            uses rcp'
   echomsg ':Nsource rsync://machine[:port]/path          uses rsync'
   echomsg ':Nsource scp://[user@]machine[[:#]port]/path  uses scp'
   echomsg ':Nsource sftp://[user@]machine[[:#]port]/path uses sftp'
   sleep 4
  else
   let i= 1
   while i <= a:0
    call netrw#NetRead(3,a:{i})
"    call Decho("s:netread_tmpfile<".s:netrw_tmpfile.">",'~'.expand("<slnum>"))
    if s:FileReadable(s:netrw_tmpfile)
"     call Decho("exe so ".fnameescape(s:netrw_tmpfile),'~'.expand("<slnum>"))
     exe "so ".fnameescape(s:netrw_tmpfile)
"     call Decho("delete(".s:netrw_tmpfile.")",'~'.expand("<slnum>"))
     if delete(s:netrw_tmpfile)
      call netrw#ErrorMsg(s:ERROR,"unable to delete directory <".s:netrw_tmpfile.">!",103)
     endif
     unlet s:netrw_tmpfile
    else
     call netrw#ErrorMsg(s:ERROR,"unable to source <".a:{i}.">!",48)
    endif
    let i= i + 1
   endwhile
  endif
"  call Dret("netrw#NetSource")
endfun

" ---------------------------------------------------------------------
" netrw#SetTreetop: resets the tree top to the current directory/specified directory {{{2
"                   (implements the :Ntree command)
fun! netrw#SetTreetop(iscmd,...)
"  call Dfunc("netrw#SetTreetop(iscmd=".a:iscmd." ".((a:0 > 0)? a:1 : "").") a:0=".a:0)
"  call Decho("w:netrw_treetop<".w:netrw_treetop.">")

  " iscmd==0: netrw#SetTreetop called using gn mapping
  " iscmd==1: netrw#SetTreetop called using :Ntree from the command line
"  call Decho("(iscmd=".a:iscmd.": called using :Ntree from command line",'~'.expand("<slnum>"))
  " clear out the current tree
  if exists("w:netrw_treetop")
"   call Decho("clearing out current tree",'~'.expand("<slnum>"))
   let inittreetop= w:netrw_treetop
   unlet w:netrw_treetop
  endif
  if exists("w:netrw_treedict")
"   call Decho("freeing w:netrw_treedict",'~'.expand("<slnum>"))
   unlet w:netrw_treedict
  endif
"  call Decho("inittreetop<".(exists("inittreetop")? inittreetop : "n/a").">")

  if (a:iscmd == 0 || a:1 == "") && exists("inittreetop")
   let treedir         = s:NetrwTreePath(inittreetop)
"   call Decho("treedir<".treedir.">",'~'.expand("<slnum>"))
  else
   if isdirectory(s:NetrwFile(a:1))
"    call Decho("a:1<".a:1."> is a directory",'~'.expand("<slnum>"))
    let treedir         = a:1
    let s:netrw_treetop = treedir
   elseif exists("b:netrw_curdir") && (isdirectory(s:NetrwFile(b:netrw_curdir."/".a:1)) || a:1 =~ '^\a\{3,}://')
    let treedir         = b:netrw_curdir."/".a:1
    let s:netrw_treetop = treedir
"    call Decho("a:1<".a:1."> is NOT a directory, using treedir<".treedir.">",'~'.expand("<slnum>"))
   else
    " normally the cursor is left in the message window.
    " However, here this results in the directory being listed in the message window, which is not wanted.
    let netrwbuf= bufnr("%")
    call netrw#ErrorMsg(s:ERROR,"sorry, ".a:1." doesn't seem to be a directory!",95)
    exe bufwinnr(netrwbuf)."wincmd w"
    let treedir         = "."
    let s:netrw_treetop = getcwd()
   endif
  endif
"  call Decho("treedir<".treedir.">",'~'.expand("<slnum>"))

  " determine if treedir is remote or local
  let islocal= expand("%") !~ '^\a\{3,}://'
"  call Decho("islocal=".islocal,'~'.expand("<slnum>"))

  " browse the resulting directory
  if islocal
   call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(islocal,treedir))
  else
   call s:NetrwBrowse(islocal,s:NetrwBrowseChgDir(islocal,treedir))
  endif

"  call Dret("netrw#SetTreetop")
endfun

" ===========================================
" s:NetrwGetFile: Function to read temporary file "tfile" with command "readcmd". {{{2
"    readcmd == %r : replace buffer with newly read file
"            == 0r : read file at top of buffer
"            == r  : read file after current line
"            == t  : leave file in temporary form (ie. don't read into buffer)
fun! s:NetrwGetFile(readcmd, tfile, method)
"  call Dfunc("NetrwGetFile(readcmd<".a:readcmd.">,tfile<".a:tfile."> method<".a:method.">)")

  " readcmd=='t': simply do nothing
  if a:readcmd == 't'
"   call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
"   call Dret("NetrwGetFile : skip read of tfile<".a:tfile.">")
   return
  endif

  " get name of remote filename (ie. url and all)
  let rfile= bufname("%")
"  call Decho("rfile<".rfile.">",'~'.expand("<slnum>"))

  if exists("*NetReadFixup")
   " for the use of NetReadFixup (not otherwise used internally)
   let line2= line("$")
  endif

  if a:readcmd[0] == '%'
  " get file into buffer
"   call Decho("get file into buffer",'~'.expand("<slnum>"))

   " rename the current buffer to the temp file (ie. tfile)
   if g:netrw_cygwin
    let tfile= substitute(a:tfile,g:netrw_cygdrive.'/\(.\)','\1:','')
   else
    let tfile= a:tfile
   endif
   call s:NetrwBufRename(tfile)

   " edit temporary file (ie. read the temporary file in)
   if     rfile =~ '\.zip$'
"    call Decho("handling remote zip file with zip#Browse(tfile<".tfile.">)",'~'.expand("<slnum>"))
    call zip#Browse(tfile)
   elseif rfile =~ '\.tar$'
"    call Decho("handling remote tar file with tar#Browse(tfile<".tfile.">)",'~'.expand("<slnum>"))
    call tar#Browse(tfile)
   elseif rfile =~ '\.tar\.gz$'
"    call Decho("handling remote gzip-compressed tar file",'~'.expand("<slnum>"))
    call tar#Browse(tfile)
   elseif rfile =~ '\.tar\.bz2$'
"    call Decho("handling remote bz2-compressed tar file",'~'.expand("<slnum>"))
    call tar#Browse(tfile)
   elseif rfile =~ '\.tar\.xz$'
"    call Decho("handling remote xz-compressed tar file",