 "xx-small", "x-small", "small", "medium", "large", "x-large", "xx-large", "larger", "smaller", "sans-serif", "serif", "monospace", "cursive", "fantasy", "caption", "icon", "menu", "message-box", "small-caption", "status-bar"]
    elseif prop =~ '^\%(height\|width\)$'
      let values = ["auto", "border-box", "content-box", "max-content", "min-content", "available", "fit-content"]
    elseif prop =~ '^\%(left\|right\)$'
      let values = ["auto"]
    elseif prop == 'image-rendering'
      let values = ["auto", "crisp-edges", "pixelated"]
    elseif prop == 'image-orientation'
      let values = ["from-image", "flip"]
    elseif prop == 'ime-mode'
      let values = ["auto", "normal", "active", "inactive", "disabled"]
    elseif prop == 'inline-size'
      let values = ["auto", "border-box", "content-box", "max-content", "min-content", "available", "fit-content"]
    elseif prop == 'isolation'
      let values = ["auto", "isolate"]
    elseif prop == 'justify-content'
      let values = ["flex-start", "flex-end", "center", "space-between", "space-around"]
    elseif prop == 'letter-spacing'
      let values = ["normal"]
    elseif prop == 'line-break'
      let values = ["auto", "loose", "normal", "strict"]
    elseif prop == 'line-height'
      let values = ["normal"]
    elseif prop == 'list-style-image'
      let values = ["url(", "none"]
    elseif prop == 'list-style-position'
      let values = ["inside", "outside"]
    elseif prop == 'list-style-type'
      let values = list_style_type_values
    elseif prop == 'list-style'
      let values = list_style_type_values + ["inside", "outside"] + ["url(", "none"]
    elseif prop == 'margin'
      let values = ["auto"]
    elseif prop =~ 'margin-\%(right\|left\|top\|bottom\|block-start\|block-end\|inline-start\|inline-end\)$'
      let values = ["auto"]
    elseif prop == 'marks'
      let values = ["crop", "cross", "none"]
    elseif prop == 'mask'
      let values = ["url("]
    elseif prop == 'mask-type'
      let values = ["luminance", "alpha"]
    elseif prop == '\%(max\|min\)-\%(block\|inline\)-size'
      let values = ["auto", "border-box", "content-box", "max-content", "min-content", "available", "fit-content"]
    elseif prop == '\%(max\|min\)-\%(height\|width\)'
      let values = ["auto", "border-box", "content-box", "max-content", "min-content", "available", "fit-content"]
    elseif prop == '\%(max\|min\)-zoom'
      let values = ["auto"]
    elseif prop == 'mix-blend-mode'
      let values = ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"]
    elseif prop == 'opacity'
      let values = []
    elseif prop == 'orientation'
      let values = ["auto", "portrait", "landscape"]
    elseif prop == 'orphans'
      let values = []
    elseif prop == 'outline-offset'
      let values = []
    elseif prop == 'outline-color'
      let values = color_values
    elseif prop == 'outline-style'
      let values = ["none", "hidden", "dotted", "dashed", "solid", "double", "groove", "ridge", "inset", "outset"]
    elseif prop == 'outline-width'
      let values = ["thin", "thick", "medium"]
    elseif prop == 'outline'
      let vals = matchstr(line, '.*:\s*\zs.*')
      if vals =~ '^\%([a-zA-Z0-9,()#]\+\)\?$'
        let values = color_values
      elseif vals =~ '^[a-zA-Z0-9,()#]\+\s\+\%([a-zA-Z]\+\)\?$'
        let values = ["none", "hidden", "dotted", "dashed", "solid", "double", "groove", "ridge", "inset", "outset"]
      elseif vals =~ '^[a-zA-Z0-9,()#]\+\s\+[a-zA-Z]\+\s\+\%([a-zA-Z(]\+\)\?$'
        let values = ["thin", "thick", "medium"]
      else
        return []
      endif
    elseif prop == 'overflow-wrap'
      let values = ["normal", "break-word"]
    elseif prop =~ 'overflow\%(-x\|-y\)\='
      let values = ["visible", "hidden", "scroll", "auto"]
    elseif prop == 'pad'
      let values = []
    elseif prop == 'padding'
      let values = []
    elseif prop =~ 'padding-\%(top\|right\|bottom\|left\|inline-start\|inline-end\|block-start\|block-end\)$'
      let values = []
    elseif prop =~ 'page-break-\%(after\|before\)$'
      let values = ["auto", "always", "avoid", "left", "right", "recto", "verso"]
    elseif prop == 'page-break-inside'
      let values = ["auto", "avoid"]
    elseif prop =~ 'pause\%(-after\|-before\)\=$'
      let values = ["none", "x-weak", "weak", "medium", "strong", "x-strong"]
    elseif prop == 'perspective'
      let values = ["none"]
    elseif prop == 'perspective-origin'
      let values = ["top", "bottom", "left", "center", " right"]
    elseif prop == 'pointer-events'
      let values = ["auto", "none", "visiblePainted", "visibleFill", "visibleStroke", "visible", "painted", "fill", "stroke", "all"]
    elseif prop == 'position'
      let values = ["static", "relative", "absolute", "fixed", "sticky"]
    elseif prop == 'prefix'
      let values = []
    elseif prop == 'quotes'
      let values = ["none"]
    elseif prop == 'range'
      let values = ["auto", "infinite"]
    elseif prop == 'resize'
      let values = ["none", "both", "horizontal", "vertical"]
    elseif prop =~ 'rest\%(-after\|-before\)\=$'
      let values = ["none", "x-weak", "weak", "medium", "strong", "x-strong"]
    elseif prop == 'ruby-align'
      let values = ["start", "center", "space-between", "space-around"]
    elseif prop == 'ruby-merge'
      let values = ["separate", "collapse", "auto"]
    elseif prop == 'ruby-position'
      let values = ["over", "under", "inter-character"]
    elseif prop == 'scroll-behavior'
      let values = ["auto", "smooth"]
    elseif prop == 'scroll-snap-coordinate'
      let values = ["none"]
    elseif prop == 'scroll-snap-destination'
      return []
    elseif prop == 'scroll-snap-points-\%(x\|y\)$'
      let values = ["none", "repeat("]
    elseif prop == 'scroll-snap-type\%(-x\|-y\)\=$'
      let values = ["none", "mandatory", "proximity"]
    elseif prop == 'shape-image-threshold'
      let values = []
    elseif prop == 'shape-margin'
      let values = []
    elseif prop == 'shape-outside'
      let values = ["margin-box", "border-box", "padding-box", "content-box", 'inset(', 'circle(', 'ellipse(', 'polygon(', 'url(']
    elseif prop == 'speak'
      let values = ["auto", "none", "normal"]
    elseif prop == 'speak-as'
      let values = ["auto", "normal", "spell-out", "digits"]
    elseif prop == 'src'
      let values = ["url("]
    elseif prop == 'suffix'
      let values = []
    elseif prop == 'symbols'
      let values = []
    elseif prop == 'system'
      let vals = matchstr(line, '.*:\s*\zs.*')
      if vals =~ '^extends'
        let values = list_style_type_values
      else
        let values = ["cyclic", "numeric", "alphabetic", "symbolic", "additive", "fixed", "extends"]
      endif
    elseif prop == 'table-layout'
      let values = ["auto", "fixed"]
    elseif prop == 'tab-size'
      let values = []
    elseif prop == 'text-align'
      let values = ["start", "end", "left", "right", "center", "justify", "match-parent"]
    elseif prop == 'text-align-last'
      let values = ["auto", "start", "end", "left", "right", "center", "justify"]
    elseif prop == 'text-combine-upright'
      let values = ["none", "all", "digits"]
    elseif prop == 'text-decoration-line'
      let values = ["none", "underline", "overline", "line-through", "blink"]
    elseif prop == 'text-decoration-color'
      let values = color_values
    elseif prop == 'text-decoration-style'
      let values = ["solid", "double", "dotted", "dashed", "wavy"]
    elseif prop == 'text-decoration'
      let values = ["none", "underline", "overline", "line-through", "blink"] + ["solid", "double", "dotted", "dashed", "wavy"] + color_values
    elseif prop == 'text-emphasis-color'
      let values = color_values
    elseif prop == 'text-emphasis-position'
      let values = ["over", "under", "left", "right"]
    elseif prop == 'text-emphasis-style'
      let values = ["none", "filled", "open", "dot", "circle", "double-circle", "triangle", "sesame"]
    elseif prop == 'text-emphasis'
      let values = color_values + ["over", "under", "left", "right"] + ["none", "filled", "open", "dot", "circle", "double-circle", "triangle", "sesame"]
    elseif prop == 'text-indent'
      let values = ["hanging", "each-line"]
    elseif prop == 'text-orientation'
      let values = ["mixed", "upright", "sideways", "sideways-right", "use-glyph-orientation"]
    elseif prop == 'text-overflow'
      let values = ["clip", "ellipsis"]
    elseif prop == 'text-rendering'
      let values = ["auto", "optimizeSpeed", "optimizeLegibility", "geometricPrecision"]
    elseif prop == 'text-shadow'
      let values = color_values
    elseif prop == 'text-transform'
      let values = ["capitalize", "uppercase", "lowercase", "full-width", "none"]
    elseif prop == 'text-underline-position'
      let values = ["auto", "under", "left", "right"]
    elseif prop == 'touch-action'
      let values = ["auto", "none", "pan-x", "pan-y", "manipulation", "pan-left", "pan-right", "pan-top", "pan-down"]
    elseif prop == 'transform'
      let values = ["matrix(", "translate(", "translateX(", "translateY(", "scale(", "scaleX(", "scaleY(", "rotate(", "skew(", "skewX(", "skewY(", "matrix3d(", "translate3d(", "translateZ(", "scale3d(", "scaleZ(", "rotate3d(", "rotateX(", "rotateY(", "rotateZ(", "perspective("]
    elseif prop == 'transform-box'
      let values = ["border-box", "fill-box", "view-box"]
    elseif prop == 'transform-origin'
      let values = ["left", "center", "right", "top", "bottom"]
    elseif prop == 'transform-style'
      let values = ["flat", "preserve-3d"]
    elseif prop == 'top'
      let values = ["auto"]
    elseif prop == 'transition-property'
      let values = ["all", "none"] + s:values
    elseif prop == 'transition-duration'
      let values = []
    elseif prop == 'transition-delay'
      let values = []
    elseif prop == 'transition-timing-function'
      let values = timing_functions
    elseif prop == 'transition'
      let values = ["all", "none"] + s:values + timing_functions
    elseif prop == 'unicode-bidi'
      let values = ["normal", "embed", "isolate", "bidi-override", "isolate-override", "plaintext"]
    elseif prop == 'unicode-range'
      let values = ["U+"]
    elseif prop == 'user-zoom'
      let values = ["zoom", "fixed"]
    elseif prop == 'vertical-align'
      let values = ["baseline", "sub", "super", "top", "text-top", "middle", "bottom", "text-bottom"]
    elseif prop == 'visibility'
      let values = ["visible", "hidden", "collapse"]
    elseif prop == 'voice-volume'
      let values = ["silent", "x-soft", "soft", "medium", "loud", "x-loud"]
    elseif prop == 'voice-balance'
      let values = ["left", "center", "right", "leftwards", "rightwards"]
    elseif prop == 'voice-family'
      let values = []
    elseif prop == 'voice-rate'
      let values = ["normal", "x-slow", "slow", "medium", "fast", "x-fast"]
    elseif prop == 'voice-pitch'
      let values = ["absolute", "x-low", "low", "medium", "high", "x-high"]
    elseif prop == 'voice-range'
      let values = ["absolute", "x-low", "low", "medium", "high", "x-high"]
    elseif prop == 'voice-stress'
      let values = ["normal", "strong", "moderate", "none", "reduced "]
    elseif prop == 'voice-duration'
      let values = ["auto"]
    elseif prop == 'white-space'
      let values = ["normal", "pre", "nowrap", "pre-wrap", "pre-line"]
    elseif prop == 'widows'
      let values = []
    elseif prop == 'will-change'
      let values = ["auto", "scroll-position", "contents"] + s:values
    elseif prop == 'word-break'
      let values = ["normal", "break-all", "keep-all"]
    elseif prop == 'word-spacing'
      let values = ["normal"]
    elseif prop == 'word-wrap'
      let values = ["normal", "break-word"]
    elseif prop == 'writing-mode'
      let values = ["horizontal-tb", "vertical-rl", "vertical-lr", "sideways-rl", "sideways-lr"]
    elseif prop == 'z-index'
      let values = ["auto"]
    elseif prop == 'zoom'
      let values = ["auto"]
    else
      " If no property match it is possible we are outside of {} and
      " trying to complete pseudo-(class|element)
      let element = tolower(matchstr(line, '\zs[a-zA-Z1-6]*\ze:[^:[:space:]]\{-}$'))
      if stridx('a,abbr,address,area,article,aside,audio,b,base,bdi,bdo,bgsound,blockquote,body,br,button,canvas,caption,center,cite,code,col,colgroup,command,content,data,datalist,dd,del,details,dfn,dialog,div,dl,dt,element,em,embed,fieldset,figcaption,figure,font,footer,form,frame,frameset,head,header,hgroup,hr,html,i,iframe,image,img,input,ins,isindex,kbd,keygen,label,legend,li,link,main,map,mark,menu,menuitem,meta,meter,nav,nobr,noframes,noscript,object,ol,optgroup,option,output,p,param,picture,pre,progress,q,rp,rt,rtc,ruby,s,samp,script,section,select,shadow,small,source,span,strong,style,sub,summary,sup,table,tbody,td,template,textarea,tfoot,th,thead,time,title,tr,track,u,ul,var,video,wbr', ','.element.',') > -1
        let values = ["active", "any", "checked", "default", "dir(", "disabled", "empty", "enabled", "first", "first-child", "first-of-type", "fullscreen", "focus", "hover", "indeterminate", "in-range", "invalid", "lang(", "last-child", "last-of-type", "left", "link", "not(", "nth-child(", "nth-last-child(", "nth-last-of-type(", "nth-of-type(", "only-child", "only-of-type", "optional", "out-of-range", "read-only", "read-write", "required", "right", "root", "scope", "target", "valid", "visited", "first-line", "first-letter", "before", "after", "selection", "backdrop"]
      else
        return []
      endif
    endif

    let values = wide_keywords + values
    " Complete values
    let entered_value = matchstr(line, '.\{-}\zs[a-zA-Z0-9#,.(_-]*$')

    for m in values
      if m =~? '^'.entered_value
        call add(res, m)
      elseif m =~? entered_value
        call add(res2, m)
      endif
    endfor

    return res + res2

  elseif borders[max(keys(borders))] == 'closebrace'

    return []

  elseif borders[max(keys(borders))] == 'exclam'

    " Complete values
    let entered_imp = matchstr(line, '.\{-}!\s*\zs[a-zA-Z ]*$')

    let values = ["important"]

    for m in values
      if m =~? '^'.entered_imp
        call add(res, m)
      endif
    endfor

    return res

  elseif borders[max(keys(borders))] == 'atrule'

    let afterat = matchstr(line, '.*@\zs.*')

    if afterat =~ '\s'

      let atrulename = matchstr(line, '.*@\zs[a-zA-Z-]\+\ze')

      if atrulename == 'media'
        let entered_atruleafter = matchstr(line, '.*@media\s\+\zs.*$')

        if entered_atruleafter =~ "([^)]*$"
          let entered_atruleafter = matchstr(entered_atruleafter, '(\s*\zs[^)]*$')
          let values = ["max-width", "min-width", "width", "max-height", "min-height", "height", "max-aspect-ration", "min-aspect-ration", "aspect-ratio", "orientation", "max-resolution", "min-resolution", "resolution", "scan", "grid", "update-frequency", "overflow-block", "overflow-inline", "max-color", "min-color", "color", "max-color-index", "min-color-index", "color-index", "monochrome", "inverted-colors", "pointer", "hover", "any-pointer", "any-hover", "light-level", "scripting"]
        else
          let values = ["screen", "print", "speech", "all", "not", "and", "("]
        endif

      elseif atrulename == 'supports'
        let entered_atruleafter = matchstr(line, '.*@supports\s\+\zs.*$')

        if entered_atruleafter =~ "([^)]*$"
          let entered_atruleafter = matchstr(entered_atruleafter, '(\s*\zs.*$')
          let values = s:values
        else
          let values = ["("]
        endif

      elseif atrulename == 'charset'
        let entered_atruleafter = matchstr(line, '.*@charset\s\+\zs.*$')
        let values = [
          \ '"UTF-8";', '"ANSI_X3.4-1968";', '"ISO_8859-1:1987";', '"ISO_8859-2:1987";', '"ISO_8859-3:1988";', '"ISO_8859-4:1988";', '"ISO_8859-5:1988";', 
          \ '"ISO_8859-6:1987";', '"ISO_8859-7:1987";', '"ISO_8859-8:1988";', '"ISO_8859-9:1989";', '"ISO-8859-10";', '"ISO_6937-2-add";', '"JIS_X0201";', 
          \ '"JIS_Encoding";', '"Shift_JIS";', '"Extended_UNIX_Code_Packed_Format_for_Japanese";', '"Extended_UNIX_Code_Fixed_Width_for_Japanese";',
          \ '"BS_4730";', '"SEN_850200_C";', '"IT";', '"ES";', '"DIN_66003";', '"NS_4551-1";', '"NF_Z_62-010";', '"ISO-10646-UTF-1";', '"ISO_646.basic:1983";',
          \ '"INVARIANT";', '"ISO_646.irv:1983";', '"NATS-SEFI";', '"NATS-SEFI-ADD";', '"NATS-DANO";', '"NATS-DANO-ADD";', '"SEN_850200_B";', '"KS_C_5601-1987";',
          \ '"ISO-2022-KR";', '"EUC-KR";', '"ISO-2022-JP";', '"ISO-2022-JP-2";', '"JIS_C6220-1969-jp";', '"JIS_C6220-1969-ro";', '"PT";', '"greek7-old";', 
          \ '"latin-greek";', '"NF_Z_62-010_(1973)";', '"Latin-greek-1";', '"ISO_5427";', '"JIS_C6226-1978";', '"BS_viewdata";', '"INIS";', '"INIS-8";', 
          \ '"INIS-cyrillic";', '"ISO_5427:1981";', '"ISO_5428:1980";', '"GB_1988-80";', '"GB_2312-80";', '"NS_4551-2";', '"videotex-suppl";', '"PT2";', 
          \ '"ES2";', '"MSZ_7795.3";', '"JIS_C6226-1983";', '"greek7";', '"ASMO_449";', '"iso-ir-90";', '"JIS_C6229-1984-a";', '"JIS_C6229-1984-b";', 
          \ '"JIS_C6229-1984-b-add";', '"JIS_C6229-1984-hand";', '"JIS_C6229-1984-hand-add";', '"JIS_C6229-1984-kana";', '"ISO_2033-1983";', 
          \ '"ANSI_X3.110-1983";', '"T.61-7bit";', '"T.61-8bit";', '"ECMA-cyrillic";', '"CSA_Z243.4-1985-1";', '"CSA_Z243.4-1985-2";', '"CSA_Z243.4-1985-gr";', 
          \ '"ISO_8859-6-E";', '"ISO_8859-6-I";', '"T.101-G2";', '"ISO_8859-8-E";', '"ISO_8859-8-I";', '"CSN_369103";', '"JUS_I.B1.002";', '"IEC_P27-1";', 
          \ '"JUS_I.B1.003-serb";', '"JUS_I.B1.003-mac";', '"greek-ccitt";', '"NC_NC00-10:81";', '"ISO_6937-2-25";', '"GOST_19768-74";', '"ISO_8859-supp";', 
          \ '"ISO_10367-box";', '"latin-lap";', '"JIS_X0212-1990";', '"DS_2089";', '"us-dk";', '"dk-us";', '"KSC5636";', '"UNICODE-1-1-UTF-7";', '"ISO-2022-CN";', 
          \ '"ISO-2022-CN-EXT";', '"ISO-8859-13";', '"ISO-8859-14";', '"ISO-8859-15";', '"ISO-8859-16";', '"GBK";', '"GB18030";', '"OSD_EBCDIC_DF04_15";', 
          \ '"OSD_EBCDIC_DF03_IRV";', '"OSD_EBCDIC_DF04_1";', '"ISO-11548-1";', '"KZ-1048";', '"ISO-10646-UCS-2";', '"ISO-10646-UCS-4";', '"ISO-10646-UCS-Basic";',
          \ '"ISO-10646-Unicode-Latin1";', '"ISO-10646-J-1";', '"ISO-Unicode-IBM-1261";', '"ISO-Unicode-IBM-1268";', '"ISO-Unicode-IBM-1276";', 
          \ '"ISO-Unicode-IBM-1264";', '"ISO-Unicode-IBM-1265";', '"UNICODE-1-1";', '"SCSU";', '"UTF-7";', '"UTF-16BE";', '"UTF-16LE";', '"UTF-16";', '"CESU-8";', 
          \ '"UTF-32";', '"UTF-32BE";', '"UTF-32LE";', '"BOCU-1";', '"ISO-8859-1-Windows-3.0-Latin-1";', '"ISO-8859-1-Windows-3.1-Latin-1";', 
          \ '"ISO-8859-2-Windows-Latin-2";', '"ISO-8859-9-Windows-Latin-5";', '"hp-roman8";', '"Adobe-Standard-Encoding";', '"Ventura-US";', 
          \ '"Ventura-International";', '"DEC-MCS";', '"IBM850";', '"PC8-Danish-Norwegian";', '"IBM862";', '"PC8-Turkish";', '"IBM-Symbols";', '"IBM-Thai";', 
          \ '"HP-Legal";', '"HP-Pi-font";', '"HP-Math8";', '"Adobe-Symbol-Encoding";', '"HP-DeskTop";', '"Ventura-Math";', '"Microsoft-Publishing";', 
          \ '"Windows-31J";', '"GB2312";', '"Big5";', '"macintosh";', '"IBM037";', '"IBM038";', '"IBM273";', '"IBM274";', '"IBM275";', '"IBM277";', '"IBM278";', 
          \ '"IBM280";', '"IBM281";', '"IBM284";', '"IBM285";', '"IBM290";', '"IBM297";', '"IBM420";', '"IBM423";', '"IBM424";', '"IBM437";', '"IBM500";', '"IBM851";', 
          \ '"IBM852";', '"IBM855";', '"IBM857";', '"IBM860";', '"IBM861";', '"IBM863";', '"IBM864";', '"IBM865";', '"IBM868";', '"IBM869";', '"IBM870";', '"IBM871";', 
          \ '"IBM880";', '"IBM891";', '"IBM903";', '"IBM904";', '"IBM905";', '"IBM918";', '"IBM1026";', '"EBCDIC-AT-DE";', '"EBCDIC-AT-DE-A";', '"EBCDIC-CA-FR";', 
          \ '"EBCDIC-DK-NO";', '"EBCDIC-DK-NO-A";', '"EBCDIC-FI-SE";', '"EBCDIC-FI-SE-A";', '"EBCDIC-FR";', '"EBCDIC-IT";', '"EBCDIC-PT";', '"EBCDIC-ES";', 
          \ '"EBCDIC-ES-A";', '"EBCDIC-ES-S";', '"EBCDIC-UK";', '"EBCDIC-US";', '"UNKNOWN-8BIT";', '"MNEMONIC";', '"MNEM";', '"VISCII";', '"VIQR";', '"KOI8-R";', 
          \ '"HZ-GB-2312";', '"IBM866";', '"IBM775";', '"KOI8-U";', '"IBM00858";', '"IBM00924";', '"IBM01140";', '"IBM01141";', '"IBM01142";', '"IBM01143";', 
          \ '"IBM01144";', '"IBM01145";', '"IBM01146";', '"IBM01147";', '"IBM01148";', '"IBM01149";', '"Big5-HKSCS";', '"IBM1047";', '"PTCP154";', '"Amiga-1251";', 
          \ '"KOI7-switched";', '"BRF";', '"TSCII";', '"windows-1250";', '"windows-1251";', '"windows-1252";', '"windows-1253";', '"windows-1254";', '"windows-1255";', 
          \ '"windows-1256";', '"windows-1257";', '"windows-1258";', '"TIS-620";']

      elseif atrulename == 'namespace'
        let entered_atruleafter = matchstr(line, '.*@namespace\s\+\zs.*$')
        let values = ["url("]

      elseif atrulename == 'document'
        let entered_atruleafter = matchstr(line, '.*@document\s\+\zs.*$')
        let values = ["url(", "url-prefix(", "domain(", "regexp("]

      elseif atrulename == 'import'
        let entered_atruleafter = matchstr(line, '.*@import\s\+\zs.*$')

        if entered_atruleafter =~ "^[\"']"
          let filestart = matchstr(entered_atruleafter, '^.\zs.*')
          let files = split(glob(filestart.'*'), '\n')
          let values = map(copy(files), '"\"".v:val')

        elseif entered_atruleafter =~ "^url("
          let filestart = matchstr(entered_atruleafter, "^url([\"']\\?\\zs.*")
          let files = split(glob(filestart.'*'), '\n')
          let values = map(copy(files), '"url(".v:val')

        else
          let values = ['"', 'url(']

        endif

      else
        return []

      endif

      for m in values
        if m =~? '^'.entered_atruleafter
          if entered_atruleafter =~? '^"' && m =~? '^"'
            let m = m[1:]
          endif
          if b:after =~? '"' && stridx(m, '"') > -1
            let m = m[0:stridx(m, '"')-1]
          endif 
          call add(res, m)
        elseif m =~? entered_atruleafter
          if m =~? '^"'
            let m = m[1:]
          endif
          call add(res2, m)
        endif
      endfor

      return res + res2

    endif

    let values = ["charset", "page", "media", "import", "font-face", "namespace", "supports", "keyframes", "viewport", "document"]

    let entered_atrule = matchstr(line, '.*@\zs[a-zA-Z-]*$')

    for m in values
      if m =~? '^'.entered_atrule
        call add(res, m .' ')
      elseif m =~? entered_atrule
        call add(res2, m .' ')
      endif
    endfor

    return res + res2

  endif

  return []

endfunction
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                "------------------------------------------------------------------------------
"  Description: Vim Ada/Dec Ada compiler file
"     Language: Ada (Dec Ada)
"          $Id: decada.vim 887 2008-07-08 14:29:01Z krischik $
"    Copyright: Copyright (C) 2006 Martin Krischik
"   Maintainer:	Martin Krischik <krischik@users.sourceforge.net>
"      $Author: krischik $
"        $Date: 2008-07-08 16:29:01 +0200 (Di, 08 Jul 2008) $
"      Version: 4.6      
"    $Revision: 887 $
"     $HeadURL: https://gnuada.svn.sourceforge.net/svnroot/gnuada/trunk/tools/vim/autoload/decada.vim $
"      History: 21.07.2006 MK New Dec Ada
"               15.10.2006 MK Bram's suggestion for runtime integration
"               05.11.2006 MK Bram suggested not to use include protection for
"                             autoload
"		05.11.2006 MK Bram suggested to save on spaces
"    Help Page: compiler-decada
"------------------------------------------------------------------------------

if version < 700
   finish
endif

function decada#Unit_Name () dict				     " {{{1
    "	Convert filename into acs unit:
    "	    1:  remove the file extension.
    "	    2:  replace all double '_' or '-' with an dot (which denotes a separate)
    "	    3:  remove a trailing '_' (which denotes a specification)
    return substitute (substitute (expand ("%:t:r"), '__\|-', ".", "g"), '_$', "", '')
endfunction decada#Unit_Name					     " }}}1

function decada#Make () dict					     " {{{1
    let l:make_prg   = substitute (g:self.Make_Command, '%<', self.Unit_Name(), '')
    let &errorformat = g:self.Error_Format
    let &makeprg     = l:make_prg
    wall
    make
    copen
    set wrap
    wincmd W
endfunction decada#Build					     " }}}1

function decada#Set_Session (...) dict				     " {{{1
   if a:0 > 0
      call ada#Switch_Session (a:1)
   elseif argc() == 0 && strlen (v:servername) > 0
      call ada#Switch_Session (
	 \ expand('~')[0:-2] . ".vimfiles.session]decada_" .
	 \ v:servername . ".vim")
   endif
   return
endfunction decada#Set_Session					     " }}}1

function decada#New ()						     " }}}1
   let Retval = {
      \ 'Make'		: function ('decada#Make'),
      \ 'Unit_Name'	: function ('decada#Unit_Name'),
      \ 'Set_Session'   : function ('decada#Set_Session'),
      \ 'Project_Dir'   : '',
      \ 'Make_Command'  : 'ACS COMPILE /Wait /Log /NoPreLoad /Optimize=Development /Debug %<',
      \ 'Error_Format'  : '%+A%%ADAC-%t-%m,%C  %#%m,%Zat line number %l in file %f,' .
			\ '%+I%%ada-I-%m,%C  %#%m,%Zat line number %l in file %f'}

   return Retval 
endfunction decada#New						     " }}}1

finish " 1}}}

"------------------------------------------------------------------------------
"   Copyright (C) 2006  Martin Krischik
"
"   Vim is Charityware - see ":help license" or uganda.txt for licence details.
"------------------------------------------------------------------------------
" vim: textwidth=78 wrap tabstop=8 shiftwidth=3 softtabstop=3 noexpandtab
" vim: foldmethod=marker
                                                                          {   .   p   ..  |  èft.vim                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          " Vim functions for file type detection
"
" Maintainer:	Bram Moolenaar <Bram@vim.org>
" Last Change:	2020 Aug 17

" These functions are moved here from runtime/filetype.vim to make startup
" faster.

" Line continuation is used here, remove 'C' from 'cpoptions'
let s:cpo_save = &cpo
set cpo&vim

func dist#ft#Check_inp()
  if getline(1) =~ '^\*'
    setf abaqus
  else
    let n = 1
    if line("$") > 500
      let nmax = 500
    else
      let nmax = line("$")
    endif
    while n <= nmax
      if getline(n) =~? "^header surface data"
	setf trasys
	break
      endif
      let n = n + 1
    endwhile
  endif
endfunc

" This function checks for the kind of assembly that is wanted by the user, or
" can be detected from the first five lines of the file.
func dist#ft#FTasm()
  " make sure b:asmsyntax exists
  if !exists("b:asmsyntax")
    let b:asmsyntax = ""
  endif

  if b:asmsyntax == ""
    call dist#ft#FTasmsyntax()
  endif

  " if b:asmsyntax still isn't set, default to asmsyntax or GNU
  if b:asmsyntax == ""
    if exists("g:asmsyntax")
      let b:asmsyntax = g:asmsyntax
    else
      let b:asmsyntax = "asm"
    endif
  endif

  exe "setf " . fnameescape(b:asmsyntax)
endfunc

func dist#ft#FTasmsyntax()
  " see if file contains any asmsyntax=foo overrides. If so, change
  " b:asmsyntax appropriately
  let head = " ".getline(1)." ".getline(2)." ".getline(3)." ".getline(4).
	\" ".getline(5)." "
  let match = matchstr(head, '\sasmsyntax=\zs[a-zA-Z0-9]\+\ze\s')
  if match != ''
    let b:asmsyntax = match
  elseif ((head =~? '\.title') || (head =~? '\.ident') || (head =~? '\.macro') || (head =~? '\.subtitle') || (head =~? '\.library'))
    let b:asmsyntax = "vmasm"
  endif
endfunc

" Check if one of the first five lines contains "VB_Name".  In that case it is
" probably a Visual Basic file.  Otherwise it's assumed to be "alt" filetype.
func dist#ft#FTVB(alt)
  if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'VB_Name\|Begin VB\.\(Form\|MDIForm\|UserControl\)'
    setf vb
  else
    exe "setf " . a:alt
  endif
endfunc

func dist#ft#FTbtm()
  if exists("g:dosbatch_syntax_for_btm") && g:dosbatch_syntax_for_btm
    setf dosbatch
  else
    setf btm
  endif
endfunc

func dist#ft#BindzoneCheck(default)
  if getline(1).getline(2).getline(3).getline(4) =~ '^; <<>> DiG [0-9.]\+.* <<>>\|$ORIGIN\|$TTL\|IN\s\+SOA'
    setf bindzone
  elseif a:default != ''
    exe 'setf ' . a:default
  endif
endfunc

func dist#ft#FTlpc()
  if exists("g:lpc_syntax_for_c")
    let lnum = 1
    while lnum <= 12
      if getline(lnum) =~# '^\(//\|inherit\|private\|protected\|nosave\|string\|object\|mapping\|mixed\)'
	setf lpc
	return
      endif
      let lnum = lnum + 1
    endwhile
  endif
  setf c
endfunc

func dist#ft#FTheader()
  if match(getline(1, min([line("$"), 200])), '^@\(interface\|end\|class\)') > -1
    if exists("g:c_syntax_for_h")
      setf objc
    else
      setf objcpp
    endif
  elseif exists("g:c_syntax_for_h")
    setf c
  elseif exists("g:ch_syntax_for_h")
    setf ch
  else
    setf cpp
  endif
endfunc

" This function checks if one of the first ten lines start with a '@'.  In
" that case it is probably a change file.
" If the first line starts with # or ! it's probably a ch file.
" If a line has "main", "include", "//" or "/*" it's probably ch.
" Otherwise CHILL is assumed.
func dist#ft#FTchange()
  let lnum = 1
  while lnum <= 10
    if getline(lnum)[0] == '@'
      setf change
      return
    endif
    if lnum == 1 && (getline(1)[0] == '#' || getline(1)[0] == '!')
      setf ch
      return
    endif
    if getline(lnum) =~ "MODULE"
      setf chill
      return
    endif
    if getline(lnum) =~ 'main\s*(\|#\s*include\|//'
      setf ch
      return
    endif
    let lnum = lnum + 1
  endwhile
  setf chill
endfunc

func dist#ft#FTent()
  " This function checks for valid cl syntax in the first five lines.
  " Look for either an opening comment, '#', or a block start, '{".
  " If not found, assume SGML.
  let lnum = 1
  while lnum < 6
    let line = getline(lnum)
    if line =~ '^\s*[#{]'
      setf cl
      return
    elseif line !~ '^\s*$'
      " Not a blank line, not a comment, and not a block start,
      " so doesn't look like valid cl code.
      break
    endif
    let lnum = lnum + 1
  endw
  setf dtd
endfunc

func dist#ft#ExCheck()
  let lines = getline(1, min([line("$"), 100]))
  if exists('g:filetype_euphoria')
    exe 'setf ' . g:filetype_euphoria
  elseif match(lines, '^--\|^ifdef\>\|^include\>') > -1
    setf euphoria3
  else
    setf elixir
  endif
endfunc

func dist#ft#EuphoriaCheck()
  if exists('g:filetype_euphoria')
    exe 'setf ' . g:filetype_euphoria
  else
    setf euphoria3
  endif
endfunc

func dist#ft#DtraceCheck()
  let lines = getline(1, min([line("$"), 100]))
  if match(lines, '^module\>\|^import\>') > -1
    " D files often start with a module and/or import statement.
    setf d
  elseif match(lines, '^#!\S\+dtrace\|#pragma\s\+D\s\+option\|:\S\{-}:\S\{-}:') > -1
    setf dtrace
  else
    setf d
  endif
endfunc

func dist#ft#FTe()
  if exists('g:filetype_euphoria')
    exe 'setf ' . g:filetype_euphoria
  else
    let n = 1
    while n < 100 && n <= line("$")
      if getline(n) =~ "^\\s*\\(<'\\|'>\\)\\s*$"
	setf specman
	return
      endif
      let n = n + 1
    endwhile
    setf eiffel
  endif
endfunc

" Distinguish between HTML, XHTML and Django
func dist#ft#FThtml()
  let n = 1
  while n < 10 && n <= line("$")
    if getline(n) =~ '\<DTD\s\+XHTML\s'
      setf xhtml
      return
    endif
    if getline(n) =~ '{%\s*\(extends\|block\|load\)\>\|{#\s\+'
      setf htmldjango
      return
    endif
    let n = n + 1
  endwhile
  setf FALLBACK html
endfunc

" Distinguish between standard IDL and MS-IDL
func dist#ft#FTidl()
  let n = 1
  while n < 50 && n <= line("$")
    if getline(n) =~ '^\s*import\s\+"\(unknwn\|objidl\)\.idl"'
      setf msidl
      return
    endif
    let n = n + 1
  endwhile
  setf idl
endfunc

" Distinguish between "default" and Cproto prototype file. */
func dist#ft#ProtoCheck(default)
  " Cproto files have a comment in the first line and a function prototype in
  " the second line, it always ends in ";".  Indent files may also have
  " comments, thus we can't match comments to see the difference.
  " IDL files can have a single ';' in the second line, require at least one
  " chacter before the ';'.
  if getline(2) =~ '.;$'
    setf cpp
  else
    exe 'setf ' . a:default
  endif
endfunc

func dist#ft#FTm()
  if exists("g:filetype_m")
    exe "setf " . g:filetype_m
    return
  endif

  " excluding end(for|function|if|switch|while) common to Murphi
  let octave_block_terminators = '\<end\%(_try_catch\|classdef\|enumeration\|events\|methods\|parfor\|properties\)\>'

  let n = 1
  let saw_comment = 0 " Whether we've seen a multiline comment leader.
  while n < 100
    let line = getline(n)
    if line =~ '^\s*/\*'
      " /* ... */ is a comment in Objective C and Murphi, so we can't conclude
      " it's either of them yet, but track this as a hint in case we don't see
      " anything more definitive.
      let saw_comment = 1
    endif
    if line =~ '^\s*\(#\s*\(include\|import\)\>\|@import\>\|//\)'
      setf objc
      return
    endif
    if line =~ '^\s*\%(#\|%!\)' || line =~ '^\s*unwind_protect\>' ||
	  \ line =~ '\%(^\|;\)\s*' .. octave_block_terminators
      setf octave
      return
    endif
    " TODO: could be Matlab or Octave
    if line =~ '^\s*%'
      setf matlab
      return
    endif
    if line =~ '^\s*(\*'
      setf mma
      return
    endif
    if line =~ '^\c\s*\(\(type\|var\)\>\|--\)'
      setf murphi
      return
    endif
    let n = n + 1
  endwhile

  if saw_comment
    " We didn't see anything definitive, but this looks like either Objective C
    " or Murphi based on the comment leader. Assume the former as it is more
    " common.
    setf objc
  else
    " Default is Matlab
    setf matlab
  endif
endfunc

func dist#ft#FTmms()
  let n = 1
  while n < 20
    let line = getline(n)
    if line =~ '^\s*\(%\|//\)' || line =~ '^\*'
      setf mmix
      return
    endif
    if line =~ '^\s*#'
      setf make
      return
    endif
    let n = n + 1
  endwhile
  setf mmix
endfunc

" This function checks if one of the first five lines start with a dot.  In
" that case it is probably an nroff file: 'filetype' is set and 1 is returned.
func dist#ft#FTnroff()
  if getline(1)[0] . getline(2)[0] . getline(3)[0] . getline(4)[0] . getline(5)[0] =~ '\.'
    setf nroff
    return 1
  endif
  return 0
endfunc

func dist#ft#FTmm()
  let n = 1
  while n < 20
    let line = getline(n)
    if line =~ '^\s*\(#\s*\(include\|import\)\>\|@import\>\|/\*\)'
      setf objcpp
      return
    endif
    let n = n + 1
  endwhile
  setf nroff
endfunc

func dist#ft#FTpl()
  if exists("g:filetype_pl")
    exe "setf " . g:filetype_pl
  else
    " recognize Prolog by specific text in the first non-empty line
    " require a blank after the '%' because Perl uses "%list" and "%translate"
    let l = getline(nextnonblank(1))
    if l =~ '\<prolog\>' || l =~ '^\s*\(%\+\(\s\|$\)\|/\*\)' || l =~ ':-'
      setf prolog
    else
      setf perl
    endif
  endif
endfunc

func dist#ft#FTinc()
  if exists("g:filetype_inc")
    exe "setf " . g:filetype_inc
  else
    let lines = getline(1).getline(2).getline(3)
    if lines =~? "perlscript"
      setf aspperl
    elseif lines =~ "<%"
      setf aspvbs
    elseif lines =~ "<?"
      setf php
    " Pascal supports // comments but they're vary rarely used for file
    " headers so assume POV-Ray
    elseif lines =~ '^\s*\%({\|(\*\)' || lines =~? s:ft_pascal_keywords
      setf pascal
    else
      call dist#ft#FTasmsyntax()
      if exists("b:asmsyntax")
	exe "setf " . fnameescape(b:asmsyntax)
      else
	setf pov
      endif
    endif
  endif
endfunc

func dist#ft#FTprogress_cweb()
  if exists("g:filetype_w")
    exe "setf " . g:filetype_w
    return
  endif
  if getline(1) =~ '&ANALYZE' || getline(3) =~ '&GLOBAL-DEFINE'
    setf progress
  else
    setf cweb
  endif
endfunc

func dist#ft#FTprogress_asm()
  if exists("g:filetype_i")
    exe "setf " . g:filetype_i
    return
  endif
  " This function checks for an assembly comment the first ten lines.
  " If not found, assume Progress.
  let lnum = 1
  while lnum <= 10 && lnum < line('$')
    let line = getline(lnum)
    if line =~ '^\s*;' || line =~ '^\*'
      call dist#ft#FTasm()
      return
    elseif line !~ '^\s*$' || line =~ '^/\*'
      " Not an empty line: Doesn't look like valid assembly code.
      " Or it looks like a Progress /* comment
      break
    endif
    let lnum = lnum + 1
  endw
  setf progress
endfunc

let s:ft_pascal_comments = '^\s*\%({\|(\*\|//\)'
let s:ft_pascal_keywords = '^\s*\%(program\|unit\|library\|uses\|begin\|procedure\|function\|const\|type\|var\)\>'

func dist#ft#FTprogress_pascal()
  if exists("g:filetype_p")
    exe "setf " . g:filetype_p
    return
  endif
  " This function checks for valid Pascal syntax in the first ten lines.
  " Look for either an opening comment or a program start.
  " If not found, assume Progress.
  let lnum = 1
  while lnum <= 10 && lnum < line('$')
    let line = getline(lnum)
    if line =~ s:ft_pascal_comments || line =~? s:ft_pascal_keywords
      setf pascal
      return
    elseif line !~ '^\s*$' || line =~ '^/\*'
      " Not an empty line: Doesn't look like valid Pascal code.
      " Or it looks like a Progress /* comment
      break
    endif
    let lnum = lnum + 1
  endw
  setf progress
endfunc

func dist#ft#FTpp()
  if exists("g:filetype_pp")
    exe "setf " . g:filetype_pp
  else
    let line = getline(nextnonblank(1))
    if line =~ s:ft_pascal_comments || line =~? s:ft_pascal_keywords
      setf pascal
    else
      setf puppet
    endif
  endif
endfunc

func dist#ft#FTr()
  let max = line("$") > 50 ? 50 : line("$")

  for n in range(1, max)
    " Rebol is easy to recognize, check for that first
    if getline(n) =~? '\<REBOL\>'
      setf rebol
      return
    endif
  endfor

  for n in range(1, max)
    " R has # comments
    if getline(n) =~ '^\s*#'
      setf r
      return
    endif
    " Rexx has /* comments */
    if getline(n) =~ '^\s*/\*'
      setf rexx
      return
    endif
  endfor

  " Nothing recognized, use user(r  )r  *r  +r  ,r  -r  .r  /r                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   default or assume Rexx
  if exists("g:filetype_r")
    exe "setf " . g:filetype_r
  else
    " Rexx used to be the default, but R appears to be much more popular.
    setf r
  endif
endfunc

func dist#ft#McSetf()
  " Rely on the file to start with a comment.
  " MS message text files use ';', Sendmail files use '#' or 'dnl'
  for lnum in range(1, min([line("$"), 20]))
    let line = getline(lnum)
    if line =~ '^\s*\(#\|dnl\)'
      setf m4  " Sendmail .mc file
      return
    elseif line =~ '^\s*;'
      setf msmessages  " MS Message text file
      return
    endif
  endfor
  setf m4  " Default: Sendmail .mc file
endfunc

" Called from filetype.vim and scripts.vim.
func dist#ft#SetFileTypeSH(name)
  if did_filetype()
    " Filetype was already detected
    return
  endif
  if expand("<amatch>") =~ g:ft_ignore_pat
    return
  endif
  if a:name =~ '\<csh\>'
    " Some .sh scripts contain #!/bin/csh.
    call dist#ft#SetFileTypeShell("csh")
    return
  elseif a:name =~ '\<tcsh\>'
    " Some .sh scripts contain #!/bin/tcsh.
    call dist#ft#SetFileTypeShell("tcsh")
    return
  elseif a:name =~ '\<zsh\>'
    " Some .sh scripts contain #!/bin/zsh.
    call dist#ft#SetFileTypeShell("zsh")
    return
  elseif a:name =~ '\<ksh\>'
    let b:is_kornshell = 1
    if exists("b:is_bash")
      unlet b:is_bash
    endif
    if exists("b:is_sh")
      unlet b:is_sh
    endif
  elseif exists("g:bash_is_sh") || a:name =~ '\<bash\>' || a:name =~ '\<bash2\>'
    let b:is_bash = 1
    if exists("b:is_kornshell")
      unlet b:is_kornshell
    endif
    if exists("b:is_sh")
      unlet b:is_sh
    endif
  elseif a:name =~ '\<sh\>'
    let b:is_sh = 1
    if exists("b:is_kornshell")
      unlet b:is_kornshell
    endif
    if exists("b:is_bash")
      unlet b:is_bash
    endif
  endif
  call dist#ft#SetFileTypeShell("sh")
endfunc

" For shell-like file types, check for an "exec" command hidden in a comment,
" as used for Tcl.
" Also called from scripts.vim, thus can't be local to this script.
func dist#ft#SetFileTypeShell(name)
  if did_filetype()
    " Filetype was already detected
    return
  endif
  if expand("<amatch>") =~ g:ft_ignore_pat
    return
  endif
  let l = 2
  while l < 20 && l < line("$") && getline(l) =~ '^\s*\(#\|$\)'
    " Skip empty and comment lines.
    let l = l + 1
  endwhile
  if l < line("$") && getline(l) =~ '\s*exec\s' && getline(l - 1) =~ '^\s*#.*\\$'
    " Found an "exec" line after a comment with continuation
    let n = substitute(getline(l),'\s*exec\s\+\([^ ]*/\)\=', '', '')
    if n =~ '\<tclsh\|\<wish'
      setf tcl
      return
    endif
  endif
  exe "setf " . a:name
endfunc

func dist#ft#CSH()
  if did_filetype()
    " Filetype was already detected
    return
  endif
  if exists("g:filetype_csh")
    call dist#ft#SetFileTypeShell(g:filetype_csh)
  elseif &shell =~ "tcsh"
    call dist#ft#SetFileTypeShell("tcsh")
  else
    call dist#ft#SetFileTypeShell("csh")
  endif
endfunc

let s:ft_rules_udev_rules_pattern = '^\s*\cudev_rules\s*=\s*"\([^"]\{-1,}\)/*".*'
func dist#ft#FTRules()
  let path = expand('<amatch>:p')
  if path =~ '/\(etc/udev/\%(rules\.d/\)\=.*\.rules\|\%(usr/\)\=lib/udev/\%(rules\.d/\)\=.*\.rules\)$'
    setf udevrules
    return
  endif
  if path =~ '^/etc/ufw/'
    setf conf  " Better than hog
    return
  endif
  if path =~ '^/\(etc\|usr/share\)/polkit-1/rules\.d'
    setf javascript
    return
  endif
  try
    let config_lines = readfile('/etc/udev/udev.conf')
  catch /^Vim\%((\a\+)\)\=:E484/
    setf hog
    return
  endtry
  let dir = expand('<amatch>:p:h')
  for line in config_lines
    if line =~ s:ft_rules_udev_rules_pattern
      let udev_rules = substitute(line, s:ft_rules_udev_rules_pattern, '\1', "")
      if dir == udev_rules
	setf udevrules
      endif
      break
    endif
  endfor
  setf hog
endfunc

func dist#ft#SQL()
  if exists("g:filetype_sql")
    exe "setf " . g:filetype_sql
  else
    setf sql
  endif
endfunc

" If the file has an extension of 't' and is in a directory 't' or 'xt' then
" it is almost certainly a Perl test file.
" If the first line starts with '#' and contains 'perl' it's probably a Perl
" file.
" (Slow test) If a file contains a 'use' statement then it is almost certainly
" a Perl file.
func dist#ft#FTperl()
  let dirname = expand("%:p:h:t")
  if expand("%:e") == 't' && (dirname == 't' || dirname == 'xt')
    setf perl
    return 1
  endif
  if getline(1)[0] == '#' && getline(1) =~ 'perl'
    setf perl
    return 1
  endif
  let save_cursor = getpos('.')
  call cursor(1,1)
  let has_use = search('^use\s\s*\k', 'c', 30)
  call setpos('.', save_cursor)
  if has_use
    setf perl
    return 1
  endif
  return 0
endfunc

" Choose context, plaintex, or tex (LaTeX) based on these rules:
" 1. Check the first line of the file for "%&<format>".
" 2. Check the first 1000 non-comment lines for LaTeX or ConTeXt keywords.
" 3. Default to "plain" or to g:tex_flavor, can be set in user's vimrc.
func dist#ft#FTtex()
  let firstline = getline(1)
  if firstline =~ '^%&\s*\a\+'
    let format = tolower(matchstr(firstline, '\a\+'))
    let format = substitute(format, 'pdf', '', '')
    if format == 'tex'
      let format = 'latex'
    elseif format == 'plaintex'
      let format = 'plain'
    endif
  elseif expand('%') =~ 'tex/context/.*/.*.tex'
    let format = 'context'
  else
    " Default value, may be changed later:
    let format = exists("g:tex_flavor") ? g:tex_flavor : 'plain'
    " Save position, go to the top of the file, find first non-comment line.
    let save_cursor = getpos('.')
    call cursor(1,1)
    let firstNC = search('^\s*[^[:space:]%]', 'c', 1000)
    if firstNC " Check the next thousand lines for a LaTeX or ConTeXt keyword.
      let lpat = 'documentclass\>\|usepackage\>\|begin{\|newcommand\>\|renewcommand\>'
      let cpat = 'start\a\+\|setup\a\+\|usemodule\|enablemode\|enableregime\|setvariables\|useencoding\|usesymbols\|stelle\a\+\|verwende\a\+\|stel\a\+\|gebruik\a\+\|usa\a\+\|imposta\a\+\|regle\a\+\|utilisemodule\>'
      let kwline = search('^\s*\\\%(' . lpat . '\)\|^\s*\\\(' . cpat . '\)',
			      \ 'cnp', firstNC + 1000)
      if kwline == 1	" lpat matched
	let format = 'latex'
      elseif kwline == 2	" cpat matched
	let format = 'context'
      endif		" If neither matched, keep default set above.
      " let lline = search('^\s*\\\%(' . lpat . '\)', 'cn', firstNC + 1000)
      " let cline = search('^\s*\\\%(' . cpat . '\)', 'cn', firstNC + 1000)
      " if cline > 0
      "   let format = 'context'
      " endif
      " if lline > 0 && (cline == 0 || cline > lline)
      "   let format = 'tex'
      " endif
    endif " firstNC
    call setpos('.', save_cursor)
  endif " firstline =~ '^%&\s*\a\+'

  " Translation from formats to file types.  TODO:  add AMSTeX, RevTex, others?
  if format == 'plain'
    setf plaintex
  elseif format == 'context'
    setf context
  else " probably LaTeX
    setf tex
  endif
  return
endfunc

func dist#ft#FTxml()
  let n = 1
  while n < 100 && n <= line("$")
    let line = getline(n)
    " DocBook 4 or DocBook 5.
    let is_docbook4 = line =~ '<!DOCTYPE.*DocBook'
    let is_docbook5 = line =~ ' xmlns="http://docbook.org/ns/docbook"'
    if is_docbook4 || is_docbook5
      let b:docbk_type = "xml"
      if is_docbook5
	let b:docbk_ver = 5
      else
	let b:docbk_ver = 4
      endif
      setf docbk
      return
    endif
    if line =~ 'xmlns:xbl="http://www.mozilla.org/xbl"'
      setf xbl
      return
    endif
    let n += 1
  endwhile
  setf xml
endfunc

func dist#ft#FTy()
  let n = 1
  while n < 100 && n <= line("$")
    let line = getline(n)
    if line =~ '^\s*%'
      setf yacc
      return
    endif
    if getline(n) =~ '^\s*\(#\|class\>\)' && getline(n) !~ '^\s*#\s*include'
      setf racc
      return
    endif
    let n = n + 1
  endwhile
  setf yacc
endfunc

func dist#ft#Redif()
  let lnum = 1
  while lnum <= 5 && lnum < line('$')
    if getline(lnum) =~ "^\ctemplate-type:"
      setf redif
      return
    endif
    let lnum = lnum + 1
  endwhile
endfunc


" Restore 'cpoptions'
let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                       " ---------------------------------------------------------------------
" getscript.vim
"  Author:	Charles E. Campbell
"  Date:	Jan 21, 2014
"  Version:	36
"  Installing:	:help glvs-install
"  Usage:	:help glvs
"
" GetLatestVimScripts: 642 1 :AutoInstall: getscript.vim
"redraw!|call inputsave()|call input("Press <cr> to continue")|call inputrestore()
" ---------------------------------------------------------------------
" Initialization:	{{{1
" if you're sourcing this file, surely you can't be
" expecting vim to be in its vi-compatible mode!
if exists("g:loaded_getscript")
 finish
endif
let g:loaded_getscript= "v36"
if &cp
 echoerr "GetLatestVimScripts is not vi-compatible; not loaded (you need to set nocp)"
 finish
endif
if v:version < 702
 echohl WarningMsg
 echo "***warning*** this version of GetLatestVimScripts needs vim 7.2"
 echohl Normal
 finish
endif
let s:keepcpo = &cpo
set cpo&vim
"DechoTabOn

" ---------------------------
" Global Variables: {{{1
" ---------------------------
" Cygwin Detection ------- {{{2
if !exists("g:getscript_cygwin")
 if has("win32") || has("win95") || has("win64") || has("win16")
  if &shell =~ '\%(\<bash\>\|\<zsh\>\)\%(\.exe\)\=$'
   let g:getscript_cygwin= 1
  else
   let g:getscript_cygwin= 0
  endif
 else
  let g:getscript_cygwin= 0
 endif
endif

" wget vs curl {{{2
if !exists("g:GetLatestVimScripts_wget")
 if executable("wget")
  let g:GetLatestVimScripts_wget= "wget"
 elseif executable("curl")
  let g:GetLatestVimScripts_wget= "curl"
 else
  let g:GetLatestVimScripts_wget    = 'echo "GetLatestVimScripts needs wget or curl"'
  let g:GetLatestVimScripts_options = ""
 endif
endif

" options that wget and curl require:
if !exists("g:GetLatestVimScripts_options")
 if g:GetLatestVimScripts_wget == "wget"
  let g:GetLatestVimScripts_options= "-q -O"
 elseif g:GetLatestVimScripts_wget == "curl"
  let g:GetLatestVimScripts_options= "-s -O"
 else
  let g:GetLatestVimScripts_options= ""
 endif
endif

" by default, allow autoinstall lines to work
if !exists("g:GetLatestVimScripts_allowautoinstall")
 let g:GetLatestVimScripts_allowautoinstall= 1
endif

" set up default scriptaddr address
if !exists("g:GetLatestVimScripts_scriptaddr")
 let g:GetLatestVimScripts_scriptaddr = 'http://vim.sourceforge.net/script.php?script_id='
endif

"" For debugging:
"let g:GetLatestVimScripts_wget    = "echo"
"let g:GetLatestVimScripts_options = "options"

" ---------------------------------------------------------------------
" Check If AutoInstall Capable: {{{1
let s:autoinstall= ""
if g:GetLatestVimScripts_allowautoinstall

 if (has("win32") || has("gui_win32") || has("gui_win32s") || has("win16") || has("win64") || has("win32unix") || has("win95")) && &shell != "bash"
  " windows (but not cygwin/bash)
  let s:dotvim= "vimfiles"
  if !exists("g:GetLatestVimScripts_mv")
   let g:GetLatestVimScripts_mv= "ren"
  endif

 else
  " unix
  let s:dotvim= ".vim"
  if !exists("g:GetLatestVimScripts_mv")
   let g:GetLatestVimScripts_mv= "mv"
  endif
 endif

 if exists("g:GetLatestVimScripts_autoinstalldir") && isdirectory(g:GetLatestVimScripts_autoinstalldir)
  let s:autoinstall= g:GetLatestVimScripts_autoinstalldir"
 elseif exists('$HOME') && isdirectory(expand("$HOME")."/".s:dotvim)
  let s:autoinstall= $HOME."/".s:dotvim
 endif
" call Decho("s:autoinstall<".s:autoinstall.">")
"else "Decho
" call Decho("g:GetLatestVimScripts_allowautoinstall=".g:GetLatestVimScripts_allowautoinstall.": :AutoInstall: disabled")
endif

" ---------------------------------------------------------------------
"  Public Interface: {{{1
com!        -nargs=0 GetLatestVimScripts call getscript#GetLatestVimScripts()
com!        -nargs=0 GetScript           call getscript#GetLatestVimScripts()
silent! com -nargs=0 GLVS                call getscript#GetLatestVimScripts()

" ---------------------------------------------------------------------
" GetLatestVimScripts: this function gets the latest versions of {{{1
"                      scripts based on the list in
"   (first dir in runtimepath)/GetLatest/GetLatestVimScripts.dat
fun! getscript#GetLatestVimScripts()
"  call Dfunc("GetLatestVimScripts() autoinstall<".s:autoinstall.">")

" insure that wget is executable
  if executable(g:GetLatestVimScripts_wget) != 1
   echoerr "GetLatestVimScripts needs ".g:GetLatestVimScripts_wget." which apparently is not available on your system"
"   call Dret("GetLatestVimScripts : wget not executable/available")
   return
  endif

  " insure that fnameescape() is available
  if !exists("*fnameescape")
   echoerr "GetLatestVimScripts needs fnameescape() (provided by 7.1.299 or later)"
   return
  endif

  " Find the .../GetLatest subdirectory under the runtimepath
  for datadir in split(&rtp,',') + ['']
   if isdirectory(datadir."/GetLatest")
"    call Decho("found directory<".datadir.">")
    let datadir= datadir . "/GetLatest"
    break
   endif
   if filereadable(datadir."GetLatestVimScripts.dat")
"    call Decho("found ".datadir."/GetLatestVimScripts.dat")
    break
   endif
  endfor

  " Sanity checks: readability and writability
  if datadir == ""
   echoerr 'Missing "GetLatest/" on your runtimepath - see :help glvs-dist-install'
"   call Dret("GetLatestVimScripts : unable to find a GetLatest subdirectory")
   return
  endif
  if filewritable(datadir) != 2
   echoerr "(getLatestVimScripts) Your ".datadir." isn't writable"
"   call Dret("GetLatestVimScripts : non-writable directory<".datadir.">")
   return
  endif
  let datafile= datadir."/GetLatestVimScripts.dat"
  if !filereadable(datafile)
   echoerr "Your data file<".datafile."> isn't readable"
"   call Dret("GetLatestVimScripts : non-readable datafile<".datafile.">")
   return
  endif
  if !filewritable(datafile)
   echoerr "Your data file<".datafile."> isn't writable"
"   call Dret("GetLatestVimScripts : non-writable datafile<".datafile.">")
   return
  endif
  " --------------------
  " Passed sanity checks
  " --------------------

"  call Decho("datadir  <".datadir.">")
"  call Decho("datafile <".datafile.">")

  " don't let any event handlers interfere (like winmanager's, taglist's, etc)
  let eikeep  = &ei
  let hlskeep = &hls
  let acdkeep = &acd
  set ei=all hls&vim noacd

  " Edit the datafile (ie. GetLatestVimScripts.dat):
  " 1. record current directory (origdir),
  " 2. change directory to datadir,
  " 3. split window
  " 4. edit datafile
  let origdir= getcwd()
"  call Decho("exe cd ".fnameescape(substitute(datadir,'\','/','ge')))
  exe "cd ".fnameescape(substitute(datadir,'\','/','ge'))
  split
"  call Decho("exe  e ".fnameescape(substitute(datafile,'\','/','ge')))
  exe "e ".fnameescape(substitute(datafile,'\','/','ge'))
  res 1000
  let s:downloads = 0
  let s:downerrors= 0

  " Check on dependencies mentioned in plugins
"  call Decho(" ")
"  call Decho("searching plugins for GetLatestVimScripts dependencies")
  let lastline    = line("$")
"  call Decho("lastline#".lastline)
  let firstdir    = substitute(&rtp,',.*$','','')
  let plugins     = split(globpath(firstdir,"plugin/**/*.vim"),'\n')
  let plugins     = plugins + split(globpath(firstdir,"AsNeeded/**/*.vim"),'\n')
  let foundscript = 0

  " this loop updates the GetLatestVimScripts.dat file
  " with dependencies explicitly mentioned in the plugins
  " via   GetLatestVimScripts: ... lines
  " It reads the plugin script at the end of the GetLatestVimScripts.dat
  " file, examines it, and then removes it.
  for plugin in plugins
"   call Decho(" ")
"   call Decho("plugin<".plugin.">")

   " read plugin in
   " evidently a :r creates a new buffer (the "#" buffer) that is subsequently unused -- bwiping it
   $
"   call Decho(".dependency checking<".plugin."> line$=".line("$"))
"   call Decho("..exe silent r ".fnameescape(plugin))
   exe "silent r ".fnameescape(plugin)
   exe "silent bwipe ".bufnr("#")

   while search('^"\s\+GetLatestVimScripts:\s\+\d\+\s\+\d\+','W') != 0
    let depscript   = substitute(getline("."),'^"\s\+GetLatestVimScripts:\s\+\d\+\s\+\d\+\s\+\(.*\)$','\1','e')
    let depscriptid = substitute(getline("."),'^"\s\+GetLatestVimScripts:\s\+\(\d\+\)\s\+.*$','\1','')
    let llp1        = lastline+1
"    call Decho("..depscript<".depscript.">")

    " found a "GetLatestVimScripts: # #" line in the script;
    " check if it's already in the datafile by searching backwards from llp1,
    " the (prior to reading in the plugin script) last line plus one of the GetLatestVimScripts.dat file,
    " for the script-id with no wrapping allowed.
    let curline     = line(".")
    let noai_script = substitute(depscript,'\s*:AutoInstall:\s*','','e')
    exe llp1
    let srchline    = search('^\s*'.depscriptid.'\s\+\d\+\s\+.*$','bW')
    if srchline == 0
     " this second search is taken when, for example, a   0 0 scriptname  is to be skipped over
     let srchline= search('\<'.noai_script.'\>','bW')
    endif
"    call Decho("..noai_script<".noai_script."> depscriptid#".depscriptid." srchline#".srchline." curline#".line(".")." lastline#".lastline)

    if srchline == 0
     " found a new script to permanently include in the datafile
     let keep_rega   = @a
     let @a          = substitute(getline(curline),'^"\s\+GetLatestVimScripts:\s\+','','')
     echomsg "Appending <".@a."> to ".datafile." for ".depscript
"     call Decho("..Appending <".@a."> to ".datafile." for ".depscript)
     exe lastline."put a"
     let @a          = keep_rega
     let lastline    = llp1
     let curline     = curline     + 1
     let foundscript = foundscript + 1
"    else	" Decho
"     call Decho("..found <".noai_script."> (already in datafile at line#".srchline.")")
    endif

    let curline = curline + 1
    exe curline
   endwhile

   " llp1: last line plus one
   let llp1= lastline + 1
"   call Decho(".deleting lines: ".llp1.",$d")
   exe "silent! ".llp1.",$d"
  endfor
"  call Decho("--- end dependency checking loop ---  foundscript=".foundscript)
"  call Decho(" ")
"  call Dredir("BUFFER TEST (GetLatestVimScripts 1)","ls!")

  if foundscript == 0
   setlocal nomod
  endif

  " --------------------------------------------------------------------
  " Check on out-of-date scripts using GetLatest/GetLatestVimScripts.dat
  " --------------------------------------------------------------------
"  call Decho("begin: checking out-of-date scripts using datafile<".datafile.">")
  setlocal lz
  1
"  /^-----/,$g/^\s*\d/call Decho(getline("."))
  1
  /^-----/,$g/^\s*\d/call s:GetOneScript()
"  call Decho("--- end out-of-date checking --- ")

  " Final report (an echomsg)
  try
   silent! ?^-------?
  catch /^Vim\%((\a\+)\)\=:E114/
"   call Dret("GetLatestVimScripts : nothing done!")
   return
  endtry
  exe "norm! kz\<CR>"
  redraw!
  let s:msg = ""
  if s:downloads == 1
  let s:msg = "Downloaded one updated script to <".datadir.">"
  elseif s:downloads == 2
   let s:msg= "Downloaded two updated scripts to <".datadir.">"
  elseif s:downloads > 1
   let s:msg= "Downloaded ".s:downloads." updated scripts to <".datadir.">"
  else
   let s:msg= "Everything was already current"
  endif
  if s:downerrors > 0
   let s:msg= s:msg." (".s:downerrors." downloading errors)"
  endif
  echomsg s:msg
  " save the file
  if &mod
   silent! w!
  endif
  q!

  " restore events and current directory
  exe "cd ".fnameescape(substitute(origdir,'\','/','ge'))
  let &ei  = eikeep
  let &hls = hlskeep
  let &acd = acdkeep
  setlocal nolz
"  call Dredir("BUFFER TEST (GetLatestVimScripts 2)","ls!")
"  call Dret("GetLatestVimScripts : did ".s:downloads." downloads")
endfun

" ---------------------------------------------------------------------
"  GetOneScript: (Get Latest Vim Script) this function operates {{{1
"    on the current line, interpreting two numbers and text as
"    ScriptID, SourceID, and Filename.
"    It downloads any scripts that have newer versions from vim.sourceforge.net.
fun! s:GetOneScript(...)
"   call Dfunc("GetOneScript()")

 " set options to allow progress to be shown on screen
  let rega= @a
  let t_ti= &t_ti
  let t_te= &t_te
  let rs  = &rs
  set t_ti= t_te= nors

 " put current line on top-of-screen and interpret it into
 " a      script identifier  : used to obtain webpage
 "        source identifier : used to identify current version
 " and an associated comment: used to report on w=r  >r  ?r  @r  Ar  Br  Cr  Dr  Er  Fr  Gr  Hr  Ir                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              hat's being considered
  if a:0 >= 3
   let scriptid = a:1
   let srcid    = a:2
   let fname    = a:3
   let cmmnt    = ""
"   call Decho("scriptid<".scriptid.">")
"   call Decho("srcid   <".srcid.">")
"   call Decho("fname   <".fname.">")
  else
   let curline  = getline(".")
   if curline =~ '^\s*#'
    let @a= rega
"    call Dret("GetOneScript : skipping a pure comment line")
    return
   endif
   let parsepat = '^\s*\(\d\+\)\s\+\(\d\+\)\s\+\(.\{-}\)\(\s*#.*\)\=$'
   try
    let scriptid = substitute(curline,parsepat,'\1','e')
   catch /^Vim\%((\a\+)\)\=:E486/
    let scriptid= 0
   endtry
   try
    let srcid    = substitute(curline,parsepat,'\2','e')
   catch /^Vim\%((\a\+)\)\=:E486/
    let srcid= 0
   endtry
   try
    let fname= substitute(curline,parsepat,'\3','e')
   catch /^Vim\%((\a\+)\)\=:E486/
    let fname= ""
   endtry
   try
    let cmmnt= substitute(curline,parsepat,'\4','e')
   catch /^Vim\%((\a\+)\)\=:E486/
    let cmmnt= ""
   endtry
"   call Decho("curline <".curline.">")
"   call Decho("parsepat<".parsepat.">")
"   call Decho("scriptid<".scriptid.">")
"   call Decho("srcid   <".srcid.">")
"   call Decho("fname   <".fname.">")
  endif

  " plugin author protection from downloading his/her own scripts atop their latest work
  if scriptid == 0 || srcid == 0
   " When looking for :AutoInstall: lines, skip scripts that have   0 0 scriptname
   let @a= rega
"   call Dret("GetOneScript : skipping a scriptid==srcid==0 line")
   return
  endif

  let doautoinstall= 0
  if fname =~ ":AutoInstall:"
"   call Decho("case AutoInstall: fname<".fname.">")
   let aicmmnt= substitute(fname,'\s\+:AutoInstall:\s\+',' ','')
"   call Decho("aicmmnt<".aicmmnt."> s:autoinstall=".s:autoinstall)
   if s:autoinstall != ""
    let doautoinstall = g:GetLatestVimScripts_allowautoinstall
   endif
  else
   let aicmmnt= fname
  endif
"  call Decho("aicmmnt<".aicmmnt.">: doautoinstall=".doautoinstall)

  exe "norm z\<CR>"
  redraw!
"  call Decho('considering <'.aicmmnt.'> scriptid='.scriptid.' srcid='.srcid)
  echo 'considering <'.aicmmnt.'> scriptid='.scriptid.' srcid='.srcid

  " grab a copy of the plugin's vim.sourceforge.net webpage
  let scriptaddr = g:GetLatestVimScripts_scriptaddr.scriptid
  let tmpfile    = tempname()
  let v:errmsg   = ""

  " make up to three tries at downloading the description
  let itry= 1
  while itry <= 3
"   call Decho(".try#".itry." to download description of <".aicmmnt."> with addr=".scriptaddr)
   if has("win32") || has("win16") || has("win95")
"    call Decho(".new|exe silent r!".g:GetLatestVimScripts_wget." ".g:GetLatestVimScripts_options." ".shellescape(tmpfile).' '.shellescape(scriptaddr)."|bw!")
    new|exe "silent r!".g:GetLatestVimScripts_wget." ".g:GetLatestVimScripts_options." ".shellescape(tmpfile).' '.shellescape(scriptaddr)|bw!
   else
"    call Decho(".exe silent !".g:GetLatestVimScripts_wget." ".g:GetLatestVimScripts_options." ".shellescape(tmpfile)." ".shellescape(scriptaddr))
    exe "silent !".g:GetLatestVimScripts_wget." ".g:GetLatestVimScripts_options." ".shellescape(tmpfile)." ".shellescape(scriptaddr)
   endif
   if itry == 1
    exe "silent vsplit ".fnameescape(tmpfile)
   else
    silent! e %
   endif
   setlocal bh=wipe
  
   " find the latest source-id in the plugin's webpage
   silent! 1
   let findpkg= search('Click on the package to download','W')
   if findpkg > 0
    break
   endif
   let itry= itry + 1
  endwhile
"  call Decho(" --- end downloading tries while loop --- itry=".itry)

  " testing: did finding "Click on the package..." fail?
  if findpkg == 0 || itry >= 4
   silent q!
   call delete(tmpfile)
  " restore options
   let &t_ti        = t_ti
   let &t_te        = t_te
   let &rs          = rs
   let s:downerrors = s:downerrors + 1
"   call Decho("***warning*** couldn'".'t find "Click on the package..." in description page for <'.aicmmnt.">")
   echomsg "***warning*** couldn'".'t find "Click on the package..." in description page for <'.aicmmnt.">"
"   call Dret("GetOneScript : srch for /Click on the package/ failed")
   let @a= rega
   return
  endif
"  call Decho('found "Click on the package to download"')

  let findsrcid= search('src_id=','W')
  if findsrcid == 0
   silent q!
   call delete(tmpfile)
  " restore options
   let &t_ti        = t_ti
   let &t_te        = t_te
   let &rs          = rs
   let s:downerrors = s:downerrors + 1
"   call Decho("***warning*** couldn'".'t find "src_id=" in description page for <'.aicmmnt.">")
   echomsg "***warning*** couldn'".'t find "src_id=" in description page for <'.aicmmnt.">"
   let @a= rega
"  call Dret("GetOneScript : srch for /src_id/ failed")
   return
  endif
"  call Decho('found "src_id=" in description page')

  let srcidpat   = '^\s*<td class.*src_id=\(\d\+\)">\([^<]\+\)<.*$'
  let latestsrcid= substitute(getline("."),srcidpat,'\1','')
  let sname      = substitute(getline("."),srcidpat,'\2','') " script name actually downloaded
"  call Decho("srcidpat<".srcidpat."> latestsrcid<".latestsrcid."> sname<".sname.">")
  silent q!
  call delete(tmpfile)

  " convert the strings-of-numbers into numbers
  let srcid       = srcid       + 0
  let latestsrcid = latestsrcid + 0
"  call Decho("srcid=".srcid." latestsrcid=".latestsrcid." sname<".sname.">")

  " has the plugin's most-recent srcid increased, which indicates that it has been updated
  if latestsrcid > srcid
"   call Decho("[latestsrcid=".latestsrcid."] <= [srcid=".srcid."]: need to update <".sname.">")

   let s:downloads= s:downloads + 1
   if sname == bufname("%")
    " GetLatestVimScript has to be careful about downloading itself
    let sname= "NEW_".sname
   endif

   " -----------------------------------------------------------------------------
   " the plugin has been updated since we last obtained it, so download a new copy
   " -----------------------------------------------------------------------------
"   call Decho(".downloading new <".sname.">")
   echomsg ".downloading new <".sname.">"
   if has("win32") || has("win16") || has("win95")
"    call Decho(".new|exe silent r!".g:GetLatestVimScripts_wget." ".g:GetLatestVimScripts_options." ".shellescape(sname)." ".shellescape('http://vim.sourceforge.net/scripts/download_script.php?src_id='.latestsrcid)."|q")
    new|exe "silent r!".g:GetLatestVimScripts_wget." ".g:GetLatestVimScripts_options." ".shellescape(sname)." ".shellescape('http://vim.sourceforge.net/scripts/download_script.php?src_id='.latestsrcid)|q
   else
"    call Decho(".exe silent !".g:GetLatestVimScripts_wget." ".g:GetLatestVimScripts_options." ".shellescape(sname)." ".shellescape('http://vim.sourceforge.net/scripts/download_script.php?src_id='))
    exe "silent !".g:GetLatestVimScripts_wget." ".g:GetLatestVimScripts_options." ".shellescape(sname)." ".shellescape('http://vim.sourceforge.net/scripts/download_script.php?src_id=').latestsrcid
   endif

   " --------------------------------------------------------------------------
   " AutoInstall: only if doautoinstall has been requested by the plugin itself
   " --------------------------------------------------------------------------
"   call Decho("checking if plugin requested autoinstall: doautoinstall=".doautoinstall)
   if doautoinstall
"    call Decho(" ")
"    call Decho("Autoinstall: getcwd<".getcwd()."> filereadable(".sname.")=".filereadable(sname))
    if filereadable(sname)
"     call Decho("<".sname."> is readable")
"     call Decho("exe silent !".g:GetLatestVimScripts_mv." ".shellescape(sname)." ".shellescape(s:autoinstall))
     exe "silent !".g:GetLatestVimScripts_mv." ".shellescape(sname)." ".shellescape(s:autoinstall)
     let curdir    = fnameescape(substitute(getcwd(),'\','/','ge'))
     let installdir= curdir."/Installed"
     if !isdirectory(installdir)
      call mkdir(installdir)
     endif
"     call Decho("curdir<".curdir."> installdir<".installdir.">")
"     call Decho("exe cd ".fnameescape(s:autoinstall))
     exe "cd ".fnameescape(s:autoinstall)

     " determine target directory for moves
     let firstdir= substitute(&rtp,',.*$','','')
     let pname   = substitute(sname,'\..*','.vim','')
"     call Decho("determine tgtdir: is <".firstdir.'/AsNeeded/'.pname." readable?")
     if filereadable(firstdir.'/AsNeeded/'.pname)
      let tgtdir= "AsNeeded"
     else
      let tgtdir= "plugin"
     endif
"     call Decho("tgtdir<".tgtdir.">  pname<".pname.">")
     
     " decompress
     if sname =~ '\.bz2$'
"      call Decho("decompress: attempt to bunzip2 ".sname)
      exe "sil !bunzip2 ".shellescape(sname)
      let sname= substitute(sname,'\.bz2$','','')
"      call Decho("decompress: new sname<".sname."> after bunzip2")
     elseif sname =~ '\.gz$'
"      call Decho("decompress: attempt to gunzip ".sname)
      exe "sil !gunzip ".shellescape(sname)
      let sname= substitute(sname,'\.gz$','','')
"      call Decho("decompress: new sname<".sname."> after gunzip")
     elseif sname =~ '\.xz$'
"      call Decho("decompress: attempt to unxz ".sname)
      exe "sil !unxz ".shellescape(sname)
      let sname= substitute(sname,'\.xz$','','')
"      call Decho("decompress: new sname<".sname."> after unxz")
     else
"      call Decho("no decompression needed")
     endif
     
     " distribute archive(.zip, .tar, .vba, ...) contents
     if sname =~ '\.zip$'
"      call Decho("dearchive: attempt to unzip ".sname)
      exe "silent !unzip -o ".shellescape(sname)
     elseif sname =~ '\.tar$'
"      call Decho("dearchive: attempt to untar ".sname)
      exe "silent !tar -xvf ".shellescape(sname)
     elseif sname =~ '\.tgz$'
"      call Decho("dearchive: attempt to untar+gunzip ".sname)
      exe "silent !tar -zxvf ".shellescape(sname)
     elseif sname =~ '\.taz$'
"      call Decho("dearchive: attempt to untar+uncompress ".sname)
      exe "silent !tar -Zxvf ".shellescape(sname)
     elseif sname =~ '\.tbz$'
"      call Decho("dearchive: attempt to untar+bunzip2 ".sname)
      exe "silent !tar -jxvf ".shellescape(sname)
     elseif sname =~ '\.txz$'
"      call Decho("dearchive: attempt to untar+xz ".sname)
      exe "silent !tar -Jxvf ".shellescape(sname)
     elseif sname =~ '\.vba$'
"      call Decho("dearchive: attempt to handle a vimball: ".sname)
      silent 1split
      if exists("g:vimball_home")
       let oldvimballhome= g:vimball_home
      endif
      let g:vimball_home= s:autoinstall
      exe "silent e ".fnameescape(sname)
      silent so %
      silent q
      if exists("oldvimballhome")
       let g:vimball_home= oldvimballhome
      else
       unlet g:vimball_home
      endif
     else
"      call Decho("no dearchiving needed")
     endif
     
     " ---------------------------------------------
     " move plugin to plugin/ or AsNeeded/ directory
     " ---------------------------------------------
     if sname =~ '.vim$'
"      call Decho("dearchive: attempt to simply move ".sname." to ".tgtdir)
      exe "silent !".g:GetLatestVimScripts_mv." ".shellescape(sname)." ".tgtdir
     else
"      call Decho("dearchive: move <".sname."> to installdir<".installdir.">")
      exe "silent !".g:GetLatestVimScripts_mv." ".shellescape(sname)." ".installdir
     endif
     if tgtdir != "plugin"
"      call Decho("exe silent !".g:GetLatestVimScripts_mv." plugin/".shellescape(pname)." ".tgtdir)
      exe "silent !".g:GetLatestVimScripts_mv." plugin/".shellescape(pname)." ".tgtdir
     endif
     
     " helptags step
     let docdir= substitute(&rtp,',.*','','e')."/doc"
"     call Decho("helptags: docdir<".docdir.">")
     exe "helptags ".fnameescape(docdir)
     exe "cd ".fnameescape(curdir)
    endif
    if fname !~ ':AutoInstall:'
     let modline=scriptid." ".latestsrcid." :AutoInstall: ".fname.cmmnt
    else
     let modline=scriptid." ".latestsrcid." ".fname.cmmnt
    endif
   else
    let modline=scriptid." ".latestsrcid." ".fname.cmmnt
   endif

   " update the data in the <GetLatestVimScripts.dat> file
   call setline(line("."),modline)
"   call Decho("update data in ".expand("%")."#".line(".").": modline<".modline.">")
"  else " Decho
"   call Decho("[latestsrcid=".latestsrcid."] <= [srcid=".srcid."], no need to update")
  endif

 " restore options
  let &t_ti = t_ti
  let &t_te = t_te
  let &rs   = rs
  let @a    = rega
"  call Dredir("BUFFER TEST (GetOneScript)","ls!")

"  call Dret("GetOneScript")
endfun

" ---------------------------------------------------------------------
" Restore Options: {{{1
let &cpo= s:keepcpo
unlet s:keepcpo

" ---------------------------------------------------------------------
"  Modelines: {{{1
" vim: ts=8 sts=2 fdm=marker nowrap
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   "------------------------------------------------------------------------------
"  Description: Vim Ada/GNAT compiler file
"     Language: Ada (GNAT)
"          $Id: gnat.vim 887 2008-07-08 14:29:01Z krischik $
"    Copyright: Copyright (C) 2006 Martin Krischik
"   Maintainer:	Martin Krischi <krischik@users.sourceforge.net>k
"		Ned Okie <nokie@radford.edu>
"      $Author: krischik $
"        $Date: 2008-07-08 16:29:01 +0200 (Di, 08 Jul 2008) $
"      Version: 4.6
"    $Revision: 887 $
"     $HeadURL: https://gnuada.svn.sourceforge.net/svnroot/gnuada/trunk/tools/vim/autoload/gnat.vim $
"      History: 24.05.2006 MK Unified Headers
"		16.07.2006 MK Ada-Mode as vim-ball
"		05.08.2006 MK Add session support
"               15.10.2006 MK Bram's suggestion for runtime integration
"               05.11.2006 MK Bram suggested not to use include protection for
"                             autoload
"		05.11.2006 MK Bram suggested to save on spaces
"		19.09.2007 NO use project file only when there is a project
"    Help Page: compiler-gnat
"------------------------------------------------------------------------------

if version < 700
    finish
endif

function gnat#Make () dict					     " {{{1
   let &l:makeprg	 = self.Get_Command('Make')
   let &l:errorformat = self.Error_Format
   wall
   make
   copen
   set wrap
   wincmd W
endfunction gnat#Make						     " }}}1

function gnat#Pretty () dict					     " {{{1
   execute "!" . self.Get_Command('Pretty')
endfunction gnat#Make						     " }}}1

function gnat#Find () dict					     " {{{1
   execute "!" . self.Get_Command('Find')
endfunction gnat#Find						     " }}}1

function gnat#Tags () dict					     " {{{1
   execute "!" . self.Get_Command('Tags')
   edit tags
   call gnat#Insert_Tags_Header ()
   update
   quit
endfunction gnat#Tags						     " }}}1

function gnat#Set_Project_File (...) dict			     " {{{1
   if a:0 > 0
      let self.Project_File = a:1

      if ! filereadable (self.Project_File)
	 let self.Project_File = findfile (
	    \ fnamemodify (self.Project_File, ':r'),
	    \ $ADA_PROJECT_PATH,
	    \ 1)
      endif
   elseif strlen (self.Project_File) > 0
      let self.Project_File = browse (0, 'GNAT Project File?', '', self.Project_File)
   elseif expand ("%:e") == 'gpr'
      let self.Project_File = browse (0, 'GNAT Project File?', '', expand ("%:e"))
   else
      let self.Project_File = browse (0, 'GNAT Project File?', '', 'default.gpr')
   endif

   if strlen (v:this_session) > 0
      execute 'mksession! ' . v:this_session
   endif

   "if strlen (self.Project_File) > 0
      "if has("vms")
	 "call ada#Switch_Session (
	    "\ expand('~')[0:-2] . ".vimfiles.session]gnat_" .
	    "\ fnamemodify (self.Project_File, ":t:r") . ".vim")
      "else
	 "call ada#Switch_Session (
	    "\ expand('~') . "/vimfiles/session/gnat_" .
	    "\ fnamemodify (self.Project_File, ":t:r") . ".vim")
      "endif
   "else
      "call ada#Switch_Session ('')
   "endif

   return
endfunction gnat#Set_Project_File				     " }}}1

function gnat#Get_Command (Command) dict			     " {{{1
   let l:Command = eval ('self.' . a:Command . '_Command')
   return eval (l:Command)
endfunction gnat#Get_Command					     " }}}1

function gnat#Set_Session (...) dict				     " {{{1
   if argc() == 1 && fnamemodify (argv(0), ':e') == 'gpr'
      call self.Set_Project_File (argv(0))
   elseif  strlen (v:servername) > 0
      call self.Set_Project_File (v:servername . '.gpr')
   endif
endfunction gnat#Set_Session					     " }}}1

function gnat#New ()						     " {{{1
   let l:Retval = {
      \ 'Make'	      : function ('gnat#Make'),
      \ 'Pretty'	      : function ('gnat#Pretty'),
      \ 'Find'	      : function ('gnat#Find'),
      \ 'Tags'	      : function ('gnat#Tags'),
      \ 'Set_Project_File' : function ('gnat#Set_Project_File'),
      \ 'Set_Session'      : function ('gnat#Set_Session'),
      \ 'Get_Command'      : function ('gnat#Get_Command'),
      \ 'Project_File'     : '',
      \ 'Make_Command'     : '"gnat make -P " . self.Project_File . "  -F -gnatef  "',
      \ 'Pretty_Command'   : '"gnat pretty -P " . self.Project_File . " "',
      \ 'Find_Program'     : '"gnat find -P " . self.Project_File . " -F "',
      \ 'Tags_Command'     : '"gnat xref -P " . self.Project_File . " -v  *.AD*"',
      \ 'Error_Format'     : '%f:%l:%c: %trror: %m,'   .
			   \ '%f:%l:%c: %tarning: %m,' .
			   \ '%f:%l:%c: (%ttyle) %m'}

   return l:Retval
endfunction gnat#New						  " }}}1

function gnat#Insert_Tags_Header ()				  " {{{1
   1insert
!_TAG_FILE_FORMAT       1	 /extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED       1	 /0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR    AdaCore	 /info@adacore.com/
!_TAG_PROGRAM_NAME      gnatxref //
!_TAG_PROGRAM_URL       http://www.adacore.com  /official site/
!_TAG_PROGRAM_VERSION   5.05w   //
.
   return
endfunction gnat#Insert_Tags_Header				  " }}}1

finish " 1}}}

"------------------------------------------------------------------------------
"   Copyright (C) 2006  Martin Krischik
"
"   Vim is Charityware - see ":help license" or uganda.txt for licence details.
"------------------------------------------------------------------------------
" vim: textwidth=0 wrap tabstop=8 shiftwidth=3 softtabstop=3 noexpandtab
" vim: foldmethod=marker
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             " Vim autoload file for editing compressed files.
" Maintainer: Bram Moolenaar <Bram@vim.org>
" Last Change: 2016 Sep 28

" These functions are used by the gzip plugin.

" Function to check that executing "cmd [-f]" works.
" The result is cached in s:have_"cmd" for speed.
fun s:check(cmd)
  let name = substitute(a:cmd, '\(\S*\).*', '\1', '')
  if !exists("s:have_" . name)
    let e = executable(name)
    if e < 0
      let r = system(name . " --version")
      let e = (r !~ "not found" && r != "")
    endif
    exe "let s:have_" . name . "=" . e
  endif
  exe "return s:have_" . name
endfun

" Set b:gzip_comp_arg to the gzip argument to be used for compression, based on
" the flags in the compressed file.
" The only compression methods that can be detected are max speed (-1) and max
" compression (-9).
fun s:set_compression(line)
  " get the Compression Method
  let l:cm = char2nr(a:line[2])
  " if it's 8 (DEFLATE), we can check for the compression level
  if l:cm == 8
    " get the eXtra FLags
    let l:xfl = char2nr(a:line[8])
    " max compression
    if l:xfl == 2
      let b:gzip_comp_arg = "-9"
    " min compression
    elseif l:xfl == 4
      let b:gzip_comp_arg = "-1"
    endif
  endif
endfun


" After reading compressed file: Uncompress text in buffer with "cmd"
fun gzip#read(cmd)
  " don't do anything if the cmd is not supported
  if !s:check(a:cmd)
    return
  endif

  " for gzip check current compression level and set b:gzip_comp_arg.
  silent! unlet b:gzip_comp_arg
  if a:cmd[0] == 'g'
    call s:set_compression(getline(1))
  endif

  " make 'patchmode' empty, we don't want a copy of the written file
  let pm_save = &pm
  set pm=
  " remove 'a' and 'A' from 'cpo' to avoid the alternate file changes
  let cpo_save = &cpo
  set cpo-=a cpo-=A
  " set 'modifiable'
  let ma_save = &ma
  setlocal ma
  " set 'write'
  let write_save = &write
  set write
  " Reset 'foldenable', otherwise line numbers get adjusted.
  if has("folding")
    let fen_save = &fen
    setlocal nofen
  endif

  " when filtering the whole buffer, it will become empty
  let empty = line("'[") == 1 && line("']") == line("$")
  let tmp = tempname()
  let tmpe = tmp . "." . expand("<afile>:e")
  if exists('*fnameescape')
    let tmp_esc = fnameescape(tmp)
    let tmpe_esc = fnameescape(tmpe)
  else
    let tmp_esc = escape(tmp, ' ')
    let tmpe_esc = escape(tmpe, ' ')
  endif
  " write the just read lines to a temp file "'[,']w tmp.gz"
  execute "silent '[,']w " . tmpe_esc
  " uncompress the temp file: call system("gzip -dn tmp.gz")
  call system(a:cmd . " " . s:escape(tmpe))
  if !filereadable(tmp)
    " uncompress didn't work!  Keep the compressed file then.
    echoerr "Error: Could not read uncompressed file"
    let ok = 0
  else
    let ok = 1
    " delete the compressed lines; remember the line number
    let l = line("'[") - 1
    if exists(":lockmarks")
      lockmarks '[,']d _
    else
      '[,']d _
    endif
    " read in the uncompressed lines "'[-1r tmp"
    " Use ++edit if the buffer was empty, keep the 'ff' and 'fenc' options.
    setlocal nobin
    if exists(":lockmarks")
      if empty
	execute "silent lockmarks " . l . "r ++edit " . tmp_esc
      else
	execute "silent lockmarks " . l . "r " . tmp_esc
      endif
    else
      execute "silent " . l . "r " . tmp_esc
    endif

    " if buffer became empty, delete trailing blank line
    if empty
      silent $delete _
      1
    endif
    " delete the temp file and the used buffers
    call delete(tmp)
    silent! exe "bwipe " . tmp_esc
    silent! exe "bwipe " . tmpe_esc
  endif
  " Store the OK flag, so that we can use it when writing.
  let b:uncompressOk = ok

  " Restore saved option values.
  let &pm = pm_save
  let &cpo = cpo_save
  let &l:ma = ma_save
  let &write = write_save
  if has("folding")
    let &l:fen = fen_save
  endif

  " When uncompressed the whole buffer, do autocommands
  if ok && empty
    if exists('*fnameescape')
      let fname = fnameescape(expand("%:r"))
    else
      let fname = escape(expand("%:r"), " \t\n*?[{`$\\%#'\"|!<")
    endif
    if &verbose >= 8
      execute "doau BufReadPost " . fname
    else
      execute "silent! doau BufReadPost " . fname
    endif
  endif
endfun

" After writing compressed file: Compress written file with "cmd"
fun gzip#write(cmd)
  if exists('b:uncompressOk') && !b:uncompressOk
    echomsg "Not compressing file because uncompress failed; reset b:uncompressOk to compress anyway"
  " don't do anything if the cmd is not supported
  elseif s:check(a:cmd)
    " Rename the file before compressing it.
    let nm = resolve(expand("<afile>"))
    let nmt = s:tempname(nm)
    if rename(nm, nmt) == 0
      if exists("b:gzip_comp_arg")
	call system(a:cmd . " " . b:gzip_comp_arg . " -- " . s:escape(nmt))
      else
	call system(a:cmd . " -- " . s:escape(nmt))
      endif
      call rename(nmt . "." . expand("<afile>:e"), nm)
    endif
  endif
endfun

" Before appending to compressed file: Uncompress file with "cmd"
fun gzip#appre(cmd)
  " don't do anything if the cmd is not supported
  if s:check(a:cmd)
    let nm = expand("<afile>")

    " for gzip check current compression level and set b:gzip_comp_arg.
    silent! unlet b:gzip_comp_arg
    if a:cmd[0] == 'g'
      call s:set_compression(readfile(nm, "b", 1)[0])
    endif

    " Rename to a weird name to avoid the risk of overwriting another file
    let nmt = expand("<afile>:p:h") . "/X~=@l9q5"
    let nmte = nmt . "." . expand("<afile>:e")
    if rename(nm, nmte) == 0
      if &patchmode != "" && getfsize(nm . &patchmode) == -1
	" Create patchmode file by creating the decompressed file new
	call system(a:cmd . " -c -- " . s:escape(nmte) . " > " . s:escape(nmt))
	call rename(nmte, nm . &patchmode)
      else
	call system(a:cmd . " -- " . s:escape(nmte))
      endif
      call rename(nmt, nm)
    endif
  endif
endfun

" find a file name for the file to be compressed.  Use "name" without an
" extension if possible.  Otherwise use a weird name to avoid overwriting an
" existing file.
fun s:tempname(name)
  let fn = fnamemodify(a:name, ":r")
  if !filereadable(fn) && !isdirectory(fn)
    return fn
  endif
  return fnamemodify(a:name, ":p:h") . "/X~=@l9q5"
endfun

fun s:escape(name)
  " shellescape() was added by patch 7.0.111
  if exists("*shellescape")
    return shellescape(a:name)
  endif
  return "'" . a:name . "'"
endfun

" vim: set sw=2 :
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   " Vim completion script
" Language:        Haskell
" Maintainer:      Daniel Campoverde <alx@sillybytes.net>
" URL:             https://github.com/alx741/haskellcomplete.vim
" Last Change:     2019 May 14

" Usage:           setlocal omnifunc=haskellcomplete#Complete


" Language extensions from:
"   https://hackage.haskell.org/package/Cabal-2.2.0.1/docs/Language-Haskell-Extension.html
"
" GHC options from:
"   https://downloads.haskell.org/~ghc/7.0.4/docs/html/users_guide/flag-reference.html
"   https://downloads.haskell.org/~ghc/8.4.3/docs/html/users_guide/flags.html



" Available completions
let b:completingLangExtension = 0
let b:completingOptionsGHC    = 0
let b:completingModule        = 0

function! haskellcomplete#Complete(findstart, base)
    if a:findstart
        let l:line = getline('.')
        let l:start = col('.') - 1

        if l:line =~ '^\s*{-#\s*LANGUAGE.*'
            while l:start >= 0 && l:line[l:start - 1] !~ '[, ]'
                let l:start -= 1
            endwhile
            let b:completingLangExtension = 1
            return l:start

        elseif l:line =~ '^\s*{-#\s*OPTIONS_GHC.*'
            while l:start >= 0 && l:line[l:start - 1] !~ '[, ]'
                let l:start -= 1
            endwhile
            let b:completingOptionsGHC = 1
            return l:start

        elseif l:line =~ '^\s*import\s*.*'
            while l:start >= 0 && l:line[l:start - 1] !~ ' '
                let l:start -= 1
            endwhile
            let b:completingModule = 1
            return l:start

        endif

        return start
    endif

    if b:completingLangExtension
        if a:base ==? ""
            " Return all possible Lang extensions
            return s:langExtensions
        else
            let l:matches = []
            for extension in s:langExtensions
                if extension =~? '^' . a:base
                    call add(l:matches, extension)
                endif
            endfor
            let b:completingLangExtension = 0
            return l:matches
        endif


    elseif b:completingOptionsGHC
        if a:base ==? ""
            " Return all possible GHC options
            return s:optionsGHC
        else
            let l:matches = []
            for flag in s:optionsGHC
                if flag =~? '^' . a:base
                    call add(l:matches, flag)
                endif
            endfor
            let b:completingOptionsGHC = 0
            return l:matches
        endif


    elseif b:completingModule
        if a:base ==? ""
            " Return all possible modules
            return s:commonModules
        else
            let l:matches = []
            for module in s:commonModules
                if module =~? '^' . a:base
                    call add(l:matches, module)
                endif
            endfor
            let b:completingModule = 0
            return l:matches
        endif

    endif

    return -1
endfunction

let s:langExtensions =
    \ [ "OverlappingInstances"
    \ , "UndecidableInstances"
    \ , "IncoherentInstances"
    \ , "DoRec"
    \ , "RecursiveDo"
    \ , "ParallelListComp"
    \ , "MultiParamTypeClasses"
    \ , "MonomorphismRestriction"
    \ , "FunctionalDependencies"
    \ , "Rank2Types"
    \ , "RankNTypes"
    \ , "PolymorphicComponents"
    \ , "ExistentialQuantification"
    \ , "ScopedTypeVariables"
    \ , "PatternSignatures"
    \ , "ImplicitParams"
    \ , "FlexibleContexts"
    \ , "FlexibleInstances"
    \ , "EmptyDataDecls"
    \ , "CPP"
    \ , "KindSignatures"
    \ , "BangPatterns"
    \ , "TypeSynonymInstances"
    \ , "TemplateHaskell"
    \ , "ForeignFunctionInterface"
    \ , "Arrows"
    \ , "Generics"
    \ , "ImplicitPrelude"
    \ , "NamedFieldPuns"
    \ , "PatternGuards"
    \ , "GeneralizedNewtypeDeriving"
    \ , "ExtensibleRecords"
    \ , "RestrictedTypeSynonyms"
    \ , "HereDocuments"
    \ , "MagicHash"
    \ , "TypeFamilies"
    \ , "StandaloneDeriving"
    \ , "UnicodeSyntax"
    \ , "UnliftedFFITypes"
    \ , "InterruptibleFFI"
    \ , "CApiFFI"
    \ , "LiberalTypeSynonyms"
    \ , "TypeOperators"
    \ , "RecordWildCards"
    \ , "RecordPuns"
    \ , "DisambiguateRecordFields"
    \ , "TraditionalRecordSyntax"
    \ , "OverloadedStrings"
    \ , "GADTs"
    \ , "GADTSyntax"
    \ , "MonoPatBinds"
    \ , "RelaxedPolyRec"
    \ , "ExtendedDefaultRules"
    \ , "UnboxedTuples"
    \ , "DeriveDataTypeable"
    \ , "DeriveGeneric"
    \ , "DefaultSignatures"
    \ , "InstanceSigs"
    \ , "ConstrainedClassMethods"
    \ , "PackageImports"
    \ , "ImpredicativeTypes"
    \ , "NewQualifiedOperators"
    \ , "PostfixOperators"
    \ , "QuasiQuotes"
    \ , "TransformListComp"
    \ , "MonadComprehensions"
    \ , "ViewPatterns"
    \ , "XmlSyntax"
    \ , "RegularPatterns"
    \ , "TupleSections"
    \ , "GHCForeignImportPrim"
    \ , "NPlusKPatterns"
    \ , "DoAndIfThenElse"
    \ , "MultiWayIf"
    \ , "LambdaCase"
    \ , "RebindableSyntax"
    \ , "ExplicitForAll"
    \ , "DatatypeContexts"
    \ , "MonoLocalBinds"
    \ , "DeriveFunctor"
    \ , "DeriveTraversable"
    \ , "DeriveFoldable"
    \ , "NondecreasingIndentation"
    \ , "SafeImports"
    \ , "Safe"
    \ , "Trustworthy"
    \ , "Unsafe"
    \ , "ConstraintKinds"
    \ , "PolyKinds"
    \ , "DataKinds"
    \ , "ParallelArrays"
    \ , "RoleAnnotations"
    \ , "OverloadedLists"
    \ , "EmptyCase"
    \ , "AutoDeriveTypeable"
    \ , "NegativeLiterals"
    \ , "BinaryLiterals"
    \ , "NumDecimals"
    \ , "NullaryTypeClasses"
    \ , "ExplicitNamespaces"
    \ , "AllowAmbiguousTypes"
    \ , "JavaScriptFFI"
    \ , "PatternSynonyms"
    \ , "PartialTypeSignatures"
    \ , "NamedWildCards"
    \ , "DeriveAnyClass"
    \ , "DeriveLift"
    \ , "StaticPointers"
    \ , "StrictData"
    \ , "Strict"
    \ , "ApplicativeDo"
    \ , "DuplicateRecordFields"
    \ , "TypeApplications"
    \ , "TypeInType"
    \ , "UndecidableSuperClasses"
    \ , "MonadFailDesugaring"
    \ , "TemplateHaskellQuotes"
    \ , "OverloadedLabels"
    \ , "TypeFamilyDependencies"
    \ , "DerivingStrategies"
    \ , "UnboxedSums"
    \ , "HexFloatLiterals"
    \ ]

let s:optionsGHC =
    \ [ "-n"
    \ , "-v"
    \ , "-vn"
    \ , "-c"
    \ , "-hcsuf"
    \ , "-hidir"
    \ , "-hisuf"
    \ , "-o"
    \ , "-odir"
    \ , "-ohi"
    \ , "-osuf"
    \ , "-stubdir"
    \ , "-outputdir"
    \ , "-keep-hc-file"
    \ , "-keep-llvm-file"
    \ , "-keep-s-file"
    \ , "-keep-raw-s-file"
    \ , "-keep-tmp-files"
    \ , "-tmpdir"
    \ , "-ddump-hi"
    \ , "-ddump-hi-diffs"
    \ , "-ddump-minimal-imports"
    \ , "-fforce-recomp"
    \ , "-fno-force-recomp"
    \ , "-fbreak-on-exception"
    \ , "-fno-break-on-exception"
    \ , "-fbreak-on-error"
    \ , "-fno-break-on-error"
    \ , "-fprint-evld-with-show"
    \ , "-fno-print-evld-with-show"
    \ , "-fprint-bind-result"
    \ , "-fno-print-bind-result"
    \ , "-fno-print-bind-contents"
    \ , "-fno-implicit-import-qualified"
    \ , "-package-name"
    \ , "-no-auto-link-packages"
    \ , "-fglasgow-exts"
    \ , "-fno-glasgow-exts"
    \ , "-XOverlappingInstances"
    \ , "-XNoOverlappingInstances"
    \ , "-XIncoherentInstances"
    \ , "-XNoIncoherentInstances"
    \ , "-XUndecidableInstances"
    \ , "-XNoUndecidableInstances"
    \ , "-fcontext-stack=Nn"
    \ , "-XArrows"
    \ , "-XNoArrows"
    \ , "-XDisambiguateRecordFields"
    \ , "-XNoDisambiguateRecordFields"
    \ , "-XForeignFunctionInterface"
    \ , "-XNoForeignFunctionInterface"
    \ , "-XGenerics"
    \ , "-XNoGenerics"
    \ , "-XImplicitParams"
    \ , "-XNoImplicitParams"
    \ , "-firrefutable-tuples"
    \ , "-fno-irrefutable-tuples"
    \ , "-XNoImplicitPrelude"
    \ , "-XImplicitPrelude"
    \ , "-XRebindableSyntax"
    \ , "-XNoRebindableSyntax"
    \ , "-XNoMonomorphismRestriction"
    \ , "-XMonomorphismRrestriction"
    \ , "-XNoNPlusKPatterns"
    \ , "-XNPlusKPatterns"
    \ , "-XNoMonoPatBinds"
    \ , "-XMonoPatBinds"
    \ , "-XRelaxedPolyRec"
    \ , "-XNoRelaxedPolyRec"
    \ , "-XExtendedDefaultRules"
    \ , "-XNoExtendedDefaultRules"
    \ , "-XOverloadedStrings"
    \ , "-XNoOverloadedStrings"
    \ , "-XGADTs"
    \ , "-XNoGADTs"
    \ , "-XTypeFamilies"
    \ , "-XNoTypeFamilies"
    \ , "-XScopedTypeVariables"
    \ , "-XNoScopedTypeVariables"
    \ , "-XMonoLocalBinds"
    \ , "-XNoMonoLocalBinds"
    \ , "-XTemplateHaskell"
    \ , "-XNoTemplateHaskell"
    \ , "-XQuasiQuotes"
    \ , "-XNoQuasiQuotes"
    \ , "-XBangPatterns"
    \ , "-XNoBangPatterns"
    \ , "-XCPP"
    \ , "-XNoCPP"
    \ , "-XPatternGuards"
    \ , "-XNoPatternGuards"
    \ , "-XViewPatterns"
    \ , "-XNoViewPatterns"
    \ , "-XUnicodeSyntax"
    \ , "-XNoUnicodeSyntax"
    \ , "-XMagicHash"
    \ , "-XNoMagicHash"
    \ , "-XNewQualifiedOperators"
    \ , "-XNoNewQualifiedOperators"
    \ , "-XExplicitForALl"
    \ , "-XNoExplicitForAll"
    \ , "-XPolymorphicComponents"
    \ , "-XNoPolymorphicComponents"
    \ , "-XRank2Types"
    \ , "-XNoRank2Types"
    \ , "-XRankNTypes"
    \ , "-XNoRankNTypes"
    \ , "-XImpredicativeTypes"
    \ , "-XNoImpredicativeTypes"
    \ , "-XExistentialQuantification"
    \ , "-XNoExistentialQuantification"
    \ , "-XKindSignatures"
    \ , "-XNoKindSignatures"
    \ , "-XEmptyDataDecls"
    \ , "-XNoEmptyDataDecls"
    \ , "-XParallelListComp"
    \ , "-XNoParallelListComp"
    \ , "-XTransformListComp"
    \ , "-XNoTransformListComp"
    \ , "-XUnliftedFFITypes"
    \ , "-XNoUnliftedFFITypes"
    \ , "-XLiberalTypeSynonyms"
    \ , "-XNoLiberalTypeSynonyms"
    \ , "-XTypeOperators"
    \ , "-XNoTypeOperators"
    \ , "-XDoRec"
    \ , "-XNoDoRec"
    \ , "-XRecursiveDo"
    \ , "-XNoRecursiveDo"
    \ , "-XPArr"
    \ , "-XNoPArr"
    \ , "-XRecordWildCards"
    \ , "-XNoRecordWildCards"
    \ , "-XNamedFieldPuns"
    \ , "-XNoNamedFieldPuns"
    \ , "-XDisambiguateRecordFields"
    \ , "-XNoDisambiguateRecordFields"
    \ , "-XUnboxedTuples"
    \ , "-XNoUnboxedTuples"
    \ , "-XStandaloneDeriving"
    \ , "-XNoStandaloneDeriving"
    \ , "-XDeriveDataTypeable"
    \ , "-XNoDeriveDataTypeable"
    \ , "-XGeneralizedNewtypeDeriving"
    \ , "-XNoGeneralizedNewtypeDeriving"
    \ , "-XTypeSynonymInstances"
    \ , "-XNoTypeSynonymInstances"
    \ , "-XFlexibleContexts"
    \ , "-XNoFlexibleContexts"
    \ , "-XFlexibleInstances"
    \ , "-XNoFlexibleInstances"
    \ , "-XConstrainedClassMethods"
    \ , "-XNoConstrainedClassMethods"
    \ , "-XMultiParamTypeClasses"
    \ , "-XNoMultiParamTypeClasses"
    \ , "-XFunctionalDependencies"
    \ , "-XNoFunctionalDependencies"
    \ , "-XPackageImports"
    \ , "-XNoPackageImports"
    \ , "-W"
    \ , "-w"
    \ , "-w"
    \ , "-Wall"
    \ , "-w"
    \ , "-Werror"
    \ , "-Wwarn"
    \ , "-Wwarn"
    \ , "-Werror"
    \ , "-fwarn-unrecognised-pragmas"
    \ , "-fno-warn-unrecognised-pragmas"
    \ , "-fwarn-warnings-deprecations"
    \ , "-fno-warn-warnings-deprecations"
    \ , "-fwarn-deprecated-flags"
    \ , "-fno-warn-deprecated-flags"
    \ , "-fwarn-duplicate-exports"
    \ , "-fno-warn-duplicate-exports"
    \ , "-fwarn-hi-shadowing"
    \ , "-fno-warn-hi-shadowing"
    \ , "-fwarn-implicit-prelude"
    \ , "-fno-warn-implicit-prelude"
    \ , "-fwarn-incomplete-patterns"
    \ , "-fno-warn-incomplete-patterns"
    \ , "-fwarn-incomplete-record-updates"
    \ , "-fno-warn-incomplete-record-updates"
    \ , "-fwarn-lazy-unlifted-bindings"
    \ , "-fno-warn-lazy-unlifted-bindings"
    \ , "-fwarn-missing-fields"
    \ , "-fno-warn-missing-fields"
    \ , "-fwarn-missing-import-lists"
    \ , "-fnowarn-missing-import-lists"
    \ , "-fwarn-missing-methods"
    \ , "-fno-warn-missing-methods"
    \ , "-fwarn-missing-signatures"
    \ , "-fno-warn-missing-signatures"
    \ , "-fwarn-name-shadowing"
    \ , "-fno-warn-name-shadowing"
    \ , "-fwarn-orphans"
    \ , "-fno-warn-orphans"
    \ , "-fwarn-overlapping-patterns"
    \ , "-fno-warn-overlapping-patterns"
    \ , "-fwarn-tabs"
    \ , "-fno-warn-tabs"
    \ , "-fwarn-type-defaults"
    \ , "-fno-warn-type-defaults"
    \ , "-fwarn-monomorphism-restriction"
    \ , "-fno-warn-monomorphism-restriction"
    \ , "-fwarn-unused-binds"
    \ , "-fno-warn-unused-binds"
    \ , "-fwarn-unused-imports"
    dr  er  fr  gr  hr  ir  jr  kr  lr  mr  nr  or  pr  qr  rr  sr  tr  ur  vr  wr  xr  yr  zr  {r  |r  }r  ~r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r  r   r  ¡r  ¢r  £r  ¤r  ¥r  ¦r  §r  ¨r  ©r  ªr  «r  ¬r  ­r  ®r  ¯r  °r  ±r  ²r  ³r  ´r  µr  ¶r  ·r  ¸r  ¹r  ºr  »r  ¼r  ½r  ¾r  ¿r                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \ , "-fno-warn-unused-imports"
    \ , "-fwarn-unused-matches"
    \ , "-fno-warn-unused-matches"
    \ , "-fwarn-unused-do-bind"
    \ , "-fno-warn-unused-do-bind"
    \ , "-fwarn-wrong-do-bind"
    \ , "-fno-warn-wrong-do-bind"
    \ , "-O"
    \ , "-O0"
    \ , "-On"
    \ , "-O0"
    \ , "-fcase-merge"
    \ , "-fno-case-merge"
    \ , "-fmethod-sharing"
    \ , "-fno-method-sharing"
    \ , "-fdo-eta-reduction"
    \ , "-fno-do-eta-reduction"
    \ , "-fdo-lambda-eta-expansion"
    \ , "-fno-do-lambda-eta-expansion"
    \ , "-fexcess-precision"
    \ , "-fno-excess-precision"
    \ , "-fignore-asserts"
    \ , "-fno-ignore-asserts"
    \ , "-fignore-interface-pragmas"
    \ , "-fno-ignore-interface-pragmas"
    \ , "-fomit-interface-pragmas"
    \ , "-fno-omit-interface-pragmas"
    \ , "-fsimplifier-phases"
    \ , "-fmax-simplifier-iterations"
    \ , "-fcse"
    \ , "-fno-cse"
    \ , "-fspecialise"
    \ , "-fno-specialise"
    \ , "-ffull-laziness"
    \ , "-fno-full-laziness"
    \ , "-ffloat-in"
    \ , "-fno-float-in"
    \ , "-fenable-rewrite-rules"
    \ , "-fno-enable-rewrite-rules"
    \ , "-fstrictness"
    \ , "-fno-strictness"
    \ , "-fstrictness=before=n"
    \ , "-fspec-constr"
    \ , "-fno-spec-constr"
    \ , "-fliberate-case"
    \ , "-fno-liberate-case"
    \ , "-fstatic-argument-transformation"
    \ , "-fno-static-argument-transformation"
    \ , "-funbox-strict-fields"
    \ , "-fno-unbox-strict-fields"
    \ , "-feager-blackholing"
    \ , "-auto"
    \ , "-no-auto"
    \ , "-auto-all"
    \ , "-no-auto-all"
    \ , "-caf-all"
    \ , "-no-caf-all"
    \ , "-hpcdir"
    \ , "-F"
    \ , "-cpp"
    \ , "-Dsymbol[=value]"
    \ , "-Usymbol"
    \ , "-Usymbol"
    \ , "-Idir"
    \ , "-fasm"
    \ , "-fvia-C"
    \ , "-fvia-C"
    \ , "-fasm"
    \ , "-fllvm"
    \ , "-fasm"
    \ , "-fno-code"
    \ , "-fbyte-code"
    \ , "-fobject-code"
    \ , "-shared"
    \ , "-dynamic"
    \ , "-framework"
    \ , "-framework-path"
    \ , "-llib"
    \ , "-Ldir"
    \ , "-main-is"
    \ , "--mk-dll"
    \ , "-no-hs-main"
    \ , "-rtsopts,"
    \ , "-with-rtsopts=opts"
    \ , "-no-link"
    \ , "-split-objs"
    \ , "-fno-gen-manifest"
    \ , "-fno-embed-manifest"
    \ , "-fno-shared-implib"
    \ , "-dylib-install-name"
    \ , "-pgmL"
    \ , "-pgmP"
    \ , "-pgmc"
    \ , "-pgmm"
    \ , "-pgms"
    \ , "-pgma"
    \ , "-pgml"
    \ , "-pgmdll"
    \ , "-pgmF"
    \ , "-pgmwindres"
    \ , "-optL"
    \ , "-optP"
    \ , "-optF"
    \ , "-optc"
    \ , "-optlo"
    \ , "-optlc"
    \ , "-optm"
    \ , "-opta"
    \ , "-optl"
    \ , "-optdll"
    \ , "-optwindres"
    \ , "-msse2"
    \ , "-monly-[432]-regs"
    \ , "-fext-core"
    \ , "-dcore-lint"
    \ , "-ddump-asm"
    \ , "-ddump-bcos"
    \ , "-ddump-cmm"
    \ , "-ddump-cpranal"
    \ , "-ddump-cse"
    \ , "-ddump-deriv"
    \ , "-ddump-ds"
    \ , "-ddump-flatC"
    \ , "-ddump-foreign"
    \ , "-ddump-hpc"
    \ , "-ddump-inlinings"
    \ , "-ddump-llvm"
    \ , "-ddump-occur-anal"
    \ , "-ddump-opt-cmm"
    \ , "-ddump-parsed"
    \ , "-ddump-prep"
    \ , "-ddump-rn"
    \ , "-ddump-rules"
    \ , "-ddump-simpl"
    \ , "-ddump-simpl-phases"
    \ , "-ddump-simpl-iterations"
    \ , "-ddump-spec"
    \ , "-ddump-splices"
    \ , "-ddump-stg"
    \ , "-ddump-stranal"
    \ , "-ddump-tc"
    \ , "-ddump-types"
    \ , "-ddump-worker-wrapper"
    \ , "-ddump-if-trace"
    \ , "-ddump-tc-trace"
    \ , "-ddump-rn-trace"
    \ , "-ddump-rn-stats"
    \ , "-ddump-simpl-stats"
    \ , "-dsource-stats"
    \ , "-dcmm-lint"
    \ , "-dstg-lint"
    \ , "-dstg-stats"
    \ , "-dverbose-core2core"
    \ , "-dverbose-stg2stg"
    \ , "-dshow-passes"
    \ , "-dfaststring-stats"
    \ , "-fno-asm-mangling"
    \ , "-fno-ghci-sandbox"
    \ , "-fdiagnostics-color="
    \ , "-fdiagnostics-show-caret"
    \ , "-fno-diagnostics-show-caret"
    \ , "-ferror-spans"
    \ , "-fhide-source-paths"
    \ , "-fprint-equality-relations"
    \ , "-fno-print-equality-relations"
    \ , "-fprint-expanded-synonyms"
    \ , "-fno-print-expanded-synonyms"
    \ , "-fprint-explicit-coercions"
    \ , "-fno-print-explicit-coercions"
    \ , "-fprint-explicit-foralls"
    \ , "-fno-print-explicit-foralls"
    \ , "-fprint-explicit-kinds"
    \ , "-fno-print-explicit-kinds"
    \ , "-fprint-explicit-runtime-rep"
    \ , "-fno-print-explicit-runtime-reps"
    \ , "-fprint-explicit-runtime-reps"
    \ , "-fno-print-explicit-runtime-reps"
    \ , "-fprint-potential-instances"
    \ , "-fno-print-potential-instances"
    \ , "-fprint-typechecker-elaboration"
    \ , "-fno-print-typechecker-elaboration"
    \ , "-fprint-unicode-syntax"
    \ , "-fno-print-unicode-syntax"
    \ , "-fshow-hole-constraints"
    \ , "-Rghc-timing"
    \ , "-v"
    \ , "-v"
    \ , "-F"
    \ , "-x"
    \ , "--exclude-module="
    \ , "-ddump-mod-cycles"
    \ , "-dep-makefile"
    \ , "-dep-suffix"
    \ , "-dumpdir"
    \ , "-hcsuf"
    \ , "-hidir"
    \ , "-hisuf"
    \ , "-include-pkg-deps"
    \ , "-o"
    \ , "-odir"
    \ , "-ohi"
    \ , "-osuf"
    \ , "-outputdir"
    \ , "-stubdir"
    \ , "-keep-hc-file,"
    \ , "-keep-hi-files"
    \ , "-no-keep-hi-files"
    \ , "-keep-llvm-file,"
    \ , "-keep-o-files"
    \ , "-no-keep-o-files"
    \ , "-keep-s-file,"
    \ , "-keep-tmp-files"
    \ , "-tmpdir"
    \ , "-i"
    \ , "-i[:]*"
    \ , "-ddump-hi"
    \ , "-ddump-hi-diffs"
    \ , "-ddump-minimal-imports"
    \ , "-fforce-recomp"
    \ , "-fno-force-recomp"
    \ , "-fignore-hpc-changes"
    \ , "-fno-ignore-hpc-changes"
    \ , "-fignore-optim-changes"
    \ , "-fno-ignore-optim-changes"
    \ , "-fbreak-on-error"
    \ , "-fno-break-on-error"
    \ , "-fbreak-on-exception"
    \ , "-fno-break-on-exception"
    \ , "-fghci-hist-size="
    \ , "-flocal-ghci-history"
    \ , "-fno-local-ghci-history"
    \ , "-fprint-bind-result"
    \ , "-fno-print-bind-result"
    \ , "-fshow-loaded-modules"
    \ , "-ghci-script"
    \ , "-ignore-dot-ghci"
    \ , "-interactive-print"
    \ , "-clear-package-db"
    \ , "-distrust"
    \ , "-distrust-all-packages"
    \ , "-fpackage-trust"
    \ , "-global-package-db"
    \ , "-hide-all-packages"
    \ , "-hide-package"
    \ , "-ignore-package"
    \ , "-no-auto-link-packages"
    \ , "-no-global-package-db"
    \ , "-no-user-package-db"
    \ , "-package"
    \ , "-package-db"
    \ , "-package-env"
    \ , "-package-id"
    \ , "-this-unit-id"
    \ , "-trust"
    \ , "-user-package-db"
    \ , "-fdefer-out-of-scope-variables"
    \ , "-fno-defer-out-of-scope-variables"
    \ , "-fdefer-type-errors"
    \ , "-fno-defer-type-errors"
    \ , "-fdefer-typed-holes"
    \ , "-fno-defer-typed-holes"
    \ , "-fhelpful-errors"
    \ , "-fno-helpful-errors"
    \ , "-fmax-pmcheck-iterations="
    \ , "-fshow-warning-groups"
    \ , "-fno-show-warning-groups"
    \ , "-W"
    \ , "-w"
    \ , "-w"
    \ , "-Wall"
    \ , "-w"
    \ , "-Wall-missed-specialisations"
    \ , "-Wno-all-missed-specialisations"
    \ , "-Wamp"
    \ , "-Wno-amp"
    \ , "-Wcompat"
    \ , "-Wno-compat"
    \ , "-Wcpp-undef"
    \ , "-Wdeferred-out-of-scope-variables"
    \ , "-Wno-deferred-out-of-scope-variables"
    \ , "-Wdeferred-type-errors"
    \ , "-Wno-deferred-type-errors"
    \ , "-Wdeprecated-flags"
    \ , "-Wno-deprecated-flags"
    \ , "-Wdeprecations"
    \ , "-Wno-deprecations"
    \ , "-Wdodgy-exports"
    \ , "-Wno-dodgy-exports"
    \ , "-Wdodgy-foreign-imports"
    \ , "-Wno-dodgy-foreign-import"
    \ , "-Wdodgy-imports"
    \ , "-Wno-dodgy-imports"
    \ , "-Wduplicate-constraints"
    \ , "-Wno-duplicate-constraints"
    \ , "-Wduplicate-exports"
    \ , "-Wno-duplicate-exports"
    \ , "-Wempty-enumerations"
    \ , "-Wno-empty-enumerations"
    \ , "-Werror"
    \ , "-Wwarn"
    \ , "-Weverything"
    \ , "-Whi-shadowing"
    \ , "-Wno-hi-shadowing"
    \ , "-Widentities"
    \ , "-Wno-identities"
    \ , "-Wimplicit-prelude"
    \ , "-Wno-implicit-prelude"
    \ , "-Wincomplete-patterns"
    \ , "-Wno-incomplete-patterns"
    \ , "-Wincomplete-record-updates"
    \ , "-Wno-incomplete-record-updates"
    \ , "-Wincomplete-uni-patterns"
    \ , "-Wno-incomplete-uni-patterns"
    \ , "-Winline-rule-shadowing"
    \ , "-Wno-inline-rule-shadowing"
    \ , "-Wmissed-specialisations"
    \ , "-Wno-missed-specialisations"
    \ , "-Wmissing-export-lists"
    \ , "-fnowarn-missing-export-lists"
    \ , "-Wmissing-exported-signatures"
    \ , "-Wno-missing-exported-signatures"
    \ , "-Wmissing-exported-sigs"
    \ , "-Wno-missing-exported-sigs"
    \ , "-Wmissing-fields"
    \ , "-Wno-missing-fields"
    \ , "-Wmissing-home-modules"
    \ , "-Wno-missing-home-modules"
    \ , "-Wmissing-import-lists"
    \ , "-fnowarn-missing-import-lists"
    \ , "-Wmissing-local-signatures"
    \ , "-Wno-missing-local-signatures"
    \ , "-Wmissing-local-sigs"
    \ , "-Wno-missing-local-sigs"
    \ , "-Wmissing-methods"
    \ , "-Wno-missing-methods"
    \ , "-Wmissing-monadfail-instances"
    \ , "-Wno-missing-monadfail-instances"
    \ , "-Wmissing-pattern-synonym-signatures"
    \ , "-Wno-missing-pattern-synonym-signatures"
    \ , "-Wmissing-signatures"
    \ , "-Wno-missing-signatures"
    \ , "-Wmonomorphism-restriction"
    \ , "-Wno-monomorphism-restriction"
    \ , "-Wname-shadowing"
    \ , "-Wno-name-shadowing"
    \ , "-Wno-compat"
    \ , "-Wcompat"
    \ , "-Wnoncanonical-monad-instances"
    \ , "-Wno-noncanonical-monad-instances"
    \ , "-Wnoncanonical-monadfail-instances"
    \ , "-Wno-noncanonical-monadfail-instances"
    \ , "-Wnoncanonical-monoid-instances"
    \ , "-Wno-noncanonical-monoid-instances"
    \ , "-Worphans"
    \ , "-Wno-orphans"
    \ , "-Woverflowed-literals"
    \ , "-Wno-overflowed-literals"
    \ , "-Woverlapping-patterns"
    \ , "-Wno-overlapping-patterns"
    \ , "-Wpartial-fields"
    \ , "-Wno-partial-fields"
    \ , "-Wpartial-type-signatures"
    \ , "-Wno-partial-type-signatures"
    \ , "-Wredundant-constraints"
    \ , "-Wno-redundant-constraints"
    \ , "-Wsafe"
    \ , "-Wno-safe"
    \ , "-Wsemigroup"
    \ , "-Wno-semigroup"
    \ , "-Wsimplifiable-class-constraints"
    \ , "-Wno-overlapping-patterns"
    \ , "-Wtabs"
    \ , "-Wno-tabs"
    \ , "-Wtrustworthy-safe"
    \ , "-Wno-safe"
    \ , "-Wtype-defaults"
    \ , "-Wno-type-defaults"
    \ , "-Wtyped-holes"
    \ , "-Wno-typed-holes"
    \ , "-Wunbanged-strict-patterns"
    \ , "-Wno-unbanged-strict-patterns"
    \ , "-Wunrecognised-pragmas"
    \ , "-Wno-unrecognised-pragmas"
    \ , "-Wunrecognised-warning-flags"
    \ , "-Wno-unrecognised-warning-flags"
    \ , "-Wunsafe"
    \ , "-Wno-unsafe"
    \ , "-Wunsupported-calling-conventions"
    \ , "-Wno-unsupported-calling-conventions"
    \ , "-Wunsupported-llvm-version"
    \ , "-Wno-monomorphism-restriction"
    \ , "-Wunticked-promoted-constructors"
    \ , "-Wno-unticked-promoted-constructors"
    \ , "-Wunused-binds"
    \ , "-Wno-unused-binds"
    \ , "-Wunused-do-bind"
    \ , "-Wno-unused-do-bind"
    \ , "-Wunused-foralls"
    \ , "-Wno-unused-foralls"
    \ , "-Wunused-imports"
    \ , "-Wno-unused-imports"
    \ , "-Wunused-local-binds"
    \ , "-Wno-unused-local-binds"
    \ , "-Wunused-matches"
    \ , "-Wno-unused-matches"
    \ , "-Wunused-pattern-binds"
    \ , "-Wno-unused-pattern-binds"
    \ , "-Wunused-top-binds"
    \ , "-Wno-unused-top-binds"
    \ , "-Wunused-type-patterns"
    \ , "-Wno-unused-type-patterns"
    \ , "-Wwarn"
    \ , "-Werror"
    \ , "-Wwarnings-deprecations"
    \ , "-Wno-warnings-deprecations"
    \ , "-Wwrong-do-bind"
    \ , "-Wno-wrong-do-bind"
    \ , "-O,"
    \ , "-O0"
    \ , "-O0"
    \ , "-O2"
    \ , "-O0"
    \ , "-Odph"
    \ , "-fcall-arity"
    \ , "-fno-call-arity"
    \ , "-fcase-folding"
    \ , "-fno-case-folding"
    \ , "-fcase-merge"
    \ , "-fno-case-merge"
    \ , "-fcmm-elim-common-blocks"
    \ , "-fno-cmm-elim-common-blocks"
    \ , "-fcmm-sink"
    \ , "-fno-cmm-sink"
    \ , "-fcpr-anal"
    \ , "-fno-cpr-anal"
    \ , "-fcross-module-specialise"
    \ , "-fno-cross-module-specialise"
    \ , "-fcse"
    \ , "-fno-cse"
    \ , "-fdicts-cheap"
    \ , "-fno-dicts-cheap"
    \ , "-fdicts-strict"
    \ , "-fno-dicts-strict"
    \ , "-fdmd-tx-dict-sel"
    \ , "-fno-dmd-tx-dict-sel"
    \ , "-fdo-eta-reduction"
    \ , "-fno-do-eta-reduction"
    \ , "-fdo-lambda-eta-expansion"
    \ , "-fno-do-lambda-eta-expansion"
    \ , "-feager-blackholing"
    \ , "-fenable-rewrite-rules"
    \ , "-fno-enable-rewrite-rules"
    \ , "-fexcess-precision"
    \ , "-fno-excess-precision"
    \ , "-fexitification"
    \ , "-fno-exitification"
    \ , "-fexpose-all-unfoldings"
    \ , "-fno-expose-all-unfoldings"
    \ , "-ffloat-in"
    \ , "-fno-float-in"
    \ , "-ffull-laziness"
    \ , "-fno-full-laziness"
    \ , "-ffun-to-thunk"
    \ , "-fno-fun-to-thunk"
    \ , "-fignore-asserts"
    \ , "-fno-ignore-asserts"
    \ , "-fignore-interface-pragmas"
    \ , "-fno-ignore-interface-pragmas"
    \ , "-flate-dmd-anal"
    \ , "-fno-late-dmd-anal"
    \ , "-fliberate-case"
    \ , "-fno-liberate-case"
    \ , "-fliberate-case-threshold="
    \ , "-fno-liberate-case-threshold"
    \ , "-fllvm-pass-vectors-in-regs"
    \ , "-fno-llvm-pass-vectors-in-regs"
    \ , "-floopification"
    \ , "-fno-loopification"
    \ , "-fmax-inline-alloc-size="
    \ , "-fmax-inline-memcpy-insns="
    \ , "-fmax-inline-memset-insns="
    \ , "-fmax-relevant-binds="
    \ , "-fno-max-relevant-bindings"
    \ , "-fmax-simplifier-iterations="
    \ , "-fmax-uncovered-patterns="
    \ , "-fmax-valid-substitutions="
    \ , "-fno-max-valid-substitutions"
    \ , "-fmax-worker-args="
    \ , "-fno-opt-coercion"
    \ , "-fno-pre-inlining"
    \ , "-fno-state-hack"
    \ , "-fomit-interface-pragmas"
    \ , "-fno-omit-interface-pragmas"
    \ , "-fomit-yields"
    \ , "-fno-omit-yields"
    \ , "-foptimal-applicative-do"
    \ , "-fno-optimal-applicative-do"
    \ , "-fpedantic-bottoms"
    \ , "-fno-pedantic-bottoms"
    \ , "-fregs-graph"
    \ , "-fno-regs-graph"
    \ , "-fregs-iterative"
    \ , "-fno-regs-iterative"
    \ , "-fsimpl-tick-factor="
    \ , "-fsimplifier-phases="
    \ , "-fsolve-constant-dicts"
    \ , "-fno-solve-constant-dicts"
    \ , "-fspec-constr"
    \ , "-fno-spec-constr"
    \ , "-fspec-constr-count="
    \ , "-fno-spec-constr-count"
    \ , "-fspec-constr-keen"
    \ , "-fno-spec-constr-keen"
    \ , "-fspec-constr-threshold="
    \ , "-fno-spec-constr-threshold"
    \ , "-fspecialise"
    \ , "-fno-specialise"
    \ , "-fspecialise-aggressively"
    \ , "-fno-specialise-aggressively"
    \ , "-fstatic-argument-transformation"
    \ , "-fno-static-argument-transformation"
    \ , "-fstg-cse"
    \ , "-fno-stg-cse"
    \ , "-fstrictness"
    \ , "-fno-strictness"
    \ , "-fstrictness-before="
    \ , "-funbox-small-strict-fields"
    \ , "-fno-unbox-small-strict-fields"
    \ , "-funbox-strict-fields"
    \ , "-fno-unbox-strict-fields"
    \ , "-funfolding-creation-threshold="
    \ , "-funfolding-dict-discount="
    \ , "-funfolding-fun-discount="
    \ , "-funfolding-keeness-factor="
    \ , "-funfolding-use-threshold="
    \ , "-fvectorisation-avoidance"
    \ , "-fno-vectorisation-avoidance"
    \ , "-fvectorise"
    \ , "-fno-vectorise"
    \ , "-fno-prof-auto"
    \ , "-fprof-auto"
    \ , "-fno-prof-cafs"
    \ , "-fprof-cafs"
    \ , "-fno-prof-count-entries"
    \ , "-fprof-count-entries"
    \ , "-fprof-auto"
    \ , "-fno-prof-auto"
    \ , "-fprof-auto-calls"
    \ , "-fno-prof-auto-calls"
    \ , "-fprof-auto-exported"
    \ , "-fno-prof-auto"
    \ , "-fprof-auto-top"
    \ , "-fno-prof-auto"
    \ , "-fprof-cafs"
    \ , "-fno-prof-cafs"
    \ , "-prof"
    \ , "-ticky"
    \ , "-fhpc"
    \ , "-cpp"
    \ , "-D[=]"
    \ , "-U"
    \ , "-I"
    \ , "-U"
    \ , "-dynamic"
    \ , "-too"
    \ , "-fasm"
    \ , "-fllvm"
    \ , "-fbyte-code"
    \ , "-fllvm"
    \ , "-fasm"
    \ , "-fno-code"
    \ , "-fobject-code"
    \ , "-fPIC"
    \ , "-fPIE"
    \ , "-fwrite-interface"
    \ , "-debug"
    \ , "-dylib-install-name"
    \ , "-dynamic"
    \ , "-dynload"
    \ , "-eventlog"
    \ , "-fno-embed-manifest"
    \ , "-fno-gen-manifest"
    \ , "-fno-shared-implib"
    \ , "-framework"
    \ , "-framework-path"
    \ , "-fwhole-archive-hs-libs"
    \ , "-L"
    \ , "-l"
    \ , "-main-is"
    \ , "-no-hs-main"
    \ , "-no-rtsopts-suggestions"
    \ , "-package"
    \ , "-pie"
    \ , "-rdynamic"
    \ , "-rtsopts[=]"
    \ , "-shared"
    \ , "-split-objs"
    \ , "-split-sections"
    \ , "-static"
    \ , "-staticlib"
    \ , "-threaded"
    \ , "-with-rtsopts="
    \ , "-fplugin-opt=:"
    \ , "-fplugin="
    \ , "-hide-all-plugin-packages"
    \ , "-plugin-package"
    \ , "-plugin-package-id"
    \ , "-pgma"
    \ , "-pgmc"
    \ , "-pgmdll"
    \ , "-pgmF"
    \ , "-pgmi"
    \ , "-pgmL"
    \ , "-pgml"
    \ , "-pgmlc"
    \ , "-pgmlibtool"
    \ , "-pgmlo"
    \ , "-pgmP"
    \ , "-pgms"
    \ , "-pgmwindres"
    \ , "-opta"
    \ , "-optc"
    \ , "-optdll"
    \ , "-optF"
    \ , "-opti"
    \ , "-optL"
    \ , "-optl"
    \ , "-optlc"
    \ , "-optlo"
    \ , "-optP"
    \ , "-optwindres"
    \ , "-msse2"
    \ , "-msse4.2"
    \ , "-dcmm-lint"
    \ , "-dcore-lint"
    \ , "-ddump-asm"
    \ , "-ddump-asm-expanded"
    \ , "-ddump-asm-liveness"
    \ , "-ddump-asm-native"
    \ , "-ddump-asm-regalloc"
    \ , "-ddump-asm-regalloc-stages"
    \ , "-ddump-asm-stats"
    \ , "-ddump-bcos"
    \ , "-ddump-cmm"
    \ , "-ddump-cmm-caf"
    \ , "-ddump-cmm-cbe"
    \ , "-ddump-cmm-cfg"
    \ , "-ddump-cmm-cps"
    \ , "-ddump-cmm-from-stg"
    \ , "-ddump-cmm-info"
    \ , "-ddump-cmm-proc"
    \ , "-ddump-cmm-procmap"
    \ , "-ddump-cmm-raw"
    \ , "-ddump-cmm-sink"
    \ , "-ddump-cmm-sp"
    \ , "-ddump-cmm-split"
    \ , "-ddump-cmm-switch"
    \ , "-ddump-cmm-verbose"
    \ , "-ddump-core-stats"
    \ , "-ddump-cse"
    \ , "-ddump-deriv"
    \ , "-ddump-ds"
    \ , "-ddump-ec-trace"
    \ , "-ddump-foreign"
    \ , "-ddump-if-trace"
    \ , "-ddump-inlinings"
    \ , "-ddump-json"
    \ , "-ddump-llvm"
    \ , "-ddump-occur-anal"
    \ , "-ddump-opt-cmm"
    \ , "-ddump-parsed"
    \ , "-ddump-parsed-ast"
    \ , "-ddump-prep"
    \ , "-ddump-rn"
    \ , "-ddump-rn-ast"
    \ , "-ddump-rn-stats"
    \ , "-ddump-rn-trace"
    \ , "-ddump-rule-firings"
    \ , "-ddump-rule-rewrites"
    \ , "-ddump-rules"
    \ , "-ddump-simpl"
    \ , "-ddump-simpl-iterations"
    \ , "-ddump-simpl-stats"
    \ , "-ddump-spec"
    \ , "-ddump-splices"
    \ , "-ddump-stg"
    \ , "-ddump-str-signatures"
    \ , "-ddump-stranal"
    \ , "-ddump-tc"
    \ , "-ddump-tc-ast"
    \ , "-ddump-tc-trace"
    \ , "-ddump-timings"
    \ , "-ddump-to-file"
    \ , "-ddump-types"
    \ , "-ddump-vect"
    \ , "-ddump-vt-trace"
    \ , "-ddump-worker-wrapper"
    \ , "-dfaststring-stats"
    \ , "-dinitial-unique="
    \ , "-dno-debug-output"
    \ , "-ddebug-output"
    \ , "-dppr-case-as-let"
    \ , "-dppr-cols="
    \ , "-dppr-debug"
    \ , "-dppr-user-length"
    \ , "-dshow-passes"
    \ , "-dstg-lint"
    \ , "-dsuppress-all"
    \ , "-dsuppress-coercions"
    \ , "-dsuppress-idinfo"
    \ , "-dsuppress-module-prefixes"
    \ , "-dsuppress-stg-free-vars"
    \ , "-dsuppress-ticks"
    \ , "-dsuppress-type-applications"
    \ , "-dsuppress-type-signatures"
    \ , "-dsuppress-unfoldings"
    \ , "-dsuppress-uniques"
    \ , "-dsuppress-var-kinds"
    \ , "-dth-dec-file="
    \ , "-dunique-increment="
    \ , "-dverbose-core2core"
    \ , "-dverbose-stg2stg"
    \ , "-falignment-sanitisation"
    \ , "-fcatch-bottoms"
    \ , "-fllvm-fill-undef-with-garbage"
    \ , "-g,"
    \ , "-fexternal-interpreter"
    \ , "-fglasgow-exts"
    \ , "-fno-glasgow-exts"
    \ , "-ghcversion-file"
    \ , "-H"
    \ , "-j[]"
    \ ]

let s:commonModules =
    \ [ "Distribution.Backpack"
    \ , "Distribution.Backpack.ComponentsGraph"
    \ , "Distribution.Backpack.Configure"
    \ , "Distribution.Backpack.ConfiguredComponent"
    \ , "Distribution.Backpack.DescribeUnitId"
    \ , "Distribution.Backpack.FullUnitId"
    \ , "Distribution.Backpack.LinkedComponent"
    \ , "Distribution.Backpack.ModSubst"
    \ , "Distribution.Backpack.ModuleShape"
    \ , "Distribution.Backpack.PreModuleShape"
    \ , "Distribution.CabalSpecVersion"
    \ , "Distribution.Compat.Binary"
    \ , "Distribution.Compat.CharParsing"
    \ , "Distribution.Compat.CreatePipe"
    \ , "Distribution.Compat.DList"
    \ , "Distribution.Compat.Directory"
    \ , "Distribution.Compat.Environment"
    \ , "Distribution.Compat.Exception"
    \ , "Distribution.Compat.Graph"
    \ , "Distribution.Compat.Internal.TempFile"
    \ , "Distribution.Compat.Lens"
    \ , "Distribution.Compat.Map.Strict"
    \ , "Distribution.Compat.Newtype"
    \ , "Distribution.Compat.Parsing"
    \ , "Distribution.Compat.Prelude.Internal"
    \ , "Distribution.Compat.ReadP"
    \ , "Distribution.Compat.Semigroup"
    \ , "Distribution.Compat.Stack"
    \ , "Distribution.Compat.Time"
    \ , "Distribution.Compiler"
    \ , "Distribution.FieldGrammar"
    \ , "Distribution.FieldGrammar.Class"
    \ , "Distribution.FieldGrammar.FieldDescrs"
    \ , "Distribution.FieldGrammar.Parsec"
    \ , "Distribution.FieldGrammar.Pretty"
    \ , "Distribution.InstalledPackageInfo"
    \ , "Distribution.License"
    \ , "Distribution.Make"
    \ , "Distribution.ModuleName"
    \ , "Distribution.Package"
    \ , "Distribution.PackageDescription"
    \ , "Distribution.PackageDescription.Check"
    \ , "Distribution.PackageDescription.Configuration"
    \ , "Distribution.PackageDescription.FieldGrammar"
    \ , "Distribution.PackageDescription.Parsec"
    \ , "Distribution.PackageDescription.PrettyPrint"
    \ , "Distribution.PackageDescription.Quirks"
    \ , "Distribution.PackageDescription.Utils"
    \ , "Distribution.ParseUtils"
    \ , "Distribution.Parsec.Class"
    \ , "Distribution.Parsec.Common"
    \ , "Distribution.Parsec.ConfVar"
    \ , "Distribution.Parsec.Field"
    \ , "Distribution.Parsec.FieldLineStream"
    \ , "Distribution.Parsec.Lexer"
    \ , "Distribution.Parsec.LexerMonad"
    \ , "Distribution.Parsec.Newtypes"
    \ , "Distribution.Parsec.ParseResult"
    \ , "Distribution.Parsec.Parser"
    \ , "Distribution.Pretty"
    \ , "Distribution.PrettyUtils"
    \ , "Distribution.ReadE"
    \ , "Distribution.SPDX"
    \ , "Distribution.SPDX.License"
    \ , "Distribution.SPDX.LicenseExceptionId"
    \ , "Distribution.SPDX.LicenseExpression"
    \ , "Distribution.SPDX.LicenseId"
    \ , "Distribution.SPDX.LicenseReference"
    \ , "Distribution.Simple"
    \ , "Distribution.Simple.Bench"
    \ , "Distribution.Simple.Build"
    \ , "Distribution.Simple.Build.Macros"
    \ , "Distribution.Simple.Build.PathsModule"
    \ , "Distribution.Simple.BuildPaths"
    \ , "Distribution.Simple.BuildTarget"
    \ , "Distribution.Simple.BuildToolDepends"
    \ , "Distribution.Simple.CCompiler"
    \ , "Distribution.Simple.Command"
    \ , "Distribution.Simple.Compiler"
    \ , "Distribution.Simple.Configure"
    \ , "Distribution.Simple.Doctest"
    \ , "Distribution.Simple.GHC"
    \ , "Distribution.Simple.GHCJS"
    \ , "Distribution.Simple.Haddock"
    \ , "Distribution.Simple.HaskellSuite"
    \ , "Distribution.Simple.Hpc"
    \ , "Distribution.Simple.Install"
    \ , "Distribution.Simple.InstallDirs"
    \ , "Distribution.Simple.JHC"
    \ , "Distribution.Simple.LHC"
    \ , "Distribution.Simple.LocalBuildInfo"
    \ , "Distribution.Simple.PackageIndex"
    \ , "Distribution.Simple.PreProcess"
    \ , "Distribution.Simple.PreProcess.Unlit"
    \ , "Distribution.Simple.Program"
    \ , "Distribution.Simple.Program.Ar"
    \ , "Distribution.Simple.Program.Builtin"
    \ , "Distribution.Simple.Program.Db"
    \ , "Distribution.Simple.Program.Find"
    \ , "Distribution.Simple.Program.GHC"
    \ , "Distribution.Simple.Program.HcPkg"
    \ , "Distribution.Simple.Program.Hpc"
    \ , "Distribution.Simple.Program.Internal"
    \ , "Distribution.Simple.Program.Ld"
    \ , "Distribution.Simple.Program.ResponseFile"
    \ , "Distribution.Simple.Program.Run"
    \ , "Distribution.Simple.Program.Script"
    \ , "Distribution.Simple.Program.Strip"
    \ , "Distribution.Simple.Program.Types"
    \ , "Distribution.Simple.Register"
    \ , "Distribution.Simple.Setup"
    \ , "Distribution.Simple.SrcDist"
    \ , "Distribution.Simple.Test"
    \ , "Distribution.Simple.Test.ExeV10"
    \ , "Distribution.Simple.Test.LibV09"
    \ , "Distribution.Simple.Test.Log"
    \ , "Distribution.Simple.UHC"
    \ , "Distribution.Simple.UserHooks"
    \ , "Distribution.Simple.Utils"
    \ , "Distribution.System"
    \ , "Distribution.TestSuite"
    \ , "Distribution.Text"
    \ , "Distribution.Types.AbiDependency"
    \ , "Distribution.Types.AbiHash"
    \ , "Distribution.Types.AnnotatedId"
    \ , "Distribution.Types.Benchmark"
    \ , "Distribution.Types.Benchmark.Lens"
    \ , "Distribution.Types.BenchmarkInterface"
    \ , "Distribution.Types.BenchmarkType"
    \ , "Distribution.Types.BuildInfo"
    \ , "Distribution.Types.BuildInfo.Lens"
    \ , "Distribution.Types.BuildType"
    \ , "Distribution.Types.Component"
    \ , "Distribution.Types.ComponentId"
    \ , "Distribution.Types.ComponentInclude"
    \ , "Distribution.Types.ComponentLocalBuildInfo"
    \ , "Distribution.Types.ComponentName"
    \ , "Distribution.Types.ComponentRequestedSpec"
    \ , "Distribution.Types.CondTree"
    \ , "Distribution.Types.Condition"
    \ , "Distribution.Types.Dependency"
    \ , "Distribution.Types.DependencyMap"
    \ , "Distribution.Types.ExeDependency"
    \ , "Distribution.Types.Executable"
    \ , "Distribution.Types.Executable.Lens"
    \ , "Distribution.Types.ExecutableScope"
    \ , "Distribution.Types.ExposedModule"
    \ , "Distribution.Types.ForeignLib"
    \ , "Distribution.Types.ForeignLib.Lens"
    \ , "Distribution.Types.ForeignLibOption"
    \ , "Distribution.Types.ForeignLibType"
    \ , "Distribution.Types.GenericPackageDescription"
    \ , "Distribution.Types.GenericPackageDescription.Lens"
    \ , "Distribution.Types.HookedBuildInfo"
    \ , "Distribution.Types.IncludeRenaming"
    \ , "Distribution.Types.InstalledPackageInfo"
    \ , "Distribution.Types.InstalledPackageInfo.FieldGrammar"
    \ , "Distribution.Types.InstalledPackageInfo.Lens"
    \ , "Distribution.Types.LegacyExeDependency"
    \ , "Distribution.Types.Lens"
    \ , "Distribution.Types.Library"
    \ , "Distribution.Types.Library.Lens"
    \ , "Distribution.Types.LocalBuildInfo"
    \ , "Distribution.Types.Mixin"
    \ , "Distribution.Types.Module"
    \ , "Distribution.Types.ModuleReexport"
    \ , "Distribution.Types.ModuleRenaming"
    \ , "Distribution.Types.MungedPackageId"
    \ , "Distribution.Types.MungedPackageName"
    \ , "Distribution.Types.PackageDescription"
    \ , "Distribution.Types.PackageDescription.Lens"
    \ , "Distribution.Types.PackageId"
    \ , "Distribution.Types.PackageId.Lens"
    \ , "Distribution.Types.PackageName"
    \ , "Distribution.Types.PkgconfigDependency"
    \ , "Distribution.Types.PkgconfigName"
    \ , "Distribution.Types.SetupBuildInfo"
    \ , "Distribution.Types.SetupBuildInfo.Lens"
    \ , "Distribution.Types.SourceRepo"
    \ , "Distribution.Types.SourceRepo.Lens"
    \ , "Distribution.Types.TargetInfo"
    \ , "Distribution.Types.TestSuite"
    \ , "Distribution.Types.TestSuite.Lens"
    \ , "Distribution.Types.TestSuiteInterface"
    \ , "Distribution.Types.TestType"
    \ , "Distribution.Types.UnitId"
    \ , "Distribution.Types.UnqualComponentName"
    \ , "Distribution.Types.Version"
    \ , "Distribution.Types.VersionInterval"
    \ , "Distribution.Types.VersionRange"
    \ , "Distribution.Utils.Generic"
    \ , "Distribution.Utils.IOData"
    \ , "Distribution.Utils.LogProgress"
    \ , "Distribution.Utils.MapAccum"
    \ , "Distribution.Utils.NubList"
    \ , "Distribution.Utils.Progress"
    \ , "Distribution.Utils.ShortText"
    \ , "Distribution.Verbosity"
    \ , "Distribution.Version"
    \ , "Language.Haskell.Extension"
    \ , "Graphics.GLU"
    \ , "Graphics.GLU.Callbacks"
    \ , "Graphics.GLU.Functions"
    \ , "Graphics.GLU.Tokens"
    \ , "Graphics.GLU.Types"
    \ , "Graphics.UI.GLUT"
    \ , "Graphics.UI.GLUT.Begin"
    \ , "Graphics.UI.GLUT.Callbacks"
    \ , "Graphics.UI.GLUT.Callbacks.Global"
    \ , "Graphics.UI.GLUT.Callbacks.Window"
    \ , "Graphics.UI.GLUT.Colormap"
    \ , "Graphics.UI.GLUT.Debugging"
    \ , "Graphics.UI.GLUT.DeviceControl"
    \ , "Graphics.UI.GLUT.Fonts"
    \ , "Graphics.UI.GLUT.GameMode"
    \ , "Graphics.UI.GLUT.Initialization"
    \ , "Graphics.UI.GLUT.Menu"
    \ , "Graphics.UI.GLUT.Objects"
    \ , "Graphics.UI.GLUT.Overlay"
    \ , "Graphics.UI.GLUT.State"
    \ , "Graphics.UI.GLUT.Window"
    \ , "Network.Browser"
    \ , "Network.BufferType"
    \ , "Network.HTTP"
    \ , "Network.HTTP.Auth"
    \ , "Network.HTTP.Base"
    \ , "Network.HTTP.Cookie"
    \ , "Network.HTTP.HandleStream"
    \ , "Network.HTTP.Headers"
    \ , "Network.HTTP.Proxy"
    \ , "Network.HTTP.Stream"
    \ , "Network.Stream"
    \ , "Network.StreamDebugger"
    \ , "Network.StreamSocket"
    \ , "Network.TCP"
    \ , "Test.HUnit"
    \ , "Test.HUnit.Base"
    \ , "Test.HUnit.Lang"
    \ , "Test.HUnit.Terminal"
    \ , "Test.HUnit.Text"
    \ , "Data.ObjectName"
    \ , "Graphics.Rendering.OpenGL"
    \ , "Graphics.Rendering.OpenGL.GL"
    \ , "Graphics.Rendering.OpenGL.GL.Antialiasing"
    \ , "Graphics.Rendering.OpenGL.GL.BeginEnd"
    \ , "Graphics.Rendering.OpenGL.GL.Bitmaps"
    \ , "Graphics.Rendering.OpenGL.GL.BufferObjects"
    \ , "Graphics.Rendering.OpenGL.GL.Clipping"
    \ , "Graphics.Rendering.OpenGL.GL.ColorSum"
    \ , "Graphics.Rendering.OpenGL.GL.Colors"
    \ , "Graphics.Rendering.OpenGL.GL.ConditionalRendering"
    \ , "Graphics.Rendering.OpenGL.GL.CoordTrans"
    \ , "Graphics.Rendering.OpenGL.GL.DebugOutput"
    \ , "Graphics.Rendering.OpenGL.GL.DisplayLists"
    \ , "Graphics.Rendering.OpenGL.GL.Evaluators"
    \ , "Graphics.Rendering.OpenGL.GL.Feedback"
    \ , "Graphics.Rendering.OpenGL.GL.FlushFinish"
    \ , "Graphics.Rendering.OpenGL.GL.Fog"
    \ , "Graphics.Rendering.OpenGL.GL.Framebuffer"
    \ , "Graphics.Rendering.OpenGL.GL.FramebufferObjects"
    \ , "Graphics.Rendering.OpenGL.GL.FramebufferObjects.Attachments"
    \ , "Graphics.Rendering.OpenGL.GL.FramebufferObjects.FramebufferObjects"
    \ , "Graphics.Rendering.OpenGL.GL.FramebufferObjects.Queries"
    \ , "Graphics.Rendering.OpenGL.GL.FramebufferObjects.RenderbufferObjects"
    \ , "Graphics.Rendering.OpenGL.GL.Hints"
    \ , "Graphics.Rendering.OpenGL.GL.LineSegments"
    \ , "Graphics.Rendering.OpenGL.GL.PerFragment"
    \ , "Graphics.Rendering.OpenGL.GL.PixelRectangles"
    \ , "Graphics.Rendering.OpenGL.GL.PixelRectangles.ColorTable"
    \ , "Graphics.Rendering.OpenGL.GL.PixelRectangles.Convolution"
    \ , "Graphics.Rendering.OpenGL.GL.PixelRectangles.Histogram"
    \ , "Graphics.Rendering.OpenGL.GL.PixelRectangles.Minmax"
    \ , "Graphics.Rendering.OpenGL.GL.PixelRectangles.PixelMap"
    \ , "Graphics.Rendering.OpenGL.GL.PixelRectangles.PixelStorage"
    \ , "Graphics.Rendering.OpenGL.GL.PixelRectangles.PixelTransfer"
    \ , "Graphics.Rendering.OpenGL.GL.PixelRectangles.Rasterization"
    \ , "Graphics.Rendering.OpenGL.GL.PixellikeObject"
    \ , "Graphics.Rendering.OpenGL.GL.Points"
    \ , "Graphics.Rendering.OpenGL.GL.Polygons"
    \ , "Graphics.Rendering.OpenGL.GL.PrimitiveMode"
    \ , "Graphics.Rendering.OpenGL.GL.QueryObjects"
    \ , "Graphics.Rendering.OpenGL.GL.RasterPos"
    \ , "Graphics.Rendering.OpenGL.GL.ReadCopyPixels"
    \ , "Graphics.Rendering.OpenGL.GL.Rectangles"
    \ , "Graphics.Rendering.OpenGL.GL.SavingState"
    \ , "Graphics.Rendering.OpenGL.GL.Selection"
    \ , "Graphics.Rendering.OpenGL.GL.Shaders"
    \ , "Graphics.Rendering.OpenGL.GL.Shaders.Attribs"
    \ , "Graphics.Rendering.OpenGL.GL.Shaders.Limits"
    \ , "Graphics.Rendering.OpenGL.GL.Shaders.ProgramBinaries"
    \ , "Graphics.Rendering.OpenGL.GL.Shaders.ProgramObjects"
    \ , "Graphics.Rendering.OpenGL.GL.Shaders.ShaderBinaries"
    \ , "Graphics.Rendering.OpenGL.GL.Shaders.ShaderObjects"
    \ , "Graphics.Rendering.OpenGL.GL.Shaders.Uniform"
    \ , "Graphics.Rendering.OpenGL.GL.StringQueries"
    \ , "Graphics.Rendering.OpenGL.GL.SyncObjects"
    \ , "Graphics.Rendering.OpenGL.GL.Tensor"
    \ , "Graphics.Rendering.OpenGL.GL.Texturing"
    \ , "Graphics.Rendering.OpenGL.GL.Texturing.Application"
    \ , "Graphics.Rendering.OpenGL.GL.Texturing.Environments"
    \ , "Graphics.Rendering.OpenGL.GL.Texturing.Objects"
    \ , "Graphics.Rendering.OpenGL.GL.Texturing.Parameters"
    \ , "Graphics.Rendering.OpenGL.GL.Texturing.Queries"
    \ , "Graphics.Rendering.OpenGL.GL.Texturing.Specification"
    \ , "Graphics.Rendering.OpenGL.GL.TransformFeedback"
    \ , "Graphics.Rendering.OpenGL.GL.VertexArrayObjects"
    \ , "Graphics.Rendering.OpenGL.GL.VertexArrays"
    \ , "Graphics.Rendering.OpenGL.GL.VertexSpec"
    \ , "Graphics.Rendering.OpenGL.GLU"
    \ , "Graphics.Rendering.OpenGL.GLU.Errors"
    \ , "Graphics.Rendering.OpenGL.GLU.Initialization"
    \ , "Graphics.Rendering.OpenGL.GLU.Matrix"
    \ , "Graphics.Rendering.OpenGL.GLU.Mipmapping"
    \ , "Graphics.Rendering.OpenGL.GLU.NURBS"
    \ , "Graphics.Rendering.OpenGL.GLU.Quadrics"
    \ , "Graphics.Rendering.OpenGL.GLU.Tessellation"
    \ , "Graphics.GL"
    \ , "Graphics.GL.AMD"
    \ , "Graphics.GL.AMD.BlendMinmaxFactor"
    \ , "Graphics.GL.AMD.DebugOutput"
    \ , "Graphics.GL.AMD.DepthClampSeparate"
    \ , "Graphics.GL.AMD.DrawBuffersBlend"
    \ , "Graphics.GL.AMD.FramebufferMultisampleAdvanced"
    \ , "Graphics.GL.AMD.FramebufferSamplePositions"
    \ , "Graphics.GL.AMD.GPUShaderHalfFloat"
    \ , "Graphics.GL.AMD.GPUShaderInt64"
    \ , "Graphics.GL.AMD.InterleavedElements"
    \ , "Graphics.GL.AMD.MultiDrawIndirect"
    \ , "Graphics.GL.AMD.NameGenDelete"
    \ , "Graphics.GL.AMD.OcclusionQueryEvent"
    \ , "Graphics.GL.AMD.PerformanceMonitor"
    \ , "Graphics.GL.AMD.PinnedMemory"
    \ , "Graphics.GL.AMD.QueryBufferObject"
    \ , "Graphics.GL.AMD.SamplePositions"
    \ , "Graphics.GL.AMD.SeamlessCubemapPerTexture"
    \ , "Graphics.GL.AMD.SparseTexture"
    \ , "Graphics.GL.AMD.StencilOperationExtended"
    \ , "Graphics.GL.AMD.TransformFeedback4"
    \ , "Graphics.GL.AMD.VertexShaderTessellator"
    \ , "Graphics.GL.APPLE"
    \ , "Graphics.GL.APPLE.AuxDepthStencil"
    \ , "Graphics.GL.APPLE.ClientStorage"
    \ , "Graphics.GL.APPLE.ElementArray"
    \ , "Graphics.GL.APPLE.Fence"
    \ , "Graphics.GL.APPLE.FloatPixels"
    \ , "Graphics.GL.APPLE.FlushBufferRange"
    \ , "Graphics.GL.APPLE.ObjectPurgeable"
    \ , "Graphics.GL.APPLE.RGB422"
    \ , "Graphics.GL.APPLE.RowBytes"
    \ , "Graphics.GL.APPLE.SpecularVector"
    \ , "Graphics.GL.APPLE.TextureRange"
    \ , "Graphics.GL.APPLE.TransformHint"
    \ , "Graphics.GL.APPLE.VertexArrayObject"
    \ , "Graphics.GL.APPLE.VertexArrayRange"
    \ , "Graphics.GL.APPLE.VertexProgramEvaluators"
    \ , "Graphics.GL.APPLE.YCbCr422"
    \ , "Graphics.GL.ARB"
    \ , "Graphics.GL.ARB.BaseInstance"
    \ , "Graphics.GL.ARB.BindlessTexture"
    \ , "Graphics.GL.ARB.BlendFuncExtended"
    \ , "Graphics.GL.ARB.BufferStorage"
    \ , "Graphics.GL.ARB.CLEvent"
    \ , "Graphics.GL.ARB.ClearBufferObject"
    \ , "Graphics.GL.ARB.ClearTexture"
    \ , "Graphics.GL.ARB.ClipControl"
    \ , "Graphics.GL.ARB.ColorBufferFloat"
    \ , "Graphics.GL.ARB.CompressedTexturePixelStorage"
    \ , "Graphics.GL.ARB.ComputeShader"
    \ , "Graphics.GL.ARB.ComputeVariableGroupSize"
    \ , "Graphics.GL.ARB.ConditionalRenderInverted"
    \ , "Graphics.GL.ARB.CopyBuffer"
    \ , "Graphics.GL.ARB.CopyImage"
    \ , "Graphics.GL.ARB.CullDistance"
    \ , "Graphics.GL.ARB.DebugOutput"
    \ , "Graphics.GL.ARB.DepthBufferFloat"
    \ , "Graphics.GL.ARB.DepthClamp"
    \ , "Graphics.GL.ARB.DepthTexture"
    \ , "Graphics.GL.ARB.DirectStateAccess"
    \ , "Graphics.GL.ARB.DrawBuffers"
    \ , "Graphics.GL.ARB.DrawBuffersBlend"
    \ , "Graphics.GL.ARB.DrawElementsBaseVertex"
    \ , "Graphics.GL.ARB.DrawIndirect"
    \ , "Graphics.GL.ARB.DrawInstanced"
    \ , "Graphics.GL.ARB.ES2Compatibility"
    \ , "Graphics.GL.ARB.ES31Compatibility"
    \ , "Graphics.GL.ARB.ES32Compatibility"
    \ , "Graphics.GL.ARB.ES3Compatibility"
    \ , "Graphics.GL.ARB.EnhancedLayouts"
    \ , "Graphics.GL.ARB.ExplicitUniformLocation"
    \ , "Graphics.GL.ARB.FragmentProgram"
    \ , "Graphics.GL.ARB.FragmentShader"
    \ , "Graphics.GL.ARB.FramebufferNoAttachments"
    \ , "Graphics.GL.ARB.FramebufferObjectCompatibility"
    \ , "Graphics.GL.ARB.FramebufferObjectCore"
    \ , "Graphics.GL.ARB.FramebufferSRGB"
    \ , "Graphics.GL.ARB.GPUShader5"
    \ , "Graphics.GL.ARB.GPUShaderFP64"
    \ , "Graphics.GL.ARB.GPUShaderInt64"
    \ , "Graphics.GL.ARB.GeometryShader4"
    \ , "Graphics.GL.ARB.GetProgramBinary"
    \ , "Graphics.GL.ARB.GetTextureSubImage"
    \ , "Graphics.GL.ARB.GlSpirv"
    \ , "Graphics.GL.ARB.HalfFloatPixel"
    \ , "Graphics.GL.ARB.HalfFloatVertex"
    \ , "Graphics.GL.ARB.ImagingCompatibility"
    \ , "Graphics.GL.ARB.ImagingCore"
    \ , "Graphics.GL.ARB.IndirectParameters"
    \ , "Graphics.GL.ARB.InstancedArrays"
    \ , "Graphics.GL.ARB.InternalformatQuery"
    \ , "Graphics.GL.ARB.InternalformatQuery2"
    \ , "Graphics.GL.ARB.InvalidateSubdata"
    \ , "Graphics.GL.ARB.MapBufferAlignment"
    \ , "Graphics.GL.ARB.MapBufferRange"
    \ , "Graphics.GL.ARB.MatrixPalette"
    \ , "Graphics.GL.ARB.MultiBind"
    \ , "Graphics.GL.ARB.MultiDrawIndirect"
    \ , "Graphics.GL.ARB.Multisample"
    \ , "Graphics.GL.ARB.Multitexture"
    \ , "Graphics.GL.ARB.OcclusionQuery"
    \ , "Graphics.GL.ARB.OcclusionQuery2"
    \ , "Graphics.GL.ARB.ParallelShaderCompile"
    \ , "Graphics.GL.ARB.PipelineStatisticsQuery"
    \ , "Graphics.GL.ARB.PixelBufferObject"
    \ , "Graphics.GL.ARB.PointParameters"
    \ , "Graphics.GL.ARB.PointSprite"
    \ , "Graphics.GL.ARB.PolygonOffsetClamp"
    \ , "Graphics.GL.ARB.ProgramInterfaceQuery"
    \ , "Graphics.GL.ARB.ProvokingVertex"
    \ , "Graphics.GL.ARB.QueryBufferObject"
    \ , "Graphics.GL.ARB.RobustnessCompatibility"
    \ , "Graphics.GL.ARB.RobustnessCore"
    \ , "Graphics.GL.ARB.SampleLocations"
    \ , "Graphics.GL.ARB.SampleShading"
    \ , "Graphics.GL.ARB.SamplerObjects"
    \ , "Graphics.GL.ARB.SeamlessCubeMap"
    \ , "Graphics.GL.ARB.SeamlessCubemapPerTexture"
    \ , "Graphics.GL.ARB.SeparateShaderObjects"
    \ , "Graphics.GL.ARB.ShaderAtomicCounters"
    \ , "Graphics.GL.ARB.ShaderImageLoadStore"
    \ , "Graphics.GL.ARB.ShaderObjects"
    \ , "Graphics.GL.ARB.ShaderStorageBufferObject"
    \ , "Graphics.GL.ARB.ShaderSubroutine"
    \ , "Graphics.GL.ARB.ShadingLanguage100"
    \ , "Graphics.GL.ARB.ShadingLanguageInclude"
    \ , "Graphics.GL.ARB.Shadow"
    \ , "Graphics.GL.ARB.ShadowAmbient"
    \ , "Graphics.GL.ARB.SparseBuffer"
    \ , "Graphics.GL.ARB.SparseTexture"
    \ , "Graphics.GL.ARB.SpirvExtensions"
    \ , "Graphics.GL.ARB.StencilTexturing"
    \ , "Graphics.GL.ARB.Sync"
    \ , "Graphics.GL.ARB.TessellationShader"
    \ , "Graphics.GL.ARB.TextureBarrier"
    \ , "Graphics.GL.ARB.TextureBorderClamp"
    \ , "Graphics.GL.ARB.TextureBufferObject"
    \ , "Graphics.GL.ARB.TextureBufferObjectRGB32"
    \ , "Graphics.GL.ARB.TextureBufferRange"
    \ , "Graphics.GL.ARB.TextureCompression"
    \ , "Graphics.GL.ARB.TextureCompressionBPTC"
    \ , "Graphics.GL.ARB.TextureCompressionRGTC"
    \ , "Graphics.GL.ARB.TextureCubeMap"
    \ , "Graphics.GL.ARB.TextureCubeMapArray"
    \ , "Graphics.GL.ARB.TextureEnvCombine"
    \ , "Graphics.GL.ARB.TextureEnvDot3"
    \ , "Graphics.GL.ARB.TextureFilterAnisotropic"
    \ , "Graphics.GL.ARB.TextureFilterMinmax"
    \ , "Graphics.GL.ARB.TextureFloat"
    \ , "Graphics.GL.ARB.TextureGather"
    \ , "Graphics.GL.ARB.TextureMirrorClampToEdge"
    \ , "Graphics.GL.ARB.TextureMirroredRepeat"
    \ , "Graphics.GL.ARB.TextureMultisample"
    \ , "Graphics.GL.ARB.TextureRG"
    \ , "Graphics.GL.ARB.TextureRGB10A2UI"
    \ , "Graphics.GL.ARB.TextureRectangle"
    \ , "Graphics.GL.ARB.TextureStencil8"
    \ , "Graphics.GL.ARB.TextureStorage"
    \ , "Graphics.GL.ARB.TextureStorageMultisample"
    \ , "Graphics.GL.ARB.TextureSwizzle"
    \ , "Graphics.GL.ARB.TextureView"
    \ , "Graphics.GL.ARB.TimerQuery"
    \ , "Graphics.GL.ARB.TransformFeedback2"
    \ , "Graphics.GL.ARB.TransformFeedback3"
    \ , "Graphics.GL.ARB.TransformFeedbackInstanced"
    \ , "Graphics.GL.ARB.TransformFeedbackOverflowQuery"
    \ , "Graphics.GL.ARB.TransposeMatrix"
    \ , "Graphics.GL.ARB.UniformBufferObject"
    \ , "Graphics.GL.ARB.VertexArrayBGRA"
    \ , "Graphics.GL.ARB.VertexArrayObject"
    \ , "Graphics.GL.ARB.VertexAttrib64Bit"
    \ , "Graphics.GL.ARB.VertexAttribBinding"
    \ , "Graphics.GL.ARB.VertexBlend"
    \ , "Graphics.GL.ARB.VertexBufferObject"
    \ , "Graphics.GL.ARB.VertexProgram"
    \ , "Graphics.GL.ARB.VertexShader"
    \ , "Graphics.GL.ARB.VertexType10f11f11fRev"
    \ , "Graphics.GL.ARB.VertexType2101010RevCompatibility"
    \ , "Graphics.GL.ARB.VertexType2101010RevCore"
    \ , "Graphics.GL.ARB.ViewportArray"
    \ , "Graphics.GL.ARB.WindowPos"
    \ , "Graphics.GL.ATI"
    \ , "Graphics.GL.ATI.DrawBuffers"
    \ , "Graphics.GL.ATI.ElementArray"
    \ , "Graphics.GL.ATI.EnvmapBumpmap"
    \ , "Graphics.GL.ATI.FragmentShader"
    \ , "Graphics.GL.ATI.MapObjectBuffer"
    \ , "Graphics.GL.ATI.Meminfo"
    \ , "Graphics.GL.ATI.PNTriangles"
    \ , "Graphics.GL.ATI.PixelFormatFloat"
    \ , "Graphics.GL.ATI.SeparateStencil"
    \ , "Graphics.GL.ATI.TextFragmentShader"
    \ , "Graphics.GL.ATI.TextureEnvCombine3"
    \ , "Graphics.GL.ATI.TextureFloat"
    \ , "Graphics.GL.ATI.TextureMirrorOnce"
    \ , "Graphics.GL.ATI.VertexArrayObject"
    \ , "Graphics.GL.ATI.VertexAttribArrayObject"
    \ , "Graphics.GL.ATI.VertexStreams"
    \ , "Graphics.GL.Compatibility30"
    \ , "Graphics.GL.Compatibility31"
    \ , "Graphics.GL.Compatibility32"
    \ , "Graphics.GL.Compatibility33"
    \ , "Graphics.GL.Compatibility40"
    \ , "Graphics.GL.Compatibility41"
    \ , "Graphics.GL.Compatibility42"
    \ , "Graphics.GL.Compatibility43"
    \ , "Graphics.GL.Compatibility44"
    \ , "Graphics.GL.Compatibility45"
    \ , "Graphics.GL.Compatibility46"
    \ , "Graphics.GL.Core30"
    \ , "Graphics.GL.Core31"
    \ , "Graphics.GL.Core32"
    \ , "Graphics.GL.Core33"
    \ , "Graphics.GL.Core40"
    \ , "Graphics.GL.Core41"
    \ , "Graphics.GL.Core42"
    \ , "Graphics.GL.Core43"
    \ , "Graphics.GL.Core44"
    \ , "Graphics.GL.Core45"
    \ , "Graphics.GL.Core46"
    \ , "Graphics.GL.EXT"
    \ , "Graphics.GL.EXT.ABGR"
    \ , "Graphics.GL.EXT.BGRA"
    \ , "Graphics.GL.EXT.BindableUniform"
    \ , "Graphics.GL.EXT.BlendColor"
    \ , "Graphics.GL.EXT.BlendEquationSeparate"
    \ , "Graphics.GL.EXT.BlendFuncSeparate"
    \ , "Graphics.GL.EXT.BlendMinmax"
    \ , "Graphics.GL.EXT.BlendSubtract"
    \ , "Graphics.GL.EXT.CMYKA"
    \ , "Graphics.GL.EXT.ClipVolumeHint"
    \ , "Graphics.GL.EXT.ColorSubtable"
    \ , "Graphics.GL.EXT.CompiledVertexArray"
    \ , "Graphics.GL.EXT.Convolution"
    \ , "Graphics.GL.EXT.CoordinateFrame"
    \ , "Graphics.GL.EXT.CopyTexture"
    \ , "Graphics.GL.EXT.CullVertex"
    \ , "Graphics.GL.EXT.DebugLabel"
    \ , "Graphics.GL.EXT.DebugMarker"
    \ , "Graphics.GL.EXT.DepthBoundsTest"
    \ , "Graphics.GL.EXT.DirectStateAccess"
    \ , "Graphics.GL.EXT.DrawBuffers2"
    \ , "Graphics.GL.EXT.DrawInstanced"
    \ , "Graphics.GL.EXT.DrawRangeElements"
    \ , "Graphics.GL.EXT.EglImageStorage"
    \ , "Graphics.GL.EXT.ExternalBuffer"
    \ , "Graphics.GL.EXT.FogCoord"
    \ , "Graphics.GL.EXT.FourTwoTwoPixels"
    \ , "Graphics.GL.EXT.FramebufferBlit"
    \ , "Graphics.GL.EXT.FramebufferMultisample"
    \ , "Graphics.GL.EXT.FramebufferMultisampleBlitScaled"
    \ , "Graphics.GL.EXT.FramebufferObject"
    \ , "Graphics.GL.EXT.FramebufferSRGB"
    \ , "Graphics.GL.EXT.GPUProgramParameters"
    \ , "Graphics.GL.EXT.GPUShader4"
    \ , "Graphics.GL.EXT.GeometryShader4"
    \ , "Graphics.GL.EXT.Histogram"
    \ , "Graphics.GL.EXT.IndexArrayFormats"
    \ , "Graphics.GL.EXT.IndexFunc"
    \ , "Graphics.GL.EXT.IndexMaterial"
    \ , "Graphics.GL.EXT.LightTexture"
    \ , "Graphics.GL.EXT.MemoryObject"
    \ , "Graphics.GL.EXT.MemoryObjectFd"
    \ , "Graphics.GL.EXT.MemoryObjectWin32"
    \ , "Graphics.GL.EXT.MultiDrawArrays"
    \ , "Graphics.GL.EXT.Multisample"
    \ , "Graphics.GL.EXT.PackedDepthStencil"
    \ , "Graphics.GL.EXT.PackedFloat"
    \ , "Graphics.GL.EXT.PackedPixels"
    \ , "Graphics.GL.EXT.PalettedTexture"
    \ , "Graphics.GL.EXT.PixelBufferObject"
    \ , "Graphics.GL.EXT.PixelTransform"
    \ , "Graphics.GL.EXT.PointParameters"
    \ , "Graphics.GL.EXT.PolygonOffset"
    \ , "Graphics.GL.EXT.PolygonOffsetClamp"
    \ , "Graphics.GL.EXT.ProvokingVertex"
    \ , "Graphics.GL.EXT.RasterMultisample"
    \ , "Graphics.GL.EXT.RescaleNormal"
    \ , "Graphics.GL.EXT.SecondaryColor"
    \ , "Graphics.GL.EXT.Semaphore"
    \ , "Graphics.GL.EXT.SemaphoreFd"
    \ , "Graphics.GL.EXT.SemaphoreWin32"
    \ , "Graphics.GL.EXT.SeparateShaderObjects"
    \ , "Graphics.GL.EXT.SeparateSpecularColor"
    \ , "Graphics.GL.EXT.ShaderFramebufferFetch"
    \ , "Graphics.GL.EXT.ShaderFramebufferFetchNonCoherent"
    \ , "Graphics.GL.EXT.ShaderImageLoadStore"
    \ , "Graphics.GL.EXT.SharedTexturePalette"
    \ , "Graphics.GL.EXT.StencilClearTag"
    \ , "Graphics.GL.EXT.StencilTwoSide"
    \ , "Graphics.GL.EXT.StencilWrap"
    \ , "Graphics.GL.EXT.Subtexture"
    \ , "Graphics.GL.EXT.Texture"
    \ , "Graphics.GL.EXT.Texture3D"
    \ , "Graphics.GL.EXT.TextureArray"
    \ , "Graphics.GL.EXT.TextureBufferObject"
    \ , "Graphics.GL.EXT.TextureCompressionLATC"
    \ , "Graphics.GL.EXT.TextureCompressionRGTC"
    \ , "Graphics.GL.EXT.TextureCompressionS3TC"
    \ , "Graphics.GL.EXT.TextureCubeMap"
    \ , "Graphics.GL.EXT.TextureEnvCombine"
    \ , "Graphics.GL.EXT.TextureEnvDot3"
    \ , "Graphics.GL.EXT.TextureFilterAnisotropic"
    \ , "Graphics.GL.EXT.TextureFilterMinmax"
    \ , "Graphics.GL.EXT.TextureInteger"
    \ , "Graphics.GL.EXT.TextureLODBias"
    \ , "Graphics.GL.EXT.TextureMirrorClamp"
    \ , "Graphics.GL.EXT.TextureObject"
    \ , "Graphics.GL.EXT.TexturePerturbNormal"
    \ , "Graphics.GL.EXT.TextureSNorm"
    \ , "Graphics.GL.EXT.TextureSRGB"
    \ , "Graphics.GL.EXT.TextureSRGBDecode"
    \ , "Graphics.GL.EXT.TextureSharedExponent"
    \ , "Graphics.GL.EXT.TextureSwizzle"
    \ , "Graphics.GL.EXT.TimerQuery"
    \ , "Graphics.GL.EXT.TransformFeedback"
    \ , "Graphics.GL.EXT.VertexArray"
    \ , "Graphics.GL.EXT.VertexArrayBGRA"
    \ , "Graphics.GL.EXT.VertexAttrib64Bit"
    \ , "Graphics.GL.EXT.VertexShader"
    \ , "Graphics.GL.EXT.VertexWeighting"
    \ , "Graphics.GL.EXT.Win32KeyedMutex"
    \ , "Graphics.GL.EXT.WindowRectangles"
    \ , "Graphics.GL.EXT.X11SyncObject"
    \ , "Graphics.GL.Functions"
    \ , "Graphics.GL.GREMEDY"
    \ , "Graphics.GL.GREMEDY.FrameTerminator"
    \ , "Graphics.GL.GREMEDY.StringMarker"
    \ , "Graphics.GL.GetProcAddress"
    \ , "Graphics.GL.Groups"
    \ , "Graphics.GL.HP"
    \ , "Graphics.GL.HP.ConvolutionBorderModes"
    \ , "Graphics.GL.HP.ImageTransform"
    \ , "Graphics.GL.HP.OcclusionTest"
    \ , "Graphics.GL.HP.TextureLighting"
    \ , "Graphics.GL.IBM"
    \ , "Graphics.GL.IBM.CullVertex"
    \ , "Graphics.GL.IBM.MultimodeDrawArrays"
    \ , "Graphics.GL.IBM.RasterposClip"
    \ , "Graphics.GL.IBM.StaticData"
    \ , "Graphics.GL.IBM.TextureMirroredRepeat"
    \ , "Graphics.GL.IBM.VertexArrayLists"
    \ , "Graphics.GL.INGR"
    \ , "Graphics.GL.INGR.BlendFuncSeparate"
    \ , "Graphics.GL.INGR.ColorClamp"
    \ , "Graphics.GL.INGR.InterlaceRead"
    \ , "Graphics.GL.INTEL"
    \ , "Graphics.GL.INTEL.BlackholeRender"
    \ , "Graphics.GL.INTEL.ConservativeRasterization"
    \ , "Graphics.GL.INTEL.FramebufferCmaa"
    \ , "Graphics.GL.INTEL.MapTexture"
    \ , "Graphics.GL.INTEL.ParallelArrays"
    \ , "Graphics.GL.INTEL.PerformanceQuery"
    \ , "Graphics.GL.KHR"
    \ , "Graphics.GL.KHR.BlendEquationAdvanced"
    \ , "Graphics.GL.KHR.BlendEquationAdvancedCoherent"
    \ , "Graphics.GL.KHR.ContextFlushControl"
    \ , "Graphics.GL.KHR.DebugCompatibility"
    \ , "Graphics.GL.KHR.DebugCore"
    \ , "Graphics.GL.KHR.NoError"
    \ , "Graphics.GL.KHR.ParallelShaderCompile"
    \ , "Graphics.GL.KHR.Robustness"
    \ , "Graphics.GL.KHR.TextureCompressionASTCHDR"
    \ , "Graphics.GL.KHR.TextureCompressionASTCLDR"
    \ , "Graphics.GL.MESA"
    \ , "Graphics.GL.MESA.PackInvert"
    \ , "Graphics.GL.MESA.ProgramBinaryFormats"
    \ , "Graphics.GL.MESA.ResizeBuffers"
    \ , "Graphics.GL.MESA.TileRasterOrder"
    \ , "Graphics.GL.MESA.WindowPos"
    \ , "Graphics.GL.MESA.YCbCrTexture"
    \ , "Graphics.GL.MESAX"
    \ , "Graphics.GL.MESAX.TextureStack"
    \ , "Graphics.GL.NV"
    \ , "Graphics.GL.NV.AlphaToCoverageDitherControl"
    \ , "Graphics.GL.NV.BindlessMultiDrawIndirect"
    \ , "Graphics.GL.NV.BindlessMultiDrawIndirectCount"
    \ , "Graphics.GL.NV.BindlessTexture"
    \ , "Graphics.GL.NV.BlendEquationAdvanced"
    \ , "Graphics.GL.NV.BlendEquationAdvancedCoherent"
    \ , "Graphics.GL.NV.BlendMinmaxFactor"
    \ , "Graphics.GL.NV.ClipSpaceWScaling"
    \ , "Graphics.GL.NV.CommandList"
    \ , "Graphics.GL.NV.ComputeProgram5"
    \ , "Graphics.GL.NV.ConditionalRender"
    \ , "Graphics.GL.NV.ConservativeRaster"
    \ , "Graphics.GL.NV.ConservativeRasterDilate"
    \ , "Graphics.GL.NV.ConservativeRasterPreSnap"
    \ , "Graphics.GL.NV.ConservativeRasterPreSnapTriangles"
    \ , "Graphics.GL.NV.CopyDepthToColor"
    \ , "Graphics.GL.NV.CopyImage"
    \ , "Graphics.GL.NV.DeepTexture3D"
    \ , "Graphics.GL.NV.DepthBufferFloat"
    \ , "Graphics.GL.NV.DepthClamp"
    \ , "Graphics.GL.NV.DrawTexture"
    \ , "Graphics.GL.NV.DrawVulkanImage"
    \ , "Graphics.GL.NV.Evaluators"
    \ , "Graphics.GL.NV.ExplicitMultisample"
    \ , "Graphics.GL.NV.Fence"
    \ , "Graphics.GL.NV.FillRectangle"
    \ , "Graphics.GL.NV.FloatBuffer"
    \ , "Graphics.GL.NV.FogDistance"
    \ , "Graphics.GL.NV.FragmentCoverageToColor"
    \ , "Graphics.GL.NV.FragmentProgram"
    \ , "Graphics.GL.NV.FragmentProgram2"
    \ , "Graphics.GL.NV.FramebufferMixedSamples"
    \ , "Graphics.GL.NV.FramebufferMultisampleCoverage"
    \ , "Graphics.GL.NV.GPUMulticast"
    \ , "Graphics.GL.NV.GPUProgram4"
    \ , "Graphics.GL.NV.GPUProgram5"
    \ , "Graphics.GL.NV.GPUShader5"
    \ , "Graphics.GL.NV.GeometryProgram4"
    \ , "Graphics.GL.NV.HalfFloat"
    \ , "Graphics.GL.NV.InternalformatSampleQuery"
    \ , "Graphics.GL.NV.LightMaxExponent"
    \ , "Graphics.GL.NV.MultisampleCoverage"
    \ , "Graphics.GL.NV.MultisampleFilterHint"
    \ , "Graphics.GL.NV.OcclusionQuery"
    \ , "Graphics.GL.NV.PackedDepthStencil"
    \ , "Graphics.GL.NV.ParameterBufferObject"
    \ , "Graphics.GL.NV.PathRenderingCompatibility"
    \ , "Graphics.GL.NV.PathRenderingCore"
    \ , "Graphics.GL.NV.PathRenderingSharedEdge"
    \ , "Graphics.GL.NV.PixelDataRange"
    \ , "Graphics.GL.NV.PointSprite"
    \ , "Graphics.GL.NV.PresentVideo"
    \ , "Graphics.GL.NV.PrimitiveRestart"
    \ , "Graphics.GL.NV.QueryResource"
    \ , "Graphics.GL.NV.QueryResourceTag"
    \ , "Graphics.GL.NV.RegisterCombiners"
    \ , "Graphics.GL.NV.RegisterCombiners2"
    \ , "Graphics.GL.NV.RobustnessVideoMemoryPurge"
    \ , "Graphics.GL.NV.SampleLocations"
    \ , "Graphics.GL.NV.ShaderBufferLoad"
    \ , "Graphics.GL.NV.ShaderBufferStore"
    \ , "Graphics.GL.NV.ShaderThreadGroup"
    \ , "Graphics.GL.NV.TessellationProgram5"
    \ , "Graphics.GL.NV.TexgenEmboss"
    \ , "Graphics.GL.NV.TexgenReflection"
    \ , "Graphics.GL.NV.TextureBarrier"
    \ , "Graphics.GL.NV.TextureEnvCombine4"
    \ , "Graphics.GL.NV.TextureExpandNormal"
    \ , "Graphics.GL.NV.TextureMultisample"
    \ , "Graphics.GL.NV.TextureRectangle"
    \ , "Graphics.GL.NV.TextureShader"
    \ , "Graphics.GL.NV.TextureShader2"
    \ , "Graphics.GL.NV.TextureShader3"
    \ , "Graphics.GL.NV.TransformFeedback"
    \ , "Graphics.GL.NV.TransformFeedback2"
    \ , "Graphics.GL.NV.UniformBufferUnifiedMemory"
    \ , "Graphics.GL.NV.VDPAUInterop"
    \ , "Graphics.GL.NV.VertexArrayRange"
    \ , "Graphics.GL.NV.VertexArrayRange2"
    \ , "Graphics.GL.NV.VertexAttribInteger64Bit"
    \ , "Graphics.GL.NV.VertexBufferUnifiedMemory"
    \ , "Graphics.GL.NV.VertexProgram"
    \ , "Graphics.GL.NV.VertexProgram2Option"
    \ , "Graphics.GL.NV.VertexProgram3"
    \ , "Graphics.GL.NV.VertexProgram4"
    \ , "Graphics.GL.NV.VideoCapture"
    \ , "Graphics.GL.NV.ViewportSwizzle"
    \ , "Graphics.GL.NVX"
    \ , "Graphics.GL.NVX.ConditionalRender"
    \ , "Graphics.GL.NVX.GPUMemoryInfo"
    \ , "Graphics.GL.NVX.LinkedGPUMulticast"
    \ , "Graphics.GL.OES"
    \ , "Graphics.GL.OES.ByteCoordinates"
    \ , "Graphics.GL.OES.CompressedPalettedTexture"
    \ , "Graphics.GL.OES.FixedPoint"
    \ , "Graphics.GL.OES.QueryMatrix"
    \ , "Graphics.GL.OES.ReadFormat"
    \ , "Graphics.GL.OES.SinglePrecision"
    \ , "Graphics.GL.OML"
    \ , "Graphics.GL.OML.Interlace"
    \ , "Graphics.GL.OML.Resample"
    \ , "Graphics.GL.OML.Subsample"
    \ , "Graphics.GL.OVR"
    \ , "Graphics.GL.OVR.Multiview"
    \ , "Graphics.GL.PGI"
    \ , "Graphics.GL.PGI.MiscHints"
    \ , "Graphics.GL.PGI.VertexHints"
    \ , "Graphics.GL.REND"
    \ , "Graphics.GL.REND.ScreenCoordinates"
    \ , "Graphics.GL.S3"
    \ , "Graphics.GL.S3.S3TC"
    \ , "Graphics.GL.SGI"
    \ , "Graphics.GL.SGI.ColorMatrix"
    \ , "Graphics.GL.SGI.ColorTable"
    \ , "Graphics.GL.SGI.TextureColorTable"
    \ , "Graphics.GL.SGIS"
    \ , "Graphics.GL.SGIS.DetailTexture"
    \ , "Graphics.GL.SGIS.FogFunction"
    \ , "Graphics.GL.SGIS.GenerateMipmap"
    \ , "Graphics.GL.SGIS.Multisample"
    \ , "Graphics.GL.SGIS.PixelTexture"
    \ , "Graphics.GL.SGIS.PointLineTexgen"
    \ , "Graphics.GL.SGIS.PointParameters"
    \ , "Graphics.GL.SGIS.SharpenTexture"
    \ , "Graphics.GL.SGIS.Texture4D"
    \ , "Graphics.GL.SGIS.TextureBorderClamp"
    \ , "Graphics.GL.SGIS.TextureColorMask"
    \ , "Graphics.GL.SGIS.TextureEdgeClamp"
    \ , "Graphics.GL.SGIS.TextureFilter4"
    \ , "Graphics.GL.SGIS.TextureLOD"
    \ , "Graphics.GL.SGIS.TextureSelect"
    \ , "Graphics.GL.SGIX"
    \ , "Graphics.GL.SGIX.Async"
    \ , "Graphics.GL.SGIX.AsyncHistogram"
    \ , "Graphics.GL.SGIX.AsyncPixel"
    \ , "Graphics.GL.SGIX.BlendAlphaMinmax"
    \ , "Graphics.GL.SGIX.CalligraphicFragment"
    \ , "Graphics.GL.SGIX.Clipmap"
    \ , "Graphics.GL.SGIX.ConvolutionAccuracy"
    \ , "Graphics.GL.SGIX.DepthTexture"
    \ , "Graphics.GL.SGIX.FlushRaster"
    \ , "Graphics.GL.SGIX.FogOffset"
    \ , "Graphics.GL.SGIX.FragmentLighting"
    \ , "Graphics.GL.SGIX.Framezoom"
    \ , "Graphics.GL.SGIX.IglooInterface"
    \ , "Graphics.GL.SGIX.Instruments"
    \ , "Graphics.GL.SGIX.Interlace"
    \ , "Graphics.GL.SGIX.IrInstrument1"
    \ , "Graphics.GL.SGIX.ListPriority"
    \ , "Graphics.GL.SGIX.PixelTexture"
    \ , "Graphics.GL.SGIX.PixelTiles"
    \ , "Graphics.GL.SGIX.PolynomialFFD"
    \ , "Graphics.GL.SGIX.ReferencePlane"
    \ , "Graphics.GL.SGIX.Resample"
    \ , "Graphics.GL.SGIX.ScalebiasHint"
    \ , "Graphics.GL.SGIX.Shadow"
    \ , "Graphics.GL.SGIX.ShadowAmbient"
    \ , "Graphics.GL.SGIX.Sprite"
    \ , "Graphics.GL.SGIX.Subsample"
    \ , "Graphics.GL.SGIX.TagSampleBuffer"
    \ , "Graphics.GL.SGIX.TextureAddEnv"
    \ , "Graphics.GL.SGIX.TextureCoordinateClamp"
    \ , "Graphics.GL.SGIX.TextureLODBias"
    \ , "Graphics.GL.SGIX.TextureMultiBuffer"
    \ , "Graphics.GL.SGIX.TextureScaleBias"
    \ , "Graphics.GL.SGIX.VertexPreclip"
    \ , "Graphics.GL.SGIX.YCrCb"
    \ , "Graphics.GL.SGIX.YCrCbA"
    \ , "Graphics.GL.SUN"
    \ , "Graphics.GL.SUN.ConvolutionBorderModes"
    \ , "Graphics.GL.SUN.GlobalAlpha"
    \ , "Graphics.GL.SUN.MeshArray"
    \ , "Graphics.GL.SUN.SliceAccum"
    \ , "Graphics.GL.SUN.TriangleList"
    \ , "Graphics.GL.SUN.Vertex"
    \ , "Graphics.GL.SUNX"
    \ , "Graphics.GL.SUNX.ConstantData"
    \ , "Graphics.GL.ThreeDFX"
    \ , "Graphics.GL.ThreeDFX.Multisample"
    \ , "Graphics.GL.ThreeDFX.Tbuffer"
    \ , "Graphics.GL.ThreeDFX.TextureCompressionFXT1"
    \ , "Graphics.GL.Tokens"
    \ , "Graphics.GL.Types"
    \ , "Graphics.GL.Version10"
    \ , "Graphics.GL.Version11"
    \ , "Graphics.GL.Version12"
    \ , "Graphics.GL.Version13"
    \ , "Graphics.GL.Version14"
    \ , "Graphics.GL.Version15"
    \ , "Graphics.GL.Version20"
    \ , "Graphics.GL.Version21"
    \ , "Graphics.GL.WIN"
    \ , "Graphics.GL.WIN.PhongShading"
    \ , "Graphics.GL.WIN.SpecularFog"
    \ , "Test.QuickCheck"
    \ , "Test.QuickCheck.All"
    \ , "Test.QuickCheck.Arbitrary"
    \ , "Test.QuickCheck.Exception"
    \ , "Test.QuickCheck.Function"
    \ , "Test.QuickCheck.Gen"
    \ , "Test.QuickCheck.Gen.Unsafe"
    \ , "Test.QuickCheck.Modifiers"
    \ , "Test.QuickCheck.Monadic"
    \ , "Test.QuickCheck.Poly"
    \ , "Test.QuickCheck.Property"
    \ , "Test.QuickCheck.Random"
    \ , "Test.QuickCheck.State"
    \ , "Test.QuickCheck.Test"
    \ , "Test.QuickCheck.Text"
    \ , "Data.StateVar"
    \ , "Graphics.Win32"
    \ , "Graphics.Win32.Control"
    \ , "Graphics.Win32.Dialogue"
    \ , "Graphics.Win32.GDI"
    \ , "Graphics.Win32.GDI.AlphaBlend"
    \ , "Graphics.Win32.GDI.Bitmap"
    \ , "Graphics.Win32.GDI.Brush"
    \ , "Graphics.Win32.GDI.Clip"
    \ , "Graphics.Win32.GDI.Font"
    \ , "Graphics.Win32.GDI.Graphics2D"
    \ , "Graphics.Win32.GDI.HDC"
    \ , "Graphics.Win32.GDI.Palette"
    \ , "Graphics.Win32.GDI.Path"
    \ , "Graphics.Win32.GDI.Pen"
    \ , "Graphics.Win32.GDI.Region"
    \ , "Graphics.Win32.GDI.Types"
    \ , "Graphics.Win32.Icon"
    \ , "Graphics.Win32.Key"
    \ , "Graphics.Win32.LayeredWindow"
    \ , "Graphics.Win32.Menu"
    \ , "Graphics.Win32.Message"
    \ , "Graphics.Win32.Misc"
    \ , "Graphics.Win32.Resource"
    \ , "Graphics.Win32.Window"
    \ , "Graphics.Win32.Window.AnimateWindow"
    \ , "Graphics.Win32.Window.ForegroundWindow"
    \ , "Graphics.Win32.Window.HotKey"
    \ , "Graphics.Win32.Window.IMM"
    \ , "Graphics.Win32.Window.PostMessage"
    \ , "Media.Win32"
    \ , "System.Win32"
    \ , "System.Win32.Automation"
    \ , "System.Win32.Automation.Input"
    \ , "System.Win32.Automation.Input.Key"
    \ , "System.Win32.Automation.Input.Mouse"
    \ , "System.Win32.Console"
    \ , "System.Win32.Console.CtrlHandler"
    \ , "System.Win32.Console.HWND"
    \ , "System.Win32.Console.Title"
    \ , "System.Win32.DLL"
    \ , "System.Win32.DebugApi"
    \ , "System.Win32.Encoding"
    \ , "System.Win32.Exception.Unsupported"
    \ , "System.Win32.File"
    \ , "System.Win32.FileMapping"
    \ , "System.Win32.HardLink"
    \ , "System.Win32.Info"
    \ , "System.Win32.Info.Computer"
    \ , "System.Win32.Info.Version"
    \ , "System.Win32.Mem"
    \ , "System.Win32.MinTTY"
    \ , "System.Win32.NLS"
    \ , "System.Win32.Path"
    \ , "System.Win32.Process"
    \ , "System.Win32.Registry"
    \ , "System.Win32.Security"
    \ , "System.Win32.Shell"
    \ , "System.Win32.SimpleMAPI"
    \ , "System.Win32.String"
    \ , "System.Win32.SymbolicLink"
    \ , "System.Win32.Thread"
    \ , "System.Win32.Time"
    \ , "System.Win32.Types"
    \ , "System.Win32.Utils"
    \ , "System.Win32.Word"
    \ , "Data.Array"
    \ , "Data.Array.Base"
    \ , "Data.Array.IArray"
    \ , "Data.Array.IO"
    \ , "Data.Array.IO.Internals"
    \ , "Data.Array.IO.Safe"
    \ , "Data.Array.MArray"
    \ , "Data.Array.MArray.Safe"
    \ , "Data.Array.ST"
    \ , "Data.Array.ST.Safe"
    \ , "Data.Array.Storable"
    \ , "Data.Array.Storable.Internals"
    \ , "Data.Array.Storable.Safe"
    \ , "Data.Array.Unboxed"
    \ , "Data.Array.Unsafe"
    \ , "Control.Concurrent.Async"
    \ , "Data.Attoparsec"
    \ , "Data.Attoparsec.ByteString"
    \ , "Data.Attoparsec.ByteString.Char8"
    \ , "Data.Attoparsec.ByteString.Lazy"
    \ , "Data.Attoparsec.Char8"
    \ , "Data.Attoparsec.Combinator"
    \ , "Data.Attoparsec.Internal"
    \ , "Data.Attoparsec.Internal.Types"
    \ , "Data.Attoparsec.Lazy"
    \ , "Data.Attoparsec.Number"
    \ , "Data.Attoparsec.Text"
    \ , "Data.Attoparsec.Text.Lazy"
    \ , "Data.Attoparsec.Types"
    \ , "Data.Attoparsec.Zepto"
    \ , "Control.Applicative"
    \ , "Control.Arrow"
    \ , "Control.Category"
    \ , "Control.Concurrent"
    \ , "Control.Concurrent.Chan"
    \ , "Control.Concurrent.MVar"
    \ , "Control.Concurrent.QSem"
    \ , "Control.Concurrent.QSemN"
    \ , "Control.Exception"
    \ , "Control.Exception.Base"
    \ , "Control.Monad"
    \ , "Control.Monad.Fail"
    \ , "Control.Monad.Fix"
    \ , "Control.Monad.IO.Class"
    \ , "Control.Monad.Instances"
    \ , "Control.Monad.ST"
    \ , "Control.Monad.ST.Lazy"
    \ , "Control.Monad.ST.Lazy.Safe"
    \ , "Control.Monad.ST.Lazy.Unsafe"
    \ , "Control.Monad.ST.Safe"
    \ , "Control.Monad.ST.Strict"
    \ , "Control.Monad.ST.Unsafe"
    \ , "Control.Monad.Zip"
    \ , "Data.Bifoldable"
    \ , "Data.Bifunctor"
    \ , "Data.Bitraversable"
    \ , "Data.Bits"
    \ , "Data.Bool"
    \ , "Data.Char"
    \ , "Data.Coerce"
    \ , "Data.Complex"
    \ , "Data.Data"
    \ , "Data.Dynamic"
    \ , "Data.Either"
    \ , "Data.Eq"
    \ , "Data.Fixed"
    \ , "Data.Foldable"
    \ , "Data.Function"
    \ , "Data.Functor"
    \ , "Data.Functor.Classes"
    \ , "Data.Functor.Compose"
    \ , "Data.Functor.Const"
    \ , "Data.Functor.Identity"
    \ , "Data.Functor.Product"
    \ , "Data.Functor.Sum"
    \ , "Data.IORef"
    \ , "Data.Int"
    \ , "Data.Ix"
    \ , "Data.Kind"
    \ , "Data.List"
    \ , "Data.List.NonEmpty"
    \ , "Data.Maybe"
    \ , "Data.Monoid"
    \ , "Data.Ord"
    \ , "Data.Proxy"
    \ , "Data.Ratio"
    \ , "Data.STRef"
    \ , "Data.STRef.Lazy"
    \ , "Data.STRef.Strict"
    \ , "Data.Semigroup"
    \ , "Data.String"
    \ , "Data.Traversable"
    \ , "Data.Tuple"
    \ , "Data.Type.Bool"
    \ , "Data.Type.Coercion"
    \ , "Data.Type.Equality"
    \ , "Data.Typeable"
    \ , "Data.Unique"
    \ , "Data.Version"
    \ , "Data.Void"
    \ , "Data.Word"
    \ , "Debug.Trace"
    \ , "Foreign"
    \ , "Foreign.C"
    \ , "Foreign.C.Error"
    \ , "Foreign.C.String"
    \ , "Foreign.C.Types"
    \ , "Foreign.Concurrent"
    \ , "Foreign.ForeignPtr"
    \ , "Foreign.ForeignPtr.Safe"
    \ , "Foreign.ForeignPtr.Unsafe"
    \ , "Foreign.Marshal"
    \ , "Foreign.Marshal.Alloc"
    \ , "Foreign.Marshal.Array"
    \ , "Foreign.Marshal.Error"
    \ , "Foreign.Marshal.Pool"
    \ , "Foreign.Marshal.Safe"
    \ , "Foreign.Marshal.Unsafe"
    \ , "Foreign.Marshal.Utils"
    \ , "Foreign.Ptr"
    \ , "Foreign.Safe"
    \ , "Foreign.StablePtr"
    \ , "Foreign.Storable"
    \ , "GHC.Arr"
    \ , "GHC.Base"
    \ , "GHC.ByteOrder"
    \ , "GHC.Char"
    \ , "GHC.Clock"
    \ , "GHC.Conc"
    \ , "GHC.Conc.IO"
    \ , "GHC.Conc.Signal"
    \ , "GHC.Conc.Sync"
    \ , "GHC.ConsoleHandler"
    \ , "GHC.Constants"
    \ , "GHC.Desugar"
    \ , "GHC.Enum"
    \ , "GHC.Environment"
    \ , "GHC.Err"
    \ , "GHC.Event"
    \ , "GHC.Exception"
    \ , "GHC.ExecutionStack"
    \ , "GHC.ExecutionStack.Internal"
    \ , "GHC.Exts"
    \ , "GHC.Fingerprint"
    \ , "GHC.Fingerprint.Type"
    \ , "GHC.Float"
    \ , "GHC.Float.ConversionUtils"
    \ , "GHC.Float.RealFracMethods"
    \ , "GHC.Foreign"
    \ , "GHC.ForeignPtr"
    \ , "GHC.GHCi"
    \ , "GHC.Generics"
    \ , "GHC.IO"
    \ , "GHC.IO.Buffer"
    \ , "GHC.IO.BufferedIO"
    \ , "GHC.IO.Device"
    \ , "GHC.IO.Encoding"
    \ , "GHC.IO.Encoding.CodePage"
    \ , "GHC.IO.Encoding.Failure"
    \ , "GHC.IO.Encoding.Iconv"
    \ , "GHC.IO.Encoding.Latin1"
    \ , "GHC.IO.Encoding.Types"
    \ , "GHC.IO.Encoding.UTF16"
    \ , "GHC.IO.Encoding.UTF32"
    \ , "GHC.IO.Encoding.UTF8"
    \ , "GHC.IO.Exception"
    \ , "GHC.IO.FD"
    \ , "GHC.IO.Handle"
    \ , "GHC.IO.Handle.FD"
    \ , "GHC.IO.Handle.Internals"
    \ , "GHC.IO.Handle.Lock"
    \ , "GHC.IO.Handle.Text"
    \ , "GHC.IO.Handle.Types"
    \ , "GHC.IO.IOMode"
    \ , "GHC.IO.Unsafe"
    \ , "GHC.IOArray"
    \ , "GHC.IORef"
    \ , "GHC.Int"
    \ , "GHC.List"
    \ , "GHC.MVar"
    \ , "GHC.Natural"
    \ , "GHC.Num"
    \ , "GHC.OldList"
    \ , "GHC.OverloadedLabels"
    \ , "GHC.PArr"
    \ , "GHC.Pack"
    \ , "GHC.Profiling"
    \ , "GHC.Ptr"
    \ , "GHC.RTS.Flags"
    \ , "GHC.Read"
    \ , "GHC.Real"
    \ , "GHC.Records"
    \ , "GHC.ST"
    \ , "GHC.STRef"
    \ , "GHC.Show"
    \ , "GHC.Stable"
    \ , "GHC.Stack"
    \ , "GHC.Stack.CCS"
    \ , "GHC.Stack.Types"
    \ , "GHC.StaticPtr"
    \ , "GHC.Stats"
    \ , "GHC.Storable"
    \ , "GHC.TopHandler"
    \ , "GHC.TypeLits"
    \ , "GHC.TypeNats"
    \ , "GHC.Unicode"
    \ , "GHC.Weak"
    \ , "GHC.Word"
    \ , "Numeric"
    \ , "Numeric.Natural"
    \ , "Prelude"
    \ , "System.CPUTime"
    \ , "System.Console.GetOpt"
    \ , "System.Environment"
    \ , "System.Environment.Blank"
    \ , "System.Exit"
    \ , "System.IO"
    \ , "System.IO.Error"
    \ , "System.IO.Unsafe"
    \ , "System.Info"
    \ , "System.Mem"
    \ , "System.Mem.StableName"
    \ , "System.Mem.Weak"
    \ , "System.Posix.Internals"
    \ , "System.Posix.Types"
    \ , "System.Timeout"
    \ , "Text.ParserCombinators.ReadP"
    \ , "Text.ParserCombinators.ReadPrec"
    \ , "Text.Printf"
    \ , "Text.Read"
    \ , "Text.Read.Lex"
    \ , "Text.Show"
    \ , "Text.Show.Functions"
    \ , "Type.Reflection"
    \ , "Type.Reflection.Unsafe"
    \ , "Unsafe.Coerce"
    \ , "Data.ByteString"
    \ , "Data.ByteString.Builder"
    \ , "Data.ByteString.Builder.Extra"
    \ , "Data.ByteString.Builder.Internal"
    \ , "Data.ByteString.Builder.Prim"
    \ , "Data.ByteString.Builder.Prim.Internal"
    \ , "Data.ByteString.Char8"
    \ , "Data.ByteString.Internal"
    \ , "Data.ByteString.Lazy"
    \ , "Data.ByteString.Lazy.Builder"
    \ , "Data.ByteString.Lazy.Builder.ASCII"
    \ , "Data.ByteString.Lazy.Builder.Extras"
    \ , "Data.ByteString.Lazy.Char8"
    \ , "Data.ByteString.Lazy.Internal"
    \ , "Data.ByteString.Short"
    \ , "Data.ByteString.Short.Internal"
    \ , "Data.ByteString.Unsafe"
    \ , "Data.CallStack"
    \ , "Data.CaseInsensitive"
    \ , "Data.CaseInsensitive.Unsafe"
    \ , "Network.CGI"
    \ , "Network.CGI.Compat"
    \ , "Network.CGI.Cookie"
    \ , "Network.CGI.Monad"
    \ , "Network.CGI.Protocol"
    \ , "Data.Graph"
    \ , "Data.IntMap"
    \ , "Data.IntMap.Internal"
    \ , "Data.IntMap.Internal.Debug"
    \ , "Data.IntMap.Lazy"
    \ , "Data.IntMap.Merge.Lazy"
    \ , "Data.IntMap.Merge.Strict"
    \ , "Data.IntMap.Strict"
    \ , "Data.IntSet"
    \ , "Data.IntSet.Internal"
    \ , "Data.Map"
    \ , "Data.Map.Internal"
    \ , "Data.Map.Internal.Debug"
    \ , "Data.Map.Lazy"
    \ , "Data.Map.Lazy.Merge"
    \ , "Data.Map.Merge.Lazy"
    \ , "Data.Map.Merge.Strict"
    \ , "Data.Map.Strict"
    \ , "Data.Map.Strict.Internal"
    \ , "Data.Map.Strict.Merge"
    \ , "Data.Sequence"
    \ , "Data.Sequence.Internal"
    \ , "Data.Sequence.Internal.Sorting"
    \ , "Data.Set"
    \ , "Data.Set.Internal"
    \ , "Data.Tree"
    \ , "Utils.Containers.Internal.BitQueue"
    \ , "Utils.Containers.Internal.BitUtil"
    \ , "Utils.Containers.Internal.StrictPair"
    \ , "Control.DeepSeq"
    \ , "System.Directory"
    \ , "System.Directory.Internal"
    \ , "System.Directory.Internal.Prelude"
    \ , "Control.Monad.Catch"
    \ , "Control.Monad.Catch.Pure"
    \ , "Control.Exception.Extensible"
    \ , "Data.Graph.Inductive"
    \ , "Data.Graph.Inductive.Basic"
    \ , "Data.Graph.Inductive.Example"
    \ , "Data.Graph.Inductive.Graph"
    \ , "Data.Graph.Inductive.Internal.Heap"
    \ , "Data.Graph.Inductive.Internal.Queue"
    \ , "Data.Graph.Inductive.Internal.RootPath"
    \ , "Data.Graph.Inductive.Internal.Thread"
    \ , "Data.Graph.Inductive.Monad"
    \ , "Data.Graph.Inductive.Monad.IOArray"
    \ , "Data.Graph.Inductive.Monad.STArray"
    \ , "Data.Graph.Inductive.NodeMap"
    \ , "Data.Graph.Inductive.PatriciaTree"
    \ , "Data.Graph.Inductive.Query"
    \ , "Data.Graph.Inductive.Query.ArtPoint"
    \ , "Data.Graph.Inductive.Query.BCC"
    \ , "Data.Graph.Inductive.Query.BFS"
    \ , "Data.Graph.Inductive.Query.DFS"
    \ , "Data.Graph.Inductive.Query.Dominators"
    \ , "Data.Graph.Inductive.Query.GVD"
    \ , "Data.Graph.Inductive.Query.Indep"
    \ , "Data.Graph.Inductive.Query.MST"
    \ , "Data.Graph.Inductive.Query.MaxFlow"
    \ , "Data.Graph.Inductive.Query.MaxFlow2"
    \ , "Data.Graph.Inductive.Query.Monad"
    \ , "Data.Graph.Inductive.Query.SP"
    \ , "Data.Graph.Inductive.Query.TransClos"
    \ , "Data.Graph.Inductive.Tree"
    \ , "System.FilePath"
    \ , "System.FilePath.Posix"
    \ , "System.FilePath.Windows"
    \ , "Numeric.Fixed"
    \ , "Annotations"
    \ , "ApiAnnotation"
    \ , "Ar"
    \ , "AsmCodeGen"
    \ , "AsmUtils"
    \ , "Avail"
    \ , "Bag"
    \ , "BasicTypes"
    \ , "BinFingerprint"
    \ , "BinIface"
    \ , "Binary"
    \ , "Bitmap"
    \ , "BkpSyn"
    \ , "BlockId"
    \ , "BooleanFormula"
    \ , "BufWrite"
    \ , "BuildTyCl"
    \ , "ByteCodeAsm"
    \ , "ByteCodeGen"
    \ , "ByteCodeInstr"
    \ , "ByteCodeItbls"
    \ , "ByteCodeLink"
    \ , "ByteCodeTypes"
    \ , "CLabel"
    \ , "CPrim"
    \ , "CSE"
    \ , "CallArity"
    \ , "CgUtils"
    \ , "Check"
    \ , "Class"
    \ , "CmdLineParser"
    \ , "Cmm"
    \ , "CmmBuildInfoTables"
    \ , "CmmCallConv"
    \ , "CmmCommonBlockElim"
    \ , "CmmContFlowOpt"
    \ , "CmmExpr"
    \ , "CmmImplementSwitchPlans"
    \ , "CmmInfo"
    \ , "CmmLayoutStack"
    \ , "CmmLex"
    \ , "CmmLint"
    \ , "CmmLive"
    \ , "CmmMachOp"
    \ , "CmmMonad"
    \ , "CmmNode"
    \ , "CmmOpt"
    \ , "CmmParse"
    \ , "CmmPipeline"
    \ , "CmmProcPoint"
    \ , "CmmSink"
    \ , "CmmSwitch"
    \ , "CmmType"
    \ , "CmmUtils"
    \ , "CoAxiom"
    \ , "CodeGen.Platform"
    \ , "CodeGen.Platform.ARM"
    \ , "CodeGen.Platform.ARM64"
    \ , "CodeGen.Platform.NoRegs"
    \ , "CodeGen.Platform.PPC"
    \ , "CodeGen.Platform.PPC_Darwin"
    \ , "CodeGen.Platform.SPARC"
    \ , "CodeGen.Platform.X86"
    \ , "CodeGen.Platform.X86_64"
    \ , "CodeOutput"
    \ , "Coercion"
    \ , "ConLike"
    \ , "Config"
    \ , "Constants"
    \ , "Convert"
    \ , "CoreArity"
    \ , "CoreFVs"
    \ , "CoreLint"
    \ , "CoreMonad"
    \ , "CoreOpt"
    \ , "CorePrep"
    \ , "CoreSeq"
    \ , "CoreStats"
    \ , "CoreSubst"
    \ , "CoreSyn"
    \ , "CoreTidy"
    \ , "CoreToStg"
    \ , "CoreUnfold"
    \ , "CoreUtils"
    \ , "CostCentre"
    \ , "Coverage"
    \ , "Ctype"
    \ , "DataCon"
    \ , "Debug"
    \ , "Debugger"
    \ , "DebuggerUtils"
    \ , "Demand"
    \ , "Desugar"
    \ , "Digraph"
    \ , "DmdAnal"
    \ , "DriverBkp"
    \ , "DriverMkDepend"
    \ , "DriverPhases"
    \ , "DriverPipeline"
    \ , "DsArrows"
    \ , "DsBinds"
    \ , "DsCCall"
    \ , "DsExpr"
    \ , "DsForeign"
    \ , "DsGRHSs"
    \ , "DsListComp"
    \ , "DsMeta"
    \ , "DsMonad"
    \ , "DsUsage"
    \ , "DsUtils"
    \ , "Dwarf"
    \ , "Dwarf.Constants"
    \ , "Dwarf.Types"
    \ , "DynFlags"
    \ , "DynamicLoading"
    \ , "Elf"
    \ , "Encoding"
    \ , "EnumSet"
    \ , "ErrUtils"
    \ , "Exception"
    \ , "Exitify"
    \ , "FV"
    \ , "FamInst"
    \ , "FamInstEnv"
    \ , "FastFunctions"
    \ , "FastMutInt"
    \ , "FastString"
    \ , "FastStringEnv"
    \ , "FieldLabel"
    \ , "FileCleanup"
    \ , "Finder"
    \ , "Fingerprint"
    \ , "FiniteMap"
    \ , "FlagChecker"
    \ , "FloatIn"
    \ , "FloatOut"
    \ , "ForeignCall"
    \ , "Format"
    \ , "FunDeps"
    \ , "GHC"
    \ , "GHCi"
    \ , "GhcMake"
    \ , "GhcMonad"
    \ , "GhcPlugins"
    \ , "GraphBase"
    \ , "GraphColor"
    \ , "GraphOps"
    \ , "GraphPpr"
    \ , "HaddockUtils"
    \ , "HeaderInfo"
    \ , "Hooks"
    \ , "Hoopl.Block"
    \ , "Hoopl.Collections"
    \ , "Hoopl.Dataflow"
    \ , "Hoopl.Graph"
    \ , "Hoopl.Label"
    \ , "Hoopl.Unique"
    \ , "HsBinds"
    \ , "HsDecls"
    \ , "HsDoc"
    \ , "HsDumpAst"
    \ , "HsExpr"
    \ , "HsExtension"
    \ , "HsImpExp"
    \ , "HsLit"
    \ , "HsPat"
    \ , "HsSyn"
    \ , "HsTypes"
    \ , "HsUtils"
    \ , "HscMain"
    \ , "HscStats"
    \ , "HscTypes"
    \ , "IOEnv"
    \ , "Id"
    \ , "IdInfo"
    \ , "IfaceEnv"
    \ , "IfaceSyn"
    \ , "IfaceType"
    \ , "Inst"
    \ , "InstEnv"
    \ , "Instruction"
    \ , "InteractiveEval"
    \ , "InteractiveEvalTypes"
    \ , "Json"
    \ , "Kind"
    \ , "KnownUniques"
    \ , "Lexeme"
    \ , "Lexer"
    \ , "LiberateCase"
    \ , "Linker"
    \ , "ListSetOps"
    \ , "ListT"
    \ , "Literal"
    \ , "Llvm"
    \ , "Llvm.AbsSyn"
    \ , "Llvm.MetaData"
    \ , "Llvm.PpLlvm"
    \ , "Llvm.Types"
    \ , "LlvmCodeGen"
    \ , "LlvmCodeGen.Base"
    \ , "LlvmCodeGen.CodeGen"
    \ , "LlvmCodeGen.Data"
    \ , "LlvmCodeGen.Ppr"
    \ , "LlvmCodeGen.Regs"
    \ , "LlvmMangler"
    \ , "LoadIface"
    \ , "Match"
    \ , "MatchCon"
    \ , "MatchLit"
    \ , "Maybes"
    \ , "MkCore"
    \ , "MkGraph"
    \ , "MkId"
    \ , "MkIface"
    \ , "Module"
    \ , "MonadUtils"
    \ , "NCGMonad"
    \ , "Name"
    \ , "NameCache"
    \ , "NameEnv"
    \ , "NameSet"
    \ , "NameShape"
    \ , "OccName"
    \ , "OccurAnal"
    \ , "OptCoercion"
    \ , "OrdList"
    \ , "Outputable"
    \ , "PIC"
    \ , "PPC.CodeGen"
    \ , "PPC.Cond"
    \ , "PPC.Instr"
    \ , "PPC.Ppr"
    \ , "PPC.RegInfo"
    \ , "PPC.Regs"
    \ , "PackageConfig"
    \ , "Packages"
    \ , "Pair"
    \ , "Panic"
    \ , "Parser"
    \ , "PatSyn"
    \ , "PipelineMonad"
    \ , "PlaceHolder"
    \ , "Platform"
    \ , "PlatformConstants"
    \ , "Plugins"
    \ , "PmExpr"
    \ , "PprBase"
    \ , "PprC"
    \ , "PprCmm"
    \ , "PprCmmDecl"
    \ , "PprCmmExpr"
    \ , "PprColour"
    \ , "PprCore"
    \ , "PprTyThing"
    \ , "PrelInfo"
    \ , "PrelNames"
    \ , "PrelRules"
    \ , "Pretty"
    \ , "PrimOp"
    \ , "ProfInit"
    \ , "RdrHsSyn"
    \ , "RdrName"
    \ , "Reg"
    \ , "RegAlloc.Graph.ArchBase"
    \ , "RegAlloc.Graph.ArchX86"
    \ , "RegAlloc.Graph.Coalesce"
    \ , "RegAlloc.Graph.Main"
    \ , "RegAlloc.Graph.Spill"
    \ , "RegAlloc.Graph.SpillClean"
    \ , "RegAlloc.Graph.SpillCost"
    \ , "RegAlloc.Graph.Stats"
    \ , "RegAlloc.Graph.TrivColorable"
    \ , "RegAlloc.Linear.Base"
    \ , "RegAlloc.Linear.FreeRegs"
    \ , "RegAlloc.Linear.JoinToTargets"
    \ , "RegAlloc.Linear.Main"
    \ , "RegAlloc.Linear.PPC.FreeRegs"
    \ , "RegAlloc.Linear.SPARC.FreeRegs"
    \ , "RegAlloc.Linear.StackMap"
    \ , "RegAlloc.Linear.State"
    \ , "RegAlloc.Linear.Stats"
    \ , "RegAlloc.Linear.X86.FreeRegs"
    \ , "RegAlloc.Linear.X86_64.FreeRegs"
    \ , "RegAlloc.Liveness"
    \ , "RegClass"
    \ , "RepType"
    \ , "RnBinds"
    \ , "RnEnv"
    \ , "RnExpr"
    \ , "RnFixity"
    \ , "RnHsDoc"
    \ , "RnModIface"
    \ , "RnNames"
    \ , "RnPat"
    \ , "RnSource"
    \ , "RnSplice"
    \ , "RnTypes"
    \ , "RnUnbound"
    \ , "RnUtils"
    \ , "RtClosureInspect"
    \ , "Rules"
    \ , "SAT"
    \ , "SMRep"
    \ , "SPARC.AddrMode"
    \ , "SPARC.Base"
    \ , "SPARC.CodeGen"
    \ , "SPARC.CodeGen.Amode"
    \ , "SPARC.CodeGen.Base"
    \ , "SPARC.CodeGen.CondCode"
    \ , "SPARC.CodeGen.Expand"
    \ , "SPARC.CodeGen.Gen32"
    \ , "SPARC.CodeGen.Gen64"
    \ , "SPARC.CodeGen.Sanity"
    \ , "SPARC.Cond"
    \ , "SPARC.Imm"
    \ , "SPARC.Instr"
    \ , "SPARC.Ppr"
    \ , "SPARC.Regs"
    \ , "SPARC.ShortcutJump"
    \ , "SPARC.Stack"
    \ , "SetLevels"
    \ , "SimplCore"
    \ , "SimplEnv"
    \ , "SimplMonad"
    \ , "SimplStg"
    \ , "SimplUtils"
    \ , "Simplify"
    \ , "SpecConstr"
    \ , "Specialise"
    \ , "SrcLoc"
    \ , "State"
    \ , "StaticPtrTable"
    \ , "StgCmm"
    \ , "StgCmmArgRep"
    \ , "StgCmmBind"
    \ , "StgCmmClosure"
    \ , "StgCmmCon"
    \ , "StgCmmEnv"
    \ , "StgCmmExpr"
    \ , "StgCmmExtCode"
    \ , "StgCmmForeign"
    \ , "StgCmmHeap"
    \ , "StgCmmHpc"
    \ , "StgCmmLayout"
    \ , "StgCmmMonad"
    \ , "StgCmmPrim"
    \ , "StgCmmProf"
    \ , "StgCmmTicky"
    \ , "StgCmmUtils"
    \ , "StgCse"
    \ , "StgLint"
    \ , "StgStats"
    \ , "StgSyn"
    \ , "Stream"
    \ , "StringBuffer"
    \ , "SysTools"
    \ , "SysTools.BaseDir"
    \ , "SysTools.ExtraObj"
    \ , "SysTools.Info"
    \ , "SysTools.Process"
    \ , "SysTools.Tasks"
    \ , "SysTools.Terminal"
    \ , "THNames"
    \ , "TargetReg"
    \ , "TcAnnotations"
    \ , "TcArrows"
    \ , "TcBackpack"
    \ , "TcBinds"
    \ , "TcCanonical"
    \ , "TcClassDcl"
    \ , "TcDefaults"
    \ , "TcDeriv"
    \ , "TcDerivInfer"
    \ , "TcDerivUtils"
    \ , "TcEnv"
    \ , "TcErrors"
    \ , "TcEvidence"
    \ , "TcExpr"
    \ , "TcFlatten"
    \ , "TcForeign"
    \ , "TcGenDeriv"
    \ , "TcGenFunctor"
    \ , "TcGenGenerics"
    \ , "TcHsSyn"
    \ , "TcHsType"
    \ , "TcIface"
    \ , "TcInstDcls"
    \ , "TcInteract"
    \ , "TcMType"
    \ , "TcMatches"
    \ , "TcPat"
    \ , "TcPatSyn"
    \ , "TcPluginM"
    \ , "TcRnDriver"
    \ , "TcRnExports"
    \ , "TcRnMonad"
    \ , "TcRnTypes"
    \ , "TcRules"
    \ , "TcSMonad"
    \ , "TcSigs"
    \ , "TcSimplify"
    \ , "TcSplice"
    \ , "TcTyClsDecls"
    \ , "TcTyDecls"
    \ , "TcType"
    \ , "TcTypeNats"
    \ , "TcTypeable"
    \ , "TcUnify"
    \ , "TcValidity"
    \ , "TidyPgm"
    \ , "TmOracle"
    \ , "ToIface"
    \ , "TrieMap"
    \ , "TyCoRep"
    \ , "TyCon"
    \ , "Type"
    \ , "TysPrim"
    \ , "TysWiredIn"
    \ , "UnVarGraph"
    \ , "UnariseStg"
    \ , "Unify"
    \ , "UniqDFM"
    \ , "UniqDSet"
    \ , "UniqFM"
    \ , "UniqMap"
    \ , "UniqSet"
    \ , "UniqSupply"
    \ , "Unique"
    \ , "Util"
    \ , "Var"
    \ , "VarEnv"
    \ , "VarSet"
    \ , "Vectorise"
    \ , "Vectorise.Builtins"
    \ , "Vectorise.Builtins.Base"
    \ , "Vectorise.Builtins.Initialise"
    \ , "Vectorise.Convert"
    \ , "Vectorise.Env"
    \ , "Vectorise.Exp"
    \ , "Vectorise.Generic.Description"
    \ , "Vectorise.Generic.PADict"
    \ , "Vectorise.Generic.PAMethods"
    \ , "Vectorise.Generic.PData"
    \ , "Vectorise.Monad"
    \ , "Vectorise.Monad.Base"
    \ , "Vectorise.Monad.Global"
    \ , "Vectorise.Monad.InstEnv"
    \ , "Vectorise.Monad.Local"
    \ , "Vectorise.Monad.Naming"
    \ , "Vectorise.Type.Classify"
    \ , "Vectorise.Type.Env"
    \ , "Vectorise.Type.TyConDecl"
    \ , "Vectorise.Type.Type"
    \ , "Vectorise.Utils"
    \ , "Vectorise.Utils.Base"
    \ , "Vectorise.Utils.Closure"
    \ , "Vectorise.Utils.Hoisting"
    \ , "Vectorise.Utils.PADict"
    \ , "Vectorise.Utils.Poly"
    \ , "Vectorise.Var"
    \ , "Vectorise.Vect"
    \ , "WorkWrap"
    \ , "WwLib"
    \ , "X86.CodeGen"
    \ , "X86.Cond"
    \ , "X86.Instr"
    \ , "X86.Ppr"
    \ , "X86.RegInfo"
    \ , "X86.Regs"
    \ , "Numeric.Half"
    \ , "Data.Hashable"
    \ , "Data.Hashable.Lifted"
    \ , "Language.Haskell.Lexer"
    \ , "Language.Haskell.ParseMonad"
    \ , "Language.Haskell.ParseUtils"
    \ , "Language.Haskell.Parser"
    \ , "Language.Haskell.Pretty"
    \ , "Language.Haskell.Syntax"
    \ , "Control.Monad"
    \ , "Data.Array"
    \ , "Data.Bits"
    \ , "Data.Char"
    \ , "Data.Complex"
    \ , "Data.Int"
    \ , "Data.Ix"
    \ , "Data.List"
    \ , "Data.Maybe"
    \ , "Data.Ratio"
    \ , "Data.Word"
    \ , "Foreign"
    \ , "Foreign.C"
    \ , "Foreign.C.Error"
    \ , "Foreign.C.String"
    \ , "Foreign.C.Types"
    \ , "Foreign.ForeignPtr"
    \ , "Foreign.Marshal"
    \ , "Foreign.Marshal.Alloc"
    \ , "Foreign.Marshal.Array"
    \ , "Foreign.Marshal.Error"
    \ , "Foreign.Marshal.Utils"
    \ , "Foreign.Ptr"
    \ , "Foreign.StablePtr"
    \ , "Foreign.Storable"
    \ , "Numeric"
    \ , "Prelude"
    \ , "System.Environment"
    \ , "System.Exit"
    \ , "System.IO"
    \ , "System.IO.Error"
    \ , "Array"
    \ , "Bits"
    \ , "CError"
    \ , "CForeign"
    \ , "CPUTime"
    \ , "CString"
    \ , "CTypes"
    \ , "Char"
    \ , "Complex"
    \ , "Directory"
    \ , "ForeignPtr"
    \ , "IO"
    \ , "Int"
    \ , "Ix"
    \ , "List"
    \ , "Locale"
    \ , "MarshalAlloc"
    \ , "MarshalArray"
    \ , "MarshalError"
    \ , "MarshalUtils"
    \ , "Maybe"
    \ , "Monad"
    \ , "Numeric"
    \ , "Prelude"
    \ , "Ptr"
    \ , "Random"
    \ , "Ratio"
    \ , "StablePtr"
    \ , "Storable"
    \ , "System"
    \ , "Time"
    \ , "Word"
    \ , "Trace.Hpc.Mix"
    \ , "Trace.Hpc.Reflect"
    \ , "Trace.Hpc.Tix"
    \ , "Trace.Hpc.Util"
    \ , "Text.Html"
    \ , "Text.Html.BlockTable"
    \ , "GHC.Integer.Logarithms.Compat"
    \ , "Math.NumberTheory.Logarithms"
    \ , "Math.NumberTheory.Powers.Integer"
    \ , "Math.NumberTheory.Powers.Natural"
    \ , "Control.Monad.Cont"
    \ , "Control.Monad.Cont.Class"
    \ , "Control.Monad.Error"
    \ , "Control.Monad.Error.Class"
    \ , "Control.Monad.Except"
    \ , "Control.Monad.Identity"
    \ , "Control.Monad.List"
    \ , "Control.Monad.RWS"
    \ , "Control.Monad.RWS.Class"
    \ , "Control.Monad.RWS.Lazy"
    \ , "Control.Monad.RWS.Strict"
    \ , "Control.Monad.Reader"
    \ , "Control.Monad.Reader.Class"
    \ , "Control.Monad.State"
    \ , "Control.Monad.State.Class"
    \ , "Control.Monad.State.Lazy"
    \ , "Control.Monad.State.Strict"
    \ , "Control.Monad.Trans"
    \ , "Control.Monad.Writer"
    \ , "Control.Monad.Writer.Class"
    \ , "Control.Monad.Writer.Lazy"
    \ , "Control.Monad.Writer.Strict"
    \ , "Network.Multipart"
    \ , "Network.Multipart.Header"
    \ , "Network"
    \ , "Network.BSD"
    \ , "Network.Socket"
    \ , "Network.Socket.ByteString"
    \ , "Network.Socket.ByteString.Lazy"
    \ , "Network.Socket.Internal"
    \ , "Network.URI"
    \ , "System.Locale"
    \ , "System.Time"
    \ , "Control.Parallel"
    \ , "Control.Parallel.Strategies"
    \ , "Control.Seq"
    \ , "Text.Parsec"
    \ , "Text.Parsec.ByteString"
    \ , "Text.Parsec.ByteString.Lazy"
    \ , "Text.Parsec.Char"
    \ , "Text.Parsec.Combinator"
    \ , "Text.Parsec.Error"
    \ , "Text.Parsec.Expr"
    \ , "Text.Parsec.Language"
    \ , "Text.Parsec.Perm"
    \ , "Text.Parsec.Pos"
    \ , "Text.Parsec.Prim"
    \ , "Text.Parsec.String"
    \ , "Text.Parsec.Text"
    \ , "Text.Parsec.Text.Lazy"
    \ , "Text.Parsec.Token"
    \ , "Text.ParserCombinators.Parsec"
    \ , "Text.ParserCombinators.Parsec.Char"
    \ , "Text.ParserCombinators.Parsec.Combinator"
    \ , "Text.ParserCombinators.Parsec.Error"
    \ , "Text.ParserCombinators.Parsec.Expr"
    \ , "Text.ParserCombinators.Parsec.Language"
    \ , "Text.ParserCombinators.Parsec.Perm"
    \ , "Text.ParserCombinators.Parsec.Pos"
    \ , "Text.ParserCombinators.Parsec.Prim"
    \ , "Text.ParserCombinators.Parsec.Token"
    \ , "Text.PrettyPrint"
    \ , "Text.PrettyPrint.Annotated"
    \ , "Text.PrettyPrint.Annotated.HughesPJ"
    \ , "Text.PrettyPrint.Annotated.HughesPJClass"
    \ , "Text.PrettyPrint.HughesPJ"
    \ , "Text.PrettyPrint.HughesPJClass"
    \ , "Control.Monad.Primitive"
    \ , "Data.Primitive"
    \ , "Data.Primitive.Addr"
    \ , "Data.Primitive.Array"
    \ , "Data.Primitive.ByteArray"
    \ , "Data.Primitive.MVar"
    \ , "Data.Primitive.MachDeps"
    \ , "Data.Primitive.MutVar"
    \ , "Data.Primitive.PrimArray"
    \ , "Data.Primitive.Ptr"
    \ , "Data.Primitive.SmallArray"
    \ , "Data.Primitive.Types"
    \ , "Data.Primitive.UnliftedArray"
    \ , "System.Cmd"
    \ , "System.Process"
    \ , "System.Process.Internals"
    \ , "System.Random"
    \ , "Text.Regex.Base"
    \ , "Text.Regex.Base.Context"
    \ , "Text.Regex.Base.Impl"
    \ , "Text.Regex.Base.RegexLike"
    \ , "Text.Regex"
    \ , "Text.Regex.Posix"
    \ , "Text.Regex.Posix.ByteString"
    \ , "Text.Regex.Posix.ByteString.Lazy"
    \ , "Text.Regex.Posix.Sequence"
    \ , "Text.Regex.Posix.String"
    \ , "Text.Regex.Posix.Wrap"
    \ , "Data.ByteString.Builder.Scientific"
    \ , "Data.Scientific"
    \ , "Data.Text.Lazy.Builder.Scientific"
    \ , "Data.List.Split"
    \ , "Data.List.Split.Internals"
    \ , "Control.Concurrent.STM"
    \ , "Control.Concurrent.STM.TArray"
    \ , "Control.Concurrent.STM.TBQueue"
    \ , "Control.Concurrent.STM.TChan"
    \ , "Control.Concurrent.STM.TMVar"
    \ , "Control.Concurrent.STM.TQueue"
    \ , "Control.Concurrent.STM.TSem"
    \ , "Control.Concurrent.STM.TVar"
    \ , "Control.Monad.STM"
    \ , "Data.Generics"
    \ , "Data.Generics.Aliases"
    \ , "Data.Generics.Basics"
    \ , "Data.Generics.Builders"
    \ , "Data.Generics.Instances"
    \ , "Data.Generics.Schemes"
    \ , "Data.Generics.Text"
    \ , "Data.Generics.Twins"
    \ , "Generics.SYB"
    \ , "Generics.SYB.Aliases"
    \ , "Generics.SYB.Basics"
    \ , "Generics.SYB.Builders"
    \ , "Generics.SYB.Instances"
    \ , "Generics.SYB.Schemes"
    \ , "Generics.SYB.Text"
    \ , "Generics.SYB.Twins"
    \ , "Language.Haskell.TH"
    \ , "Language.Haskell.TH.LanguageExtensions"
    \ , "Language.Haskell.TH.Lib"
    \ , "Language.Haskell.TH.Lib.Internal"
    \ , "Language.Haskell.TH.Ppr"
    \ , "Language.Haskell.TH.PprLib"
    \ , "Language.Haskell.TH.Quote"
    \ , "Language.Haskell.TH.Syntax"
    \ , "Data.Text"
    \ , "Data.Text.Array"
    \ , "Data.Text.Encoding"
    \ , "Data.Text.Encoding.Error"
    \ , "Data.Text.Foreign"
    \ , "Data.Text.IO"
    \ , "Data.Text.Internal"
    \ , "Data.Text.Internal.Builder"
    \ , "Data.Text.Internal.Builder.Functions"
    \ , "Data.Text.Internal.Builder.Int.Digits"
    \ , "Data.Text.Internal.Builder.RealFloat.Functions"
    \ , "Data.Text.Internal.Encoding.Fusion"
    \ , "Data.Text.Internal.Encoding.Fusion.Common"
    \ , "Data.Text.Internal.Encoding.Utf16"
    \ , "Data.Text.Internal.Encoding.Utf32"
    \ , "Data.Text.Internal.Encoding.Utf8"
    \ , "Data.Text.Internal.Functions"
    \ , "Data.Text.Internal.Fusion"
    \ , "Data.Text.Internal.Fusion.CaseMapping"
    \ , "Data.Text.Internal.Fusion.Common"
    \ , "Data.Text.Internal.Fusion.Size"
    \ , "Data.Text.Internal.Fusion.Types"
    \ , "Data.Text.Internal.IO"
    \ , "Data.Text.Internal.Lazy"
    \ , "Data.Text.Internal.Lazy.Encoding.Fusion"
    \ , "Data.Text.Internal.Lazy.Fusion"
    \ , "Data.Text.Internal.Lazy.Search"
    \ , "Data.Text.Internal.Private"
    \ , "Data.Text.Internal.Read"
    \ , "Data.Text.Internal.Search"
    \ , "Data.Text.Internal.Unsafe"
    \ , "Data.Text.Internal.Unsafe.Char"
    \ , "Data.Text.Internal.Unsafe.Shift"
    \ , "Data.Text.Lazy"
    \ , "Data.Text.Lazy.Builder"
    \ , "Data.Text.Lazy.Builder.Int"
    \ , "Data.Text.Lazy.Builder.RealFloat"
    \ , "Data.Text.Lazy.Encoding"
    \ , "Data.Text.Lazy.IO"
    \ , "Data.Text.Lazy.Internal"
    \ , "Data.Text.Lazy.Read"
    \ , "Data.Text.Read"
    \ , "Data.Text.Unsafe"
    \ , "System.Random.TF"
    \ , "System.Random.TF.Gen"
    \ , "System.Random.TF.Init"
    \ , "System.Random.TF.Instances"
    \ , "Data.Time"
    \ , "Data.Time.Calendar"
    \ , "Data.Time.Calendar.Easter"
    \ , "Data.Time.Calendar.Julian"
    \ , "Data.Time.Calendar.MonthDay"
    \ , "Data.Time.Calendar.OrdinalDate"
    \ , "Data.Time.Calendar.WeekDate"
    \ , "Data.Time.Clock"
    \ , "Data.Time.Clock.POSIX"
    \ , "Data.Time.Clock.System"
    \ , "Data.Time.Clock.TAI"
    \ , "Data.Time.Format"
    \ , "Data.Time.LocalTime"
    \ , "Control.Applicative.Backwards"
    \ , "Control.Applicative.Lift"
    \ , "Control.Monad.Signatures"
    \ , "Control.Monad.Trans.Accum"
    \ , "Control.Monad.Trans.Class"
    \ , "Control.Monad.Trans.Cont"
    \ , "Control.Monad.Trans.Error"
    \ , "Control.Monad.Trans.Except"
    \ , "Control.Monad.Trans.Identity"
    \ , "Control.Monad.Trans.List"
    \ , "Control.Monad.Trans.Maybe"
    \ , "Control.Monad.Trans.RWS"
    \ , "Control.Monad.Trans.RWS.Lazy"
    \ , "Control.Monad.Trans.RWS.Strict"
    \ , "Control.Monad.Trans.Reader"
    \ , "Control.Monad.Trans.Select"
    \ , "Control.Monad.Trans.State"
    \ , "Control.Monad.Trans.State.Lazy"
    \ , "Control.Monad.Trans.State.Strict"
    \ , "Control.Monad.Trans.Writer"
    \ , "Control.Monad.Trans.Writer.Lazy"
    \ , "Control.Monad.Trans.Writer.Strict"
    \ , "Data.Functor.Constant"
    \ , "Data.Functor.Reverse"
    \ , "Control.Monad.Trans.Instances"
    \ , "Data.Functor.Classes.Generic"
    \ , "Data.Functor.Classes.Generic.Internal"
    \ , "System.Posix"
    \ , "System.Posix.ByteString"
    \ , "System.Posix.ByteString.FilePath"
    \ , "System.Posix.Directory"
    \ , "System.Posix.Directory.ByteString"
    \ , "System.Posix.DynamicLinker"
    \ , "System.Posix.DynamicLinker.ByteString"
    \ , "System.Posix.DynamicLinker.Module"
    \ , "System.Posix.DynamicLinker.Module.ByteString"
    \ , "System.Posix.DynamicLinker.Prim"
    \ , "System.Posix.Env"
    \ , "System.Posix.Env.ByteString"
    \ , "System.Posix.Error"
    \ , "System.Posix.Fcntl"
    \ , "System.Posix.Files"
    \ , "System.Posix.Files.ByteString"
    \ , "System.Posix.IO"
    \ , "System.Posix.IO.ByteString"
    \ , "System.Posix.Process"
    \ , "System.Posix.Process.ByteString"
    \ , "System.Posix.Process.Internals"
    \ , "System.Posix.Resource"
    \ , "System.Posix.Semaphore"
    \ , "System.Posix.SharedMem"
    \ , "System.Posix.Signals"
    \ , "System.Posix.Signals.Exts"
    \ , "System.Posix.Temp"
    \ , "System.Posix.Temp.ByteString"
    \ , "System.Posix.Terminal"
    \ , "System.Posix.Terminal.ByteString"
    \ , "System.Posix.Time"
    \ , "System.Posix.Unistd"
    \ , "System.Posix.User"
    \ , "Data.HashMap.Lazy"
    \ , "Data.HashMap.Strict"
    \ , "Data.HashSet"
    \ , "Data.Vector"
    \ , "Data.Vector.Fusion.Bundle"
    \ , "Data.Vector.Fusion.Bundle.Monadic"
    \ , "Data.Vector.Fusion.Bundle.Size"
    \ , "Data.Vector.Fusion.Stream.Monadic"
    \ , "Data.Vector.Fusion.Util"
    \ , "Data.Vector.Generic"
    \ , "Data.Vector.Generic.Base"
    \ , "Data.Vector.Generic.Mutable"
    \ , "Data.Vector.Generic.Mutable.Base"
    \ , "Data.Vector.Generic.New"
    \ , "Data.Vector.Internal.Check"
    \ , "Data.Vector.Mutable"
    \ , "Data.Vector.Primitive"
    \ , "Data.Vector.Primitive.Mutable"
    \ , "Data.Vector.Storable"
    \ , "Data.Vector.Storable.Internal"
    \ , "Data.Vector.Storable.Mutable"
    \ , "Data.Vector.Unboxed"
    \ , "Data.Vector.Unboxed.Base"
    \ , "Data.Vector.Unboxed.Mutable"
    \ , "Text.XHtml"
    \ , "Text.XHtml.Debug"
    \ , "Text.XHtml.Frameset"
    \ , "Text.XHtml.Strict"
    \ , "Text.XHtml.Table"
    \ , "Text.XHtml.Transitional"
    \ , "Codec.Compression.GZip"
    \ , "Codec.Compression.Zlib"
    \ , "Codec.Compression.Zlib.Internal"
    \ , "Codec.Compression.Zlib.Raw"
    \ , "Web.Spock"
    \ , "Web.Spock.Config"
    \ , "Web.Spock.Internal.SessionManager"
    \ , "Web.Spock.Internal.SessionVault"
    \ , "Web.Spock.SessionActions"
    \ , "Web.Spock.Api"
    \ , "Web.Spock.Auth"
    \ , "Web.Spock.Action"
    \ , "Web.Spock.Core"
    \ , "Web.Spock.Internal.Cookies"
    \ , "Web.Spock.Internal.Util"
    \ , "Web.Spock.Routing"
    \ , "Web.Spock.Digestive"
    \ , "Database.Esqueleto"
    \ , "Database.Esqueleto.Internal.Language"
    \ , "Database.Esqueleto.Internal.Sql"
    \ , "Database.Esqueleto.PostgreSQL"
    \ , "Database.Persist"
    \ , "Database.Persist.Class"
    \ , "Database.Persist.Quasi"
    \ , "Database.Persist.Sql"
    \ , "Database.Persist.Sql.Types.Internal"
    \ , "Database.Persist.Sql.Util"
    \ , "Database.Persist.Types"
    \ , "Database.Persist.MySQL"
    \ , "Database.Persist.Postgresql"
    \ , "Database.Persist.Postgresql.JSON"
    \ , "Database.Persist.Redis"
    \ , "Database.Persist.Sqlite"
    \ , "Database.Sqlite"
    \ , "Servant.API"
    \ , "Servant.API.Alternative"
    \ , "Servant.API.BasicAuth"
    \ , "Servant.API.Capture"
    \ , "Servant.API.ContentTypes"
    \ , "Servant.API.Description"
    \ , "Servant.API.Empty"
    \ , "Servant.API.Experimental.Auth"
    \ , "Servant.API.Generic"
    \ , "Servant.API.Header"
    \ , "Servant.API.HttpVersion"
    \ , "Servant.API.Internal.Test.ComprehensiveAPI"
    \ , "Servant.API.IsSecure"
    \ , "Servant.API.Modifiers"
    \ , "Servant.API.QueryParam"
    \ , "Servant.API.Raw"
    \ , "Servant.API.RemoteHost"
    \ , "Servant.API.ReqBody"
    \ , "Servant.API.ResponseHeaders"
    \ , "Servant.API.Stream"
    \ , "Servant.API.Sub"
    \ , "Servant.API.TypeLevel"
    \ , "Servant.API.Vault"
    \ , "Servant.API.Verbs"
    \ , "Servant.API.WithNamedContext"
    \ , "Servant.Links"
    \ , "Servant.Utils.Enter"
    \ , "Servant.Utils.Links"
    \ , "Servant.Auth"
    \ , "Servant.Client"
    \ , "Servant.Client.Internal.HttpClient"
    \ , "Servant"
    \ , "Servant.Server"
    \ , "Servant.Server.Experimental.Auth"
    \ , "Servant.Server.Generic"
    \ , "Servant.Server.Internal"
    \ , "Servant.Server.Internal.BasicAuth"
    \ , "Servant.Server.Internal.Context"
    \ , "Servant.Server.Internal.Handler"
    \ , "Servant.Server.Internal.Router"
    \ , "Servant.Server.Internal.RoutingApplication"
    \ , "Servant.Server.Internal.ServantErr"
    \ , "Servant.Server.StaticFiles"
    \ , "Servant.Utils.StaticFiles"
    \ ]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                " Vim completion script
" Language:	HTML and XHTML
" Maintainer:	Mikolaj Machowski ( mikmach AT wp DOT pl )
" Last Change:	2019 Sep 27

" Distinguish between HTML versions.
" To use with other HTML versions add another "elseif" condition to match
" proper DOCTYPE.
function! htmlcomplete#DetectOmniFlavor()
  if &filetype == 'xhtml'
    let b:html_omni_flavor = 'xhtml10s'
  else
    let b:html_omni_flavor = 'html401t'
  endif
  let i = 1
  let line = ""
  while i < 10 && i < line("$")
    let line = getline(i)
    if line =~ '<!DOCTYPE.*\<DTD '
      break
    endif
    let i += 1
  endwhile
  if line =~ '<!DOCTYPE.*\<DTD '  " doctype line found above
    if line =~ ' HTML 3\.2'
      let b:html_omni_flavor = 'html32'
    elseif line =~ ' XHTML 1\.1'
      let b:html_omni_flavor = 'xhtml11'
    else    " two-step detection with strict/frameset/transitional
      if line =~ ' XHTML 1\.0'
	let b:html_omni_flavor = 'xhtml10'
      elseif line =~ ' HTML 4\.01'
	let b:html_omni_flavor = 'html401'
      elseif line =~ ' HTML 4.0\>'
	let b:html_omni_flavor = 'html40'
      endif
      if line =~ '\<Transitional\>'
	let b:html_omni_flavor .= 't'
      elseif line =~ '\<Frameset\>'
	let b:html_omni_flavor .= 'f'
      else
	let b:html_omni_flavor .= 's'
      endif
    endif
  endif
endfunction

function! htmlcomplete#CompleteTags(findstart, base)
  if a:findstart
    " locate the start of the word
    let line = getline('.')
    let start = col('.') - 1
	let curline = line('.')
	let compl_begin = col('.') - 2
    while start >= 0 && line[start - 1] =~ '\(\k\|[!:.-]\)'
		let start -= 1
    endwhile
	" Handling of entities {{{
	if start >= 0 && line[start - 1] =~ '&'
		let b:entitiescompl = 1
		let b:compl_context = ''
		return start
	endif
	" }}}
	" Handling of <style> tag {{{
	let stylestart = searchpair('<style\>', '', '<\/style\>', "bnW")
	let styleend   = searchpair('<style\>', '', '<\/style\>', "nW")
	if stylestart != 0 && styleend != 0
		if stylestart <= curline && styleend >= curline
			let start = col('.') - 1
			let b:csscompl = 1
			while start >= 0 && line[start - 1] =~ '\(\k\|-\)'
				let start -= 1
			endwhile
		endif
	endif
	" }}}
	" Handling of <script> tag {{{
	let scriptstart = searchpair('<script\>', '', '<\/script\>', "bnW")
	let scriptend   = searchpair('<script\>', '', '<\/script\>', "nW")
	if scriptstart != 0 && scriptend != 0
		if scriptstart <= curline && scriptend >= curline
			let start = col('.') - 1
			let b:jscompl = 1
			let b:jsrange = [scriptstart, scriptend]
			while start >= 0 && line[start - 1] =~ '\k'
				let start -= 1
			endwhile
			" We are inside of <script> tag. But we should also get contents
			" of all linked external files and (secondary, less probably) other <script> tags
			" This logic could possible be done in separate function - may be
			" reused in events scripting (also with option could be reused for
			" CSS
			let b:js_extfiles = []
			let l = line('.')
			let c = col('.')
			call cursor(1,1)
			while search('<\@<=script\>', 'W') && line('.') <= l
				if synIDattr(synID(line('.'),col('.')-1,0),"name") !~? 'comment'
					let sname = matchstr(getline('.'), '<script[^>]*src\s*=\s*\([''"]\)\zs.\{-}\ze\1')
					if filereadable(sname)
						let b:js_extfiles += readfile(sname)
					endif
				endif
			endwhile
			call cursor(1,1)
			let js_scripttags = []
			while search('<script\>', 'W') && line('.') < l
				if matchstr(getline('.'), '<script[^>]*src') == ''
					let js_scripttag = getline(line('.'), search('</script>', 'W'))
					let js_scripttags += js_scripttag
				endif
			endwhile
			let b:js_extfiles += js_scripttags
			call cursor(l,c)
			unlet! l c
		endif
	endif
	" }}}
	if !exists("b:csscompl") && !exists("b:jscompl")
		let b:compl_context = getline('.')[0:(compl_begin)]
		if b:compl_context !~ '<[^>]*$'
			" Look like we may have broken tag. Check previous lines.
			let i = 1
			while 1
				let context_line = getline(curline-i)
				if context_line =~ '<[^>]*$'
					" Yep, this is this line
					let context_lines = getline(curline-i, curline-1) + [b:compl_context]
					let b:compl_context = join(context_lines, ' ')
					break
				elseif context_line =~ '>[^<]*$' || i == curline
					" We are in normal tag line, no need for completion at all
					" OR reached first line without tag at all
					let b:compl_context = ''
					break
				endif
				let i += 1
			endwhile
			" Make sure we don't have counter
			unlet! i
		endif
		let b:compl_context = matchstr(b:compl_context, '.*\zs<.*')

		" Return proper start for on-events. Without that beginning of
		" completion will be badly reported
		if b:compl_context =~? 'on[a-z]*\s*=\s*\(''[^'']*\|"[^"]*\)$'
			let start = col('.') - 1
			while start >= 0 && line[start - 1] =~ '\k'
				let start -= 1
			endwhile
		endif
		" If b:compl_context begins with <? we are inside of PHP code. It
		" wasn't closed so PHP completion passed it to HTML
		if &filetype =~? 'php' && b:compl_context =~ '^<?'
			let b:phpcompl = 1
			let start = col('.') - 1
			while start >= 0 && line[start - 1] =~ '[a-zA-Z_0-9\x7f-\xff$]'
				let start -= 1
			endwhile
		endif
	else
		let b:compl_context = getline('.')[0:compl_begin]
	endif
    return start
  else
	" Initialize base return lists
    let res = []
    let res2 = []
	" a:base is very short - we need context
	let context = b:compl_context
	" Check if we should do CSS completion inside of <style> tag
	" or JS completion inside of <script> tag or PHP completion in case of <?
	" tag AND &ft==php
	if exists("b:csscompl")
		unlet! b:csscompl
		let context = b:compl_context
		unlet! b:compl_context
		return csscomplete#CompleteCSS(0, context)
	elseif exists("b:jscompl")
		unlet! b:jscompl
		return javascriptcomplete#CompleteJS(0, a:base)
	elseif exists("b:phpcompl")
		unlet! b:phpcompl
		let context = b:compl_context
		return phpcomplete#CompletePHP(0, a:base)
	else
		if len(b:compl_context) == 0 && !exists("b:entitiescompl")
			return []
		endif
		let context = matchstr(b:compl_context, '.\zs.*')
	endif
	unlet! b:compl_context
	" Entities completion {{{
	if exists("b:entitiescompl")
		unlet! b:entitiescompl

		if !exists("b:html_doctype")
			call htmlcomplete#CheckDoctype()
		endif
		if !exists("b:html_omni")
			"runtime! autoload/xml/xhtml10s.vim
			call htmlcomplete#LoadData()
		endif

	    let entities =  b:html_omni['vimxmlentities']

		if len(a:base) == 1
			for m in entities
				if m =~ '^'.a:base
					call add(res, m.';')
				endif
			endfor
			return res
		else
			for m in entities
				if m =~? '^'.a:base
					call add(res, m.';')
				elseif m =~? a:base
					call add(res2, m.';')
				endif
			endfor

			return res + res2
		endif


	endif
	" }}}
	if context =~ '>'
		" Generally if context contains > it means we are outside of tag and
		" should abandon action - with one exception: <style> span { bo
		if context =~ 'style[^>]\{-}>[^<]\{-}$'
			return csscomplete#CompleteCSS(0, context)
		elseif context =~ 'script[^>]\{-}>[^<]\{-}$'
			let b:jsrange = [line('.'), search('<\/script\>', 'nW')]
			return javascriptcomplete#CompleteJS(0, context)
		else
			return []
		endif
	endif

	" If context contains > it means we are already outside of tag and we
	" should abandon action
	" If context contains white space it is attribute.
	" It can be also value of attribute.
	" We have to get first word to offer proper completions
	if context =~ '^\s*$'
		" empty or whitespace line
		let tag = ''
	else
		let tag = split(context)[0]
		" Detect if tag is uppercase to return in proper case,
		" we need to make it lowercase for processing
		if tag =~ '^[A-Z]*$'
			let uppercase_tag = 1
			let tag = tolower(tag)
		else
			let uppercase_tag = 0
		endif
	endif
	" Get last word, it should be attr name
	let attr = matchstr(context, '.*\s\zs.*')
	" Possible situations where any prediction would be difficult:
	" 1. Events attributes
	if context =~ '\s'
		" Sort out style, class, and on* cases
		if context =~? "\\(on[a-z]*\\|id\\|style\\|class\\)\\s*=\\s*[\"']"
			" Id, class completion {{{
			if context =~? "\\(id\\|class\\)\\s*=\\s*[\"'][a-zA-Z0-9_ -]*$"
				if context =~? "class\\s*=\\s*[\"'][a-zA-Z0-9_ -]*$"
					let search_for = "class"
				elseif context =~? "id\\s*=\\s*[\"'][a-zA-Z0-9_ -]*$"
					let search_for = "id"
				endif
				" Handle class name completion
				" 1. Find lines of <link stylesheet>
				" 1a. Check file for @import
				" 2. Extract filename(s?) of stylesheet,
				call cursor(1,1)
				let head = getline(search('<head\>'), search('<\/head>'))
				let headjoined = join(copy(head), ' ')
				if headjoined =~ '<style'
					" Remove possibly confusing CSS operators
					let stylehead = substitute(headjoined, '+>\*[,', ' ', 'g')
					if search_for == 'class'
						let styleheadlines = split(stylehead)
						let headclasslines = filter(copy(styleheadlines), "v:val =~ '\\([a-zA-Z0-9:]\\+\\)\\?\\.[a-zA-Z0-9_-]\\+'")
					else
						let stylesheet = split(headjoined, '[{}]')
						" Get all lines which fit id syntax
						let classlines = filter(copy(stylesheet), "v:val =~ '#[a-zA-Z0-9_-]\\+'")
						" Filter out possible color definitions
						call filter(classlines, "v:val !~ ':\\s*#[a-zA-Z0-9_-]\\+'")
						" Filter out complex border definitions
						call filter(classlines, "v:val !~ '\\(none\\|hidden\\|dotted\\|dashed\\|solid\\|double\\|groove\\|ridge\\|inset\\|outset\\)\\s*#[a-zA-Z0-9_-]\\+'")
						let templines = join(classlines, ' ')
						let headclasslines = split(templines)
						call filter(headclasslines, "v:val =~ '#[a-zA-Z0-9_-]\\+'")
					endif
					let internal = 1
				else
					let internal = 0
				endif
				let styletable = []
				let secimportfiles = []
				let filestable = filter(copy(head), "v:val =~ '\\(@import\\|link.*stylesheet\\)'")
				for line in filestable
					if line =~ "@import"
						let styletable += [matchstr(line, "import\\s\\+\\(url(\\)\\?[\"']\\?\\zs\\f\\+\\ze")]
					elseif line =~ "<link"
						let styletable += [matchstr(line, "href\\s*=\\s*[\"']\\zs\\f\\+\\ze")]
					endif
				endfor
				for file in styletable
					if filereadable(file)
						let stylesheet = readfile(file)
						let secimport = filter(copy(stylesheet), "v:val =~ '@import'")
						if len(secimport) > 0
							for line in secimport
								let secfile = matchstr(line, "import\\s\\+\\(url(\\)\\?[\"']\\?\\zs\\f\\+\\ze")
								let secfile = fnamemodify(file, ":p:h").'/'.secfile
								let secimportfiles += [secfile]
							endfor
						endif
					endif
				endfor
				let cssfiles = styletable + secimportfiles
				let classes = []
				for file in cssfiles
				  	let classlines = []
					if filereadable(file)
						let stylesheet = readfile(file)
						let stylefile = join(stylesheet, ' ')
						let stylefile = substitute(stylefile, '+>\*[,', ' ', 'g')
						if search_for == 'class'
							let stylesheet = split(stylefile)
							let classlines = filter(copy(stylesheet), "v:val =~ '\\([a-zA-Z0-9:]\\+\\)\\?\\.[a-zA-Z0-9_-]\\+'")
						else
							let stylesheet = split(stylefile, '[{}]')
							" Get all lines which fit id syntax
							let classlines = filter(copy(stylesheet), "v:val =~ '#[a-zA-Z0-9_-]\\+'")
							" Filter out possible color definitions
							call filter(classlines, "v:val !~ ':\\s*#[a-zA-Z0-9_-]\\+'")
							" Filter out complex border definitions
							call filter(classlines, "v:val !~ '\\(none\\|hidden\\|dotted\\|dashed\\|solid\\|double\\|groove\\|ridge\\|inset\\|outset\\)\\s*#[a-zA-Z0-9_-]\\+'")
							let templines = join(classlines, ' ')
							let stylelines = split(templines)
							let classlines = filter(stylelines, "v:val =~ '#[a-zA-Z0-9_-]\\+'")

						endif
					endif
					" We gathered classes definitions from all external files
					let classes += classlines
				endfor
				if internal == 1
					let classes += headclasslines
				endif

				if search_for == 'class'
					let elements = {}
					for element in classes
						if element =~ '^\.'
							let class = matchstr(element, '^\.\zs[a-zA-Z][a-zA-Z0-9_-]*\ze')
							let class = substitute(class, ':.*', '', '')
							if has_key(elements, 'common')
								let elements['common'] .= ' '.class
							else
								let elements['common'] = class
							endif
						else
							let class = matchstr(element, '[a-zA-Z1-6]*\.\zs[a-zA-Z][a-zA-Z0-9_-]*\ze')
							letÍr  Îr  Ïr  Ðr  Ñr  Òr  Ór  Ôr  Õr  Ör  ×r  Ør  Ùr                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               tagname = tolower(matchstr(element, '[a-zA-Z1-6]*\ze.'))
							if tagname != ''
								if has_key(elements, tagname)
									let elements[tagname] .= ' '.class
								else
									let elements[tagname] = class
								endif
							endif
						endif
					endfor

					if has_key(elements, tag) && has_key(elements, 'common')
						let values = split(elements[tag]." ".elements['common'])
					elseif has_key(elements, tag) && !has_key(elements, 'common')
						let values = split(elements[tag])
					elseif !has_key(elements, tag) && has_key(elements, 'common')
						let values = split(elements['common'])
					else
						return []
					endif

				elseif search_for == 'id'
					" Find used IDs
					" 1. Catch whole file
					let filelines = getline(1, line('$'))
					" 2. Find lines with possible id
					let used_id_lines = filter(filelines, 'v:val =~ "id\\s*=\\s*[\"''][a-zA-Z0-9_-]\\+"')
					" 3a. Join all filtered lines
					let id_string = join(used_id_lines, ' ')
					" 3b. And split them to be sure each id is in separate item
					let id_list = split(id_string, 'id\s*=\s*')
					" 4. Extract id values
					let used_id = map(id_list, 'matchstr(v:val, "[\"'']\\zs[a-zA-Z0-9_-]\\+\\ze")')
					let joined_used_id = ','.join(used_id, ',').','

					let allvalues = map(classes, 'matchstr(v:val, ".*#\\zs[a-zA-Z0-9_-]\\+")')

					let values = []

					for element in classes
						if joined_used_id !~ ','.element.','
							let values += [element]
						endif

					endfor

				endif

				" We need special version of sbase
				let classbase = matchstr(context, ".*[\"']")
				let classquote = matchstr(classbase, '.$')

				let entered_class = matchstr(attr, ".*=\\s*[\"']\\zs.*")

				for m in sort(values)
					if m =~? '^'.entered_class
						call add(res, m . classquote)
					elseif m =~? entered_class
						call add(res2, m . classquote)
					endif
				endfor

				return res + res2

			elseif context =~? "style\\s*=\\s*[\"'][^\"']*$"
				return csscomplete#CompleteCSS(0, context)

			endif
			" }}}
			" Complete on-events {{{
			if context =~? 'on[a-z]*\s*=\s*\(''[^'']*\|"[^"]*\)$'
				" We have to:
				" 1. Find external files
				let b:js_extfiles = []
				let l = line('.')
				let c = col('.')
				call cursor(1,1)
				while search('<\@<=script\>', 'W') && line('.') <= l
					if synIDattr(synID(line('.'),col('.')-1,0),"name") !~? 'comment'
						let sname = matchstr(getline('.'), '<script[^>]*src\s*=\s*\([''"]\)\zs.\{-}\ze\1')
						if filereadable(sname)
							let b:js_extfiles += readfile(sname)
						endif
					endif
				endwhile
				" 2. Find at least one <script> tag
				call cursor(1,1)
				let js_scripttags = []
				while search('<script\>', 'W') && line('.') < l
					if matchstr(getline('.'), '<script[^>]*src') == ''
						let js_scripttag = getline(line('.'), search('</script>', 'W'))
						let js_scripttags += js_scripttag
					endif
				endwhile
				let b:js_extfiles += js_scripttags

				" 3. Proper call for javascriptcomplete#CompleteJS
				call cursor(l,c)
				let js_context = matchstr(a:base, '\k\+$')
				let js_shortcontext = substitute(a:base, js_context.'$', '', '')
				let b:compl_context = context
				let b:jsrange = [l, l]
				unlet! l c
				return javascriptcomplete#CompleteJS(0, js_context)

			endif

			" }}}
			let stripbase = matchstr(context, ".*\\(on[a-zA-Z]*\\|style\\|class\\)\\s*=\\s*[\"']\\zs.*")
			" Now we have context stripped from all chars up to style/class.
			" It may fail with some strange style value combinations.
			if stripbase !~ "[\"']"
				return []
			endif
		endif
		" Value of attribute completion {{{
		" If attr contains =\s*[\"'] we match value of attribute
		if attr =~ "=\s*[\"']" || attr =~ "=\s*$"
			" Let do attribute specific completion
			let attrname = matchstr(attr, '.*\ze\s*=')
			let entered_value = matchstr(attr, ".*=\\s*[\"']\\?\\zs.*")
			let values = []
			" Load data {{{
			if !exists("b:html_doctype")
				call htmlcomplete#CheckDoctype()
			endif
			if !exists("b:html_omni")
				"runtime! autoload/xml/xhtml10s.vim
				call htmlcomplete#LoadData()
			endif
			" }}}
			if attrname == 'href'
				" Now we are looking for local anchors defined by name or id
				if entered_value =~ '^#'
					let file = join(getline(1, line('$')), ' ')
					" Split it be sure there will be one id/name element in
					" item, it will be also first word [a-zA-Z0-9_-] in element
					let oneelement = split(file, "\\(meta \\)\\@<!\\(name\\|id\\)\\s*=\\s*[\"']")
					for i in oneelement
						let values += ['#'.matchstr(i, "^[a-zA-Z][a-zA-Z0-9%_-]*")]
					endfor
				endif
			else
				if has_key(b:html_omni, tag) && has_key(b:html_omni[tag][1], attrname)
					let values = b:html_omni[tag][1][attrname]
				else
					return []
				endif
			endif

			if len(values) == 0
				return []
			endif

			" We need special version of sbase
			let attrbase = matchstr(context, ".*[\"']")
			let attrquote = matchstr(attrbase, '.$')
			if attrquote !~ "['\"]"
				let attrquoteopen = '"'
				let attrquote = '"'
			else
				let attrquoteopen = ''
			endif

			for m in values
				" This if is needed to not offer all completions as-is
				" alphabetically but sort them. Those beginning with entered
				" part will be as first choices
				if m =~ '^'.entered_value
					call add(res, attrquoteopen . m . attrquote)
				elseif m =~ entered_value
					call add(res2, attrquoteopen . m . attrquote)
				endif
			endfor

			return res + res2

		endif
		" }}}
		" Attribute completion {{{
		" Shorten context to not include last word
		let sbase = matchstr(context, '.*\ze\s.*')

		" Load data {{{
		if !exists("b:html_doctype")
			call htmlcomplete#CheckDoctype()
		endif
		if !exists("b:html_omni")
			call htmlcomplete#LoadData()
		endif
		" }}}

		if has_key(b:html_omni, tag)
			let attrs = keys(b:html_omni[tag][1])
		else
			return []
		endif

		for m in sort(attrs)
			if m =~ '^'.attr
				call add(res, m)
			elseif m =~ attr
				call add(res2, m)
			endif
		endfor
		let menu = res + res2
		if has_key(b:html_omni, 'vimxmlattrinfo')
			let final_menu = []
			for i in range(len(menu))
				let item = menu[i]
				if has_key(b:html_omni['vimxmlattrinfo'], item)
					let m_menu = b:html_omni['vimxmlattrinfo'][item][0]
					let m_info = b:html_omni['vimxmlattrinfo'][item][1]
				else
					let m_menu = ''
					let m_info = ''
				endif
				if len(b:html_omni[tag][1][item]) > 0 && b:html_omni[tag][1][item][0] =~ '^\(BOOL\|'.item.'\)$'
					let item = item
					let m_menu = 'Bool'
				else
					let item .= '="'
				endif
				let final_menu += [{'word':item, 'menu':m_menu, 'info':m_info}]
			endfor
		else
			let final_menu = []
			for i in range(len(menu))
				let item = menu[i]
				if len(b:html_omni[tag][1][item]) > 0 && b:html_omni[tag][1][item][0] =~ '^\(BOOL\|'.item.'\)$'
					let item = item
				else
					let item .= '="'
				endif
				let final_menu += [item]
			endfor
			return final_menu

		endif
		return final_menu

	endif
	" }}}
	" Close tag {{{
	let b:unaryTagsStack = "base meta link hr br param img area input col"
	if context =~ '^\/'
		if context =~ '^\/.'
			return []
		else
			let opentag = xmlcomplete#GetLastOpenTag("b:unaryTagsStack")
			return [opentag.">"]
		endif
	endif
	" }}}
	" Load data {{{
	if !exists("b:html_doctype")
		call htmlcomplete#CheckDoctype()
	endif
	if !exists("b:html_omni")
		"runtime! autoload/xml/xhtml10s.vim
		call htmlcomplete#LoadData()
	endif
	" }}}
	" Tag completion {{{
	" Deal with tag completion.
	let opentag = tolower(xmlcomplete#GetLastOpenTag("b:unaryTagsStack"))
	" MM: TODO: GLOT works always the same but with some weird situation it
	" behaves as intended in HTML but screws in PHP
	if opentag == '' || &filetype == 'php' && !has_key(b:html_omni, opentag)
		" Hack for sometimes failing GetLastOpenTag.
		" As far as I tested fail isn't GLOT fault but problem
		" of invalid document - not properly closed tags and other mish-mash.
		" Also when document is empty. Return list of *all* tags.
	    let tags = keys(b:html_omni)
		call filter(tags, 'v:val !~ "^vimxml"')
	else
		if has_key(b:html_omni, opentag)
			let tags = b:html_omni[opentag][0]
		else
			return []
		endif
	endif
	" }}}

	if exists("uppercase_tag") && uppercase_tag == 1
		let context = tolower(context)
	endif
	" Handle XML keywords: DOCTYPE
	if opentag == ''
		let tags += [
				\ '!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">',
				\ '!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">',
				\ '!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">',
				\ '!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN" "http://www.w3.org/TR/REC-html40/frameset.dtd">',
				\ '!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">',
				\ '!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">',
				\ '!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd">',
				\ '!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">',
				\ '!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">',
				\ '!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">',
				\ '!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/1999/xhtml">'
				\ ]
	endif

	for m in sort(tags)
		if m =~ '^'.context
			call add(res, m)
		elseif m =~ context
			call add(res2, m)
		endif
	endfor
	let menu = res + res2
	if has_key(b:html_omni, 'vimxmltaginfo')
		let final_menu = []
		for i in range(len(menu))
			let item = menu[i]
			if has_key(b:html_omni['vimxmltaginfo'], item)
				let m_menu = b:html_omni['vimxmltaginfo'][item][0]
				let m_info = b:html_omni['vimxmltaginfo'][item][1]
			else
				let m_menu = ''
				let m_info = ''
			endif
			if &filetype == 'html' && exists("uppercase_tag") && uppercase_tag == 1 && item !~ 'DOCTYPE'
				let item = toupper(item)
			endif
			if item =~ 'DOCTYPE'
				let abbr = 'DOCTYPE '.matchstr(item, 'DTD \zsX\?HTML .\{-}\ze\/\/')
			else
				let abbr = item
			endif
			let final_menu += [{'abbr':abbr, 'word':item, 'menu':m_menu, 'info':m_info}]
		endfor
	else
		let final_menu = menu
	endif
	return final_menu

	" }}}
  endif
endfunction

function! htmlcomplete#LoadData() " {{{
	if !exists("b:html_omni_flavor")
		if &filetype == 'html'
			let b:html_omni_flavor = 'html401t'
		else
			let b:html_omni_flavor = 'xhtml10s'
		endif
	endif
	" With that if we still have bloated memory but create new buffer
	" variables only by linking to existing g:variable, not sourcing whole
	" file.
	if exists('g:xmldata_'.b:html_omni_flavor)
		exe 'let b:html_omni = g:xmldata_'.b:html_omni_flavor
	else
		exe 'runtime! autoload/xml/'.b:html_omni_flavor.'.vim'
		exe 'let b:html_omni = g:xmldata_'.b:html_omni_flavor
	endif
endfunction
" }}}
function! htmlcomplete#CheckDoctype() " {{{
	if exists('b:html_omni_flavor')
		let old_flavor = b:html_omni_flavor
	else
		let old_flavor = ''
	endif
	let i = 1
	while i < 10 && i < line("$")
		let line = getline(i)
		if line =~ '<!DOCTYPE.*\<DTD HTML 3\.2'
			let b:html_omni_flavor = 'html32'
			let b:html_doctype = 1
			break
		elseif line =~ '<!DOCTYPE.*\<DTD HTML 4\.0 Transitional'
			let b:html_omni_flavor = 'html40t'
			let b:html_doctype = 1
			break
		elseif line =~ '<!DOCTYPE.*\<DTD HTML 4\.0 Frameset'
			let b:html_omni_flavor = 'html40f'
			let b:html_doctype = 1
			break
		elseif line =~ '<!DOCTYPE.*\<DTD HTML 4\.0'
			let b:html_omni_flavor = 'html40s'
			let b:html_doctype = 1
			break
		elseif line =~ '<!DOCTYPE.*\<DTD HTML 4\.01 Transitional'
			let b:html_omni_flavor = 'html401t'
			let b:html_doctype = 1
			break
		elseif line =~ '<!DOCTYPE.*\<DTD HTML 4\.01 Frameset'
			let b:html_omni_flavor = 'html401f'
			let b:html_doctype = 1
			break
		elseif line =~ '<!DOCTYPE.*\<DTD HTML 4\.01'
			let b:html_omni_flavor = 'html401s'
			let b:html_doctype = 1
			break
		elseif line =~ '<!DOCTYPE.*\<DTD XHTML 1\.0 Transitional'
			let b:html_omni_flavor = 'xhtml10t'
			let b:html_doctype = 1
			break
		elseif line =~ '<!DOCTYPE.*\<DTD XHTML 1\.0 Frameset'
			let b:html_omni_flavor = 'xhtml10f'
			let b:html_doctype = 1
			break
		elseif line =~ '<!DOCTYPE.*\<DTD XHTML 1\.0 Strict'
			let b:html_omni_flavor = 'xhtml10s'
			let b:html_doctype = 1
			break
		elseif line =~ '<!DOCTYPE.*\<DTD XHTML 1\.1'
			let b:html_omni_flavor = 'xhtml11'
			let b:html_doctype = 1
			break
		endif
		let i += 1
	endwhile
	if !exists("b:html_doctype")
		return
	else
		" Tie g:xmldata with b:html_omni this way we need to sourca data file only
		" once, not every time per buffer.
		if old_flavor == b:html_omni_flavor
			return
		else
			if exists('g:xmldata_'.b:html_omni_flavor)
				exe 'let b:html_omni = g:xmldata_'.b:html_omni_flavor
			else
				exe 'runtime! autoload/xml/'.b:html_omni_flavor.'.vim'
				exe 'let b:html_omni = g:xmldata_'.b:html_omni_flavor
			endif
			return
		endif
	endif
endfunction
" }}}
" vim:set foldmethod=marker:
                                                                                                                      " Vim completion script
" Language:	Java Script
" Maintainer:	Jay Sitter (jay@jaysitter.com)
" URL: https://github.com/jsit/javascriptcomplete.vim/
" Previous Maintainer:	Mikolaj Machowski ( mikmach AT wp DOT pl )
" Last Change:	2020 Jul 30

function! javascriptcomplete#CompleteJS(findstart, base)
  if a:findstart
	" locate the start of the word
	let line = getline('.')
	let start = col('.') - 1
	let curline = line('.')
	let compl_begin = col('.') - 2
	" Bit risky but JS is rather limited language and local chars shouldn't
	" fint way into names
	while start >= 0 && line[start - 1] =~ '\k'
		let start -= 1
	endwhile
	let b:compl_context = getline('.')[0:compl_begin]
	return start
  else
	" Initialize base return lists
	let res = []
	let res2 = []
	" a:base is very short - we need context
	" Shortcontext is context without a:base, useful for checking if we are
	" looking for objects and for what objects we are looking for
	let context = b:compl_context
	let shortcontext = substitute(context, a:base.'$', '', '')
	unlet! b:compl_context

	if exists("b:jsrange")
		let file = getline(b:jsrange[0],b:jsrange[1])
		unlet! b:jsrange

		if len(b:js_extfiles) > 0
			let file = b:js_extfiles + file
		endif

	else
		let file = getline(1, '$')
	endif


	" Completion of properties, methods, etc. {{{
	if shortcontext =~ '\.$'
		" Complete methods and properties for objects
		" DOM separate
		let doms = ['style.']
		" Arrays
		let arrayprop = ['constructor', 'index', 'input', 'length', 'prototype']
		let arraymeth = ['concat', 'join', 'pop', 'push', 'reverse', 'shift',
					\ 'splice', 'sort', 'toSource', 'toString', 'unshift', 'valueOf',
					\ 'watch', 'unwatch']
		call map(arraymeth, 'v:val."("')
		let arrays = arrayprop + arraymeth

		" Boolean - complete subset of array values
		" properties - constructor, prototype
		" methods    - toSource, toString, valueOf

		" Date
		" properties - constructor, prototype
		let datemeth = ['getDate', 'getDay', 'getFullYear', 'getHours', 'getMilliseconds',
					\ 'getMinutes', 'getMonth', 'getSeconds', 'getTime', 'getTimezoneOffset',
					\ 'getUTCDate', 'getUTCDay', 'getUTCFullYear', 'getUTCHours', 'getUTCMilliseconds',
					\ 'getUTCMinutes', 'getUTCMonth', 'getUTCSeconds',
					\ 'getYear', 'parse', 'parse',
					\ 'setDate', 'setDay', 'setFullYear', 'setHours', 'setMilliseconds',
					\ 'setMinutes', 'setMonth', 'setSeconds',
					\ 'setUTCDate', 'setUTCDay', 'setUTCFullYear', 'setUTCHours', 'setUTCMilliseconds',
					\ 'setUTCMinutes', 'setUTCMonth', 'setUTCSeconds', 'setYear', 'setTime',
					\ 'toGMTString', 'toLocaleString', 'toLocaleDateString', 'toLocaleTimeString',
					\ 'toSource', 'toString', 'toUTCString', 'UTC', 'valueOf', 'watch', 'unwatch']
		call map(datemeth, 'v:val."("')
		let dates = datemeth

		" Function
		let funcprop = ['arguments', 'arguments.callee', 'arguments.caller', 'arguments.length',
					\ 'arity', 'constructor', 'length', 'prototype']
		let funcmeth = ['apply', 'call', 'toSource', 'toString', 'valueOf']
		call map(funcmeth, 'v:val."("')
		let funcs = funcprop + funcmeth

		" Math
		let mathprop = ['E', 'LN2', 'LN10', 'LOG2E', 'LOG10E', 'PI', 'SQRT1_2', 'SQRT']
		let mathmeth = ['abs', 'acos', 'asin', 'atan', 'atan2', 'ceil', 'cos', 'exp', 'floor',
					\ 'log', 'max', 'min', 'pow', 'random', 'round', 'sin', 'sqrt', 'tan',
					\ 'watch', 'unwatch']
		call map(mathmeth, 'v:val."("')
		let maths = mathprop + mathmeth

		" Number
		let numbprop = ['MAX_VALUE', 'MIN_VALUE', 'NaN', 'NEGATIVE_INFINITY', 'POSITIVE_INFINITY', 
					\ 'constructor', 'prototype']
		let numbmeth = ['toExponential', 'toFixed', 'toPrecision', 'toSource', 'toString', 'valueOf',
					\ 'watch', 'unwatch']
		call map(numbmeth, 'v:val."("')
		let numbs = numbprop + numbmeth

		" Object
		let objeprop = ['constructor', 'prototype']
		let objemeth = ['eval', 'toSource', 'toString', 'unwatch', 'watch', 'valueOf']
		call map(objemeth, 'v:val."("')
		let objes = objeprop + objemeth

		" RegExp
		let regeprop = ['constructor', 'global', 'ignoreCase', 'lastIndex', 'multiline', 'source', 'prototype']
		let regemeth = ['exec', 'test', 'toSource', 'toString', 'watch', 'unwatch']
		call map(regemeth, 'v:val."("')
		let reges = regeprop + regemeth

		" String
		let striprop = ['constructor', 'length', 'prototype']
		let strimeth = ['anchor', 'big', 'blink', 'bold', 'charAt', 'charCodeAt', 'concat',
					\ 'fixed', 'fontcolor', 'fontsize', 'fromCharCode', 'indexOf', 'italics',
					\ 'lastIndexOf', 'link', 'match', 'replace', 'search', 'slice', 'small',
					\ 'split', 'strike', 'sub', 'substr', 'substring', 'sup', 'toLowerCase',
					\ 'toSource', 'toString', 'toUpperCase', 'watch', 'unwatch']
		call map(strimeth, 'v:val."("')
		let stris = striprop + strimeth

		" User created properties
		let user_props1 = filter(copy(file), 'v:val =~ "this\\.\\k"')
		let juser_props1 = join(user_props1, ' ')
		let user_props1 = split(juser_props1, '\zethis\.')
		unlet! juser_props1
		call map(user_props1, 'matchstr(v:val, "this\\.\\zs\\k\\+\\ze")')

		let user_props2 = filter(copy(file), 'v:val =~ "\\.prototype\\.\\k"')
		let juser_props2 = join(user_props2, ' ')
		let user_props2 = split(juser_props2, '\zeprototype\.')
		unlet! juser_props2
		call map(user_props2, 'matchstr(v:val, "prototype\\.\\zs\\k\\+\\ze")')
		let user_props = user_props1 + user_props2

		" HTML DOM properties
		" Anchors - anchor.
		let anchprop = ['accessKey', 'charset', 'coords', 'href', 'hreflang', 'id', 'innerHTML',
					\ 'name', 'rel', 'rev', 'shape', 'tabIndex', 'target', 'type', 'onBlur', 'onFocus']
		let anchmeth = ['blur', 'focus']
		call map(anchmeth, 'v:val."("')
		let anths = anchprop + anchmeth
		" Area - area.
		let areaprop = ['accessKey', 'alt', 'coords', 'hash', 'host', 'hostname', 'href', 'id',
					\ 'noHref', 'pathname', 'port', 'protocol', 'search', 'shape', 'tabIndex', 'target']
		let areameth = ['onClick', 'onDblClick', 'onMouseOut', 'onMouseOver']
		call map(areameth, 'v:val."("')
		let areas = areaprop + areameth
		" Base - base.
		let baseprop = ['href', 'id', 'target']
		let bases = baseprop
		" Body - body.
		let bodyprop = ['aLink', 'background', 'gbColor', 'id', 'link', 'scrollLeft', 'scrollTop',
					\ 'text', 'vLink']
		let bodys = bodyprop
		" Document - document.
		let docuprop = ['anchors', 'body', 'characterSet', 'doctype',
					\ 'documentElement', 'documentURI', 'embeds', 'fonts', 'forms',
					\ 'head', 'hidden', 'images', 'implementation', 'lastStyleSheetSet',
					\ 'links', 'plugins', 'preferredStyleSheetSet', 'scripts',
					\ 'scrollingElement', 'selectedStyleSheetSet', 'styleSheetSets',
					\ 'timeline', 'visibilityState', 'cookie', 'defaultView',
					\ 'designMode', 'dir', 'domain', 'lastModified', 'location',
					\ 'readyState', 'referrer', 'title', 'URL', 'activeElement',
					\ 'fullscreenElement', 'styleSheets']
		let documeth = ['adoptNode', 'close', 'createAttribute',
					\ 'createAttributeNS', 'createCDATASection', 'createComment',
					\ 'createDocumentFragment', 'createElement', 'createElementNS',
					\ 'createEvent', 'createExpression', 'createNSResolver',
					\ 'createNodeIterator', 'createProcessingInstruction', 'createRange',
					\ 'createTextNode', 'createTouchList', 'createTreeWalker',
					\ 'enableStyleSheetsForSet', 'evaluate', 'focus', 'getElementById',
					\ 'getElementById', 'getElementsByClassName', 'getElementsByName',
					\ 'getElementsByTagName', 'getElementsByTagNameNS',
					\ 'hasStorageAccess', 'importNode', 'onClick', 'onDblClick',
					\ 'onFocus', 'onKeyDown', 'onKeyPress', 'onKeyUp', 'onMouseDown',
					\ 'onMouseMove', 'onMouseOut', 'onMouseOver', 'onMouseUp',
					\ 'onResize', 'open', 'querySelector', 'querySelectorAll',
					\ 'requestStorageAccess', 'write', 'writeln']

		call map(documeth, 'v:val."("')
		let docuxprop = ['attributes', 'childNodes', 'doctype', 'documentElement', 'firstChild',
					\ 'implementation', 'namespaceURI', 'nextSibling', 'nodeName', 'nodeType',
					\ 'nodeValue', 'ownerDocument', 'parentNode', 'previousSibling']
		let docuxmeth = ['createAttribute', 'createCDATASection',
					\ 'createComment', 'createDocument', 'createDocumentFragment',
					\ 'createElement', 'createEntityReference', 'createProcessingInstruction',
					\ 'createTextNode']
		call map(docuxmeth, 'v:val."("')
		let docus = docuprop + docuxprop + documeth + docuxmeth
		" Form - form.
		let formprop = ['elements', 'acceptCharset', 'action', 'encoding', 'enctype', 'id', 'length',
					\ 'method', 'name', 'tabIndex', 'target']
		let formmeth = ['reset', 'submit', 'onReset', 'onSubmit']
		call map(formmeth, 'v:val."("')
		let forms = formprop + formmeth
		" Frame - frame.
		let framprop = ['contentDocument', 'frameBorder', 'id', 'longDesc', 'marginHeight', 'marginWidth',
					\ 'name', 'noResize', 'scrolling', 'src']
		let frammeth = ['blur', 'focus']
		call map(frammeth, 'v:val."("')
		let frams = framprop + frammeth
		" Frameset - frameset.
		let fsetprop = ['cols', 'id', 'rows']
		let fsetmeth = ['blur', 'focus']
		call map(fsetmeth, 'v:val."("')
		let fsets = fsetprop + fsetmeth
		" History - history.
		let histprop = ['length']
		let histmeth = ['back', 'forward', 'go']
		call map(histmeth, 'v:val."("')
		let hists = histprop + histmeth
		" Iframe - iframe.
		let ifraprop = ['align', 'frameBorder', 'height', 'id', 'longDesc', 'marginHeight', 'marginWidth',
					\ 'name', 'scrolling', 'src', 'width']
		let ifras = ifraprop
		" Image - image.
		let imagprop = ['align', 'alt', 'border', 'complete', 'height', 'hspace', 'id', 'isMap', 'longDesc',
					\ 'lowSrc', 'name', 'src', 'useMap', 'vspace', 'width']
		let imagmeth = ['onAbort', 'onError', 'onLoad']
		call map(imagmeth, 'v:val."("')
		let imags = histprop + imagmeth
		" Button - accessible only by other properties
		let buttprop = ['accessKey', 'disabled', 'form', 'id', 'name', 'tabIndex', 'type', 'value']
		let buttmeth = ['blur', 'click', 'focus', 'onBlur', 'onClick', 'onFocus', 'onMouseDown', 'onMouseUp']
		call map(buttmeth, 'v:val."("')
		let butts = buttprop + buttmeth
		" Checkbox - accessible only by other properties
		let checprop = ['accept', 'accessKey', 'align', 'alt', 'checked', 'defaultChecked', 
					\ 'disabled', 'form', 'id', 'name', 'tabIndex', 'type', 'value'] 
		let checmeth = ['blur', 'click', 'focus', 'onBlur', 'onClick', 'onFocus', 'onMouseDown', 'onMouseUp']
		call map(checmeth, 'v:val."("')
		let checs = checprop + checmeth
		" File upload - accessible only by other properties
		let fileprop = ['accept', 'accessKey', 'align', 'alt', 'defaultValue', 
					\ 'disabled', 'form', 'id', 'name', 'tabIndex', 'type', 'value'] 
		let filemeth = ['blur', 'focus', 'onBlur', 'onClick', 'onFocus', 'onMouseDown', 'onMouseUp']
		call map(filemeth, 'v:val."("')
		let files = fileprop + filemeth
		" Hidden - accessible only by other properties
		let hiddprop = ['defaultValue', 'form', 'id', 'name', 'type', 'value'] 
		let hidds = hiddprop
		" Password - accessible only by other properties
		let passprop = ['accept', 'accessKey', 'defaultValue', 
					\ 'disabled', 'form', 'id', 'maxLength', 'name', 'readOnly', 'size', 'tabIndex', 
					\ 'type', 'value'] 
		let passmeth = ['blur', 'click', 'focus', 'select', 'onBlur', 'onFocus', 'onKeyDown', 
					\ 'onKeyPress', 'onKeyUp']
		call map(passmeth, 'v:val."("')
		let passs = passprop + passmeth
		" Radio - accessible only by other properties
		let radiprop = ['accept', 'accessKey', 'align', 'alt', 'checked', 'defaultChecked', 
					\ 'disabled', 'form', 'id', 'name', 'tabIndex', 'type', 'value'] 
		let radimeth = ['blur', 'click', 'focus', 'select', 'onBlur', 'onFocus']
		call map(radimeth, 'v:val."("')
		let radis = radiprop + radimeth
		" Reset - accessible only by other properties
		let reseprop = ['accept', 'accessKey', 'align', 'alt', 'defaultValue', 
					\ 'disabled', 'form', 'id', 'name', 'size', 'tabIndex', 'type', 'value'] 
		let resemeth = ['blur', 'click', 'focus', 'select', 'onBlur', 'onFocus']
		call map(resemeth, 'v:val."("')
		let reses = reseprop + resemeth
		" Submit - accessible only by other properties
		let submprop = ['accept', 'accessKey', 'align', 'alt', 'defaultValue', 
					\ 'disabled', 'form', 'id', 'name', 'size', 'tabIndex', 'type', 'value'] 
		let submmeth =çr  èr  ér  êr  ër  ìr  ír  îr  ïr  ðr  ñr  òr  ór  ôr  õr  ör                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ['blur', 'click', 'focus', 'select', 'onClick', 'onSelectStart']
		call map(submmeth, 'v:val."("')
		let subms = submprop + submmeth
		" Text - accessible only by other properties
		let textprop = ['accept', 'accessKey', 'align', 'alt', 'defaultValue', 
					\ 'disabled', 'form', 'id', 'maxLength', 'name', 'readOnly', 
					\ 'size', 'tabIndex', 'type', 'value'] 
		let textmeth = ['blur', 'focus', 'select', 'onBlur', 'onChange', 'onFocus', 'onKeyDown',
					\ 'onKeyPress', 'onKeyUp', 'onSelect']
		call map(textmeth, 'v:val."("')
		let texts = textprop + textmeth
		" Link - link.
		let linkprop = ['charset', 'disabled', 'href', 'hreflang', 'id', 'media',
					\ 'rel', 'rev', 'target', 'type']
		let linkmeth = ['onLoad']
		call map(linkmeth, 'v:val."("')
		let links = linkprop + linkmeth
		" Location - location.
		let locaprop = ['href', 'hash', 'host', 'hostname', 'pathname', 'port', 'protocol',
					\ 'search']
		let locameth = ['assign', 'reload', 'replace']
		call map(locameth, 'v:val."("')
		let locas = locaprop + locameth
		" Meta - meta.
		let metaprop = ['charset', 'content', 'disabled', 'httpEquiv', 'name', 'scheme']
		let metas = metaprop
		" Navigator - navigator.
		let naviprop = ['plugins', 'appCodeName', 'appName', 'appVersion', 'cookieEnabled',
					\ 'platform', 'userAgent']
		let navimeth = ['javaEnabled', 'taintEnabled']
		call map(navimeth, 'v:val."("')
		let navis = naviprop + navimeth
		" Object - object.
		let objeprop = ['align', 'archive', 'border', 'code', 'codeBase', 'codeType', 'data',
					\ 'declare', 'form', 'height', 'hspace', 'id', 'name', 'standby', 'tabIndex',
					\ 'type', 'useMap', 'vspace', 'width']
		let objes = objeprop
		" Option - accessible only by other properties
		let optiprop = ['defaultSelected', 
					\ 'disabled', 'form', 'id', 'index', 'label', 'selected', 'text', 'value']
		let optis = optiprop
		" Screen - screen.
		let screprop = ['availHeight', 'availWidth', 'colorDepth', 'height', 'width']
		let scres = screprop
		" Select - accessible only by other properties
		let seleprop = ['options', 'disabled', 'form', 'id', 'length', 'multiple', 'name', 
					\ 'selectedIndex', 'size', 'tabIndex', 'type', 'value'] 
		let selemeth = ['blur', 'focus', 'remove', 'onBlur', 'onChange', 'onFocus']
		call map(selemeth, 'v:val."("')
		let seles = seleprop + selemeth
		" Style - style.
		let stylprop = ['background', 'backgroundAttachment', 'backgroundColor', 'backgroundImage',
					\ 'backgroundPosition', 'backgroundRepeat',
					\ 'border', 'borderBottom', 'borderLeft', 'borderRight', 'borderTop',
					\ 'borderBottomColor', 'borderLeftColor', 'borderRightColor', 'borderTopColor',
					\ 'borderBottomStyle', 'borderLeftStyle', 'borderRightStyle', 'borderTopStyle',
					\ 'borderBottomWidth', 'borderLeftWidth', 'borderRightWidth', 'borderTopWidth',
					\ 'borderColor', 'borderStyle', 'borderWidth', 'margin', 'marginBottom',
					\ 'marginLeft', 'marginRight', 'marginTop', 'outline', 'outlineStyle', 'outlineWidth',
					\ 'outlineColor', 'outlineStyle', 'outlineWidth', 'padding', 'paddingBottom',
					\ 'paddingLeft', 'paddingRight', 'paddingTop',
					\ 'clear', 'clip', 'clipBottom', 'clipLeft', 'clipRight', 'clipTop', 'content',
					\ 'counterIncrement', 'counterReset', 'cssFloat', 'cursor', 'direction',
					\ 'display', 'markerOffset', 'marks', 'maxHeight', 'maxWidth', 'minHeight',
					\ 'minWidth', 'overflow', 'overflowX', 'overflowY', 'verticalAlign', 'visibility',
					\ 'width',
					\ 'listStyle', 'listStyleImage', 'listStylePosition', 'listStyleType',
					\ 'cssText', 'bottom', 'height', 'left', 'position', 'right', 'top', 'width', 'zindex',
					\ 'orphans', 'widows', 'page', 'pageBreakAfter', 'pageBreakBefore', 'pageBreakInside',
					\ 'borderCollapse', 'borderSpacing', 'captionSide', 'emptyCells', 'tableLayout',
					\ 'color', 'font', 'fontFamily', 'fontSize', 'fontSizeAdjust', 'fontStretch',
					\ 'fontStyle', 'fontVariant', 'fontWeight', 'letterSpacing', 'lineHeight', 'quotes',
					\ 'textAlign', 'textIndent', 'textShadow', 'textTransform', 'textUnderlinePosition',
					\ 'unicodeBidi', 'whiteSpace', 'wordSpacing']
		let styls = stylprop
		" Table - table.
		let tablprop = ['rows', 'tBodies', 'align', 'bgColor', 'border', 'caption', 'cellPadding',
					\ 'cellSpacing', 'frame', 'height', 'rules', 'summary', 'tFoot', 'tHead', 'width']
		let tablmeth = ['createCaption', 'createTFoot', 'createTHead', 'deleteCaption', 'deleteRow',
					\ 'deleteTFoot', 'deleteTHead', 'insertRow']
		call map(tablmeth, 'v:val."("')
		let tabls = tablprop + tablmeth
		" Table data - TableData.
		let tdatprop = ['abbr', 'align', 'axis', 'bgColor', 'cellIndex', 'ch', 'chOff',
					\ 'colSpan', 'headers', 'noWrap', 'rowSpan', 'scope', 'vAlign', 'width']
		let tdats = tdatprop
		" Table row - TableRow.
		let trowprop = ['cells', 'align', 'bgColor', 'ch', 'chOff', 'rowIndex', 'sectionRowIndex',
					\ 'vAlign']
		let trowmeth = ['deleteCell', 'insertCell']
		call map(trowmeth, 'v:val."("')
		let trows = trowprop + trowmeth
		" Textarea - accessible only by other properties
		let tareprop = ['accessKey', 'cols', 'defaultValue', 
					\ 'disabled', 'form', 'id', 'name', 'readOnly', 'rows', 
					\ 'tabIndex', 'type', 'value', 'selectionStart', 'selectionEnd'] 
		let taremeth = ['blur', 'focus', 'select', 'onBlur', 'onChange', 'onFocus']
		call map(taremeth, 'v:val."("')
		let tares = tareprop + taremeth
		" Window - window.
		let windprop = ['frames', 'closed', 'defaultStatus', 'encodeURI', 'event', 'history',
					\ 'length', 'location', 'name', 'onload', 'opener', 'parent', 'screen', 'self',
					\ 'status', 'top', 'XMLHttpRequest', 'ActiveXObject']
		let windmeth = ['alert', 'blur', 'clearInterval', 'clearTimeout', 'close', 'confirm', 'focus',
					\ 'moveBy', 'moveTo', 'open', 'print', 'prompt', 'scrollBy', 'scrollTo', 'setInterval',
					\ 'setTimeout']
		call map(windmeth, 'v:val."("')
		let winds = windprop + windmeth
		" XMLHttpRequest - access by new xxx()
		let xmlhprop = ['onreadystatechange', 'readyState', 'responseText', 'responseXML',
					\ 'status', 'statusText', 'parseError']
		let xmlhmeth = ['abort', 'getAllResponseHeaders', 'getResponseHeaders', 'open',
					\ 'send', 'setRequestHeader']
		call map(xmlhmeth, 'v:val."("')
		let xmlhs = xmlhprop + xmlhmeth

		" XML DOM
		" Attributes - element.attributes[x].
		let xdomattrprop = ['name', 'specified', 'value']
		" Element - anyelement.
		let xdomelemprop = ['attributes', 'childNodes', 'firstChild', 'lastChild', 
					\ 'namespaceURI', 'nextSibling', 'nodeName', 'nodeType', 'nodeValue',
					\ 'ownerDocument', 'parentNode', 'prefix', 'previousSibling', 'tagName']
		let xdomelemmeth = ['appendChild', 'addEventListener', 'cloneNode',
					\ 'dispatchEvent', 'getAttribute', 'getAttributeNode',
					\ 'getElementsByTagName', 'hasChildNodes', 'insertBefore',
					\ 'normalize', 'removeAttribute', 'removeAttributeNode',
					\ 'removeChild', 'removeEventListener', 'replaceChild',
					\ 'setAttribute', 'setAttributeNode']
		call map(xdomelemmeth, 'v:val."("')
		let xdomelems = xdomelemprop + xdomelemmeth
		" Node - anynode.
		let xdomnodeprop = ['attributes', 'childNodes', 'firstChild', 'lastChild', 
					\ 'namespaceURI', 'nextSibling', 'nodeName', 'nodeType', 'nodeValue',
					\ 'ownerDocument', 'parentNode', 'prefix', 'previousSibling']
		let xdomnodemeth = ['appendChild', 'cloneNode',
					\ 'hasChildNodes', 'insertBefore', 'removeChild', 'replaceChild']
		call map(xdomnodemeth, 'v:val."("')
		let xdomnodes = xdomnodeprop + xdomnodemeth
		" NodeList 
		let xdomnliss = ['length', 'item(']
		" Error - parseError.
		let xdomerror = ['errorCode', 'reason', 'line', 'linepos', 'srcText', 'url', 'filepos']

		" Find object type declaration to reduce number of suggestions. {{{
		" 1. Get object name
		" 2. Find object declaration line
		" 3. General declaration follows "= new Type" syntax, additional else
		"    for regexp "= /re/"
		" 4. Make correction for Microsoft.XMLHTTP ActiveXObject
		" 5. Repeat for external files
		let object = matchstr(shortcontext, '\zs\k\+\ze\(\[.\{-}\]\)\?\.$')
		if len(object) > 0
			let decl_line = search(object.'.\{-}=\s*new\s*', 'bn')
			if decl_line > 0
				let object_type = matchstr(getline(decl_line), object.'.\{-}=\s*new\s*\zs\k\+\ze')
				if object_type == 'ActiveXObject' && matchstr(getline(decl_line), object.'.\{-}=\s*new\s*ActiveXObject\s*(.Microsoft\.XMLHTTP.)') != ''
						let object_type = 'XMLHttpRequest'
				endif
			else
				let decl_line = search('var\s*'.object.'\s*=\s*\/', 'bn')
				if decl_line > 0
					let object_type = 'RegExp'
				endif
			endif
			" We didn't find var declaration in current file but we may have
			" something in external files.
			if decl_line == 0 && exists("b:js_extfiles")
				let dext_line = filter(copy(b:js_extfiles), 'v:val =~ "'.object.'.\\{-}=\\s*new\\s*"')
				if len(dext_line) > 0
					let object_type = matchstr(dext_line[-1], object.'.\{-}=\s*new\s*\zs\k\+\ze')
					if object_type == 'ActiveXObject' && matchstr(dext_line[-1], object.'.\{-}=\s*new\s*ActiveXObject\s*(.Microsoft\.XMLHTTP.)') != ''
							let object_type = 'XMLHttpRequest'
					endif
				else
					let dext_line = filter(copy(b:js_extfiles), 'v:val =~ "var\s*'.object.'\\s*=\\s*\\/"')
					if len(dext_line) > 0
						let object_type = 'RegExp'
					endif
				endif
			endif
		endif
		" }}}

		if !exists('object_type')
			let object_type = ''
		endif

		if object_type == 'Date'
			let values = dates
		elseif object_type == 'Image'
			let values = imags
		elseif object_type == 'Array'
			let values = arrays
		elseif object_type == 'Boolean'
			" TODO: a bit more than real boolean
			let values = arrays
		elseif object_type == 'XMLHttpRequest'
			let values = xmlhs
		elseif object_type == 'String'
			let values = stris
		elseif object_type == 'RegExp'
			let values = reges
		elseif object_type == 'Math'
			let values = maths
		endif

		if !exists('values')
		" List of properties
		if shortcontext =~ 'Math\.$'
			let values = maths
		elseif shortcontext =~ 'anchors\(\[.\{-}\]\)\?\.$'
			let values = anths
		elseif shortcontext =~ 'area\.$'
			let values = areas
		elseif shortcontext =~ 'base\.$'
			let values = bases
		elseif shortcontext =~ 'body\.$'
			let values = bodys
		elseif shortcontext =~ 'document\.$'
			let values = docus
		elseif shortcontext =~ 'forms\(\[.\{-}\]\)\?\.$'
			let values = forms
		elseif shortcontext =~ 'frameset\.$'
			let values = fsets
		elseif shortcontext =~ 'history\.$'
			let values = hists
		elseif shortcontext =~ 'iframe\.$'
			let values = ifras
		elseif shortcontext =~ 'images\(\[.\{-}\]\)\?\.$'
			let values = imags
		elseif shortcontext =~ 'links\(\[.\{-}\]\)\?\.$'
			let values = links
		elseif shortcontext =~ 'location\.$'
			let values = locas
		elseif shortcontext =~ 'meta\.$'
			let values = metas
		elseif shortcontext =~ 'navigator\.$'
			let values = navis
		elseif shortcontext =~ 'object\.$'
			let values = objes
		elseif shortcontext =~ 'screen\.$'
			let values = scres
		elseif shortcontext =~ 'style\.$'
			let values = styls
		elseif shortcontext =~ 'table\.$'
			let values = tabls
		elseif shortcontext =~ 'TableData\.$'
			let values = tdats
		elseif shortcontext =~ 'TableRow\.$'
			let values = trows
		elseif shortcontext =~ 'window\.$'
			let values = winds
		elseif shortcontext =~ 'parseError\.$'
			let values = xdomerror
		elseif shortcontext =~ 'attributes\[\d\+\]\.$'
			let values = xdomattrprop
		else
			let values = user_props + arrays + dates + funcs + maths + numbs + objes + reges + stris
			let values += doms + anths + areas + bases + bodys + docus + forms + frams + fsets + hists
			let values += ifras + imags + links + locas + metas + navis + objes + scres
			let values += tabls + trows + tares + winds
			let values += xdomnodes + xdomnliss + xdomelems
		endif
		endif

		for m in values
			if m =~? '^'.a:base
				call add(res, m)
			elseif m =~? a:base
				call add(res2, m)
			endif
		endfor

		unlet! values
		return res + res2

	endif
	" }}}

	" Get variables data.
	let variables = filter(copy(file), 'v:val =~ "var\\s"')
	call map(variables, 'matchstr(v:val, ".\\{-}var\\s\\+\\zs.*\\ze")')
	call map(variables, 'substitute(v:val, ";\\|$", ",", "g")')
	let vars = []
	" This loop (and next one) is necessary to get variable names from
	" constructs like: var var1, var2, var3 = "something";
	for i in range(len(variables))
		let comma_separated = split(variables[i], ',\s*')
		call map(comma_separated, 'matchstr(v:val, "\\k\\+")')
		let vars += comma_separated
	endfor

	let variables = sort(vars)
	unlet! vars

	" Add "no var" variables.
	let undeclared_variables = filter(copy(file), 'v:val =~ "^\\s*\\k\\+\\s*="')
	let u_vars = []
	for i in range(len(undeclared_variables))
		let  split_equal = split(undeclared_variables[i], '\s*=')
		call map(split_equal, 'matchstr(v:val, "\\k\\+$")')
		let u_vars += split_equal
	endfor

	let variables += sort(u_vars)
	unlet! u_vars

	" Get functions
	let functions = filter(copy(file), 'v:val =~ "^\\s*function\\s"')
	let arguments = copy(functions)
	call map(functions, 'matchstr(v:val, "^\\s*function\\s\\+\\zs\\k\\+")')
	call map(functions, 'v:val."("')
	let functions = sort(functions)

	" Create table to keep arguments for additional 'menu' info
	let b:js_menuinfo = {}
	for i in arguments
		let g:ia = i
		let f_elements = matchlist(i, 'function\s\+\(\k\+\)\s*(\(.\{-}\))')
		if len(f_elements) >= 3
			let b:js_menuinfo[f_elements[1].'('] = f_elements[2]
		endif
	endfor

	" Get functions arguments
	call map(arguments, 'matchstr(v:val, "function.\\{-}(\\zs.\\{-}\\ze)")')
	let jargs = join(arguments, ',')
	let jargs = substitute(jargs, '\s', '', 'g')
	let arguments = split(jargs, ',')
	let arguments = sort(arguments)

	" Built-in functions
	let builtin = ['alert(', 'confirm(']

	" Top-level HTML DOM objects
	let htmldom = ['document', 'anchor', 'area', 'base', 'body', 'document', 'event', 'form', 'frame', 'frameset', 'history', 'iframe', 'image', 'input', 'link', 'location', 'meta', 'navigator', 'object', 'option', 'screen', 'select', 'table', 'tableData', 'tableHeader', 'tableRow', 'textarea', 'window']
	call map(htmldom, 'v:val."."')

	" Top-level properties
	let properties = ['decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent',
				\ 'eval', 'Infinity', 'isFinite', 'isNaN', 'NaN', 'Number', 'parseFloat',
				\ 'parseInt', 'String', 'undefined', 'escape', 'unescape']

	" Keywords
	let keywords = ["Array", "Boolean", "Date", "Function", "Math", "Number", "Object", "RegExp", "String", "XMLHttpRequest", "ActiveXObject", "abstract", "boolean", "break", "byte", "case", "catch", "char", "class", "const", "continue", "debugger", "default", "delete", "do", "double ", "else", "enum", "export", "extends", "false", "final", "finally", "float", "for", "function", "goto", "if", "implements", "import", "in ", "instanceof", "int", "interface", "long", "native", "new", "null", "package", "private", "protected", "public", "return", "short", "static", "super ", "switch", "synchronized", "this", "throw", "throws", "transient", "true", "try", "typeof", "var", "void", "volatile", "while", "with"]

	let values = variables + functions + htmldom + arguments + builtin + properties + keywords

	for m in values
		if m =~? '^'.a:base
			call add(res, m)
		elseif m =~? a:base
			call add(res2, m)
		endif
	endfor

	let menu = res + res2
	let final_menu = []
	for i in range(len(menu))
		let item = menu[i]
		if item =~ '($'
			let kind = 'f'
			if has_key(b:js_menuinfo, item)
				let m_info = b:js_menuinfo[item]
			else
				let m_info = ''
			endif
		else
			let kind = 'v'
			let m_info = ''
		endif
		let final_menu += [{'word':item, 'menu':m_info, 'kind':kind}]
	endfor
	let g:fm = final_menu
	return final_menu

endfunction

" vim:set foldmethod=marker:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    " netrw.vim: Handles file transfer and remote directory listing across
"            AUTOLOAD SECTION
" Date:		Aug 16, 2021
" Version:	171
" Maintainer:	Charles E Campbell <NcampObell@SdrPchip.AorgM-NOSPAM>
" GetLatestVimScripts: 1075 1 :AutoInstall: netrw.vim
" Copyright:    Copyright (C) 2016 Charles E. Campbell {{{1
"               Permission is hereby granted to use and distribute this code,
"               with or without modifications, provided that this copyright
"               notice is copied with it. Like anything else that's free,
"               netrw.vim, netrwPlugin.vim, and netrwSettings.vim are provided
"               *as is* and come with no warranty of any kind, either
"               expressed or implied. By using this plugin, you agree that
"               in no event will the copyright holder be liable for any damages
"               resulting from the use of this software.
"
" Note: the code here was started in 1999 under a much earlier version of vim.  The directory browsing
"       code was written using vim v6, which did not have Lists (Lists were first offered with vim-v7).
"
"redraw!|call DechoSep()|call inputsave()|call input("Press <cr> to continue")|call inputrestore()
"
"  But be doers of the Word, and not only hearers, deluding your own selves {{{1
"  (James 1:22 RSV)
" =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
" Load Once: {{{1
if &cp || exists("g:loaded_netrw")
  finish
endif

" Check that vim has patches that netrw requires.
" Patches needed for v7.4: 1557, and 213.
" (netrw will benefit from vim's having patch#656, too)
let s:needspatches=[1557,213]
if exists("s:needspatches")
 for ptch in s:needspatches
  if v:version < 704 || (v:version == 704 && !has("patch".ptch))
   if !exists("s:needpatch{ptch}")
    unsilent echomsg "***sorry*** this version of netrw requires vim v7.4 with patch#".ptch
   endif
   let s:needpatch{ptch}= 1
   finish
  endif
 endfor
endif

let g:loaded_netrw = "v171"
if !exists("s:NOTE")
 let s:NOTE    = 0
 let s:WARNING = 1
 let s:ERROR   = 2
endif

let s:keepcpo= &cpo
setl cpo&vim
"DechoFuncName 1
"DechoRemOn
"call Decho("doing autoload/netrw.vim version ".g:loaded_netrw,'~'.expand("<slnum>"))

" ======================
"  Netrw Variables: {{{1
" ======================

" ---------------------------------------------------------------------
" netrw#ErrorMsg: {{{2
"   0=note     = s:NOTE
"   1=warning  = s:WARNING
"   2=error    = s:ERROR
"   Usage: netrw#ErrorMsg(s:NOTE | s:WARNING | s:ERROR,"some message",error-number)
"          netrw#ErrorMsg(s:NOTE | s:WARNING | s:ERROR,["message1","message2",...],error-number)
"          (this function can optionally take a list of messages)
"  Dec 2, 2019 : max errnum currently is 106
fun! netrw#ErrorMsg(level,msg,errnum)
"  call Dfunc("netrw#ErrorMsg(level=".a:level." msg<".a:msg."> errnum=".a:errnum.") g:netrw_use_errorwindow=".g:netrw_use_errorwindow)

  if a:level < g:netrw_errorlvl
"   call Dret("netrw#ErrorMsg : suppressing level=".a:level." since g:netrw_errorlvl=".g:netrw_errorlvl)
   return
  endif

  if a:level == 1
   let level= "**warning** (netrw) "
  elseif a:level == 2
   let level= "**error** (netrw) "
  else
   let level= "**note** (netrw) "
  endif
"  call Decho("level=".level,'~'.expand("<slnum>"))

  if g:netrw_use_errorwindow == 2 && (v:version > 802 || (v:version == 802 && has("patch486")))
   " use popup window
   if type(a:msg) == 3
    let msg = [level]+a:msg
   else
    let msg= level.a:msg
   endif
   let s:popuperr_id  = popup_atcursor(msg,{})
   let s:popuperr_text= ""
 elseif g:netrw_use_errorwindow
   " (default) netrw creates a one-line window to show error/warning
   " messages (reliably displayed)

   " record current window number
   let s:winBeforeErr= winnr()
"   call Decho("s:winBeforeErr=".s:winBeforeErr,'~'.expand("<slnum>"))

   " getting messages out reliably is just plain difficult!
   " This attempt splits the current window, creating a one line window.
   if bufexists("NetrwMessage") && bufwinnr("NetrwMessage") > 0
"    call Decho("write to NetrwMessage buffer",'~'.expand("<slnum>"))
    exe bufwinnr("NetrwMessage")."wincmd w"
"    call Decho("setl ma noro",'~'.expand("<slnum>"))
    setl ma noro
    if type(a:msg) == 3
     for msg in a:msg
      NetrwKeepj call setline(line("$")+1,level.msg)
     endfor
    else
     NetrwKeepj call setline(line("$")+1,level.a:msg)
    endif
    NetrwKeepj $
   else
"    call Decho("create a NetrwMessage buffer window",'~'.expand("<slnum>"))
    bo 1split
    sil! call s:NetrwEnew()
    sil! NetrwKeepj call s:NetrwOptionsSafe(1)
    setl bt=nofile
    NetrwKeepj file NetrwMessage
"    call Decho("setl ma noro",'~'.expand("<slnum>"))
    setl ma noro
    if type(a:msg) == 3
     for msg in a:msg
      NetrwKeepj call setline(line("$")+1,level.msg)
     endfor
    else
     NetrwKeepj call setline(line("$"),level.a:msg)
    endif
    NetrwKeepj $
   endif
"   call Decho("wrote msg<".level.a:msg."> to NetrwMessage win#".winnr(),'~'.expand("<slnum>"))
   if &fo !~ '[ta]'
    syn clear
    syn match netrwMesgNote	"^\*\*note\*\*"
    syn match netrwMesgWarning	"^\*\*warning\*\*"
    syn match netrwMesgError	"^\*\*error\*\*"
    hi link netrwMesgWarning WarningMsg
    hi link netrwMesgError   Error
   endif
"   call Decho("setl noma ro bh=wipe",'~'.expand("<slnum>"))
   setl ro nomod noma bh=wipe

  else
   " (optional) netrw will show messages using echomsg.  Even if the
   " message doesn't appear, at least it'll be recallable via :messages
"   redraw!
   if a:level == s:WARNING
    echohl WarningMsg
   elseif a:level == s:ERROR
    echohl Error
   endif

   if type(a:msg) == 3
     for msg in a:msg
      unsilent echomsg level.msg
     endfor
   else
    unsilent echomsg level.a:msg
   endif

"   call Decho("echomsg ***netrw*** ".a:msg,'~'.expand("<slnum>"))
   echohl None
  endif

"  call Dret("netrw#ErrorMsg")
endfun

" ---------------------------------------------------------------------
" s:NetrwInit: initializes variables if they haven't been defined {{{2
"            Loosely,  varname = value.
fun s:NetrwInit(varname,value)
" call Decho("varname<".a:varname."> value=".a:value,'~'.expand("<slnum>"))
  if !exists(a:varname)
   if type(a:value) == 0
    exe "let ".a:varname."=".a:value
   elseif type(a:value) == 1 && a:value =~ '^[{[]'
    exe "let ".a:varname."=".a:value
   elseif type(a:value) == 1
    exe "let ".a:varname."="."'".a:value."'"
   else
    exe "let ".a:varname."=".a:value
   endif
  endif
endfun

" ---------------------------------------------------------------------
"  Netrw Constants: {{{2
call s:NetrwInit("g:netrw_dirhistcnt",0)
if !exists("s:LONGLIST")
 call s:NetrwInit("s:THINLIST",0)
 call s:NetrwInit("s:LONGLIST",1)
 call s:NetrwInit("s:WIDELIST",2)
 call s:NetrwInit("s:TREELIST",3)
 call s:NetrwInit("s:MAXLIST" ,4)
endif

" ---------------------------------------------------------------------
" Default option values: {{{2
let g:netrw_localcopycmdopt    = ""
let g:netrw_localcopydircmdopt = ""
let g:netrw_localmkdiropt      = ""
let g:netrw_localmovecmdopt    = ""
let g:netrw_localrmdiropt      = ""

" ---------------------------------------------------------------------
" Default values for netrw's global protocol variables {{{2
if (v:version > 802 || (v:version == 802 && has("patch486"))) && has("balloon_eval") && !exists("s:initbeval") && !exists("g:netrw_nobeval") && has("syntax") && exists("g:syntax_on") && has("mouse")
  call s:NetrwInit("g:netrw_use_errorwindow",2)
else
  call s:NetrwInit("g:netrw_use_errorwindow",1)
endif

if !exists("g:netrw_dav_cmd")
 if executable("cadaver")
  let g:netrw_dav_cmd	= "cadaver"
 elseif executable("curl")
  let g:netrw_dav_cmd	= "curl"
 else
  let g:netrw_dav_cmd   = ""
 endif
endif
if !exists("g:netrw_fetch_cmd")
 if executable("fetch")
  let g:netrw_fetch_cmd	= "fetch -o"
 else
  let g:netrw_fetch_cmd	= ""
 endif
endif
if !exists("g:netrw_file_cmd")
 if executable("elinks")
  call s:NetrwInit("g:netrw_file_cmd","elinks")
 elseif executable("links")
  call s:NetrwInit("g:netrw_file_cmd","links")
 endif
endif
if !exists("g:netrw_ftp_cmd")
  let g:netrw_ftp_cmd	= "ftp"
endif
let s:netrw_ftp_cmd= g:netrw_ftp_cmd
if !exists("g:netrw_ftp_options")
 let g:netrw_ftp_options= "-i -n"
endif
if !exists("g:netrw_http_cmd")
 if executable("wget")
  let g:netrw_http_cmd	= "wget"
  call s:NetrwInit("g:netrw_http_xcmd","-q -O")
 elseif executable("curl")
  let g:netrw_http_cmd	= "curl"
  call s:NetrwInit("g:netrw_http_xcmd","-L -o")
 elseif executable("elinks")
  let g:netrw_http_cmd = "elinks"
  call s:NetrwInit("g:netrw_http_xcmd","-source >")
 elseif executable("fetch")
  let g:netrw_http_cmd	= "fetch"
  call s:NetrwInit("g:netrw_http_xcmd","-o")
 elseif executable("links")
  let g:netrw_http_cmd = "links"
  call s:NetrwInit("g:netrw_http_xcmd","-http.extra-header ".shellescape("Accept-Encoding: identity", 1)." -source >")
 else
  let g:netrw_http_cmd	= ""
 endif
endif
call s:NetrwInit("g:netrw_http_put_cmd","curl -T")
call s:NetrwInit("g:netrw_keepj","keepj")
call s:NetrwInit("g:netrw_rcp_cmd"  , "rcp")
call s:NetrwInit("g:netrw_rsync_cmd", "rsync")
call s:NetrwInit("g:netrw_rsyn