yIndexOutOfBoundsException ArithmeticException ClassCastException EnumConstantNotPresentException StringIndexOutOfBoundsException IllegalArgumentException IllegalMonitorStateException IllegalThreadStateException NumberFormatException NullPointerException TypeNotPresentException SecurityException
  syn cluster javaTop add=javaR_JavaLang
  syn cluster javaClasses add=javaR_JavaLang
  hi def link javaR_JavaLang javaR_Java
  syn keyword javaC_JavaLang Process RuntimePermission StringKeySet CharacterData01 Class ThreadLocal ThreadLocalMap CharacterData0E Package Character StringCoding Long ProcessImpl ProcessEnvironment Short AssertionStatusDirectives 1PackageInfoProxy UnicodeBlock InheritableThreadLocal AbstractStringBuilder StringEnvironment ClassLoader ConditionalSpecialCasing CharacterDataPrivateUse StringBuffer StringDecoder Entry StringEntry WrappedHook StringBuilder StrictMath State ThreadGroup Runtime CharacterData02 MethodArray Object CharacterDataUndefined Integer Gate Boolean Enum Variable Subset StringEncoder Void Terminator CharsetSD IntegerCache CharacterCache Byte CharsetSE Thread SystemClassLoaderAction CharacterDataLatin1 StringValues StackTraceElement Shutdown ShortCache String ConverterSD ByteCache Lock EnclosingMethodInfo Math Float Value Double SecurityManager LongCache ProcessBuilder StringEntrySet Compiler Number UNIXProcess ConverterSE ExternalData CaseInsensitiveComparator CharacterData00 NativeLibrary
  syn cluster javaTop add=javaC_JavaLang
  syn cluster javaClasses add=javaC_JavaLang
  hi def link javaC_JavaLang javaC_Java
  syn keyword javaE_JavaLang IncompatibleClassChangeError InternalError UnknownError ClassCircularityError AssertionError ThreadDeath IllegalAccessError NoClassDefFoundError ClassFormatError UnsupportedClassVersionError NoSuchFieldError VerifyError ExceptionInInitializerError InstantiationError LinkageError NoSuchMethodError Error UnsatisfiedLinkError StackOverflowError AbstractMethodError VirtualMachineError OutOfMemoryError
  syn cluster javaTop add=javaE_JavaLang
  syn cluster javaClasses add=javaE_JavaLang
  hi def link javaE_JavaLang javaE_Java
  syn keyword javaX_JavaLang CloneNotSupportedException Exception NoSuchMethodException IllegalAccessException NoSuchFieldException Throwable InterruptedException ClassNotFoundException InstantiationException
  syn cluster javaTop add=javaX_JavaLang
  syn cluster javaClasses add=javaX_JavaLang
  hi def link javaX_JavaLang javaX_Java

  hi def link javaR_Java javaR_
  hi def link javaC_Java javaC_
  hi def link javaE_Java javaE_
  hi def link javaX_Java javaX_
  hi def link javaX_		     javaExceptions
  hi def link javaR_		     javaExceptions
  hi def link javaE_		     javaExceptions
  hi def link javaC_		     javaConstant

  syn keyword javaLangObject clone equals finalize getClass hashCode
  syn keyword javaLangObject notify notifyAll toString wait
  hi def link javaLangObject		     javaConstant
  syn cluster javaTop add=javaLangObject
endif

if filereadable(expand("<sfile>:p:h")."/javaid.vim")
  source <sfile>:p:h/javaid.vim
endif

if exists("java_space_errors")
  if !exists("java_no_trail_space_error")
    syn match	javaSpaceError	"\s\+$"
  endif
  if !exists("java_no_tab_space_error")
    syn match	javaSpaceError	" \+\t"me=e-1
  endif
endif

syn region  javaLabelRegion	transparent matchgroup=javaLabel start="\<case\>" matchgroup=NONE end=":" contains=javaNumber,javaCharacter,javaString
syn match   javaUserLabel	"^\s*[_$a-zA-Z][_$a-zA-Z0-9_]*\s*:"he=e-1 contains=javaLabel
syn keyword javaLabel		default

" highlighting C++ keywords as errors removed, too many people find it
" annoying.  Was: if !exists("java_allow_cpp_keywords")

" The following cluster contains all java groups except the contained ones
syn cluster javaTop add=javaExternal,javaError,javaError,javaBranch,javaLabelRegion,javaLabel,javaConditional,javaRepeat,javaBoolean,javaConstant,javaTypedef,javaOperator,javaType,javaType,javaStatement,javaStorageClass,javaAssert,javaExceptions,javaMethodDecl,javaClassDecl,javaClassDecl,javaClassDecl,javaScopeDecl,javaError,javaError2,javaUserLabel,javaLangObject,javaAnnotation,javaVarArg


" Comments
syn keyword javaTodo		 contained TODO FIXME XXX
if exists("java_comment_strings")
  syn region  javaCommentString    contained start=+"+ end=+"+ end=+$+ end=+\*/+me=s-1,he=s-1 contains=javaSpecial,javaCommentStar,javaSpecialChar,@Spell
  syn region  javaComment2String   contained start=+"+	end=+$\|"+  contains=javaSpecial,javaSpecialChar,@Spell
  syn match   javaCommentCharacter contained "'\\[^']\{1,6\}'" contains=javaSpecialChar
  syn match   javaCommentCharacter contained "'\\''" contains=javaSpecialChar
  syn match   javaCommentCharacter contained "'[^\\]'"
  syn cluster javaCommentSpecial add=javaCommentString,javaCommentCharacter,javaNumber
  syn cluster javaCommentSpecial2 add=javaComment2String,javaCommentCharacter,javaNumber
endif
syn region  javaComment		 start="/\*"  end="\*/" contains=@javaCommentSpecial,javaTodo,@Spell
syn match   javaCommentStar	 contained "^\s*\*[^/]"me=e-1
syn match   javaCommentStar	 contained "^\s*\*$"
syn match   javaLineComment	 "//.*" contains=@javaCommentSpecial2,javaTodo,@Spell
hi def link javaCommentString javaString
hi def link javaComment2String javaString
hi def link javaCommentCharacter javaCharacter

syn cluster javaTop add=javaComment,javaLineComment

if !exists("java_ignore_javadoc") && main_syntax != 'jsp'
  syntax case ignore
  " syntax coloring for javadoc comments (HTML)
  syntax include @javaHtml <sfile>:p:h/html.vim
  unlet b:current_syntax
  " HTML enables spell checking for all text that is not in a syntax item. This
  " is wrong for Java (all identifiers would be spell-checked), so it's undone
  " here.
  syntax spell default

  syn region  javaDocComment	start="/\*\*"  end="\*/" keepend contains=javaCommentTitle,@javaHtml,javaDocTags,javaDocSeeTag,javaTodo,@Spell
  syn region  javaCommentTitle	contained matchgroup=javaDocComment start="/\*\*"   matchgroup=javaCommentTitle keepend end="\.$" end="\.[ \t\r<&]"me=e-1 end="[^{]@"me=s-2,he=s-1 end="\*/"me=s-1,he=s-1 contains=@javaHtml,javaCommentStar,javaTodo,@Spell,javaDocTags,javaDocSeeTag

  syn region javaDocTags	 contained start="{@\(code\|link\|linkplain\|inherit[Dd]oc\|doc[rR]oot\|value\)" end="}"
  syn match  javaDocTags	 contained "@\(param\|exception\|throws\|since\)\s\+\S\+" contains=javaDocParam
  syn match  javaDocParam	 contained "\s\S\+"
  syn match  javaDocTags	 contained "@\(version\|author\|return\|deprecated\|serial\|serialField\|serialData\)\>"
  syn region javaDocSeeTag	 contained matchgroup=javaDocTags start="@see\s\+" matchgroup=NONE end="\_."re=e-1 contains=javaDocSeeTagParam
  syn match  javaDocSeeTagParam  contained @"\_[^"]\+"\|<a\s\+\_.\{-}</a>\|\(\k\|\.\)*\(#\k\+\((\_[^)]\+)\)\=\)\=@ extend
  syntax case match
endif

" match the special comment /**/
syn match   javaComment		 "/\*\*/"

" Strings and constants
syn match   javaSpecialError	 contained "\\."
syn match   javaSpecialCharError contained "[^']"
syn match   javaSpecialChar	 contained "\\\([4-9]\d\|[0-3]\d\d\|[\"\\'ntbrf]\|u\x\{4\}\)"
syn region  javaString		start=+"+ end=+"+ end=+$+ contains=javaSpecialChar,javaSpecialError,@Spell
" next line disabled, it can cause a crash for a long line
"syn match   javaStringError	  +"\([^"\\]\|\\.\)*$+
syn match   javaCharacter	 "'[^']*'" contains=javaSpecialChar,javaSpecialCharError
syn match   javaCharacter	 "'\\''" contains=javaSpecialChar
syn match   javaCharacter	 "'[^\\]'"
syn match   javaNumber		 "\<\(0[bB][0-1]\+\|0[0-7]*\|0[xX]\x\+\|\d\(\d\|_\d\)*\)[lL]\=\>"
syn match   javaNumber		 "\(\<\d\(\d\|_\d\)*\.\(\d\(\d\|_\d\)*\)\=\|\.\d\(\d\|_\d\)*\)\([eE][-+]\=\d\(\d\|_\d\)*\)\=[fFdD]\="
syn match   javaNumber		 "\<\d\(\d\|_\d\)*[eE][-+]\=\d\(\d\|_\d\)*[fFdD]\=\>"
syn match   javaNumber		 "\<\d\(\d\|_\d\)*\([eE][-+]\=\d\(\d\|_\d\)*\)\=[fFdD]\>"

" unicode characters
syn match   javaSpecial "\\u\d\{4\}"

syn cluster javaTop add=javaString,javaCharacter,javaNumber,javaSpecial,javaStringError

if exists("java_highlight_functions")
  if java_highlight_functions == "indent"
    syn match  javaFuncDef "^\(\t\| \{8\}\)[_$a-zA-Z][_$a-zA-Z0-9_. \[\]<>]*([^-+*/]*)" contains=javaScopeDecl,javaType,javaStorageClass,@javaClasses,javaAnnotation
    syn region javaFuncDef start=+^\(\t\| \{8\}\)[$_a-zA-Z][$_a-zA-Z0-9_. \[\]<>]*([^-+*/]*,\s*+ end=+)+ contains=javaScopeDecl,javaType,javaStorageClass,@javaClasses,javaAnnotation
    syn match  javaFuncDef "^  [$_a-zA-Z][$_a-zA-Z0-9_. \[\]<>]*([^-+*/]*)" contains=javaScopeDecl,javaType,javaStorageClass,@javaClasses,javaAnnotation
    syn region javaFuncDef start=+^  [$_a-zA-Z][$_a-zA-Z0-9_. \[\]<>]*([^-+*/]*,\s*+ end=+)+ contains=javaScopeDecl,javaType,javaStorageClass,@javaClasses,javaAnnotation
  else
    " This line catches method declarations at any indentation>0, but it assumes
    " two things:
    "	1. class names are always capitalized (ie: Button)
    "	2. method names are never capitalized (except constructors, of course)
    "syn region javaFuncDef start=+^\s\+\(\(public\|protected\|private\|static\|abstract\|final\|native\|synchronized\)\s\+\)*\(\(void\|boolean\|char\|byte\|short\|int\|l
‰  ‰  ‰  ‰  ‰  ‰  ‰                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ong\|float\|double\|\([A-Za-z_][A-Za-z0-9_$]*\.\)*[A-Z][A-Za-z0-9_$]*\)\(<[^>]*>\)\=\(\[\]\)*\s\+[a-z][A-Za-z0-9_$]*\|[A-Z][A-Za-z0-9_$]*\)\s*([^0-9]+ end=+)+ contains=javaScopeDecl,javaType,javaStorageClass,javaComment,javaLineComment,@javaClasses
    syn region javaFuncDef start=+^\s\+\(\(public\|protected\|private\|static\|abstract\|final\|native\|synchronized\)\s\+\)*\(<.*>\s\+\)\?\(\(void\|boolean\|char\|byte\|short\|int\|long\|float\|double\|\([A-Za-z_][A-Za-z0-9_$]*\.\)*[A-Z][A-Za-z0-9_$]*\)\(<[^(){}]*>\)\=\(\[\]\)*\s\+[a-z][A-Za-z0-9_$]*\|[A-Z][A-Za-z0-9_$]*\)\s*(+ end=+)+ contains=javaScopeDecl,javaType,javaStorageClass,javaComment,javaLineComment,@javaClasses,javaAnnotation
  endif
  syn match javaLambdaDef "[a-zA-Z_][a-zA-Z0-9_]*\s*->"
  syn match  javaBraces  "[{}]"
  syn cluster javaTop add=javaFuncDef,javaBraces,javaLambdaDef
endif

if exists("java_highlight_debug")

  " Strings and constants
  syn match   javaDebugSpecial		contained "\\\d\d\d\|\\."
  syn region  javaDebugString		contained start=+"+  end=+"+  contains=javaDebugSpecial
  syn match   javaDebugStringError	+"\([^"\\]\|\\.\)*$+
  syn match   javaDebugCharacter	contained "'[^\\]'"
  syn match   javaDebugSpecialCharacter contained "'\\.'"
  syn match   javaDebugSpecialCharacter contained "'\\''"
  syn match   javaDebugNumber		contained "\<\(0[0-7]*\|0[xX]\x\+\|\d\+\)[lL]\=\>"
  syn match   javaDebugNumber		contained "\(\<\d\+\.\d*\|\.\d\+\)\([eE][-+]\=\d\+\)\=[fFdD]\="
  syn match   javaDebugNumber		contained "\<\d\+[eE][-+]\=\d\+[fFdD]\=\>"
  syn match   javaDebugNumber		contained "\<\d\+\([eE][-+]\=\d\+\)\=[fFdD]\>"
  syn keyword javaDebugBoolean		contained true false
  syn keyword javaDebugType		contained null this super
  syn region javaDebugParen  start=+(+ end=+)+ contained contains=javaDebug.*,javaDebugParen

  " to make this work you must define the highlighting for these groups
  syn match javaDebug "\<System\.\(out\|err\)\.print\(ln\)*\s*("me=e-1 contains=javaDebug.* nextgroup=javaDebugParen
  syn match javaDebug "\<p\s*("me=e-1 contains=javaDebug.* nextgroup=javaDebugParen
  syn match javaDebug "[A-Za-z][a-zA-Z0-9_]*\.printStackTrace\s*("me=e-1 contains=javaDebug.* nextgroup=javaDebugParen
  syn match javaDebug "\<trace[SL]\=\s*("me=e-1 contains=javaDebug.* nextgroup=javaDebugParen

  syn cluster javaTop add=javaDebug

  hi def link javaDebug		 Debug
  hi def link javaDebugString		 DebugString
  hi def link javaDebugStringError	 javaError
  hi def link javaDebugType		 DebugType
  hi def link javaDebugBoolean		 DebugBoolean
  hi def link javaDebugNumber		 Debug
  hi def link javaDebugSpecial		 DebugSpecial
  hi def link javaDebugSpecialCharacter DebugSpecial
  hi def link javaDebugCharacter	 DebugString
  hi def link javaDebugParen		 Debug

  hi def link DebugString		 String
  hi def link DebugSpecial		 Special
  hi def link DebugBoolean		 Boolean
  hi def link DebugType		 Type
endif

if exists("java_mark_braces_in_parens_as_errors")
  syn match javaInParen		 contained "[{}]"
  hi def link javaInParen	javaError
  syn cluster javaTop add=javaInParen
endif

" catch errors caused by wrong parenthesis
syn region  javaParenT	transparent matchgroup=javaParen  start="(" end=")" contains=@javaTop,javaParenT1
syn region  javaParenT1 transparent matchgroup=javaParen1 start="(" end=")" contains=@javaTop,javaParenT2 contained
syn region  javaParenT2 transparent matchgroup=javaParen2 start="(" end=")" contains=@javaTop,javaParenT  contained
syn match   javaParenError	 ")"
" catch errors caused by wrong square parenthesis
syn region  javaParenT	transparent matchgroup=javaParen  start="\[" end="\]" contains=@javaTop,javaParenT1
syn region  javaParenT1 transparent matchgroup=javaParen1 start="\[" end="\]" contains=@javaTop,javaParenT2 contained
syn region  javaParenT2 transparent matchgroup=javaParen2 start="\[" end="\]" contains=@javaTop,javaParenT  contained
syn match   javaParenError	 "\]"

hi def link javaParenError	javaError

if exists("java_highlight_functions")
   syn match javaLambdaDef "([a-zA-Z0-9_<>\[\], \t]*)\s*->"
   " needs to be defined after the parenthesis error catcher to work
endif

if !exists("java_minlines")
  let java_minlines = 10
endif
exec "syn sync ccomment javaComment minlines=" . java_minlines

" The default highlighting.
hi def link javaLambdaDef		Function
hi def link javaFuncDef		Function
hi def link javaVarArg			Function
hi def link javaBraces			Function
hi def link javaBranch			Conditional
hi def link javaUserLabelRef		javaUserLabel
hi def link javaLabel			Label
hi def link javaUserLabel		Label
hi def link javaConditional		Conditional
hi def link javaRepeat			Repeat
hi def link javaExceptions		Exception
hi def link javaAssert			Statement
hi def link javaStorageClass		StorageClass
hi def link javaMethodDecl		javaStorageClass
hi def link javaClassDecl		javaStorageClass
hi def link javaScopeDecl		javaStorageClass

hi def link javaBoolean		Boolean
hi def link javaSpecial		Special
hi def link javaSpecialError		Error
hi def link javaSpecialCharError	Error
hi def link javaString			String
hi def link javaCharacter		Character
hi def link javaSpecialChar		SpecialChar
hi def link javaNumber			Number
hi def link javaError			Error
hi def link javaStringError		Error
hi def link javaStatement		Statement
hi def link javaOperator		Operator
hi def link javaComment		Comment
hi def link javaDocComment		Comment
hi def link javaLineComment		Comment
hi def link javaConstant		Constant
hi def link javaTypedef		Typedef
hi def link javaTodo			Todo
hi def link javaAnnotation		PreProc

hi def link javaCommentTitle		SpecialComment
hi def link javaDocTags		Special
hi def link javaDocParam		Function
hi def link javaDocSeeTagParam		Function
hi def link javaCommentStar		javaComment

hi def link javaType			Type
hi def link javaExternal		Include

hi def link htmlComment		Special
hi def link htmlCommentPart		Special
hi def link javaSpaceError		Error

if fnamemodify(bufname("%"), ":t") == "module-info.java"
    hi def link javaModuleStorageClass	StorageClass
    hi def link javaModuleStmt		Statement
    hi def link javaModuleExternal	Include
endif

let b:current_syntax = "java"

if main_syntax == 'java'
  unlet main_syntax
endif

let b:spell_options="contained"
let &cpo = s:cpo_save
unlet s:cpo_save

" vim: ts=8
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           " Vim syntax file
" Language:	JavaCC, a Java Compiler Compiler written by JavaSoft
" Maintainer:	Claudio Fleiner <claudio@fleiner.com>
" URL:		http://www.fleiner.com/vim/syntax/javacc.vim
" Last Change:	2012 Oct 05

" Uses java.vim, and adds a few special things for JavaCC Parser files.
" Those files usually have the extension  *.jj

" quit when a syntax file was already loaded
if exists("b:current_syntax")
  finish
endif

let s:cpo_save = &cpo
set cpo&vim

" source the java.vim file
runtime! syntax/java.vim
unlet b:current_syntax

"remove catching errors caused by wrong parenthesis (does not work in javacc
"files) (first define them in case they have not been defined in java)
syn match	javaParen "--"
syn match	javaParenError "--"
syn match	javaInParen "--"
syn match	javaError2 "--"
syn clear	javaParen
syn clear	javaParenError
syn clear	javaInParen
syn clear	javaError2

" remove function definitions (they look different) (first define in
" in case it was not defined in java.vim)
"syn match javaFuncDef "--"
syn clear javaFuncDef
syn match javaFuncDef "[$_a-zA-Z][$_a-zA-Z0-9_. \[\]]*([^-+*/()]*)[ \t]*:" contains=javaType

syn keyword javaccPackages options DEBUG_PARSER DEBUG_LOOKAHEAD DEBUG_TOKEN_MANAGER
syn keyword javaccPackages COMMON_TOKEN_ACTION IGNORE_CASE CHOICE_AMBIGUITY_CHECK
syn keyword javaccPackages OTHER_AMBIGUITY_CHECK STATIC LOOKAHEAD ERROR_REPORTING
syn keyword javaccPackages USER_TOKEN_MANAGER  USER_CHAR_STREAM JAVA_UNICODE_ESCAPE
syn keyword javaccPackages UNICODE_INPUT JDK_VERSION
syn match javaccPackages "PARSER_END([^)]*)"
syn match javaccPackages "PARSER_BEGIN([^)]*)"
syn match javaccSpecToken "<EOF>"
" the dot is necessary as otherwise it will be matched as a keyword.
syn match javaccSpecToken ".LOOKAHEAD("ms=s+1,me=e-1
syn match javaccToken "<[^> \t]*>"
syn keyword javaccActionToken TOKEN SKIP MORE SPECIAL_TOKEN
syn keyword javaccError DEBUG IGNORE_IN_BNF

" Define the default highlighting.
" Only when an item doesn't have highlighting yet
hi def link javaccSpecToken Statement
hi def link javaccActionToken Type
hi def link javaccPackages javaScopeDecl
hi def link javaccToken String
hi def link javaccError Error

let b:current_syntax = "javacc"
let &cpo = s:cpo_save
unlet s:cpo_save

" vim: ts=8
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                " Vim syntax file
" Language:	JavaScript
" Maintainer:	Claudio Fleiner <claudio@fleiner.com>
" Updaters:	Scott Shattuck (ss) <ss@technicalpursuit.com>
" URL:		http://www.fleiner.com/vim/syntax/javascript.vim
" Changes:	(ss) added keywords, reserved words, and other identifiers
"		(ss) repaired several quoting and grouping glitches
"		(ss) fixed regex parsing issue with multiple qualifiers [gi]
"		(ss) additional factoring of keywords, globals, and members
" Last Change:	2021 Mar 30
" 		2013 Jun 12: adjusted javaScriptRegexpString (Kevin Locke)
" 		2018 Apr 14: adjusted javaScriptRegexpString (LongJohnCoder)

" tuning parameters:
" unlet javaScript_fold

if !exists("main_syntax")
  " quit when a syntax file was already loaded
  if exists("b:current_syntax")
    finish
  endif
  let main_syntax = 'javascript'
elseif exists("b:current_syntax") && b:current_syntax == "javascript"
  finish
endif

let s:cpo_save = &cpo
set cpo&vim


syn keyword javaScriptCommentTodo      TODO FIXME XXX TBD contained
syn match   javaScriptLineComment      "\/\/.*" contains=@Spell,javaScriptCommentTodo
syn match   javaScriptCommentSkip      "^[ \t]*\*\($\|[ \t]\+\)"
syn region  javaScriptComment	       start="/\*"  end="\*/" contains=@Spell,javaScriptCommentTodo
syn match   javaScriptSpecial	       "\\\d\d\d\|\\."
syn region  javaScriptStringD	       start=+"+  skip=+\\\\\|\\"+  end=+"\|$+	contains=javaScriptSpecial,@htmlPreproc
syn region  javaScriptStringS	       start=+'+  skip=+\\\\\|\\'+  end=+'\|$+	contains=javaScriptSpecial,@htmlPreproc
syn region  javaScriptStringT	       start=+`+  skip=+\\\\\|\\`+  end=+`+	contains=javaScriptSpecial,javaScriptEmbed,@htmlPreproc

syn region  javaScriptEmbed	       start=+${+  end=+}+	contains=@javaScriptEmbededExpr

syn match   javaScriptSpecialCharacter "'\\.'"
syn match   javaScriptNumber	       "-\=\<\d\+L\=\>\|0[xX][0-9a-fA-F]\+\>"
syn match   javaScriptNumber	       "-\=\<\d\+\%(_\d\+\)*\>"
syn region  javaScriptRegexpString     start=+[,(=+]\s*/[^/*]+ms=e-1,me=e-1 skip=+\\\\\|\\/+ end=+/[gimuys]\{0,2\}\s*$+ end=+/[gimuys]\{0,2\}\s*[+;.,)\]}]+me=e-1 end=+/[gimuys]\{0,2\}\s\+\/+me=e-1 contains=@htmlPreproc,javaScriptComment oneline

syn keyword javaScriptConditional	if else switch
syn keyword javaScriptRepeat		while for do in
syn keyword javaScriptBranch		break continue
syn keyword javaScriptOperator		new delete instanceof typeof
syn keyword javaScriptType		Array Boolean Date Function Number Object String RegExp
syn keyword javaScriptStatement		return with await
syn keyword javaScriptBoolean		true false
syn keyword javaScriptNull		null undefined
syn keyword javaScriptIdentifier	arguments this var let
syn keyword javaScriptLabel		case default
syn keyword javaScriptException		try catch finally throw
syn keyword javaScriptMessage		alert confirm prompt status
syn keyword javaScriptGlobal		self window top parent
syn keyword javaScriptMember		document event location 
syn keyword javaScriptDeprecated	escape unescape
syn keyword javaScriptReserved		abstract boolean byte char class const debugger double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile async

syn cluster  javaScriptEmbededExpr	contains=javaScriptBoolean,javaScriptNull,javaScriptIdentifier,javaScriptStringD,javaScriptStringS,javaScriptStringT

if exists("javaScript_fold")
    syn match	javaScriptFunction	"\<function\>"
    syn region	javaScriptFunctionFold	start="\<function\>.*[^};]$" end="^\z1}.*$" transparent fold keepend

    syn sync match javaScriptSync	grouphere javaScriptFunctionFold "\<function\>"
    syn sync match javaScriptSync	grouphere NONE "^}"

    setlocal foldmethod=syntax
    setlocal foldtext=getline(v:foldstart)
else
    syn keyword javaScriptFunction	function
    syn match	javaScriptBraces	   "[{}\[\]]"
    syn match	javaScriptParens	   "[()]"
endif

if main_syntax == "javascript"
  syn sync fromstart
  syn sync maxlines=100

  syn sync ccomment javaScriptComment
endif

" Define the default highlighting.
" Only when an item doesn't have highlighting yet
hi def link javaScriptComment		Comment
hi def link javaScriptLineComment		Comment
hi def link javaScriptCommentTodo		Todo
hi def link javaScriptSpecial		Special
hi def link javaScriptStringS		String
hi def link javaScriptStringD		String
hi def link javaScriptStringT		String
hi def link javaScriptCharacter		Character
hi def link javaScriptSpecialCharacter	javaScriptSpecial
hi def link javaScriptNumber		javaScriptValue
hi def link javaScriptConditional		Conditional
hi def link javaScriptRepeat		Repeat
hi def link javaScriptBranch		Conditional
hi def link javaScriptOperator		Operator
hi def link javaScriptType			Type
hi def link javaScriptStatement		Statement
hi def link javaScriptFunction		Function
hi def link javaScriptBraces		Function
hi def link javaScriptError		Error
hi def link javaScrParenError		javaScriptError
hi def link javaScriptNull			Keyword
hi def link javaScriptBoolean		Boolean
hi def link javaScriptRegexpString		String

hi def link javaScriptIdentifier		Identifier
hi def link javaScriptLabel		Label
hi def link javaScriptException		Exception
hi def link javaScriptMessage		Keyword
hi def link javaScriptGlobal		Keyword
hi def link javaScriptMember		Keyword
hi def link javaScriptDeprecated		Exception 
hi def link javaScriptReserved		Keyword
hi def link javaScriptDebug		Debug
hi def link javaScriptConstant		Label
hi def link javaScriptEmbed		Special



let b:current_syntax = "javascript"
if main_syntax == 'javascript'
  unlet main_syntax
endif
let &cpo = s:cpo_save
unlet s:cpo_save

" vim: ts=8
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   " Placeholder for backwards compatilibity: .jsx used to be associated with the
" filetpye JavaScript.
runtime! syntax/javascript.vim
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           " Vim syntax file
" Language:	Jess
" Maintainer:	Paul Baleme <pbaleme@mail.com>
" Last change:	September 14, 2000
" Based on lisp.vim by : Dr. Charles E. Campbell, Jr.

" quit when a syntax file was already loaded
if exists("b:current_syntax")
  finish
endif

setlocal iskeyword=42,43,45,47-58,60-62,64-90,97-122,_

" Lists
syn match	jessSymbol	![^()'`,"; \t]\+!	contained
syn match	jessBarSymbol	!|..\{-}|!		contained
syn region	jessList matchgroup=Delimiter start="(" skip="|.\{-}|" matchgroup=Delimiter end=")" contains=jessAtom,jessBQList,jessConcat,jessDeclaration,jessList,jessNumber,jessSymbol,jessSpecial,jessFunc,jessKey,jessAtomMark,jessString,jessComment,jessBarSymbol,jessAtomBarSymbol,jessVar
syn region	jessBQList	matchgroup=PreProc   start="`("	skip="|.\{-}|" matchgroup=PreProc   end=")" contains=jessAtom,jessBQList,jessConcat,jessDeclaration,jessList,jessNumber,jessSpecial,jessSymbol,jessFunc,jessKey,jessVar,jessAtomMark,jessString,jessComment,jessBarSymbol,jessAtomBarSymbol

" Atoms
syn match	jessAtomMark	"'"
syn match	jessAtom	"'("me=e-1	contains=jessAtomMark	nextgroup=jessAtomList
syn match	jessAtom	"'[^ \t()]\+"	contains=jessAtomMark
syn match	jessAtomBarSymbol	!'|..\{-}|!	contains=jessAtomMark
syn region	jessAtom	start=+'"+	skip=+\\"+ end=+"+
syn region	jessAtomList	matchgroup=Special start="("	skip="|.\{-}|" matchgroup=Special end=")"	contained contains=jessAtomList,jessAtomNmbr0,jessString,jessComment,jessAtomBarSymbol
syn match	jessAtomNmbr	"\<[0-9]\+"			contained

" Standard jess Functions and Macros
syn keyword jessFunc    *   +   **	-   /   <   >   <=  >=  <>  =
syn keyword jessFunc    long	    longp
syn keyword jessFunc    abs	    agenda	      and
syn keyword jessFunc    assert	    assert-string       bag
syn keyword jessFunc    batch	    bind	      bit-and
syn keyword jessFunc    bit-not	    bit-or	      bload
syn keyword jessFunc    bsave	    build	      call
syn keyword jessFunc    clear	    clear-storage       close
syn keyword jessFunc    complement$     context	      count-query-results
syn keyword jessFunc    create$
syn keyword jessFunc    delete$	    div
syn keyword jessFunc    do-backward-chaining	      e
syn keyword jessFunc    engine	    eq	      eq*
syn keyword jessFunc    eval	    evenp	      exit
syn keyword jessFunc    exp	    explode$	      external-addressp
syn keyword jessFunc    fact-slot-value facts	      fetch
syn keyword jessFunc    first$	    float	      floatp
syn keyword jessFunc    foreach	    format	      gensym*
syn keyword jessFunc    get	    get-fact-duplication
syn keyword jessFunc    get-member	    get-multithreaded-io
syn keyword jessFunc    get-reset-globals	      get-salience-evaluation
syn keyword jessFunc    halt	    if	      implode$
syn keyword jessFunc    import	    insert$	      integer
syn keyword jessFunc    integerp	    intersection$       jess-version-number
syn keyword jessFunc    jess-version-string	      length$
syn keyword jessFunc    lexemep	    list-function$      load-facts
syn keyword jessFunc    load-function   load-package	      log
syn keyword jessFunc    log10	    lowcase	      matches
syn keyword jessFunc    max	    member$	      min
syn keyword jessFunc    mod	    modify	      multifieldp
syn keyword jessFunc    neq	    new	      not
syn keyword jessFunc    nth$	    numberp	      oddp
syn keyword jessFunc    open	    or	      pi
syn keyword jessFunc    ppdeffunction   ppdefglobal	      ddpefrule
syn keyword jessFunc    printout	    random	      read
syn keyword jessFunc    readline	    replace$	      reset
syn keyword jessFunc    rest$	    retract	      retract-string
syn keyword jessFunc    return	    round	      rules
syn keyword jessFunc    run	    run-query	      run-until-halt
syn keyword jessFunc    save-facts	    set	      set-fact-duplication
syn keyword jessFunc    set-factory     set-member	      set-multithreaded-io
syn keyword jessFunc    set-node-index-hash	      set-reset-globals
syn keyword jessFunc    set-salience-evaluation	      set-strategy
syn keyword jessFunc    setgen	    show-deffacts       show-deftemplates
syn keyword jessFunc    show-jess-listeners	      socket
syn keyword jessFunc    sqrt	    store	      str-cat
syn keyword jessFunc    str-compare     str-index	      str-length
syn keyword jessFunc    stringp	    sub-string	      subseq$
syn keyword jessFunc    subsetp	    sym-cat	      symbolp
syn keyword jessFunc    system	    throw	      time
syn keyword jessFunc    try	    undefadvice	      undefinstance
syn keyword jessFunc    undefrule	    union$	      unwatch
syn keyword jessFunc    upcase	    view	      watch
syn keyword jessFunc    while
syn match   jessFunc	"\<c[ad]\+r\>"

" jess Keywords (modifiers)
syn keyword jessKey	    defglobal	  deffunction	    defrule
syn keyword jessKey	    deffacts
syn keyword jessKey	    defadvice	  defclass	    definstance

" Standard jess Variables
syn region	jessVar	start="?"	end="[^a-zA-Z0-9]"me=e-1

" Strings
syn region	jessString	start=+"+	skip=+\\"+ end=+"+

" Shared with Declarations, Macros, Functions
"syn keyword	jessDeclaration

syn match	jessNumber	"[0-9]\+"

syn match	jessSpecial	"\*[a-zA-Z_][a-zA-Z_0-9-]*\*"
syn match	jessSpecial	!#|[^()'`,"; \t]\+|#!
syn match	jessSpecial	!#x[0-9a-fA-F]\+!
syn match	jessSpecial	!#o[0-7]\+!
syn match	jessSpecial	!#b[01]\+!
syn match	jessSpecial	!#\\[ -\~]!
syn match	jessSpecial	!#[':][^()'`,"; \t]\+!
syn match	jessSpecial	!#([^()'`,"; \t]\+)!

syn match	jessConcat	"\s\.\s"
syntax match	jessParenError	")"

" Comments
syn match	jessComment	";.*$"

" synchronization
syn sync lines=100

" Define the default highlighting.
" Only when an item doesn't have highlighting yet

hi def link jessAtomNmbr	jessNumber
hi def link jessAtomMark	jessMark

hi def link jessAtom		Identifier
hi def link jessAtomBarSymbol	Special
hi def link jessBarSymbol	Special
hi def link jessComment	Comment
hi def link jessConcat	Statement
hi def link jessDeclaration	Statement
hi def link jessFunc		Statement
hi def link jessKey		Type
hi def link jessMark		Delimiter
hi def link jessNumber	Number
hi def link jessParenError	Error
hi def link jessSpecial	Type
hi def link jessString	String
hi def link jessVar		Identifier


let b:current_syntax = "jess"

" vim: ts=18
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          " Vim syntax file
" Language:	jgraph (graph plotting utility)
" Maintainer:	Jonas Munsin jmunsin@iki.fi
" Last Change:	2003 May 04
" this syntax file is not yet complete


" quit when a syntax file was already loaded
if exists("b:current_syntax")
  finish
endif

syn case match

" comments
syn region	jgraphComment	start="(\* " end=" \*)"

syn keyword	jgraphCmd	newcurve newgraph marktype
syn keyword	jgraphType	xaxis yaxis

syn keyword	jgraphType	circle box diamond triangle x cross ellipse
syn keyword	jgraphType	xbar ybar text postscript eps none general

syn keyword	jgraphType	solid dotted dashed longdash dotdash dodotdash
syn keyword	jgraphType	dotdotdashdash pts

"integer number, or floating point number without a dot. - or no -
syn match  jgraphNumber		 "\<-\=\d\+\>"
"floating point number, with dot - or no -
syn match  jgraphNumber		 "\<-\=\d\+\.\d*\>"
"floating point number, starting with a dot - or no -
syn match  jgraphNumber		 "\-\=\.\d\+\>"


" Define the default highlighting.
" Only when an item doesn't have highlighting yet

hi def link jgraphComment	Comment
hi def link jgraphCmd	Identifier
hi def link jgraphType	Type
hi def link jgraphNumber	Number



let b:current_syntax = "jgraph"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    " Vim syntax file
" Language: JOVIAL J73
" Version: 1.2
" Maintainer: Paul McGinnis <paulmcg@aol.com>
" Last Change: 2011/06/17
" Remark: Based on MIL-STD-1589C for JOVIAL J73 language

" Quit when a (custom) syntax file was already loaded
if exists("b:current_syntax")
  finish
endif

syn case ignore

syn keyword jovialTodo TODO FIXME XXX contained

" JOVIAL beads - first digit is number of bits, [0-9A-V] is the bit value
" representing 0-31 (for 5 bits on the bead)
syn match jovialBitConstant "[1-5]B'[0-9A-V]'"

syn match jovialNumber "\<\d\+\>"

syn match jovialFloat "\d\+E[-+]\=\d\+"
syn match jovialFloat "\d\+\.\d*\(E[-+]\=\d\+\)\="
syn match jovialFloat "\.\d\+\(E[-+]\=\d\+\)\="

syn region jovialComment start=/"/ end=/"/ contains=jovialTodo
syn region jovialComment start=/%/ end=/%/ contains=jovialTodo

" JOVIAL variable names. This rule is to prevent conflicts with strings.
" Handle special case where ' character can be part of a JOVIAL variable name.
syn match jovialIdentifier "[A-Z\$][A-Z0-9'\$]\+"

syn region jovialString start="\s*'" skip=/''/ end=/'/ oneline

" JOVIAL compiler directives -- see Section 9 in MIL-STD-1589C
syn region jovialPreProc start="\s*![A-Z]\+" end=/;/

syn keyword jovialOperator AND OR NOT XOR EQV MOD

" See Section 2.1 in MIL-STD-1589C for data types
syn keyword jovialType ITEM B C P V
syn match jovialType "\<S\(,R\|,T\|,Z\)\=\>"
syn match jovialType "\<U\(,R\|,T\|,Z\)\=\>"
syn match jovialType "\<F\(,R\|,T\|,Z\)\=\>"
syn match jovialType "\<A\(,R\|,T\|,Z\)\=\>"

syn keyword jovialStorageClass STATIC CONSTANT PARALLEL BLOCK N M D W

syn keyword jovialStructure TABLE STATUS

syn keyword jovialConstant NULL

syn keyword jovialBoolean FALSE TRUE

syn keyword jovialTypedef TYPE

syn keyword jovialStatement ABORT BEGIN BY BYREF BYRES BYVAL CASE COMPOOL
syn keyword jovialStatement DEF DEFAULT DEFINE ELSE END EXIT FALLTHRU FOR
syn keyword jovialStatement GOTO IF INLINE INSTANCE LABEL LIKE OVERLAY POS
syn keyword jovialStatement PROC PROGRAM REC REF RENT REP RETURN START STOP
syn keyword jovialStatement TERM THEN WHILE

" JOVIAL extensions, see section 8.2.2 in MIL-STD-1589C
syn keyword jovialStatement CONDITION ENCAPSULATION EXPORTS FREE HANDLER IN INTERRUPT NEW
syn keyword jovialStatement PROTECTED READONLY REGISTER SIGNAL TO UPDATE WITH WRITEONLY ZONE

" implementation specific constants and functions, see section 1.4 in MIL-STD-1589C
syn keyword jovialConstant BITSINBYTE BITSINWORD LOCSINWORD
syn keyword jovialConstant BYTESINWORD BITSINPOINTER INTPRECISION
syn keyword jovialConstant FLOATPRECISION FIXEDPRECISION FLOATRADIX
syn keyword jovialConstant MAXFLOATPRECISION MAXFIXEDPRECISION
syn keyword jovialConstant MAXINTSIZE MAXBYTES MAXBITS
syn keyword jovialConstant MAXTABLESIZE MAXSTOP MINSTOP MAXSIGDIGITS
syn keyword jovialFunction BYTEPOS MAXINT MININT
syn keyword jovialFunction IMPLFLOATPRECISION IMPLFIXEDPRECISION IMPLINTSIZE
syn keyword jovialFunction MINSIZE MINFRACTION MINSCALE MINRELPRECISION
syn keyword jovialFunction MAXFLOAT MINFLOAT FLOATRELPRECISION
syn keyword jovialFunction FLOATUNDERFLOW MAXFIXED MINFIXED

" JOVIAL built-in functions
syn keyword jovialFunction LOC NEXT BIT BYTE SHIFTL SHIFTR ABS SGN BITSIZE
syn keyword jovialFunction BYTESIZE WORDSIZE LBOUND UBOUND NWDSEN FIRST
syn keyword jovialFunction LAST NENT

" Define the default highlighting.
hi def link jovialBitConstant Number
hi def link jovialBoolean Boolean
hi def link jovialComment Comment
hi def link jovialConstant Constant
hi def link jovialFloat Float
hi def link jovialFunction Function
" No color highlighting for JOVIAL identifiers. See above,
" this is to prevent confusion with JOVIAL strings
"hi def link jovialIdentifier Identifier
hi def link jovialNumber Number
hi def link jovialOperator Operator
hi def link jovialPreProc PreProc
hi def link jovialStatement Statement
hi def link jovialStorageClass StorageClass
hi def link jovialString String
hi def link jovialStructure Structure
hi def link jovialTodo Todo
hi def link jovialType Type
hi def link jovialTypedef Typedef


let b:current_syntax = "jovial"

" vim: ts=8
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     " Vim syntax file
" Language:	Java Properties resource file (*.properties[_*])
" Maintainer:	Simon Baldwin <simonb@sco.com>
" Last change:	26th Mar 2000

" =============================================================================

" Optional and tuning variables:

" jproperties_lines
" -----------------
"   Set a value for the sync block that we use to find long continuation lines
"   in properties; the value is already large - if you have larger continuation
"   sets you may need to increase it further - if not, and you find editing is
"   slow, reduce the value of jproperties_lines.
if !exists("jproperties_lines")
	let jproperties_lines = 256
endif

" jproperties_strict_syntax
" -------------------------
"   Most properties files assign values with "id=value" or "id:value".  But,
"   strictly, the Java properties parser also allows "id value", "id", and
"   even more bizarrely "=value", ":value", " value", and so on.  These latter
"   ones, however, are rarely used, if ever, and handling them in the high-
"   lighting can obscure errors in the more normal forms.  So, in practice
"   we take special efforts to pick out only "id=value" and "id:value" forms
"   by default.  If you want strict compliance, set jproperties_strict_syntax
"   to non-zero (and good luck).
if !exists("jproperties_strict_syntax")
	let jproperties_strict_syntax = 0
endif

" jproperties_show_messages
" -------------------------
"   If this properties file contains messages for use with MessageFormat,
"   setting a non-zero value will highlight them.  Messages are of the form
"   "{...}".  Highlighting doesn't go to the pains of picking apart what is
"   in the format itself - just the basics for now.
if !exists("jproperties_show_messages")
	let jproperties_show_messages = 0
endif

" =============================================================================

" quit when a syntax file was already loaded
if exists("b:current_syntax")
  finish
endif

" switch case sensitivity off
syn case ignore

" set the block
exec "syn sync lines=" . jproperties_lines

" switch between 'normal' and 'strict' syntax
if jproperties_strict_syntax != 0

	" an assignment is pretty much any non-empty line at this point,
	" trying to not think about continuation lines
	syn match   jpropertiesAssignment	"^\s*[^[:space:]]\+.*$" contains=jpropertiesIdentifier

	" an identifier is anything not a space character, pretty much; it's
	" followed by = or :, or space or tab.  Or end-of-line.
	syn match   jpropertiesIdentifier	"[^=:[:space:]]*" contained nextgroup=jpropertiesDelimiter

	" treat the delimiter specially to get colours right
	syn match   jpropertiesDelimiter	"\s*[=:[:space:]]\s*" contained nextgroup=jpropertiesString

	" catch the bizarre case of no identifier; a special case of delimiter
	syn match   jpropertiesEmptyIdentifier	"^\s*[=:]\s*" nextgroup=jpropertiesString
else

	" here an assignment is id=value or id:value, and we conveniently
	" ignore continuation lines for the present
	syn match   jpropertiesAssignment	"^\s*[^=:[:space:]]\+\s*[=:].*$" contains=jpropertiesIdentifier

	" an identifier is anything not a space character, pretty much; it's
	" always followed by = or :, and we find it in an assignment
	syn match   jpropertiesIdentifier	"[^=:[:space:]]\+" contained nextgroup=jpropertiesDelimiter

	" treat the delimiter specially to get colours right; this time the
	" delimiter must contain = or :
	syn match   jpropertiesDelimiter	"\s*[=:]\s*" contained nextgroup=jpropertiesString
endif

" a definition is all up to the last non-\-terminated line; strictly, Java
" properties tend to ignore leading whitespace on all lines of a multi-line
" definition, but we don't look for that here (because it's a major hassle)
syn region  jpropertiesString		start="" skip="\\$" end="$" contained contains=jpropertiesSpecialChar,jpropertiesError,jpropertiesSpecial

" {...} is a Java Message formatter - add a minimal recognition of these
" if required
if jproperties_show_messages != 0
	syn match   jpropertiesSpecial		"{[^}]*}\{-1,\}" contained
	syn match   jpropertiesSpecial		"'{" contained
	syn match   jpropertiesSpecial		"''" contained
endif

" \uABCD are unicode special characters
syn match   jpropertiesSpecialChar	"\\u\x\{1,4}" contained

" ...and \u not followed by a hex digit is an error, though the properties
" file parser won't issue an error on it, just set something wacky like zero
syn match   jpropertiesError		"\\u\X\{1,4}" contained
syn match   jpropertiesError		"\\u$"me=e-1 contained

" other things of note are the \t,r,n,\, and the \ preceding line end
syn match   jpropertiesSpecial		"\\[trn\\]" contained
syn match   jpropertiesSpecial		"\\\s" contained
syn match   jpropertiesSpecial		"\\$" contained

" comments begin with # or !, and persist to end of line; put here since
" they may have been caught by patterns above us
syn match   jpropertiesComment		"^\s*[#!].*$" contains=jpropertiesTODO
syn keyword jpropertiesTodo		TODO FIXME XXX contained

" Define the default highlighting.
" Only when an item doesn't have highlighting yet

hi def link jpropertiesComment	Comment
hi def link jpropertiesTodo		Todo
hi def link jpropertiesIdentifier	Identifier
hi def link jpropertiesString	String
hi def link jpropertiesExtendString	String
hi def link jpropertiesCharacter	Character
hi def link jpropertiesSpecial	Special
hi def link jpropertiesSpecialChar	SpecialChar
hi def link jpropertiesError	Error


let b:current_syntax = "jproperties"

" vim:ts=8
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           json.vim   	jsonc.vim      jsp.vim    	julia.vim   	   kconfig.vim 
   kivy.vim   kix.vim    kscript.vim    kwt.vim    lace.vim   	latte.vim      ld.vim     ldapconf.vim   ldif.vim   less.vim   lex.vim    lftp.vim   lhaskell.vim   	libao.vim      lifelines.vim      lilo.vim   
limits.vim     
liquid.vim     lisp.vim   lite.vim   litestep.vim   loginaccess.vim     logindefs.vim   !   logtalk.vim "   	lotos.vim   #   lout.vim$   lpc.vim %   lprolog.vim &   lscript.vim '   lsl.vim (   lss.vim )   lua.vim *   lynx.vim+   m3build.vim ,   m3quake.vim -   m4.vim  .   mail.vim/   mailaliases.vim 0   mailcap.vim 1   make.vim2   mallard.vim 3   man.vim 4   manconf.vim 5   
manual.vim  6   	maple.vim   7   markdown.vim8   masm.vim9   	mason.vim   :   
master.vim  ;   
matlab.vim          " Vim syntax file
" Language:	JSON
" Maintainer:	vacancy
" Previous Maintainer:	Eli Parra <eli@elzr.com>
" Last Change:	2019 Sep 17
" Version:      0.12

if !exists("main_syntax")
  " quit when a syntax file was already loaded
  if exists("b:current_syntax")
    finish
  endif
  let main_syntax = 'json'
endif

syntax match   jsonNoise           /\%(:\|,\)/

" NOTE that for the concealing to work your conceallevel should be set to 2

" Syntax: JSON Keywords
" Separated into a match and region because a region by itself is always greedy
syn match  jsonKeywordMatch /"\([^"]\|\\\"\)\+"[[:blank:]\r\n]*\:/ contains=jsonKeyword
if has('conceal') && (!exists("g:vim_json_conceal") || g:vim_json_conceal==1)
   syn region  jsonKeyword matchgroup=jsonQuote start=/"/  end=/"\ze[[:blank:]\r\n]*\:/ concealends contained
else
   syn region  jsonKeyword matchgroup=jsonQuote start=/"/  end=/"\ze[[:blank:]\r\n]*\:/ contained
endif

" Syntax: Strings
" Separated into a match and region because a region by itself is always greedy
" Needs to come after keywords or else a json encoded string will break the
" syntax
syn match  jsonStringMatch /"\([^"]\|\\\"\)\+"\ze[[:blank:]\r\n]*[,}\]]/ contains=jsonString
if has('conceal') && (!exists("g:vim_json_conceal") || g:vim_json_conceal==1)
	syn region  jsonString oneline matchgroup=jsonQuote start=/"/  skip=/\\\\\|\\"/  end=/"/ concealends contains=jsonEscape contained
else
	syn region  jsonString oneline matchgroup=jsonQuote start=/"/  skip=/\\\\\|\\"/  end=/"/ contains=jsonEscape contained
endif

" Syntax: JSON does not allow strings with single quotes, unlike JavaScript.
syn region  jsonStringSQError oneline  start=+'+  skip=+\\\\\|\\"+  end=+'+


" Syntax: Escape sequences
syn match   jsonEscape    "\\["\\/bfnrt]" contained
syn match   jsonEscape    "\\u\x\{4}" contained

" Syntax: Numbers
syn match   jsonNumber    "-\=\<\%(0\|[1-9]\d*\)\%(\.\d\+\)\=\%([eE][-+]\=\d\+\)\=\>\ze[[:blank:]\r\n]*[,}\]]"

" ERROR WARNINGS **********************************************
if (!exists("g:vim_json_warnings") || g:vim_json_warnings==1)
	" Syntax: Strings should always be enclosed with quotes.
	syn match   jsonNoQuotesError  "\<[[:alpha:]][[:alnum:]]*\>"
	syn match   jsonTripleQuotesError  /"""/

	" Syntax: An integer part of 0 followed by other digits is not allowed.
	syn match   jsonNumError  "-\=\<0\d\.\d*\>"

	" Syntax: Decimals smaller than one should begin with 0 (so .1 should be 0.1).
	syn match   jsonNumError  "\:\@<=[[:blank:]\r\n]*\zs\.\d\+"

	" Syntax: No comments in JSON, see http://stackoverflow.com/questions/244777/can-i-comment-a-json-file
	syn match   jsonCommentError  "//.*"
	syn match   jsonCommentError  "\(/\*\)\|\(\*/\)"

	" Syntax: No semicolons in JSON
	syn match   jsonSemicolonError  ";"

	" Syntax: No trailing comma after the last element of arrays or objects
	syn match   jsonTrailingCommaError  ",\_s*[}\]]"

	" Syntax: Watch out for missing commas between elements
	syn match   jsonMissingCommaError /\("\|\]\|\d\)\zs\_s\+\ze"/
	syn match   jsonMissingCommaError /\(\]\|\}\)\_s\+\ze"/ "arrays/objects as values
	syn match   jsonMissingCommaError /}\_s\+\ze{/ "objects as elements in an array
	syn match   jsonMissingCommaError /\(true\|false\)\_s\+\ze"/ "true/false as value
endif

" ********************************************** END OF ERROR WARNINGS
" Allowances for JSONP: function call at the beginning of the file,
" parenthesis and semicolon at the end.
" Function name validation based on
" http://stackoverflow.com/questions/2008279/validate-a-javascript-function-name/2008444#2008444
syn match  jsonPadding "\%^[[:blank:]\r\n]*[_$[:alpha:]][_$[:alnum:]]*[[:blank:]\r\n]*("
syn match  jsonPadding ");[[:blank:]\r\n]*\%$"

" Syntax: Boolean
syn match  jsonBoolean /\(true\|false\)\(\_s\+\ze"\)\@!/

" Syntax: Null
syn keyword  jsonNull      null

" Syntax: Braces
syn region  jsonFold matchgroup=jsonBraces start="{" end=/}\(\_s\+\ze\("\|{\)\)\@!/ transparent fold
syn region  jsonFold matchgroup=jsonBraces start="\[" end=/]\(\_s\+\ze"\)\@!/ transparent fold

" Define the default highlighting.
" Only when an item doesn't have highlighting yet
hi def link jsonPadding         Operator
hi def link jsonString          String
hi def link jsonTest          Label
hi def link jsonEscape          Special
hi def link jsonNumber          Number
hi def link jsonBraces          Delimiter
hi def link jsonNull            Function
hi def link jsonBoolean         Boolean
hi def link jsonKeyword         Label

if (!exists("g:vim_json_warnings") || g:vim_json_warnings==1)
hi def link jsonNumError        Error
hi def link jsonCommentError    Error
hi def link jsonSemicolonError  Error
hi def link jsonTrailingCommaError     Error
hi def link jsonMissingCommaError      Error
hi def link jsonStringSQError        	Error
hi def link jsonNoQuotesError        	Error
hi def link jsonTripleQuotesError     	Error
endif
hi def link jsonQuote           Quote
hi def link jsonNoise           Noise

let b:current_syntax = "json"
if main_syntax == 'json'
  unlet main_syntax
endif

" Vim settings
" vim: ts=8 fdm=marker

" MIT License
" Copyright (c) 2013, Jeroen Ruigrok van der Werven, Eli Parra
"Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the Software), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
"The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
"THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
"See https://twitter.com/elzr/status/294964017926119424
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 " Vim syntax file
" Language:         JSONC (JSON with Comments)
" Original Author:  Izhak Jakov <izhak724@gmail.com>
" Acknowledgement:  Based off of vim-jsonc maintained by Kevin Locke <kevin@kevinlocke.name>
"                   https://github.com/kevinoid/vim-jsonc
" License:          MIT
" Last Change:      2021-07-01

" Ensure syntax is loaded once, unless nested inside another (main) syntax
" For description of main_syntax, see https://stackoverflow.com/q/16164549
if !exists('g:main_syntax')
  if exists('b:current_syntax') && b:current_syntax ==# 'jsonc'
    finish
  endif
  let g:main_syntax = 'jsonc'
endif

" Based on vim-json syntax
runtime! syntax/json.vim

" Remove syntax group for comments treated as errors
if !exists("g:vim_json_warnings") || g:vim_json_warnings
  syn clear jsonCommentError
endif

syn match jsonStringMatch /"\([^"]\|\\\"\)\+"\ze\(\_s*\/\/.*\_s*\)*[}\]]/ contains=jsonString
syn match jsonStringMatch /"\([^"]\|\\\"\)\+"\ze\_s*\/\*\_.*\*\/\_s*[}\]]/ contains=jsonString
syn match jsonTrailingCommaError /\(,\)\+\ze\(\_s*\/\/.*\_s*\)*[}\]]/
syn match jsonTrailingCommaError /\(,\)\+\ze\_s*\/\*\_.*\*\/\_s*[}\]]/

" Define syntax matching comments and their contents
syn keyword jsonCommentTodo  FIXME NOTE TBD TODO XXX
syn region  jsonLineComment  start=+\/\/+ end=+$+   contains=@Spell,jsonCommentTodo keepend
syn region  jsonComment      start='/\*'  end='\*/' contains=@Spell,jsonCommentTodo fold

" Link comment syntax comment to highlighting
hi! def link jsonLineComment    Comment
hi! def link jsonComment        Comment

" Set/Unset syntax to avoid duplicate inclusion and correctly handle nesting
let b:current_syntax = 'jsonc'
if g:main_syntax ==# 'jsonc'
  unlet g:main_syntax
endif
                                                                                                                                                                                                                                                                                                                           " Vim syntax file
" Language:	JSP (Java Server Pages)
" Maintainer:	Rafael Garcia-Suarez <rgarciasuarez@free.fr>
" URL:		http://rgarciasuarez.free.fr/vim/syntax/jsp.vim
" Last change:	2004 Feb 02
" Credits : Patch by Darren Greaves (recognizes <jsp:...> tags)
"	    Patch by Thomas Kimpton (recognizes jspExpr inside HTML tags)

" quit when a syntax file was already loaded
if exists("b:current_syntax")
  finish
endif

if !exists("main_syntax")
  let main_syntax = 'jsp'
endif

" Source HTML syntax
runtime! syntax/html.vim
unlet b:current_syntax

" Next syntax items are case-sensitive
syn case match

" Include Java syntax
syn include @jspJava syntax/java.vim

syn region jspScriptlet matchgroup=jspTag start=/<%/  keepend end=/%>/ contains=@jspJava
syn region jspComment			  start=/<%--/	      end=/--%>/
syn region jspDecl	matchgroup=jspTag start=/<%!/ keepend end=/%>/ contains=@jspJava
syn region jspExpr	matchgroup=jspTag start=/<%=/ keepend end=/%>/ contains=@jspJava
syn region jspDirective			  start=/<%@/	      end=/%>/ contains=htmlString,jspDirName,jspDirArg

syn keyword jspDirName contained include page taglib
syn keyword jspDirArg contained file uri prefix language extends import session buffer autoFlush
syn keyword jspDirArg contained isThreadSafe info errorPage contentType isErrorPage
syn region jspCommand			  start=/<jsp:/ start=/<\/jsp:/ keepend end=/>/ end=/\/>/ contains=htmlString,jspCommandName,jspCommandArg
syn keyword jspCommandName contained include forward getProperty plugin setProperty useBean param params fallback
syn keyword jspCommandArg contained id scope class type beanName page flush name value property
syn keyword jspCommandArg contained code codebase name archive align height
syn keyword jspCommandArg contained width hspace vspace jreversion nspluginurl iepluginurl

" Redefine htmlTag so that it can contain jspExpr
syn clear htmlTag
syn region htmlTag start=+<[^/%]+ end=+>+ contains=htmlTagN,htmlString,htmlArg,htmlValue,htmlTagError,htmlEvent,htmlCssDefinition,@htmlPreproc,@htmlArgCluster,jspExpr,javaScript

" Define the default highlighting.
" Only when an item doesn't have highlighting yet
" java.vim has redefined htmlComment highlighting
hi def link htmlComment	 Comment
hi def link htmlCommentPart Comment
" Be consistent with html highlight settings
hi def link jspComment	 htmlComment
hi def link jspTag		 htmlTag
hi def link jspDirective	 jspTag
hi def link jspDirName	 htmlTagName
hi def link jspDirArg	 htmlArg
hi def link jspCommand	 jspTag
hi def link jspCommandName  htmlTagName
hi def link jspCommandArg	 htmlArg

if main_syntax == 'jsp'
  unlet main_syntax
endif

let b:current_syntax = "jsp"

" vim: ts=8
                                                                                                                                                                                                                                                                                                                                                                                                          " Vim syntax file
" Language:	julia
" Maintainer:	Carlo Baldassi <carlobaldassi@gmail.com>
" Homepage:	https://github.com/JuliaEditorSupport/julia-vim
" Last Change:	2021 Aug 04

if version < 600
  syntax clear
elseif exists("b:current_syntax")
  finish
endif

let s:cpo_save = &cpo
set cpo&vim

if version < 704
  " this is used to disable regex syntax like `\@3<='
  " on older vim versions
  function! s:d(x)
    return ''
  endfunction
else
  function! s:d(x)
    return string(a:x)
  endfunction
endif

scriptencoding utf-8

let s:julia_spellcheck_strings = get(g:, "julia_spellcheck_strings", 0)
let s:julia_spellcheck_docstrings = get(g:, "julia_spellcheck_docstrings", 1)
let s:julia_spellcheck_comments = get(g:, "julia_spellcheck_comments", 1)

let s:julia_highlight_operators = get(g:, "julia_highlight_operators", 1)

" List of characters, up to \UFF, which cannot be used in identifiers.
" (It includes operator characters; we don't consider them identifiers.)
" This is used mostly in lookbehinds with `\@<=`, e.g. when we need to check
" that that we're not in the middle of an identifier.
" It doesn't include a few characters (spaces and all closing parentheses)
" because those may or may not be valid in the lookbehind on a case-by-case
" basis.
let s:nonid_chars = '\U00-\U08' . '\U0A-\U1F'
      \             . '\U21-\U28' . '\U2A-\U2F' . '\U3A-\U40' . '\U5B-\U5E' . '\U60' . '\U7B\U7C'
      \             . '\U7E-\UA1' . '\UA7\UA8' . '\UAB-\UAD' . '\UAF\UB1\UB4' . '\UB6-\UB8' . '\UBB\UBF' . '\UD7\UF7'

" The complete list
let s:nonidS_chars = '[:space:])\U5D}' . s:nonid_chars


" List of all valid operator chars up to \UFF (NOTE: they must all be included
" in s:nonidS_chars, so that if we include that, then this is redundant)
" It does not include '!' since it can be used in an identifier.
" The list contains the following characters: '%&*+-/<=>\\^|~Â¬Â±Ã—Ã·'
let s:op_chars = '\U25\U26\U2A\U2B\U2D\U2F\U3C-\U3E\U5C\U5E\U7C\U7E\UAC\UB1\UD7\UF7'

" List of all valid operator chars above \UFF
" Written with ranges for performance reasons
" The list contains the following characters: 'â€¦ââ…‹â†â†‘â†’â†“â†”â†šâ†›â†œâ†â†žâ† â†¢â†£â†¤â†¦â†©â†ªâ†«â†¬â†®â†¶â†·â†ºâ†»â†¼â†½â‡€â‡â‡„â‡†â‡‡â‡‰â‡‹â‡Œâ‡â‡Žâ‡â‡â‡’â‡”â‡šâ‡›â‡œâ‡â‡ â‡¢â‡´â‡µâ‡¶â‡·â‡¸â‡¹â‡ºâ‡»â‡¼â‡½â‡¾â‡¿âˆˆâˆ‰âˆŠâˆ‹âˆŒâˆâˆ“âˆ”âˆ—âˆ˜âˆ™âˆšâˆ›âˆœâˆâˆ¤âˆ¥âˆ¦âˆ§âˆ¨âˆ©âˆªâˆ·âˆ¸âˆºâˆ»âˆ½âˆ¾â‰€â‰â‰‚â‰ƒâ‰„â‰…â‰†â‰‡â‰ˆâ‰‰â‰Šâ‰‹â‰Œâ‰â‰Žâ‰â‰â‰‘â‰’â‰“â‰”â‰•â‰–â‰—â‰˜â‰™â‰šâ‰›â‰œâ‰â‰žâ‰Ÿâ‰ â‰¡â‰¢â‰£â‰¤â‰¥â‰¦â‰§â‰¨â‰©â‰ªâ‰«â‰¬â‰­â‰®â‰¯â‰°â‰±â‰²â‰³â‰´â‰µâ‰¶â‰·â‰¸â‰¹â‰ºâ‰»â‰¼â‰½â‰¾â‰¿âŠ€âŠâŠ‚âŠƒâŠ„âŠ…âŠ†âŠ‡âŠˆâŠ‰âŠŠâŠ‹âŠâŠŽâŠâŠâŠ‘âŠ’âŠ“âŠ”âŠ•âŠ–âŠ—âŠ˜âŠ™âŠšâŠ›âŠœâŠžâŠŸâŠ âŠ¡âŠ¢âŠ£âŠ©âŠ¬âŠ®âŠ°âŠ±âŠ²âŠ³âŠ´âŠµâŠ¶âŠ·âŠ»âŠ¼âŠ½â‹„â‹…â‹†â‹‡â‹‰â‹Šâ‹‹â‹Œâ‹â‹Žâ‹â‹â‹‘â‹’â‹“â‹•â‹–â‹—â‹˜â‹™â‹šâ‹›â‹œâ‹â‹žâ‹Ÿâ‹ â‹¡â‹¢â‹£â‹¤â‹¥â‹¦â‹§â‹¨â‹©â‹ªâ‹«â‹¬â‹­â‹®â‹¯â‹°â‹±â‹²â‹³â‹´â‹µâ‹¶â‹·â‹¸â‹¹â‹ºâ‹»â‹¼â‹½â‹¾â‹¿âŒ¿â–·âŸ‚âŸˆâŸ‰âŸ‘âŸ’âŸ•âŸ–âŸ—âŸ°âŸ±âŸµâŸ¶âŸ·âŸ¹âŸºâŸ»âŸ¼âŸ½âŸ¾âŸ¿â¤€â¤â¤‚â¤ƒâ¤„â¤…â¤†â¤‡â¤ˆâ¤‰â¤Šâ¤‹â¤Œâ¤â¤Žâ¤â¤â¤‘â¤’â¤“â¤”â¤•â¤–â¤—â¤˜â¤â¤žâ¤Ÿâ¤ â¥„â¥…â¥†â¥‡â¥ˆâ¥‰â¥Šâ¥‹â¥Œâ¥â¥Žâ¥â¥â¥‘â¥’â¥“â¥”â¥•â¥–â¥—â¥˜â¥™â¥šâ¥›â¥œâ¥â¥žâ¥Ÿâ¥ â¥¡â¥¢â¥£â¥¤â¥¥â¥¦â¥§â¥¨â¥©â¥ªâ¥«â¥¬â¥­â¥®â¥¯â¥°â¦·â¦¸â¦¼â¦¾â¦¿â§€â§â§¡â§£â§¤â§¥â§´â§¶â§·â§ºâ§»â¨‡â¨ˆâ¨â¨Ÿâ¨¢â¨£â¨¤â¨¥â¨¦â¨§â¨¨â¨©â¨ªâ¨«â¨¬â¨­â¨®â¨°â¨±â¨²â¨³â¨´â¨µâ¨¶â¨·â¨¸â¨¹â¨ºâ¨»â¨¼â¨½â©€â©â©‚â©ƒâ©„â©…â©Šâ©‹â©Œâ©â©Žâ©â©â©‘â©’â©“â©”â©•â©–â©—â©˜â©šâ©›â©œâ©â©žâ©Ÿâ© â©¡â©¢â©£â©¦â©§â©ªâ©«â©¬â©­â©®â©¯â©°â©±â©²â©³â©´â©µâ©¶â©·â©¸â©¹â©ºâ©»â©¼â©½â©¾â©¿âª€âªâª‚âªƒâª„âª…âª†âª‡âªˆâª‰âªŠâª‹âªŒâªâªŽâªâªâª‘âª’âª“âª”âª•âª–âª—âª˜âª™âªšâª›âªœâªâªžâªŸâª âª¡âª¢âª£âª¤âª¥âª¦âª§âª¨âª©âªªâª«âª¬âª­âª®âª¯âª°âª±âª²âª³âª´âªµâª¶âª·âª¸âª¹âªºâª»âª¼âª½âª¾âª¿â«€â«â«‚â«ƒâ«„â«…â«†â«‡â«ˆâ«‰â«Šâ«‹â«Œâ«â«Žâ«â«â«‘â«’â«“â«”â«•â«–â«—â«˜â«™â«›â«·â«¸â«¹â«ºâ¬°â¬±â¬²â¬³â¬´â¬µâ¬¶â¬·â¬¸â¬¹â¬ºâ¬»â¬¼â¬½â¬¾â¬¿â­€â­â­‚â­ƒâ­„â­‡â­ˆâ­‰â­Šâ­‹â­Œï¿©ï¿ªï¿«ï¿¬'
let s:op_chars_wc = '\U2026\U205D\U214B\U2190-\U2194\U219A-\U219E\U21A0\U21A2-\U21A4\U21A6\U21A9-\U21AC\U21AE\U21B6\U21B7\U21BA-\U21BD\U21C0\U21C1\U21C4\U21C6\U21C7\U21C9\U21CB-\U21D0\U21D2\U21D4\U21DA-\U21DD\U21E0\U21E2\U21F4-\U21FF\U2208-\U220D\U2213\U2214\U2217-\U221D\U2224-\U222A\U2237\U2238\U223A\U223B\U223D\U223E\U2240-\U228B\U228D-\U229C\U229E-\U22A3\U22A9\U22AC\U22AE\U22B0-\U22B7\U22BB-\U22BD\U22C4-\U22C7\U22C9-\U22D3\U22D5-\U22FF\U233F\U25B7\U27C2\U27C8\U27C9\U27D1\U27D2\U27D5-\U27D7\U27F0\U27F1\U27F5-\U27F7\U27F9-\U27FF\U2900-\U2918\U291D-\U2920\U2944-\U2970\U29B7\U29B8\U29BC\U29BE-\U29C1\U29E1\U29E3-\U29E5\U29F4\U29F6\U29F7\U29FA\U29FB\U2A07\U2A08\U2A1D\U2A1F\U2A22-\U2A2E\U2A30-\U2A3D\U2A40-\U2A45\U2A4A-\U2A58\U2A5A-\U2A63\U2A66\U2A67\U2A6A-\U2AD9\U2ADB\U2AF7-\U2AFA\U2B30-\U2B44\U2B47-\U2B4C\UFFE9-\UFFEC'

" Full operators regex
let s:operators = '\%(' . '\.\%([-+*/^Ã·%|&âŠ»]\|//\|\\\|>>\|>>>\?\)\?=' .
      \           '\|'  . '[:<>]=\|||\|&&\||>\|<|\|[<>:]:\|<<\|>>>\?\|//\|[-=]>\|\.\.\.\?' .
      \           '\|'  . '\.\?[!' . s:op_chars . s:op_chars_wc . ']' .
      \           '\)'


" Characters that can be used to start an identifier. Above \UBF we don't
" bother checking. (If a UTF8 operator is used, it will take precedence anyway.)
let s:id_charsH = '\%([A-Za-z_\UA2-\UA6\UA9\UAA\UAE\UB0\UB5\UBA]\|[^\U00-\UBF]\)'
" Characters that can appear in an identifier, starting in 2nd position. Above
" \UBF we check for operators since we need to stop the identifier if one
" appears. We don't check for invalid characters though.
let s:id_charsW = '\%([0-9A-Za-z_!\UA2-\UA6\UA9\UAA\UAE-\UB0\UB2-\UB5\UB8-\UBA\UBC-\UBE]\|[^\U00-\UBF]\@=[^' . s:op_chars_wc . ']\)'

" A valid julia identifier, more or less
let s:idregex = '\%(' . s:id_charsH . s:id_charsW . '*\)'



syn case match

syntax cluster juliaExpressions		contains=@juliaParItems,@juliaStringItems,@juliaKeywordItems,@juliaBlocksItems,@juliaTypesItems,@juliaConstItems,@juliaMacroItems,@juliaSymbolItems,@juliaOperatorItems,@juliaNumberItems,@juliaCommentItems,@juliaErrorItems,@juliaSyntaxRegions
syntax cluster juliaExprsPrintf		contains=@juliaExpressions,@juliaPrintfItems
syntax cluster juliaExprsNodot		contains=@juliaParItems,@juliaStringItems,@juliaMacroItems,@juliaSymbolItems,@juliaOperatorItems,@juliaCommentItems,juliaIdSymbol

syntax cluster juliaParItems		contains=juliaParBlock,juliaSqBraIdxBlock,juliaSqBraBlock,juliaCurBraBlock,juliaQuotedParBlock,juliaQuotedQMarkPar
syntax cluster juliaKeywordItems	contains=juliaKeyword,juliaWhereKeyword,juliaImportLine,juliaInfixKeyword,juliaRepKeyword
syntax cluster juliaBlocksItems		contains=juliaConditionalBlock,juliaWhileBlock,juliaForBlock,juliaBeginBlock,juliaFunctionBlock,juliaMacroBlock,juliaQuoteBlock,juliaTypeBlock,juliaImmutableBlock,juliaExceptionBlock,juliaLetBlock,juliaDoBlock,juliaModuleBlock,juliaStructBlock,juliaMutableStructBlock,juliaAbstractBlock,juliaPrimitiveBlock
syntax cluster juliaTypesItems		contains=juliaBaseTypeBasic,juliaBaseTypeNum,juliaBaseTypeC,juliaBaseTypeError,juliaBaseTypeIter,juliaBaseTypeString,juliaBaseTypeArray,juliaBaseTypeDict,juliaBaseTypeSet,juliaBaseTypeIO,juliaBaseTypeProcess,juliaBaseTypeRange,juliaBaseTypeRegex,juliaBaseTypeFact,juliaBaseTypeFact,juliaBaseTypeSort,juliaBaseTypeRound,juliaBaseTypeSpecial,juliaBaseTypeRandom,juliaBaseTypeDisplay,juliaBaseTypeTime,juliaBaseTypeOther

syntax cluster juliaConstItems  	contains=juliaConstNum,juliaConstBool,juliaConstEnv,juliaConstMMap,juliaConstC,juliaConstGeneric,juliaConstIO,juliaPossibleEuler

syntax cluster juliaMacroItems		contains=juliaPossibleMacro,juliaDollarVar,juliaDollarPar,juliaDollarSqBra
syntax cluster juliaSymbolItems		contains=juliaPossibleSymbol
syntax cluster juliaNumberItems		contains=juliaNumbers
syntax cluster juliaStringItems		contains=juliaChar,juliaString,juliabString,juliasString,juliaShellString,juliaDocString,juliaRegEx
syntax cluster juliaPrintfItems		contains=juliaPrintfParBlock,juliaPrintfString
syntax cluster juliaOperatorItems	contains=juliaOperator,juliaRangeOperator,juliaCTransOperator,juliaTernaryRegion,juliaColon,juliaSemicolon,juliaComma
syntax cluster juliaCommentItems	contains=juliaCommentL,juliaCommentM
syntax cluster juliaErrorItems		contains=juliaErrorPar,juliaErrorEnd,juliaErrorElse,juliaErrorCatch,juliaErrorFinally

syntax cluster juliaSyntaxRegions	contains=juliaIdSymbol,juliaTypeOperatorR2,juliaTypeOperatorR3,juliaWhereR,juliaDotted

syntax cluster juliaSpellcheckStrings		contains=@spell
syntax cluster juliaSpellcheckDocStrings	contains=@spell
syntax cluster juliaSpellcheckComments		contains=@spell

if !s:julia_spellcheck_docstrings
  syntax cluster juliaSpellcheckDocStrings	remove=@spell
endif
if !s:julia_spellcheck_strings
  syntax cluster juliaSpellcheckStrings		remove=@spell
endif
if !s:julia_spellcheck_comments
  syntax cluster juliaSpellcheckComments	remove=@spell
endif

syntax match   juliaSemicolon		display ";"
syntax match   juliaComma		display ","
syntax match   juliaColon		display ":"

" A dot can introduce a sort of 'environment' such that words after it are not
" recognized as keywords. This has low precedence so that it can be overridden
" by operators
syntax match   juliaDotted		transparent "\.\s*[^])}.]" contains=@juliaExprsNodot
syntax match   juliaDottedT		contained transparent "\.\s*[^])}.]" contains=@juliaExprsNodot,juliaType

syntax match   juliaErrorPar		display "[])}]"
syntax match   juliaErrorEnd		display "\<end\>"
syntax match   juliaErrorElse		display "\<\%(else\|elseif\)\>"
syntax match   juliaErrorCatch		display "\<catch\>"
syntax match   juliaErrorFinally	display "\<finally\>"
syntax match   juliaErrorSemicol	display contained ";"

syntax region  juliaParBlock		matchgroup=juliaParDelim start="(" end=")" contains=@juliaExpressions,juliaComprehensionFor
syntax region  juliaParBlockInRange	matchgroup=juliaParDelim contained start="(" end=")" contains=@juliaExpressions,juliaParBlockInRange,juliaRangeKeyword,juliaComprehensionFor
syntax region  juliaSqBraIdxBlock	matchgroup=juliaParDelim start="\[" end="\]" contains=@juliaExpressions,juliaParBlockInRange,juliaRangeKeyword,juliaComprehensionFor,juliaSymbolS,juliaQuotedParBlockS,juliaQuotedQMarkParS
exec 'syntax region  juliaSqBraBlock	matchgroup=juliaParDelim start="\%(^\|\s\|' . s:operators . '\)\@'.s:d(3).'<=\[" end="\]" contains=@juliaExpressions,juliaComprehensionFor,juliaSymbolS,juliaQuotedParBlockS,juliaQuotedQMarkParS'
syntax region  juliaCurBraBlock		matchgroup=juliaParDelim start="{" end="}" contains=juliaType,juliaDottedT,@juliaExpressions

exec 'syntax match   juliaType		contained "\%(' . s:idregex . '\.\)*\zs' . s:idregex . '"'

" This is a generic identifier followed by some symbol, either a type
" operator (<: or >:), or an open parenthesis, or an open curly bracket.
" It's used to recognize one of the contained regions looking for identifiers
" only once. Once recognized, those regions no longer need to use the
" expensive s:idregex.
exec 'syntax match   juliaIdSymbol	transparent "' . s:idregex . '\%(\s*[<>]:\|\.\?(\|{\|\"\)\@=" contains=juliaFunctionCall,juliaParamType,juliaStringPrefixed,juliaTypeOperatorR1'

syntax match  juliaFunctionCall		contained "[^{([:space:]<>\"]\+(\@=" nextgroup=juliaParBlock

exec 'syntax match   juliaFunctionDef	contained transparent "\%(\<\%(function\|macro\)\)\@'.s:d(8).'<=\s\+\zs' . s:idregex . '\%(\.' . s:idregex . '\)*\ze\s*\%((\|\send\>\|$\)" contains=juliaFunctionName'
exec 'syntax match   juliaFunctionName	contained "\%(\<\%(function\|macro\)\s\+\)\@'.s:d(20).'<=\%(' . s:idregex . '\.\)*\zs' . s:idregex . '"'

exec 'syntax match   juliaStructR	contained transparent "\%(\<\%(\%(mutable\s\+\)\?struct\|\%(abstract\|primitive\)\s\+type\)\s\+\)\@'.s:d(20).'<=\%(' . s:idregex . '\.\)*' . s:idregex . '\>\(\s*(\)\@!" contains=juliaType'

syntax match   juliaKeyword		display "\<\%(return\|local\|global\|const\)\>"
syntax match   juliaInfixKeyword	display "\%(=\s*\)\@<!\<\%(in\|isa\)\>\S\@!\%(\s*=\)\@!"

" The import/export/using keywords introduce a sort of special parsing
" environment with its own rules
exec 'syntax region  juliaImportLine		matchgroup=juliaKeyword excludenl start="\<\%(import\|using\|export\)\>" skip="\%(\%(\<\%(import\|using\|export\)\>\)\|^\)\@'.s:d(6).'<=$" end="$" end="\%([])}]\)\@=" contains=@juliaExpressions,juliaAsKeyword,@juliaContinuationItems,juliaMacroName'
syntax match   juliI‰  J‰  K‰  L‰  M‰  N‰  O‰  P‰  Q‰  R‰  S‰  T‰  U‰  V‰  W‰  X‰  Y‰  Z‰  [‰  \‰  ]‰  ^‰  _‰  `‰  a‰  b‰                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          aAsKeyword		display contained "\<as\>"

syntax match   juliaRepKeyword		display "\<\%(break\|continue\)\>"
syntax region  juliaConditionalBlock	matchgroup=juliaConditional start="\<if\>" end="\<end\>" contains=@juliaExpressions,juliaConditionalEIBlock,juliaConditionalEBlock fold
syntax region  juliaConditionalEIBlock	matchgroup=juliaConditional transparent contained start="\<elseif\>" end="\<\%(end\|else\|elseif\)\>"me=s-1 contains=@juliaExpressions,juliaConditionalEIBlock,juliaConditionalEBlock
syntax region  juliaConditionalEBlock	matchgroup=juliaConditional transparent contained start="\<else\>" end="\<end\>"me=s-1 contains=@juliaExpressions
syntax region  juliaWhileBlock		matchgroup=juliaRepeat start="\<while\>" end="\<end\>" contains=@juliaExpressions fold
syntax region  juliaForBlock		matchgroup=juliaRepeat start="\<for\>" end="\<end\>" contains=@juliaExpressions,juliaOuter fold
syntax region  juliaBeginBlock		matchgroup=juliaBlKeyword start="\<begin\>" end="\<end\>" contains=@juliaExpressions fold
syntax region  juliaFunctionBlock	matchgroup=juliaBlKeyword start="\<function\>" end="\<end\>" contains=@juliaExpressions,juliaFunctionDef fold
syntax region  juliaMacroBlock		matchgroup=juliaBlKeyword start="\<macro\>" end="\<end\>" contains=@juliaExpressions,juliaFunctionDef fold
syntax region  juliaQuoteBlock		matchgroup=juliaBlKeyword start="\<quote\>" end="\<end\>" contains=@juliaExpressions fold
syntax region  juliaStructBlock		matchgroup=juliaBlKeyword start="\<struct\>" end="\<end\>" contains=@juliaExpressions,juliaStructR fold
syntax region  juliaMutableStructBlock	matchgroup=juliaBlKeyword start="\<mutable\s\+struct\>" end="\<end\>" contains=@juliaExpressions,juliaStructR fold
syntax region  juliaLetBlock		matchgroup=juliaBlKeyword start="\<let\>" end="\<end\>" contains=@juliaExpressions fold
syntax region  juliaDoBlock		matchgroup=juliaBlKeyword start="\<do\>" end="\<end\>" contains=@juliaExpressions fold
syntax region  juliaModuleBlock		matchgroup=juliaBlKeyword start="\<\%(bare\)\?module\>" end="\<end\>" contains=@juliaExpressions fold
syntax region  juliaExceptionBlock	matchgroup=juliaException start="\<try\>" end="\<end\>" contains=@juliaExpressions,juliaCatchBlock,juliaFinallyBlock fold
syntax region  juliaCatchBlock		matchgroup=juliaException transparent contained start="\<catch\>" end="\<end\>"me=s-1 contains=@juliaExpressions,juliaFinallyBlock
syntax region  juliaFinallyBlock	matchgroup=juliaException transparent contained start="\<finally\>" end="\<end\>"me=s-1 contains=@juliaExpressions
syntax region  juliaAbstractBlock	matchgroup=juliaBlKeyword start="\<abstract\s\+type\>" end="\<end\>" fold contains=@juliaExpressions,juliaStructR
syntax region  juliaPrimitiveBlock	matchgroup=juliaBlKeyword start="\<primitive\s\+type\>" end="\<end\>" fold contains=@juliaExpressions,juliaStructR

exec 'syntax region  juliaComprehensionFor	matchgroup=juliaComprehensionFor transparent contained start="\%([^[:space:],;:({[]\_s*\)\@'.s:d(80).'<=\<for\>" end="\ze[]);]" contains=@juliaExpressions,juliaComprehensionIf,juliaComprehensionFor'
syntax match   juliaComprehensionIf	contained "\<if\>"

exec 'syntax match   juliaOuter		contained "\<outer\ze\s\+' . s:idregex . '\>"'

syntax match   juliaRangeKeyword	contained "\<\%(begin\|end\)\>"

syntax match   juliaBaseTypeBasic	display "\<\%(\%(N\|Named\)\?Tuple\|Symbol\|Function\|Union\%(All\)\?\|Type\%(Name\|Var\)\?\|Any\|ANY\|Vararg\|Ptr\|Exception\|Module\|Expr\|DataType\|\%(LineNumber\|Quote\)Node\|\%(Weak\|Global\)\?Ref\|Method\|Pair\|Val\|Nothing\|Some\|Missing\)\>"
syntax match   juliaBaseTypeNum		display "\<\%(U\?Int\%(8\|16\|32\|64\|128\)\?\|Float\%(16\|32\|64\)\|Complex\|Bool\|Char\|Number\|Signed\|Unsigned\|Integer\|AbstractFloat\|Real\|Rational\|\%(Abstract\)\?Irrational\|Enum\|BigInt\|BigFloat\|MathConst\|ComplexF\%(16\|32\|64\)\)\>"
syntax match   juliaBaseTypeC		display "\<\%(FileOffset\|C\%(u\?\%(char\|short\|int\|long\(long\)\?\|w\?string\)\|float\|double\|\%(ptrdiff\|s\?size\|wchar\|off\|u\?intmax\)_t\|void\)\)\>"
syntax match   juliaBaseTypeError	display "\<\%(\%(Bounds\|Divide\|Domain\|\%(Stack\)\?Overflow\|EOF\|Undef\%(Ref\|Var\)\|System\|Type\|Parse\|Argument\|Key\|Load\|Method\|Inexact\|OutOfMemory\|Init\|Assertion\|ReadOnlyMemory\|StringIndex\)Error\|\%(Interrupt\|Error\|ProcessExited\|Captured\|Composite\|InvalidState\|Missing\|\%(Process\|Task\)Failed\)Exception\|DimensionMismatch\|SegmentationFault\)\>"
syntax match   juliaBaseTypeIter	display "\<\%(EachLine\|Enumerate\|Cartesian\%(Index\|Range\)\|LinSpace\|CartesianIndices\)\>"
syntax match   juliaBaseTypeString	display "\<\%(DirectIndex\|Sub\|Rep\|Rev\|Abstract\|Substitution\)\?String\>"
syntax match   juliaBaseTypeArray	display "\<\%(\%(Sub\)\?Array\|\%(Abstract\|Dense\|Strided\)\?\%(Array\|Matrix\|Vec\%(tor\|OrMat\)\)\|SparseMatrixCSC\|\%(AbstractSparse\|Bit\|Shared\)\%(Array\|Vector\|Matrix\)\|\%\(D\|Bid\|\%(Sym\)\?Trid\)iagonal\|Hermitian\|Symmetric\|UniformScaling\|\%(Lower\|Upper\)Triangular\|\%(Sparse\|Row\)Vector\|VecElement\|Conj\%(Array\|Matrix\|Vector\)\|Index\%(Cartesian\|Linear\|Style\)\|PermutedDimsArray\|Broadcasted\|Adjoint\|Transpose\|LinearIndices\)\>"
syntax match   juliaBaseTypeDict	display "\<\%(WeakKey\|Id\|Abstract\)\?Dict\>"
syntax match   juliaBaseTypeSet		display "\<\%(\%(Abstract\|Bit\)\?Set\)\>"
syntax match   juliaBaseTypeIO		display "\<\%(IO\%(Stream\|Buffer\|Context\)\?\|RawFD\|StatStruct\|FileMonitor\|PollingFileWatcher\|Timer\|Base64\%(Decode\|Encode\)Pipe\|\%(UDP\|TCP\)Socket\|\%(Abstract\)\?Channel\|BufferStream\|ReentrantLock\|GenericIOBuffer\)\>"
syntax match   juliaBaseTypeProcess	display "\<\%(Pipe\|Cmd\|PipeBuffer\)\>"
syntax match   juliaBaseTypeRange	display "\<\%(Dims\|RangeIndex\|\%(Abstract\|Lin\|Ordinal\|Step\|\%(Abstract\)\?Unit\)Range\|Colon\|ExponentialBackOff\|StepRangeLen\)\>"
syntax match   juliaBaseTypeRegex	display "\<Regex\%(Match\)\?\>"
syntax match   juliaBaseTypeFact	display "\<\%(Factorization\|BunchKaufman\|\%(Cholesky\|QR\)\%(Pivoted\)\?\|\%(Generalized\)\?\%(Eigen\|SVD\|Schur\)\|Hessenberg\|LDLt\|LQ\|LU\)\>"
syntax match   juliaBaseTypeSort	display "\<\%(Insertion\|\(Partial\)\?Quick\|Merge\)Sort\>"
syntax match   juliaBaseTypeRound	display "\<Round\%(ingMode\|FromZero\|Down\|Nearest\%(Ties\%(Away\|Up\)\)\?\|ToZero\|Up\)\>"
syntax match   juliaBaseTypeSpecial	display "\<\%(LocalProcess\|ClusterManager\)\>"
syntax match   juliaBaseTypeRandom	display "\<\%(AbstractRNG\|MersenneTwister\|RandomDevice\)\>"
syntax match   juliaBaseTypeDisplay	display "\<\%(Text\(Display\)\?\|\%(Abstract\)\?Display\|MIME\|HTML\)\>"
syntax match   juliaBaseTypeTime	display "\<\%(Date\%(Time\)\?\|DateFormat\)\>"
syntax match   juliaBaseTypeOther	display "\<\%(RemoteRef\|Task\|Condition\|VersionNumber\|IPv[46]\|SerializationState\|WorkerConfig\|Future\|RemoteChannel\|IPAddr\|Stack\%(Trace\|Frame\)\|\(Caching\|Worker\)Pool\|AbstractSerializer\)\>"

syntax match   juliaConstNum		display "\%(\<\%(\%(NaN\|Inf\)\%(16\|32\|64\)\?\|pi\|Ï€\)\>\)"
" Note: recognition of â„¯, which Vim does not consider a valid identifier, is
" complicated. We detect possible uses by just looking for the character (for
" performance) and then check that it's actually used by its own.
" (This also tries to detect preceding number constants; it does so in a crude
" way.)
syntax match   juliaPossibleEuler	"â„¯" contains=juliaEuler
exec 'syntax match   juliaEuler		contained "\%(\%(^\|[' . s:nonidS_chars . s:op_chars_wc . ']\)\%(.\?[0-9][.0-9eEf_]*\d\)\?\)\@'.s:d(80).'<=â„¯\ze[' . s:nonidS_chars . s:op_chars_wc . ']"'
syntax match   juliaConstBool		display "\<\%(true\|false\)\>"
syntax match   juliaConstEnv		display "\<\%(ARGS\|ENV\|ENDIAN_BOM\|LOAD_PATH\|VERSION\|PROGRAM_FILE\|DEPOT_PATH\)\>"
syntax match   juliaConstIO		display "\<\%(std\%(out\|in\|err\)\|devnull\)\>"
syntax match   juliaConstC		display "\<\%(C_NULL\)\>"
syntax match   juliaConstGeneric	display "\<\%(nothing\|Main\|undef\|missing\)\>"

syntax match   juliaParamType		contained "[^{([:space:]<>\"]\+\ze{" nextgroup=juliaCurBraBlock

syntax match   juliaPossibleMacro	transparent "@" contains=juliaMacroCall,juliaMacroCallP,juliaPrintfMacro,juliaDocMacro,juliaDocMacroPre

exec 'syntax match   juliaMacro		contained "@' . s:idregex . '\%(\.' . s:idregex . '\)*"'
syntax match   juliaMacro		contained "@[!.~$%^*/\\|<>+-]\ze[^0-9]"
exec 'syntax region  juliaMacroCall	contained transparent start="\(@' . s:idregex . '\%(\.' . s:idregex . '\)*\)\@=\1\%([^(]\|$\)" end="\ze\%([])};#]\|$\|\<for\>\|\<end\>\)" contains=@juliaExpressions,juliaMacro,juliaSymbolS,juliaQuotedParBlockS'
exec 'syntax region  juliaMacroCall	contained transparent start="\(@.\)\@=\1\%([^(]\|$\)" end="\ze\%([])};#]\|$\|\<for\>\|\<end\>\)" contains=@juliaExpressions,juliaMacro,juliaSymbolS,juliaQuotedParBlockS'
exec 'syntax region  juliaMacroCallP	contained transparent start="@' . s:idregex . '\%(\.' . s:idregex . '\)*(" end=")\@'.s:d(1).'<=" contains=juliaMacro,juliaParBlock'
exec 'syntax region  juliaMacroCallP	contained transparent start="@.(" end=")\@'.s:d(1).'<=" contains=juliaMacro,juliaParBlock'

exec 'syntax match   juliaNumbers	transparent "\%(^\|[' . s:nonidS_chars . s:op_chars_wc . ']\)\@'.s:d(1).'<=\d\|\.\d\|im\>" contains=juliaNumber,juliaFloat,juliaComplexUnit'

"integer regexes
let s:dec_regex = '\d\%(_\?\d\)*\%(\>\|im\>\|\ze\D\)'
let s:hex_regex = '0x\x\%(_\?\x\)*\%(\>\|im\>\|\ze\X\)'
let s:bin_regex = '0b[01]\%(_\?[01]\)*\%(\>\|im\>\|\ze[^01]\)'
let s:oct_regex = '0o\o\%(_\?\o\)*\%(\>\|im\>\|\ze\O\)'

let s:int_regex = '\%(' . s:hex_regex .
      \           '\|'  . s:bin_regex .
      \           '\|'  . s:oct_regex .
      \           '\|'  . s:dec_regex .
      \           '\)'

"floating point regexes
"  starting with a dot, optional exponent
let s:float_regex1 = '\.\d\%(_\?\d\)*\%([eEf][-+]\?\d\+\)\?\%(\>\|im\>\|\ze\D\)'
"  with dot, optional exponent
let s:float_regex2 = '\d\%(_\?\d\)*\.\%(\d\%(_\?\d\)*\)\?\%([eEf][-+]\?\d\+\)\?\%(\>\|im\>\|\ze\D\)'
"  without dot, with exponent
let s:float_regex3 = '\d\%(_\?\d\)*[eEf][-+]\?\d\+\%(\>\|im\>\|\ze\D\)'

"hex floating point numbers
"  starting with a dot
let s:hexfloat_regex1 = '0x\.\%\(\x\%(_\?\x\)*\)\?[pP][-+]\?\d\+\%(\>\|im\>\|\ze\X\)'
"  starting with a digit
let s:hexfloat_regex2 = '0x\x\%(_\?\x\)*\%\(\.\%\(\x\%(_\?\x\)*\)\?\)\?[pP][-+]\?\d\+\%(\>\|im\>\|\ze\X\)'

let s:float_regex = '\%(' . s:float_regex3 .
      \             '\|'  . s:float_regex2 .
      \             '\|'  . s:float_regex1 .
      \             '\|'  . s:hexfloat_regex2 .
      \             '\|'  . s:hexfloat_regex1 .
      \             '\)'

exec 'syntax match   juliaNumber	contained "' . s:int_regex . '" contains=juliaComplexUnit'
exec 'syntax match   juliaFloat		contained "' . s:float_regex . '" contains=juliaComplexUnit'
syntax match   juliaComplexUnit		display	contained "\<im\>"

syntax match   juliaRangeOperator	display ":"
exec 'syntax match   juliaOperator	"' . s:operators . '"'

exec 'syntax region  juliaTernaryRegion	matchgroup=juliaTernaryOperator start="\s\zs?\ze\s" skip="\%(:\(:\|[^:[:space:]'."'".'"({[]\+\s*\ze:\)\|\%(?\s*\)\@'.s:d(6).'<=:(\)" end=":" contains=@juliaExpressions,juliaErrorSemicol'

let s:interp_dollar = '\([' . s:nonidS_chars . s:op_chars_wc . '!]\|^\)\@'.s:d(1).'<=\$'

exec 'syntax match   juliaDollarVar	display contained "' . s:interp_dollar . s:idregex . '"'
exec 'syntax region  juliaDollarPar	matchgroup=juliaDollarVar contained start="' .s:interp_dollar . '(" end=")" contains=@juliaExpressions'
exec 'syntax region  juliaDollarSqBra	matchgroup=juliaDollarVar contained start="' .s:interp_dollar . '\[" end="\]" contains=@juliaExpressions,juliaComprehensionFor,juliaSymbolS,juliaQuotedParBlockS'

syntax match   juliaChar		"'\\\?.'" contains=juliaSpecialChar
syntax match   juliaChar		display "'\\\o\{3\}'" contains=juliaOctalEscapeChar
syntax match   juliaChar		display "'\\x\x\{2\}'" contains=juliaHexEscapeChar
syntax match   juliaChar		display "'\\u\x\{1,4\}'" contains=juliaUniCharSmall
syntax match   juliaChar		display "'\\U\x\{1,8\}'" contains=juliaUniCharLarge

exec 'syntax match   juliaCTransOperator	"[[:space:]}' . s:nonid_chars . s:op_chars_wc . '!]\@'.s:d(1).'<!\.\?' . "'" . 'áµ€\?"'

" TODO: some of these might be specialized; the rest could be just left to the
"       generic juliaStringPrefixed fallback
syntax region  juliaString		matchgroup=juliaStringDelim start=+\z("\(""\)\?\)+ skip=+\%(\\\\\)*\\"+ end=+\z1+ contains=@juliaStringVars,@juliaSpecialChars,@juliaSpellcheckStrings
syntax region  juliaStringPrefixed	contained matchgroup=juliaStringDelim start=+[^{([:space:]<>"]\+\z("\(""\)\?\)+ skip=+\%(\\\\\)*\\"+ end=+\z1+ contains=@juliaSpecialCharsRaw
syntax region  juliabString		matchgroup=juliaStringDelim start=+\<b\z("\(""\)\?\)+ skip=+\%(\\\\\)*\\"+ end=+\z1+ contains=@juliaSpecialChars
syntax region  juliasString		matchgroup=juliaStringDelim start=+\<s\z("\(""\)\?\)+ skip=+\%(\\\\\)*\\"+ end=+\z1+ contains=@juliaSpecialChars

syntax region  juliaDocString		matchgroup=juliaDocStringDelim fold start=+^"""+ skip=+\%(\\\\\)*\\"+ end=+"""+ contains=@juliaStringVars,@juliaSpecialChars,@juliaSpellcheckDocStrings

exec 'syntax region  juliaPrintfMacro		contained transparent start="@s\?printf(" end=")\@'.s:d(1).'<=" contains=juliaMacro,juliaPrintfParBlock'
syntax region  juliaPrintfMacro		contained transparent start="@s\?printf\s\+" end="\ze\%([])};#]\|$\|\<for\>\)" contains=@juliaExprsPrintf,juliaMacro,juliaSymbolS,juliaQuotedParBlockS
syntax region  juliaPrintfParBlock	contained matchgroup=juliaParDelim start="(" end=")" contains=@juliaExprsPrintf
syntax region  juliaPrintfString	contained matchgroup=juliaStringDelim start=+"+ skip=+\%(\\\\\)*\\"+ end=+"+ contains=@juliaSpecialChars,@juliaPrintfChars

exec 'syntax region  juliaDocMacroPre	contained transparent start=+@doc\s\+\%(' . s:idregex . '\%(\.' . s:idregex . '\)*\)\z("\%(""\)\?\)+ skip=+\%(\\\\\)*\\"+ end=+\(\z1\)\@'.s:d(3).'<=+ contains=juliaMacro,juliaDocStringMRaw'
exec 'syntax region  juliaDocMacro	contained transparent start=+@doc\s\+\z("\%(""\)\?\)+ skip=+\%(\\\\\)*\\"+ end=+\(\z1\)\@'.s:d(3).'<=+ contains=juliaMacro,juliaDocStringM'
syntax region  juliaDocStringMRaw	contained fold matchgroup=juliaDocStringDelim fold start=+\z\("\(""\)\?\)+ skip=+\%(\\\\\)*\\"+ end=+\z1+ contains=@juliaSpellcheckDocStrings
syntax region  juliaDocStringM		contained fold matchgroup=juliaDocStringDelim fold start=+\z\("\(""\)\?\)+ skip=+\%(\\\\\)*\\"+ end=+\z1+ contains=@juliaStringVars,@juliaSpecialChars,@juliaSpellcheckDocStrings

syntax region  juliaShellString		matchgroup=juliaStringDelim start=+`+ skip=+\%(\\\\\)*\\`+ end=+`+ contains=@juliaStringVars,juliaSpecialChar

syntax cluster juliaStringVars		contains=juliaStringVarsPar,juliaStringVarsSqBra,juliaStringVarsCurBra,juliaStringVarsPla
syntax region  juliaStringVarsPar	contained matchgroup=juliaStringVarDelim start="$(" end=")" contains=@juliaExpressions
syntax region  juliaStringVarsSqBra	contained matchgroup=juliaStringVarDelim start="$\[" end="\]" contains=@juliaExpressions,juliaComprehensionFor,juliaSymbolS,juliaQuotedParBlockS
syntax region  juliaStringVarsCurBra	contained matchgroup=juliaStringVarDelim start="${" end="}" contains=@juliaExpressions
exec 'syntax match   juliaStringVarsPla	contained "\$' . s:idregex . '"'

" TODO improve RegEx
syntax region  juliaRegEx		matchgroup=juliaStringDelim start=+\<r\z("\(""\)\?\)+ skip=+\%(\\\\\)*\\"+ end=+\z1[imsx]*+

syntax cluster juliaSpecialChars	contains=juliaSpecialChar,juliaDoubleBackslash,juliaEscapedQuote,juliaOctalEscapeChar,juliaHexEscapeChar,juliaUniCharSmall,juliaUniCharLarge
syntax match   juliaSpecialChar		display contained "\\."
syntax match   juliaOctalEscapeChar	display contained "\\\o\{3\}"
syntax match   juliaHexEscapeChar	display contained "\\x\x\{2\}"
syntax match   juliaUniCharSmall	display contained "\\u\x\{1,4\}"
syntax match   juliaUniCharLarge	display contained "\\U\x\{1,8\}"
syntax cluster juliaSpecialCharsRaw	contains=juliaDoubleBackslash,juliaEscapedQuote
syntax match   juliaDoubleBackslash	contained "\\\\"
syntax match   juliaEscapedQuote	contained "\\\""

syntax cluster juliaPrintfChars		contains=juliaErrorPrintfFmt,juliaPrintfFmt
syntax match   juliaErrorPrintfFmt	display contained "\\\?%."
syntax match   juliaPrintfFmt		display contained "%\%(\d\+\$\)\=[-+' #0]*\%(\d*\|\*\|\*\d\+\$\)\%(\.\%(\d*\|\*\|\*\d\+\$\)\)\=\%([hlLjqzt]\|ll\|hh\)\=[aAbdiuoxXDOUfFeEgGcCsSpn]"
syntax match   juliaPrintfFmt		display contained "%%"
syntax match   juliaPrintfFmt		display contained "\\%\%(\d\+\$\)\=[-+' #0]*\%(\d*\|\*\|\*\d\+\$\)\%(\.\%(\d*\|\*\|\*\d\+\$\)\)\=\%([hlLjqzt]\|ll\|hh\)\=[aAbdiuoxXDOUfFeEgGcCsSpn]"hs=s+1
syntax match   juliaPrintfFmt		display contained "\\%%"hs=s+1

" this is used to restrict the search for Symbols to when colons appear at all
" (for performance reasons)
syntax match   juliaPossibleSymbol	transparent ":\ze[^:]" contains=juliaSymbol,juliaQuotedParBlock,juliaQuotedQMarkPar,juliaColon

let s:quotable = '\%(' . s:idregex . '\|' . s:operators . '\|[?.]\|' . s:float_regex . '\|' . s:int_regex . '\)'
let s:quoting_colon = '\%(\%(^\s*\|\s\{6,\}\|[' . s:nonid_chars . s:op_chars_wc . ']\s*\)\@'.s:d(6).'<=\|\%(\<\%(return\|if\|else\%(if\)\?\|while\|try\|begin\)\s\+\)\@'.s:d(9).'<=\)\zs:'
let s:quoting_colonS = '\s\@'.s:d(1).'<=:'

" note: juliaSymbolS only works within whitespace-sensitive contexts,
" such as in macro calls without parentheses, or within square brackets.
" It is used to override the recognition of expressions like `a :b` as
" ranges rather than symbols in those contexts.
" (Note that such `a :b` expressions only allows at most 5 spaces between
" the identifier and the colon anyway.)

exec 'syntax match   juliaSymbol	contained "' . s:quoting_colon . s:quotable . '"'
exec 'syntax match   juliaSymbolS	contained "' . s:quoting_colonS . s:quotable . '"'

" same as above for quoted expressions such as :(expr)
exec 'syntax region   juliaQuotedParBlock	matchgroup=juliaQParDelim start="' . s:quoting_colon . '(" end=")" contains=@juliaExpressions'
exec 'syntax match    juliaQuotedQMarkPar	"' . s:quoting_colon . '(\s*?\s*)" contains=juliaQuotedQMark'
exec 'syntax region   juliaQuotedParBlockS	matchgroup=juliaQParDelim contained start="' . s:quoting_colonS . '(" end=")" contains=@juliaExpressions'


syntax match   juliaTypeOperatorR1	contained "[^{([:space:]<>\"]\+\%(\s*[<>]:\)\@="

" force precedence over Symbols
syntax match   juliaTypeOperator	contained "[<>:]:"
exec 'syntax match   juliaTypeOperatorR2	transparent "[<>:]:\s*\%(' . s:idregex . '\.\)*' . s:idregex . '" contains=juliaTypeOperator,juliaType,juliaDottedT,@juliaExpressions nextgroup=juliaTypeOperator'
syntax match   juliaIsaKeyword		contained "\<isa\>"
exec 'syntax match   juliaTypeOperatorR3	transparent "\<isa\s\+\%(' . s:idregex . '\.\)*' . s:idregex . '" contains=juliaIsaKeyword,juliaType,juliaDottedT,@juliaExpressions nextgroup=juliaIsaKeyword'

syntax match   juliaWhereKeyword       	"\<where\>"
exec 'syntax match   juliaWhereR	transparent "\<where\s\+' . s:idregex . '" contains=juliaWhereKeyword,juliaType,juliaDottedT,juliaIdSymbol'

syntax region  juliaCommentL		matchgroup=juliaCommentDelim excludenl start="#\ze\%([^=]\|$\)" end="$" contains=juliaTodo,@juliaSpellcheckComments
syntax region  juliaCommentM		matchgroup=juliaCommentDelim fold start="#=\ze\%([^#]\|$\)" end="=#" contains=juliaTodo,juliaCommentM,@juliaSpellcheckComments
syntax keyword juliaTodo		contained TODO FIXME XXX

" detect an end-of-line with only whitespace or comments before it
let s:eol = '\s*\%(\%(\%(#=\%(=#\@!\|[^=]\|\n\)\{-}=#\)\s*\)\+\)\?\%(#=\@!.*\)\?\n'

" a trailing comma, or colon, or an empty line in an import/using/export
" multi-line command. Used to recognize the as keyword, and for indentation
" (this needs to take precedence over normal commas and colons, and comments)
syntax cluster juliaContinuationItems	contains=juliaContinuationComma,juliaContinuationColon,juliaContinuationNone
exec 'syntax region  juliaContinuationComma	matchgroup=juliaComma contained start=",\ze'.s:eol.'" end="\n\+\ze." contains=@juliaCommentItems'
exec 'syntax region  juliaContinuationColon	matchgroup=juliaColon contained start=":\ze'.s:eol.'" end="\n\+\ze." contains=@juliaCommentItems'
exec 'syntax region  juliaContinuationNone	matchgroup=NONE contained start="\%(\<\%(import\|using\|export\)\>\|^\)\@'.s:d(6).'<=\ze'.s:eol.'" end="\n\+\ze." contains=@juliaCommentItems,juliaAsKeyword'
exec 'syntax match   juliaMacroName		contained "@' . s:idregex . '\%(\.' . s:idregex . '\)*"'

" the following are disabled by default, but
" can be enabled by entering e.g.
"   :hi link juliaParDelim Delimiter
hi def link juliaParDelim		juliaNone
hi def link juliaSemicolon		juliaNone
hi def link juliaComma			juliaNone
hi def link juliaFunctionCall		juliaNone

hi def link juliaColon			juliaOperator

hi def link juliaFunctionName		juliaFunction
hi def link juliaFunctionName1		juliaFunction
hi def link juliaMacroName		juliaMacro


hi def link juliaKeyword		Keyword
hi def link juliaWhereKeyword		Keyword
hi def link juliaInfixKeyword		Keyword
hi def link juliaIsaKeyword		Keyword
hi def link juliaAsKeyword		Keyword
hi def link juliaRepKeyword		Keyword
hi def link juliaBlKeyword		Keyword
hi def link juliaConditional		Conditional
hi def link juliaRepeat			Repeat
hi def link juliaException		Exception
hi def link juliaOuter			Keyword
hi def link juliaBaseTypeBasic		Type
hi def link juliaBaseTypeNum		Type
hi def link juliaBaseTypeC		Type
hi def link juliaBaseTypeError		Type
hi def link juliaBaseTypeIter		Type
hi def link juliaBaseTypeString		Type
hi def link juliaBaseTypeArray		Type
hi def link juliaBaseTypeDict		Type
hi def link juliaBaseTypeSet		Type
hi def link juliaBaseTypeIO		Type
hi def link juliaBaseTypeProcess	Type
hi def link juliaBaseTypeRange		Type
hi def link juliaBaseTypeRegex		Type
hi def link juliaBaseTypeFact		Type
hi def link juliaBaseTypeSort		Type
hi def link juliaBaseTypeRound		Type
hi def link juliaBaseTypeSpecial	Type
hi def link juliaBaseTypeRandom		Type
hi def link juliaBaseTypeDisplay	Type
hi def link juliaBaseTypeTime		Type
hi def link juliaBaseTypeOther		Type

hi def link juliaType			Type
hi def link juliaParamType		Type
hi def link juliaTypeOperatorR1		Type

" NOTE: deprecated constants are not highlighted as such. For once,
" one can still legitimately use them by importing Base.MathConstants.
" Plus, one-letter variables like `e` and `Î³` can be used with other
" meanings.
hi def link juliaConstNum		Constant
hi def link juliaEuler			Constant

hi def link juliaConstEnv		Constant
hi def link juliaConstC			Constant
hi def link juliaConstLimits		Constant
hi def link juliaConstGeneric		Constant
hi def link juliaRangeKeyword		Constant
hi def link juliaConstBool		Boolean
hi def link juliaConstIO		Boolean

hi def link juliaComprehensionFor	Keyword
hi def link juliaComprehensionIf	Keyword

hi def link juliaDollarVar		Identifier

hi def link juliaFunction		Function
hi def link juliaMacro			Macro
hi def link juliaSymbol			Identifier
hi def link juliaSymbolS		Identifier
hi def link juliaQParDelim		Identifier
hi def link juliaQuotedQMarkPar		Identifier
hi def link juliaQuotedQMark		juliaOperatorHL

hi def link juliaNumber			Number
hi def link juliaFloat			Float
hi def link juliaComplexUnit		Constant

hi def link juliaChar			Character

hi def link juliaString			String
hi def link juliaStringPrefixed		juliaString
hi def link juliabString		juliaString
hi def link juliasString		juliaString
hi def link juliavString		juliaString
hi def link juliarString		juliaString
hi def link juliaipString		juliaString
hi def link juliabigString		juliaString
hi def link juliaMIMEString		juliaString
hi def link juliarawString		juliaString
hi def link juliatestString		juliaString
hi def link juliahtmlString		juliaString
hi def link juliaint128String		juliaString
hi def link juliaPrintfString		juliaString
hi def link juliaShellString		juliaString
hi def link juliaDocString		juliaString
hi def link juliaDocStringM		juliaDocString
hi def link juliaDocStringMRaw		juliaDocString
hi def link juliaStringDelim		juliaString
hi def link juliaDocStringDelim		juliaDocString
hi def link juliaStringVarsPla		Identifier
hi def link juliaStringVarDelim		Identifier

hi def link juliaRegEx			String

hi def link juliaSpecialChar		SpecialChar
hi def link juliaOctalEscapeChar	SpecialChar
hi def link juliaHexEscapeChar		SpecialChar
hi def link juliaUniCharSmall		SpecialChar
hi def link juliaUniCharLarge		SpecialChar
hi def link juliaDoubleBackslash	SpecialChar
hi def link juliaEscapedQuote		SpecialChar

hi def link juliaPrintfFmt		SpecialChar

if s:julia_highlight_operators
  hi! def link juliaOperatorHL		Operator
else
  hi! def link juliaOperatorHL		juliaNone
endif
hi def link juliaOperator		juliaOperatorHL
hi def link juliaRangeOperator		juliaOperatorHL
hi def link juliaCTransOperator		juliaOperatorHL
hi def link juliaTernaryOperator	juliaOperatorHL
hi def link juliaTypeOperator		juliaOperatorHL

hi def link juliaCommentL		Comment
hi def link juliaCommentM		Comment
hi def link juliaCommentDelim		Comment
hi def link juliaTodo			Todo

hi def link juliaErrorPar		juliaError
hi def link juliaErrorEnd		juliaError
hi def link juliaErrorElse		juliaError
hi def link juliaErrorCatch		juliaError
hi def link juliaErrorFinally		juliaError
hi def link juliaErrorSemicol		juliaError
hi def link juliaErrorPrintfFmt		juliaError

hi def link juliaError			Error

syntax sync fromstart

let b:current_syntax = "julia"

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             " Vim syntax file
" Maintainer:           Christian Brabandt <cb@256bit.org>
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2015-05-29
" License:              Vim (see :h license)
" Repository:		https://github.com/chrisbra/vim-kconfig

if exists("b:current_syntax")
  finish
endif

let s:cpo_save = &cpo
set cpo&vim

if exists("g:kconfig_syntax_heavy")

syn match   kconfigBegin              '^' nextgroup=kconfigKeyword
                                      \ skipwhite

syn keyword kconfigTodo               contained TODO FIXME XXX NOTE

syn match   kconfigComment            display '#.*$' contains=kconfigTodo

syn keyword kconfigKeyword            config nextgroup=kconfigSymbol
                                      \ skipwhite

syn keyword kconfigKeyword            menuconfig nextgroup=kconfigSymbol
                                      \ skipwhite

syn keyword kconfigKeyword            comment menu mainmenu
                                      \ nextgroup=kconfigKeywordPrompt
                                      \ skipwhite

syn keyword kconfigKeyword            choice
                                      \ nextgroup=@kconfigConfigOptions
                                      \ skipwhite skipnl

syn keyword kconfigKeyword            endmenu endchoice

syn keyword kconfigPreProc            source
                                      \ nextgroup=kconfigPath
                                      \ skipwhite

" TODO: This is a hack.  The who .*Expr stuff should really be generated so
" that we can reuse it for various nextgroups.
syn keyword kconfigConditional        if endif
                                      \ nextgroup=@kconfigConfigOptionIfExpr
                                      \ skipwhite

syn match   kconfigKeywordPrompt      '"[^"\\]*\%(\\.[^"\\]*\)*"'
                                      \ contained
                                      \ nextgroup=@kconfigConfigOptions
                                      \ skipwhite skipnl

syn match   kconfigPath               '"[^"\\]*\%(\\.[^"\\]*\)*"\|\S\+'
                                      \ contained

syn match   kconfigSymbol             '\<\k\+\>'
                                      \ contained
                                      \ nextgroup=@kconfigConfigOptions
                                      \ skipwhite skipnl

" FIXME: There is â€“ probably â€“ no reason to cluster these instead of just
" defining them in the same group.
syn cluster kconfigConfigOptions      contains=kconfigTypeDefinition,
                                      \        kconfigInputPrompt,
                                      \        kconfigDefaultValue,
                                      \        kconfigDependencies,
                                      \        kconfigReverseDependencies,
                                      \        kconfigNumericalRanges,
                                      \        kconfigHelpText,
                                      \        kconfigDefBool,
                                      \        kconfigOptional

syn keyword kconfigTypeDefinition     bool boolean tristate string hex int
                                      \ contained
                                      \ nextgroup=kconfigTypeDefPrompt,
                                      \           @kconfigConfigOptions
                                      \ skipwhite skipnl

syn match   kconfigTypeDefPrompt      '"[^"\\]*\%(\\.[^"\\]*\)*"'
                                      \ contained
                                      \ nextgroup=kconfigConfigOptionIf,
                                      \           @kconfigConfigOptions
                                      \ skipwhite skipnl

syn match   kconfigTypeDefPrompt      "'[^'\\]*\%(\\.[^'\\]*\)*'"
                                      \ contained
                                      \ nextgroup=kconfigConfigOptionIf,
                                      \           @kconfigConfigOptions
                                      \ skipwhite skipnl

syn keyword kconfigInputPrompt        prompt
                                      \ contained
                                      \ nextgroup=kconfigPromptPrompt
                                      \ skipwhite

syn match   kconfigPromptPrompt       '"[^"\\]*\%(\\.[^"\\]*\)*"'
                                      \ contained
                                      \ nextgroup=kconfigConfigOptionIf,
                                      \           @kconfigConfigOptions
                                      \ skipwhite skipnl

syn match   kconfigPromptPrompt       "'[^'\\]*\%(\\.[^'\\]*\)*'"
                                      \ contained
                                      \ nextgroup=kconfigConfigOptionIf,
                                      \           @kconfigConfigOptions
                                      \ skipwhite skipnl

syn keyword   kconfigDefaultValue     default
                                      \ contained
                                      \ nextgroup=@kconfigConfigOptionExpr
                                      \ skipwhite

syn match   kconfigDependencies       'depends on\|requires'
                                      \ contained
                                      \ nextgroup=@kconfigConfigOptionIfExpr
                                      \ skipwhite

syn keyword kconfigReverseDependencies select
                                      \ contained
                                      \ nextgroup=@kconfigRevDepSymbol
                                      \ skipwhite

syn cluster kconfigRevDepSymbol       contains=kconfigRevDepCSymbol,
                                      \        kconfigRevDepNCSymbol

syn match   kconfigRevDepCSymbol      '"[^"\\]*\%(\\.[^"\\]*\)*"'
                                      \ contained
                                      \ nextgroup=kconfigConfigOptionIf,
                                      \           @kconfigConfigOptions
                                      \ skipwhite skipnl

syn match   kconfigRevDepCSymbol      "'[^'\\]*\%(\\.[^'\\]*\)*'"
                                      \ contained
                                      \ nextgroup=kconfigConfigOptionIf,
                                      \           @kconfigConfigOptions
                                      \ skipwhite skipnl

syn match   kconfigRevDepNCSymbol     '\<\k\+\>'
                                      \ contained
                                      \ nextgroup=kconfigConfigOptionIf,
                                      \           @kconfigConfigOptions
                                      \ skipwhite skipnl

syn keyword kconfigNumericalRanges    range
                                      \ contained
                                      \ nextgroup=@kconfigRangeSymbol
                                      \ skipwhite

syn cluster kconfigRangeSymbol        contains=kconfigRangeCSymbol,
                                      \        kconfigRangeNCSymbol

syn match   kconfigRangeCSymbol       '"[^"\\]*\%(\\.[^"\\]*\)*"'
                                      \ contained
                                      \ nextgroup=@kconfigRangeSymbol2
                                      \ skipwhite skipnl

syn match   kconfigRangeCSymbol       "'[^'\\]*\%(\\.[^'\\]*\)*'"
                                      \ contained
                                      \ nextgroup=@kconfigRangeSymbol2
                                      \ skipwhite skipnl

syn match   kconfigRangeNCSymbol      '\<\k\+\>'
                                      \ contained
                                      \ nextgroup=@kconfigRangeSymbol2
                                      \ skipwhite skipnl

syn cluster kconfigRangeSymbol2       contains=kconfigRangeCSymbol2,
                                      \        kconfigRangeNCSymbol2

syn match   kconfigRangeCSymbol2      "'[^'\\]*\%(\\.[^'\\]*\)*'"
                                      \ contained
                                      \ nextgroup=kconfigConfigOptionIf,
                                      \           @kconfigConfigOptions
                                      \ skipwhite skipnl

syn match   kconfigRangeNCSymbol2     '\<\k\+\>'
                                      \ contained
                                      \ nextgroup=kconfigConfigOptionIf,
                                      \           @kconfigConfigOptions
                                      \ skipwhite skipnl

syn region  kconfigHelpText           contained
      \ matchgroup=kconfigConfigOption
      \ start='\%(help\|---help---\)\ze\s*\n\z(\s\+\)'
      \ skip='^$'
      \ end='^\z1\@!'
      \ nextgroup=@kconfigConfigOptions
      \ skipwhite skipnl

" XXX: Undocumented
syn keyword kconfigDefBool            def_bool
                                      \ contained
                                      \ nextgroup=@kconfigDefBoolSymbol
                                      \ skipwhite

syn cluster kconfigDefBoolSymbol      contains=kconfigDefBoolCSymbol,
                                      \        kconfigDefBoolNCSymbol

syn match   kconfigDefBoolCSymbol     '"[^"\\]*\%(\\.[^"\\]*\)*"'
                                      \ contained
                                      \ nextgroup=kconfigConfigOptionIf,
                                      \           @kconfigConfigOptions
                                      \ skipwhite skipnl

syn match   kconfigDefBoolCSymbol     "'[^'\\]*\%(\\.[^'\\]*\)*'"
                                      \ contained
                                      \ nextgroup=kconfigConfigOptionIf,
                                      \           @kconfigConfigOptions
                                      \ skipwhite skipnl

syn match   kconfigDefBoolNCSymbol    '\<\k\+\>'
                                      \ contained
                                      \ nextgroup=kconfigConfigOptionIf,
                                      \           @kconfigConfigOptions
                                      \ skipwhite skipnl

" XXX: This is actually only a valid option for â€œchoiceâ€, but treating it
" specially would require a lot of extra groups.
syn keyword kconfigOptional           optional
                                      \ contained
                                      \ nextgroup=@kconfigConfigOptions
                                      \ skipwhite skipnl

syn keyword kconfigConfigOptionIf     if
                                      \ contained
                                      \ nextgroup=@kconfigConfigOptionIfExpr
                                      \ skipwhite

syn cluster kconfigConfigOptionIfExpr contains=@kconfigConfOptIfExprSym,
                                      \        kconfigConfOptIfExprNeg,
                                      \        kconfigConfOptIfExprGroup

syn cluster kconfigConfOptIfExprSym   contains=kconfigConfOptIfExprCSym,
                                      \        kconfigConfOptIfExprNCSym

syn match   kconfigConfOptIfExprCSym  '"[^"\\]*\%(\\.[^"\\]*\)*"'
                                      \ contained
                                      \ nextgroup=@kconfigConfigOptions,
                                      \           kconfigConfOptIfExprAnd,
                                      \           kconfigConfOptIfExprOr,
                                      \           kconfigConfOptIfExprEq,
                                      \           kconfigConfOptIfExprNEq
                                      \ skipwhite skipnl

syn match   kconfigConfOptIfExprCSym  "'[^'\\]*\%(\\.[^'\\]*\)*'"
                                      \ contained
                                      \ nextgroup=@kconfigConfigOptions,
                                      \           kconfigConfOptIfExprAnd,
                                      \           kconfigConfOptIfExprOr,
                                      \           kconfigConfOptIfExprEq,
                                      \           kconfigConfOptIfExprNEq
                                      \ skipwhite skipnl

syn match   kconfigConfOptIfExprNCSym '\<\k\+\>'
                                      \ contained
                                      \ nextgroup=@kconfigConfigOptions,
                              p‰  q‰  r‰  s‰  t‰  u‰  v‰  w‰  x‰  y‰  z‰  {‰  |‰  }‰  ~‰  ‰  €‰  ‰  ‚‰  ƒ‰  „‰  …‰  †‰  ‡‰                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          \           kconfigConfOptIfExprAnd,
                                      \           kconfigConfOptIfExprOr,
                                      \           kconfigConfOptIfExprEq,
                                      \           kconfigConfOptIfExprNEq
                                      \ skipwhite skipnl

syn cluster kconfigConfOptIfExprSym2  contains=kconfigConfOptIfExprCSym2,
                                      \        kconfigConfOptIfExprNCSym2

syn match   kconfigConfOptIfExprEq    '='
                                      \ contained
                                      \ nextgroup=@kconfigConfOptIfExprSym2
                                      \ skipwhite

syn match   kconfigConfOptIfExprNEq   '!='
                                      \ contained
                                      \ nextgroup=@kconfigConfOptIfExprSym2
                                      \ skipwhite

syn match   kconfigConfOptIfExprCSym2 "'[^'\\]*\%(\\.[^'\\]*\)*'"
                                      \ contained
                                      \ nextgroup=@kconfigConfigOptions,
                                      \           kconfigConfOptIfExprAnd,
                                      \           kconfigConfOptIfExprOr
                                      \ skipwhite skipnl

syn match   kconfigConfOptIfExprNCSym2 '\<\k\+\>'
                                      \ contained
                                      \ nextgroup=@kconfigConfigOptions,
                                      \           kconfigConfOptIfExprAnd,
                                      \           kconfigConfOptIfExprOr
                                      \ skipwhite skipnl

syn match   kconfigConfOptIfExprNeg   '!'
                                      \ contained
                                      \ nextgroup=@kconfigConfigOptionIfExpr
                                      \ skipwhite

syn match   kconfigConfOptIfExprAnd   '&&'
                                      \ contained
                                      \ nextgroup=@kconfigConfigOptionIfExpr
                                      \ skipwhite

syn match   kconfigConfOptIfExprOr    '||'
                                      \ contained
                                      \ nextgroup=@kconfigConfigOptionIfExpr
                                      \ skipwhite

syn match   kconfigConfOptIfExprGroup '('
                                      \ contained
                                      \ nextgroup=@kconfigConfigOptionIfGExp
                                      \ skipwhite

" TODO: hm, this kind of recursion doesn't work right.  We need another set of
" expressions that have kconfigConfigOPtionIfGExp as nextgroup and a matcher
" for '(' that sets it all off.
syn cluster kconfigConfigOptionIfGExp contains=@kconfigConfOptIfGExpSym,
                                      \        kconfigConfOptIfGExpNeg,
                                      \        kconfigConfOptIfExprGroup

syn cluster kconfigConfOptIfGExpSym   contains=kconfigConfOptIfGExpCSym,
                                      \        kconfigConfOptIfGExpNCSym

syn match   kconfigConfOptIfGExpCSym  '"[^"\\]*\%(\\.[^"\\]*\)*"'
                                      \ contained
                                      \ nextgroup=@kconfigConfigIf,
                                      \           kconfigConfOptIfGExpAnd,
                                      \           kconfigConfOptIfGExpOr,
                                      \           kconfigConfOptIfGExpEq,
                                      \           kconfigConfOptIfGExpNEq
                                      \ skipwhite skipnl

syn match   kconfigConfOptIfGExpCSym  "'[^'\\]*\%(\\.[^'\\]*\)*'"
                                      \ contained
                                      \ nextgroup=@kconfigConfigIf,
                                      \           kconfigConfOptIfGExpAnd,
                                      \           kconfigConfOptIfGExpOr,
                                      \           kconfigConfOptIfGExpEq,
                                      \           kconfigConfOptIfGExpNEq
                                      \ skipwhite skipnl

syn match   kconfigConfOptIfGExpNCSym '\<\k\+\>'
                                      \ contained
                                      \ nextgroup=kconfigConfOptIfExprGrpE,
                                      \           kconfigConfOptIfGExpAnd,
                                      \           kconfigConfOptIfGExpOr,
                                      \           kconfigConfOptIfGExpEq,
                                      \           kconfigConfOptIfGExpNEq
                                      \ skipwhite skipnl

syn cluster kconfigConfOptIfGExpSym2  contains=kconfigConfOptIfGExpCSym2,
                                      \        kconfigConfOptIfGExpNCSym2

syn match   kconfigConfOptIfGExpEq    '='
                                      \ contained
                                      \ nextgroup=@kconfigConfOptIfGExpSym2
                                      \ skipwhite

syn match   kconfigConfOptIfGExpNEq   '!='
                                      \ contained
                                      \ nextgroup=@kconfigConfOptIfGExpSym2
                                      \ skipwhite

syn match   kconfigConfOptIfGExpCSym2 '"[^"\\]*\%(\\.[^"\\]*\)*"'
                                      \ contained
                                      \ nextgroup=kconfigConfOptIfExprGrpE,
                                      \           kconfigConfOptIfGExpAnd,
                                      \           kconfigConfOptIfGExpOr
                                      \ skipwhite skipnl

syn match   kconfigConfOptIfGExpCSym2 "'[^'\\]*\%(\\.[^'\\]*\)*'"
                                      \ contained
                                      \ nextgroup=kconfigConfOptIfExprGrpE,
                                      \           kconfigConfOptIfGExpAnd,
                                      \           kconfigConfOptIfGExpOr
                                      \ skipwhite skipnl

syn match   kconfigConfOptIfGExpNCSym2 '\<\k\+\>'
                                      \ contained
                                      \ nextgroup=kconfigConfOptIfExprGrpE,
                                      \           kconfigConfOptIfGExpAnd,
                                      \           kconfigConfOptIfGExpOr
                                      \ skipwhite skipnl

syn match   kconfigConfOptIfGExpNeg   '!'
                                      \ contained
                                      \ nextgroup=@kconfigConfigOptionIfGExp
                                      \ skipwhite

syn match   kconfigConfOptIfGExpAnd   '&&'
                                      \ contained
                                      \ nextgroup=@kconfigConfigOptionIfGExp
                                      \ skipwhite

syn match   kconfigConfOptIfGExpOr    '||'
                                      \ contained
                                      \ nextgroup=@kconfigConfigOptionIfGExp
                                      \ skipwhite

syn match   kconfigConfOptIfExprGrpE  ')'
                                      \ contained
                                      \ nextgroup=@kconfigConfigOptions,
                                      \           kconfigConfOptIfExprAnd,
                                      \           kconfigConfOptIfExprOr
                                      \ skipwhite skipnl


syn cluster kconfigConfigOptionExpr   contains=@kconfigConfOptExprSym,
                                      \        kconfigConfOptExprNeg,
                                      \        kconfigConfOptExprGroup

syn cluster kconfigConfOptExprSym     contains=kconfigConfOptExprCSym,
                                      \        kconfigConfOptExprNCSym

syn match   kconfigConfOptExprCSym    '"[^"\\]*\%(\\.[^"\\]*\)*"'
                                      \ contained
                                      \ nextgroup=kconfigConfigOptionIf,
                                      \           kconfigConfOptExprAnd,
                                      \           kconfigConfOptExprOr,
                                      \           kconfigConfOptExprEq,
                                      \           kconfigConfOptExprNEq,
                                      \           @kconfigConfigOptions
                                      \ skipwhite skipnl

syn match   kconfigConfOptExprCSym    "'[^'\\]*\%(\\.[^'\\]*\)*'"
                                      \ contained
                                      \ nextgroup=kconfigConfigOptionIf,
                                      \           kconfigConfOptExprAnd,
                                      \           kconfigConfOptExprOr,
                                      \           kconfigConfOptExprEq,
                                      \           kconfigConfOptExprNEq,
                                      \           @kconfigConfigOptions
                                      \ skipwhite skipnl

syn match   kconfigConfOptExprNCSym   '\<\k\+\>'
                                      \ contained
                                      \ nextgroup=kconfigConfigOptionIf,
                                      \           kconfigConfOptExprAnd,
                                      \           kconfigConfOptExprOr,
                                      \           kconfigConfOptExprEq,
                                      \           kconfigConfOptExprNEq,
                                      \           @kconfigConfigOptions
                                      \ skipwhite skipnl

syn cluster kconfigConfOptExprSym2    contains=kconfigConfOptExprCSym2,
                                      \        kconfigConfOptExprNCSym2

syn match   kconfigConfOptExprEq      '='
                                      \ contained
                                      \ nextgroup=@kconfigConfOptExprSym2
                                      \ skipwhite

syn match   kconfigConfOptExprNEq     '!='
                                      \ contained
                                      \ nextgroup=@kconfigConfOptExprSym2
                                      \ skipwhite

syn match   kconfigConfOptExprCSym2   '"[^"\\]*\%(\\.[^"\\]*\)*"'
                                      \ contained
                                      \ nextgroup=kconfigConfigOptionIf,
                                      \           kconfigConfOptExprAnd,
                                      \           kconfigConfOptExprOr,
                                      \           @kconfigConfigOptions
                                      \ skipwhite skipnl

syn match   kconfigConfOptExprCSym2   "'[^'\\]*\%(\\.[^'\\]*\)*'"
                                      \ contained
                                      \ nextgroup=kconfigConfigOptionIf,
                                      \           kconfigConfOptExprAnd,
                                      \           kconfigConfOptExprOr,
                                      \           @kconfigConfigOptions
                                      \ skipwhite skipnl

syn match   kconfigConfOptExprNCSym2  '\<\k\+\>'
                                      \ contained
                                      \ nextgroup=kconfigConfigOptionIf,
                                      \           kconfigConfOptExprAnd,
                                      \           kconfigConfOptExprOr,
                                      \           @kconfigConfigOptions
                                      \ skipwhite skipnl

syn match   kconfigConfOptExprNeg     '!'
                                      \ contained
                                      \ nextgroup=@kconfigConfigOptionExpr
                                      \ skipwhite

syn match   kconfigConfOptExprAnd     '&&'
                                      \ contained
                                      \ nextgroup=@kconfigConfigOptionExpr
                                      \ skipwhite

syn match   kconfigConfOptExprOr      '||'
                                      \ contained
                                      \ nextgroup=@kconfigConfigOptionExpr
                                      \ skipwhite

syn match   kconfigConfOptExprGroup   '('
                                      \ contained
                                      \ nextgroup=@kconfigConfigOptionGExp
                                      \ skipwhite

syn cluster kconfigConfigOptionGExp   contains=@kconfigConfOptGExpSym,
                                      \        kconfigConfOptGExpNeg,
                                      \        kconfigConfOptGExpGroup

syn cluster kconfigConfOptGExpSym     contains=kconfigConfOptGExpCSym,
                                      \        kconfigConfOptGExpNCSym

syn match   kconfigConfOptGExpCSym    '"[^"\\]*\%(\\.[^"\\]*\)*"'
                                      \ contained
                                      \ nextgroup=kconfigConfOptExprGrpE,
                                      \           kconfigConfOptGExpAnd,
                                      \           kconfigConfOptGExpOr,
                                      \           kconfigConfOptGExpEq,
                                      \           kconfigConfOptGExpNEq
                                      \ skipwhite skipnl

syn match   kconfigConfOptGExpCSym    "'[^'\\]*\%(\\.[^'\\]*\)*'"
                                      \ contained
                                      \ nextgroup=kconfigConfOptExprGrpE,
                                      \           kconfigConfOptGExpAnd,
                                      \           kconfigConfOptGExpOr,
                                      \           kconfigConfOptGExpEq,
                                      \           kconfigConfOptGExpNEq
                                      \ skipwhite skipnl

syn match   kconfigConfOptGExpNCSym   '\<\k\+\>'
                                      \ contained
                                      \ nextgroup=kconfigConfOptExprGrpE,
                                      \           kconfigConfOptGExpAnd,
                                      \           kconfigConfOptGExpOr,
                                      \           kconfigConfOptGExpEq,
                                      \           kconfigConfOptGExpNEq
                                      \ skipwhite skipnl

syn cluster kconfigConfOptGExpSym2    contains=kconfigConfOptGExpCSym2,
                                      \        kconfigConfOptGExpNCSym2

syn match   kconfigConfOptGExpEq      '='
                                      \ contained
                                      \ nextgroup=@kconfigConfOptGExpSym2
                                      \ skipwhite

syn match   kconfigConfOptGExpNEq     '!='
                                      \ contained
                                      \ nextgroup=@kconfigConfOptGExpSym2
                                      \ skipwhite

syn match   kconfigConfOptGExpCSym2   '"[^"\\]*\%(\\.[^"\\]*\)*"'
                                      \ contained
                                      \ nextgroup=kconfigConfOptExprGrpE,
                                      \           kconfigConfOptGExpAnd,
                                      \           kconfigConfOptGExpOr
                                      \ skipwhite skipnl

syn match   kconfigConfOptGExpCSym2   "'[^'\\]*\%(\\.[^'\\]*\)*'"
                                      \ contained
                                      \ nextgroup=kconfigConfOptExprGrpE,
                                      \           kconfigConfOptGExpAnd,
                                      \           kconfigConfOptGExpOr
                                      \ skipwhite skipnl

syn match   kconfigConfOptGExpNCSym2  '\<\k\+\>'
                                      \ contained
                                      \ nextgroup=kconfigConfOptExprGrpE,
                                      \           kconfigConfOptGExpAnd,
                                      \           kconfigConfOptGExpOr
                                      \ skipwhite skipnl

syn match   kconfigConfOptGExpNeg     '!'
                                      \ contained
                                      \ nextgroup=@kconfigConfigOptionGExp
                                      \ skipwhite

syn match   kconfigConfOptGExpAnd     '&&'
                                      \ contained
                                      \ nextgroup=@kconfigConfigOptionGExp
                                      \ skipwhite

syn match   kconfigConfOptGExpOr      '||'
                                      \ contained
                                      \ nextgroup=@kconfigConfigOptionGExp
                                      \ skipwhite

syn match   kconfigConfOptExprGrpE    ')'
                                      \ contained
                                      \ nextgroup=kconfigConfigOptionIf,
                                      \           kconfigConfOptExprAnd,
                                      \           kconfigConfOptExprOr
                                      \ skipwhite skipnl

syn sync minlines=50

hi def link kconfigTodo                 Todo
hi def link kconfigComment              Comment
hi def link kconfigKeyword              Keyword
hi def link kconfigPreProc              PreProc
hi def link kconfigConditional          Conditional
hi def link kconfigPrompt               String
hi def link kconfigKeywordPrompt        kconfigPrompt
hi def link kconfigPath                 String
hi def link kconfigSymbol               String
hi def link kconfigConstantSymbol       Constant
hi def link kconfigConfigOption         Type
hi def link kconfigTypeDefinition       kconfigConfigOption
hi def link kconfigTypeDefPrompt        kconfigPrompt
hi def link kconfigInputPrompt          kconfigConfigOption
hi def link kconfigPromptPrompt         kconfigPrompt
hi def link kconfigDefaultValue         kconfigConfigOption
hi def link kconfigDependencies         kconfigConfigOption
hi def link kconfigReverseDependencies  kconfigConfigOption
hi def link kconfigRevDepCSymbol        kconfigConstantSymbol
hi def link kconfigRevDepNCSymbol       kconfigSymbol
hi def link kconfigNumericalRanges      kconfigConfigOption
hi def link kconfigRangeCSymbol         kconfigConstantSymbol
hi def link kconfigRangeNCSymbol        kconfigSymbol
hi def link kconfigRangeCSymbol2        kconfigConstantSymbol
hi def link kconfigRangeNCSymbol2       kconfigSymbol
hi def link kconfigHelpText             Normal
hi def link kconfigDefBool              kconfigConfigOption
hi def link kconfigDefBoolCSymbol       kconfigConstantSymbol
hi def link kconfigDefBoolNCSymbol      kconfigSymbol
hi def link kconfigOptional             kconfigConfigOption
hi def link kconfigConfigOptionIf       Conditional
hi def link kconfigConfOptIfExprCSym    kconfigConstantSymbol
hi def link kconfigConfOptIfExprNCSym   kconfigSymbol
hi def link kconfigOperator             Operator
hi def link kconfigConfOptIfExprEq      kconfigOperator
hi def link kconfigConfOptIfExprNEq     kconfigOperator
hi def link kconfigConfOptIfExprCSym2   kconfigConstantSymbol
hi def link kconfigConfOptIfExprNCSym2  kconfigSymbol
hi def link kconfigConfOptIfExprNeg     kconfigOperator
hi def link kconfigConfOptIfExprAnd     kconfigOperator
hi def link kconfigConfOptIfExprOr      kconfigOperator
hi def link kconfigDelimiter            Delimiter
hi def link kconfigConfOptIfExprGroup   kconfigDelimiter
hi def link kconfigConfOptIfGExpCSym    kconfigConstantSymbol
hi def link kconfigConfOptIfGExpNCSym   kconfigSymbol
hi def link kconfigConfOptIfGExpEq      kconfigOperator
hi def link kconfigConfOptIfGExpNEq     kconfigOperator
hi def link kconfigConfOptIfGExpCSym2   kconfigConstantSymbol
hi def link kconfigConfOptIfGExpNCSym2  kconfigSymbol
hi def link kconfigConfOptIfGExpNeg     kconfigOperator
hi def link kconfigConfOptIfGExpAnd     kconfigOperator
hi def link kconfigConfOptIfGExpOr      kconfigOperator
hi def link kconfigConfOptIfExprGrpE    kconfigDelimiter
hi def link kconfigConfOptExprCSym      kconfigConstantSymbol
hi def link kconfigConfOptExprNCSym     kconfigSymbol
hi def link kconfigConfOptExprEq        kconfigOperator
hi def link kconfigConfOptExprNEq       kconfigOperator
hi def link kconfigConfOptExprCSym2     kconfigConstantSymbol
hi def link kconfigConfOptExprNCSym2    kconfigSymbol
hi def link kconfigConfOptExprNeg       kconfigOperator
hi def link kconfigConfOptExprAnd       kconfigOperator
hi def link kconfigConfOptExprOr        kconfigOperator
hi def link kconfigConfOptExprGroup     kconfigDelimiter
hi def link kconfigConfOptGExpCSym      kconfigConstantSymbol
hi def link kconfigConfOptGExpNCSym     kconfigSymbol
hi def link kconfigConfOptGExpEq        kconfigOperator
hi def link kconfigConfOptGExpNEq       kconfigOperator
hi def link kconfigConfOptGExpCSym2     kconfigConstantSymbol
hi def link kconfigConfOptGExpNCSym2    kconfigSymbol
hi def link kconfigConfOptGExpNeg       kconfigOperator
hi def link kconfigConfOptGExpAnd       kconfigOperator
hi def link kconfigConfOptGExpOr        kconfigOperator
hi def link kconfigConfOptExprGrpE      kconfigConfOptIfExprGroup

else

syn keyword kconfigTodo               contained TODO FIXME XXX NOTE

syn match   kconfigComment            display '#.*$' contains=kconfigTodo

syn keyword kconfigKeyword            config menuconfig comment mainmenu

syn keyword kconfigConditional        menu endmenu choice endchoice if endif

syn keyword kconfigPreProc            source
                                      \ nextgroup=kconfigPath
                                      \ skipwhite

syn keyword kconfigTriState           y m n

syn match   kconfigSpecialChar        contained '\\.'
syn match   kconfigSpecialChar        '\\$'

syn region  kconfigPath               matchgroup=kconfigPath
                                      \ start=+"+ skip=+\\\\\|\\\"+ end=+"+
                                      \ contains=kconfigSpecialChar

syn region  kconfigPath               matchgroup=kconfigPath
                                      \ start=+'+ skip=+\\\\\|\\\'+ end=+'+
                                      \ contains=kconfigSpecialChar

syn match   kconfigPath               '\S\+'
                                      \ contained

syn region  kconfigString             matchgroup=kconfigString
                                      \ start=+"+ skip=+\\\\\|\\\"+ end=+"+
                                      \ contains=kconfigSpecialChar

syn region  kconfigString             matchgroup=kconfigString
                                      \ start=+'+ skip=+\\\\\|\\\'+ end=+'+
                                      \ contains=kconfigSpecialChar

syn keyword kconfigType               bool boolean tristate string hex int

syn keyword kconfigOption             prompt default requires select range
                                      \ optional
syn match   kconfigOption             'depends\%( on\)\='

syn keyword kconfigMacro              def_bool def_tristate

syn region  kconfigHelpText
      \ matchgroup=kconfigOption
      \ start='\%(help\|---help---\)\ze\s*\n\z(\s\+\)'
      \ skip='^$'
      \ end='^\z1\@!'

syn sync    match kconfigSyncHelp     grouphere kconfigHelpText 'help\|---help---'

hi def link kconfigTodo         Todo
hi def link kconfigComment      Comment
hi def link kconfigKeyword      Keyword
hi def link kconfigConditional  Conditional
hi def link kconfigPreProc      PreProc
hi def link kconfigTriState     Boolean
hi def link kconfigSpecialChar  SpecialChar
hi def link kconfigPath         String
hi def link kconfigString       String
hi def link kconfigType         Type
hi def link kconfigOption       Identifier
hi def link kconfigHelpText     Normal
hi def link kconfigmacro        Macro

endif

let b:current_syntax = "kconfig"

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                " Vim syntax file
" Language:    Kivy
" Maintainer:  Corey Prophitt <prophitt.corey@gmail.com>
" Last Change: May 29th, 2014
" Version:     1
" URL:         http://kivy.org/

if exists("b:current_syntax")
    finish
endif

" Load Python syntax first (Python can be used within Kivy)
syn include @pyth $VIMRUNTIME/syntax/python.vim

" Kivy language rules can be found here
"   http://kivy.org/docs/guide/lang.html

" Define Kivy syntax
syn match kivyPreProc   /#:.*/
syn match kivyComment   /#.*/
syn match kivyRule      /<\I\i*\(,\s*\I\i*\)*>:/
syn match kivyAttribute /\<\I\i*\>/ nextgroup=kivyValue

syn region kivyValue start=":" end=/$/  contains=@pyth skipwhite

syn region kivyAttribute matchgroup=kivyIdent start=/[\a_][\a\d_]*:/ end=/$/ contains=@pyth skipwhite

hi def link kivyPreproc   PreProc
hi def link kivyComment   Comment
hi def link kivyRule      Function
hi def link kivyIdent     Statement
hi def link kivyAttribute Label

let b:current_syntax = "kivy"

" vim: ts=8
                                      " Vim syntax file
" Language:	KixTart 95, Kix2001 Windows script language http://kixtart.org/
" Maintainer:	Richard Howarth <rhowarth@sgb.co.uk>
" Last Change:	2003 May 11
" URL:		http://www.howsoft.demon.co.uk/

" KixTart files identified by *.kix extension.

" Amendment History:
" 26 April 2001: RMH
"    Removed development comments from distro version
"    Renamed "Kix*" to "kix*" for consistancy
"    Changes made in preperation for VIM version 5.8/6.00

" TODO:
"	Handle arrays highlighting
"	Handle object highlighting
" The next two may not be possible:
"	Work out how to error too many "(", i.e. (() should be an error.
"	Similarly, "if" without "endif" and similar constructs should error.

" quit when a syntax file was already loaded
if exists("b:current_syntax")
	finish
endif

syn case match
syn keyword kixTODO		TODO FIX XXX contained

" Case insensitive language.
syn case ignore

" Kix statements
syn match   kixStatement	"?"
syn keyword kixStatement	beep big break
syn keyword kixStatement	call cd cls color cookie1 copy
syn keyword kixStatement	del dim display
syn keyword kixStatement	exit
syn keyword kixStatement	flushkb
syn keyword kixStatement	get gets global go gosub goto
syn keyword kixStatement	md
syn keyword kixStatement	password play
syn keyword kixStatement	quit
syn keyword kixStatement	rd return run
syn keyword kixStatement	set setl setm settime shell sleep small
syn keyword kixStatement	use

" Kix2001
syn keyword kixStatement	debug function endfunction redim

" Simple variables
syn match   kixNotVar		"\$\$\|@@\|%%" transparent contains=NONE
syn match   kixLocalVar		"\$\w\+"
syn match   kixMacro		"@\w\+"
syn match   kixEnvVar		"%\w\+"

" Destination labels
syn match   kixLabel		":\w\+\>"

" Identify strings, trap unterminated strings
syn match   kixStringError      +".*\|'.*+
syn region  kixDoubleString	oneline start=+"+ skip=+\\\\\|\\"+ end=+"+ contains=kixLocalVar,kixMacro,kixEnvVar,kixNotVar
syn region  kixSingleString	oneline start=+'+ skip=+\\\\\|\\'+ end=+'+ contains=kixLocalVar,kixMacro,kixEnvVar,kixNotVar

" Operators
syn match   kixOperator		"+\|-\|\*\|/\|=\|&\||"
syn keyword kixOperator		and or
" Kix2001
syn match   kixOperator		"=="
syn keyword kixOperator		not

" Numeric constants
syn match   kixInteger		"-\=\<\d\+\>" contains=NONE
syn match   kixFloat		"-\=\.\d\+\>\|-\=\<\d\+\.\d\+\>" contains=NONE

" Hex numeric constants
syn match   kixHex		"\&\x\+\>" contains=NONE

" Other contants
" Kix2001
syn keyword kixConstant		on off

" Comments
syn match   kixComment		";.*$" contains=kixTODO

" Trap unmatched parenthesis
syn match   kixParenCloseError	")"
syn region  kixParen		oneline transparent start="(" end=")" contains=ALLBUT,kixParenCloseError

" Functions (Builtin + UDF)
syn match   kixFunction		"\w\+("he=e-1,me=e-1 contains=ALL

" Trap unmatched brackets
syn match   kixBrackCloseError	"\]"
syn region  kixBrack		transparent start="\[" end="\]" contains=ALLBUT,kixBrackCloseError

" Clusters for ALLBUT shorthand
syn cluster kixIfBut		contains=kixIfError,kixSelectOK,kixDoOK,kixWhileOK,kixForEachOK,kixForNextOK
syn cluster kixSelectBut	contains=kixSelectError,kixIfOK,kixDoOK,kixWhileOK,kixForEachOK,kixForNextOK
syn cluster kixDoBut		contains=kixDoError,kixSelectOK,kixIfOK,kixWhileOK,kixForEachOK,kixForNextOK
syn cluster kixWhileBut		contains=kixWhileError,kixSelectOK,kixIfOK,kixDoOK,kixForEachOK,kixForNextOK
syn cluster kixForEachBut	contains=kixForEachError,kixSelectOK,kixIfOK,kixDoOK,kixForNextOK,kixWhileOK
syn cluster kixForNextBut	contains=kixForNextError,kixSelectOK,kixIfOK,kixDoOK,kixForEachOK,kixWhileOK
" Condtional construct errors.
syn match   kixIfError		"\<if\>\|\<else\>\|\<endif\>"
syn match   kixIfOK		contained "\<if\>\|\<else\>\|\<endif\>"
syn region  kixIf		transparent matchgroup=kixIfOK start="\<if\>" end="\<endif\>" contains=ALLBUT,@kixIfBut
syn match   kixSelectError	"\<select\>\|\<case\>\|\<endselect\>"
syn match   kixSelectOK		contained "\<select\>\|\<case\>\|\<endselect\>"
syn region  kixSelect		transparent matchgroup=kixSelectOK start="\<select\>" end="\<endselect\>" contains=ALLBUT,@kixSelectBut

" Program control constructs.
syn match   kixDoError		"\<do\>\|\<until\>"
syn match   kixDoOK		contained "\<do\>\|\<until\>"
syn region  kixDo		transparent matchgroup=kixDoOK start="\<do\>" end="\<until\>" contains=ALLBUT,@kixDoBut
syn match   kixWhileError	"\<while\>\|\<loop\>"
syn match   kixWhileOK		contained "\<while\>\|\<loop\>"
syn region  kixWhile		transparent matchgroup=kixWhileOK start="\<while\>" end="\<loop\>" contains=ALLBUT,@kixWhileBut
syn match   kixForNextError	"\<for\>\|\<to\>\|\<step\>\|\<next\>"
syn match   kixForNextOK	contained "\<for\>\|\<to\>\|\<step\>\|\<next\>"
syn region  kixForNext		transparent matchgroup=kixForNextOK start="\<for\>" end="\<next\>" contains=ALLBUT,@kixForBut
syn match   kixForEachError	"\<for each\>\|\<in\>\|\<next\>"
syn match   kixForEachOK	contained "\<for each\>\|\<in\>\|\<next\>"
syn region  kixForEach		transparent matchgroup=kixForEachOK start="\<for each\>" end="\<next\>" contains=ALLBUT,@kixForEachBut

" Expressions
syn match   kixExpression	"<\|>\|<=\|>=\|<>"


" Default highlighting.
" Set default highlight only if it doesn't already have a value.

hi def link kixDoubleString		String
hi def link kixSingleString		String
hi def link kixStatement		Statement
hi def link kixRepeat		Repeat
hi def link kixComment		Comment
hi def link kixBuiltin		Function
hi def link kixLocalVar		Special
hi def link kixMacro			Special
hi def link kixEnvVar		Special
hi def link kixLabel			Type
hi def link kixFunction		Function
hi def link kixInteger		Number
hi def link kixHex			Number
hi def link kixFloat			Number
hi def link kixOperator		Operator
hi def link kixExpression		Operator

hi def link kixParenCloseError	Error
hi def link kixBrackCloseError	Error
hi def link kixStringError		Error

hi def link kixWhileError		Error
hi def link kixWhileOK		Conditional
hi def link kixDoError		Error
hi def link kixDoOK			Conditional
hi def link kixIfError		Error
hi def link kixIfOK			Conditional
hi def link kixSelectError		Error
hi def link kixSelectOK		Conditional
hi def link kixForNextError		Error
hi def link kixForNextOK		Conditional
hi def link kixForEachError		Error
hi def link kixForEachOK		Conditional


let b:current_syntax = "kix"

" vim: ts=8 sw=2
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       " Vim syntax file
" Language:	kscript
" Maintainer:	Thomas Capricelli <orzel@yalbi.com>
" URL:		http://aquila.rezel.enst.fr/thomas/vim/kscript.vim
" CVS:		$Id: kscript.vim,v 1.1 2004/06/13 17:40:02 vimboss Exp $

" quit when a syntax file was already loaded
if exists("b:current_syntax")
  finish
endif

syn keyword	kscriptPreCondit	import from

syn keyword	kscriptHardCoded	print println connect length arg mid upper lower isEmpty toInt toFloat findApplication
syn keyword	kscriptConditional	if else switch
syn keyword	kscriptRepeat		while for do foreach
syn keyword	kscriptExceptions	emit catch raise try signal
syn keyword	kscriptFunction		class struct enum
syn keyword	kscriptConst		FALSE TRUE false true
syn keyword	kscriptStatement	return delete
syn keyword	kscriptLabel		case default
syn keyword	kscriptStorageClass	const
syn keyword	kscriptType		in out inout var

syn keyword	kscriptTodo		contained TODO FIXME XXX

syn region	kscriptComment		start="/\*" end="\*/" contains=kscriptTodo
syn match	kscriptComment		"//.*" contains=kscriptTodo
syn match	kscriptComment		"#.*$" contains=kscriptTodo

syn region	kscriptString		start=+'+  end=+'+ skip=+\\\\\|\\'+
syn region	kscriptString		start=+"+  end=+"+ skip=+\\\\\|\\"+
syn region	kscriptString		start=+"""+  end=+"""+
syn region	kscriptString		start=+'''+  end=+'''+

" Define the default highlighting.
" Only when an item doesn't have highlighting yet

hi def link kscriptConditional		Conditional
hi def link kscriptRepeat			Repeat
hi def link kscriptExceptions		Statement
hi def link kscriptFunction		Function
hi def link kscriptConst			Constant
hi def link kscriptStatement		Statement
hi def link kscriptLabel			Label
hi def link kscriptStorageClass		StorageClass
hi def link kscriptType			Type
hi def link kscriptTodo			Todo
hi def link kscriptComment		Comment
hi def link kscriptString			String
hi def link kscriptPreCondit		PreCondit
hi def link kscriptHardCoded		Statement


let b:current_syntax = "kscript"

" vim: ts=8
                                                               " Vim syntax file
" Language:	kimwitu++
" Maintainer:	Michael Piefel <entwurf@piefel.de>
" Last Change:	2 May 2001

" quit when a syntax file was already loaded
if exists("b:current_syntax")
    finish
endif

" Read the C++ syntax to start with
runtime! syntax/cpp.vim
unlet b:current_syntax

" kimwitu++ extentions

" Don't stop at eol, messes around with CPP mode, but gives line spanning
" strings in unparse rules
syn region cCppString		start=+"+ skip=+\\\\\|\\"+ end=+"+ contains=cSpecial,cFormat
syn keyword cType		integer real casestring nocasestring voidptr list
syn keyword cType		uview rview uview_enum rview_enum

" avoid unparsing rule sth:view being scanned as label
syn clear   cUserCont
syn match   cUserCont		"^\s*\I\i*\s*:$" contains=cUserLabel contained
syn match   cUserCont		";\s*\I\i*\s*:$" contains=cUserLabel contained
syn match   cUserCont		"^\s*\I\i*\s*:[^:]"me=e-1 contains=cUserLabel contained
syn match   cUserCont		";\s*\I\i*\s*:[^:]"me=e-1 contains=cUserLabel contained

" highlight phylum decls
syn match   kwtPhylum		"^\I\i*:$"
syn match   kwtPhylum		"^\I\i*\s*{\s*\(!\|\I\)\i*\s*}\s*:$"

syn keyword kwtStatement	with foreach afterforeach provided
syn match kwtDecl		"%\(uviewvar\|rviewvar\)"
syn match kwtDecl		"^%\(uview\|rview\|ctor\|dtor\|base\|storageclass\|list\|attr\|member\|option\)"
syn match kwtOption		"no-csgio\|no-unparse\|no-rewrite\|no-printdot\|no-hashtables\|smart-pointer\|weak-pointer"
syn match kwtSep		"^%}$"
syn match kwtSep		"^%{\(\s\+\I\i*\)*$"
syn match kwtCast		"\<phylum_cast\s*<"me=e-1
syn match kwtCast		"\<phylum_cast\s*$"


" match views, remove paren error in brackets
syn clear cErrInBracket
syn match cErrInBracket		contained ")"
syn match kwtViews		"\(\[\|<\)\@<=[ [:alnum:]_]\{-}:"

" match rule bodies
syn region kwtUnpBody		transparent keepend extend fold start="->\s*\[" start="^\s*\[" skip="\$\@<!{\_.\{-}\$\@<!}" end="\s]\s\=;\=$" end="^]\s\=;\=$" end="}]\s\=;\=$"
syn region kwtRewBody		transparent keepend extend fold start="->\s*<" start="^\s*<" end="\s>\s\=;\=$" end="^>\s\=;\=$"

" Define the default highlighting.
" Only when an item doesn't have highlighting yet

hi def link kwtStatement	cppStatement
hi def link kwtDecl	cppStatement
hi def link kwtCast	cppStatement
hi def link kwtSep	Delimiter
hi def link kwtViews	Label
hi def link kwtPhylum	Type
hi def link kwtOption	PreProc
"hi def link cText	Comment


syn sync lines=300

let b:current_syntax = "kwt"

" vim: ts=8
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          " Vim syntax file
" Language:		lace
" Maintainer:	Jocelyn Fiat <utilities@eiffel.com>
" Last Change:	2001 May 09

" Copyright Interactive Software Engineering, 1998
" You are free to use this file as you please, but
" if you make a change or improvement you must send
" it to the maintainer at <utilities@eiffel.com>


" quit when a syntax file was already loaded
if exists("b:current_syntax")
  finish
endif

" LACE is case insensitive, but the style guide lines are not.

if !exists("lace_case_insensitive")
	syn case match
else
	syn case ignore
endif

" A bunch of useful LACE keywords
syn keyword laceTopStruct		system root default option visible cluster
syn keyword laceTopStruct		external generate end
syn keyword laceOptionClause	collect assertion debug optimize trace
syn keyword laceOptionClause	profile inline precompiled multithreaded
syn keyword laceOptionClause	exception_trace dead_code_removal
syn keyword laceOptionClause	array_optimization
syn keyword laceOptionClause	inlining_size inlining
syn keyword laceOptionClause	console_application dynamic_runtime
syn keyword laceOptionClause	line_generation
syn keyword laceOptionMark		yes no all
syn keyword laceOptionMark		require ensure invariant loop check
syn keyword laceClusterProp		use include exclude
syn keyword laceAdaptClassName	adapt ignore rename as
syn keyword laceAdaptClassName	creation export visible
syn keyword laceExternal		include_path object makefile

" Operators
syn match   laceOperator		"\$"
syn match   laceBrackets		"[[\]]"
syn match   laceExport			"[{}]"

" Constants
syn keyword laceBool		true false
syn keyword laceBool		True False
syn region  laceString		start=+"+ skip=+%"+ end=+"+ contains=laceEscape,laceStringError
syn match   laceEscape		contained "%[^/]"
syn match   laceEscape		contained "%/\d\+/"
syn match   laceEscape		contained "^[ \t]*%"
syn match   laceEscape		contained "%[ \t]*$"
syn match   laceStringError	contained "%/[^0-9]"
syn match   laceStringError	contained "%/\d\+[^0-9/]"
syn match   laceStringError	"'\(%[^/]\|%/\d\+/\|[^'%]\)\+'"
syn match   laceCharacter	"'\(%[^/]\|%/\d\+/\|[^'%]\)'" contains=laceEscape
syn match   laceNumber		"-\=\<\d\+\(_\d\+\)*\>"
syn match   laceNumber		"\<[01]\+[bB]\>"
syn match   laceNumber		"-\=\<\d\+\(_\d\+\)*\.\(\d\+\(_\d\+\)*\)\=\([eE][-+]\=\d\+\(_\d\+\)*\)\="
syn match   laceNumber		"-\=\.\d\+\(_\d\+\)*\([eE][-+]\=\d\+\(_\d\+\)*\)\="
syn match   laceComment		"--.*" contains=laceTodo


syn case match

" Case sensitive stuff

syn keyword laceTodo		TODO XXX FIXME
syn match	laceClassName	"\<[A-Z][A-Z0-9_]*\>"
syn match	laceCluster		"[a-zA-Z][a-zA-Z0-9_]*\s*:"
syn match	laceCluster		"[a-zA-Z][a-zA-Z0-9_]*\s*(\s*[a-zA-Z][a-zA-Z0-9_]*\s*)\s*:"

" Catch mismatched parentheses
syn match laceParenError	")"
syn match laceBracketError	"\]"
syn region laceGeneric		transparent matchgroup=laceBrackets start="\[" end="\]" contains=ALLBUT,laceBracketError
syn region laceParen		transparent start="(" end=")" contains=ALLBUT,laceParenError

" Should suffice for even very long strings and expressions
syn sync lines=40

" Define the default highlighting.
" Only when an item doesn't have highlighting yet

hi def link laceTopStruct			PreProc

hi def link laceOptionClause		Statement
hi def link laceOptionMark			Constant
hi def link laceClusterProp		Label
hi def link laceAdaptClassName		Label
hi def link laceExternal			Statement
hi def link laceCluster			ModeMsg

hi def link laceEscape				Special

hi def link laceBool				Boolean
hi def link laceString				String
hi def link laceCharacter			Character
hi def link laceClassName			Type
hi def link laceNumber				Number

hi def link laceOperator			Special
hi def link laceArray				Special
hi def link laceExport				Special
hi def link laceCreation			Special
hi def link laceBrackets			Special
hi def link laceConstraint			Special

hi def link laceComment			Comment

hi def link laceError				Error
hi def link laceStringError		Error
hi def link laceParenError			Error
hi def link laceBracketError		Error
hi def link laceTodo				Todo


let b:current_syntax = "lace"

" vim: ts=4
                     " Vim syntax file
" Language:	Latte
" Maintainer:	Nick Moffitt, <nick@zork.net>
" Last Change:	14 June, 2000
"
" Notes:
" I based this on the TeX and Scheme syntax files (but mostly scheme).
" See http://www.latte.org for info on the language.

" quit when a syntax file was already loaded
if exists("b:current_syntax")
  finish
endif

syn match latteError "[{}\\]"
syn match latteOther "\\{"
syn match latteOther "\\}"
syn match latteOther "\\\\"

setlocal iskeyword=33,43,45,48-57,63,65-90,95,97-122,_

syn region latteVar matchgroup=SpecialChar start=!\\[A-Za-z_]!rs=s+1 end=![^A-Za-z0-9?!+_-]!me=e-1 contains=ALLBUT,latteNumber,latteOther
syn region latteVar matchgroup=SpecialChar start=!\\[=\&][A-Za-z_]!rs=s+2 end=![^A-Za-z0-9?!+_-]!me=e-1 contains=ALLBUT,latteNumber,latteOther
syn region latteString	start=+\\"+ skip=+\\\\"+ end=+\\"+

syn region latteGroup	matchgroup=Delimiter start="{" skip="\\[{}]" matchgroup=Delimiter end="}" contains=ALLBUT,latteSyntax

syn region latteUnquote matchgroup=Delimiter start="\\,{" skip="\\[{}]" matchgroup=Delimiter end="}" contains=ALLBUT,latteSyntax
syn region latteSplice matchgroup=Delimiter start="\\,@{" skip="\\[{}]" matchgroup=Delimiter end="}" contains=ALLBUT,latteSyntax
syn region latteQuote matchgroup=Delimiter start="\\'{" skip="\\[{}]" matchgroup=Delimiter end="}"
syn region latteQuote matchgroup=Delimiter start="\\`{" skip="\\[{}]" matchgroup=Delimiter end="}" contains=latteUnquote,latteSplice

syn match  latteOperator   '\\/'
syn match  latteOperator   '='

syn match  latteComment	"\\;.*$"

" This was gathered by slurping in the index.

syn keyword latteSyntax __FILE__ __latte-version__ contained
syn keyword latteSyntax _bal-tag _pre _tag add and append apply back contained
syn keyword latteSyntax caar cadr car cdar cddr cdr ceil compose contained
syn keyword latteSyntax concat cons def defmacro divide downcase contained
syn keyword latteSyntax empty? equal? error explode file-contents contained
syn keyword latteSyntax floor foreach front funcall ge?  getenv contained
syn keyword latteSyntax greater-equal? greater? group group? gt? html contained
syn keyword latteSyntax if include lambda le? length less-equal? contained
syn keyword latteSyntax less? let lmap load-file load-library lt?  macro contained
syn keyword latteSyntax member?  modulo multiply not nth operator? contained
syn keyword latteSyntax or ordinary quote process-output push-back contained
syn keyword latteSyntax push-front quasiquote quote random rdc reverse contained
syn keyword latteSyntax set!  snoc splicing unquote strict-html4 contained
syn keyword latteSyntax string-append string-ge?  string-greater-equal? contained
syn keyword latteSyntax string-greater?  string-gt?  string-le? contained
syn keyword latteSyntax string-less-equal?  string-less?  string-lt? contained
syn keyword latteSyntax string?  subseq substr subtract  contained
syn keyword latteSyntax upcase useless warn while zero?  contained


" If it's good enough for scheme...

syn sync match matchPlace grouphere NONE "^[^ \t]"
" ... i.e. synchronize on a line that starts at the left margin

" Define the default highlighting.
" Only when an item doesn't have highlighting yet

hi def link latteSyntax		Statement
hi def link latteVar			Function

hi def link latteString		String
hi def link latteQuote			String

hi def link latteDelimiter		Delimiter
hi def link latteOperator		Operator

hi def link latteComment		Comment
hi def link latteError			Error


let b:current_syntax = "latte"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         " Vim syntax file
" Language:             ld(1) script
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2006-04-19

if exists("b:current_syntax")
  finish
endif

let s:cpo_save = &cpo
set cpo&vim

syn keyword ldTodo          contained TODO FIXME XXX NOTE

syn region  ldComment       start='/\*' end='\*/' contains=ldTodo,@Spell

syn region  ldFileName      start=+"+ end=+"+

syn keyword ldPreProc       SECTIONS MEMORY OVERLAY PHDRS VERSION INCLUDE
syn match   ldPreProc       '\<VERS_\d\+\.\d\+'

syn keyword ldFunction      ABSOLUTE ADDR ALIGN BLOCK DATA_SEGMENT_ALIGN
                            \ DATA_SEGMENT_END DATA_SEGMENT_RELRO_END DEFINED
                            \ LOADADDR MAX MIN NEXT SIZEOF SIZEOF_HEADERS
                            \ sizeof_headers

syn keyword ldKeyword       ENTRY INPUT GROUP OUTPUT
                            \ SEARCH_DIR STARTUP OUTPUT_FORMAT TARGET
                            \ ASSERT EXTERN FORCE_COMMON_ALLOCATION
                            \ INHIBIT_COMMON_ALLOCATION NOCROSSREFS OUTPUT_ARCH
                            \ PROVIDE EXCLUDE_FILE SORT KEEP FILL
                            \ CREATE_OBJECT_SYMBOLS CONSTRUCTORS SUBALIGN
                            \ FILEHDR AT __asm__ ABSOLUTE

syn keyword ldDataType      BYTE SHORT LONG QUAD SQUAD
syn keyword ldOutputType    NOLOAD DSECT COPY INFO OVERLAY
syn keyword ldPTType        PT_NULL PT_LOAD PT_DYNAMIC PT_INTERP
                            \ PT_NOTE PT_SHLIB PT_PHDR

syn keyword ldSpecial       COMMON
syn match   ldSpecial       '/DISCARD/'

syn keyword ldIdentifier    ORIGIN LENGTH

syn match   ldSpecSections  '\.'
syn match   ldSections      '\.\S\+'
syn match   ldSpecSections  '\.\%(text\|data\|bss\|symver\)\>'

syn match   ldNumber        display '\<0[xX]\x\+\>'
syn match   ldNumber        display '\d\+[KM]\>' contains=ldNumberMult
syn match   ldNumberMult    display '\(\d\+\)\@<=[KM]\>'
syn match   ldOctal         contained display '\<0\o\+\>'
                            \ contains=ldOctalZero
syn match   ldOctalZero     contained display '\<0'
syn match   ldOctalError    contained display '\<0\o*[89]\d*\>'


hi def link ldTodo          Todo
hi def link ldComment       Comment
hi def link ldFileName      String
hi def link ldPreProc       PreProc
hi def link ldFunction      Identifier
hi def link ldKeyword       Keyword
hi def link ldType          Type
hi def link ldDataType      ldType
hi def link ldOutputType    ldType
hi def link ldPTType        ldType
hi def link ldSpecial       Special
hi def link ldIdentifier    Identifier
hi def link ldSections      Constant
hi def link ldSpecSections  Special
hi def link ldNumber        Number
hi def link ldNumberMult    PreProc
hi def link ldOctal         ldNumber
hi def link ldOctalZero     PreProc
hi def link ldOctalError    Error

let b:current_syntax = "ld"

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                              " Vim syntax file
" Language:             ldap.conf(5) configuration file.
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2006-12-11

if exists("b:current_syntax")
  finish
endif

let s:cpo_save = &cpo
set cpo&vim

syn keyword ldapconfTodo          contained TODO FIXME XXX NOTE

syn region  ldapconfComment       display oneline start='^\s*#' end='$'
      \                           contains=ldapconfTodo,
      \                                    @Spell

syn match   ldapconfBegin         display '^'
      \                           nextgroup=ldapconfOption,
      \                                     ldapconfDeprOption,
      \                                     ldapconfComment

syn case    ignore

syn keyword ldapconfOption        contained URI 
      \                           nextgroup=ldapconfURI
      \                           skipwhite

syn keyword ldapconfOption        contained
      \                           BASE
      \                           BINDDN
      \                           nextgroup=ldapconfDNAttrType
      \                           skipwhite

syn keyword ldapconfDeprOption    contained 
      \                           HOST
      \                           nextgroup=ldapconfHost
      \                           skipwhite

syn keyword ldapconfDeprOption    contained
      \                           PORT
      \                           nextgroup=ldapconfPort
      \                           skipwhite

syn keyword ldapconfOption        contained
      \                           REFERRALS
      \                           nextgroup=ldapconfBoolean
      \                           skipwhite

syn keyword ldapconfOption        contained
      \                           SIZELIMIT
      \                           TIMELIMIT
      \                           nextgroup=ldapconfInteger
      \                           skipwhite

syn keyword ldapconfOption        contained
      \                           DEREF
      \                           nextgroup=ldapconfDerefWhen
      \                           skipwhite

syn keyword ldapconfOption        contained
      \                           SASL_MECH
      \                           nextgroup=ldapconfSASLMechanism
      \                           skipwhite

syn keyword ldapconfOption        contained
      \                           SASL_REALM
      \                           nextgroup=ldapconfSASLRealm
      \                           skipwhite

syn keyword ldapconfOption        contained
      \                           SASL_AUTHCID
      \                           SASL_AUTHZID
      \                           nextgroup=ldapconfSASLAuthID
      \                           skipwhite

syn keyword ldapconfOption        contained
      \                           SASL_SECPROPS
      \                           nextgroup=ldapconfSASLSecProps
      \                           skipwhite

syn keyword ldapconfOption        contained
      \                           TLS_CACERT
      \                           TLS_CERT
      \                           TLS_KEY
      \                           TLS_RANDFILE
      \                           nextgroup=ldapconfFilename
      \                           skipwhite

syn keyword ldapconfOption        contained
      \                           TLS_CACERTDIR
      \                           nextgroup=ldapconfPath
      \                           skipwhite

syn keyword ldapconfOption        contained
      \                           TLS_CIPHER_SUITE
      \                           nextgroup=@ldapconfTLSCipher
      \                           skipwhite

syn keyword ldapconfOption        contained
      \                           TLS_REQCERT
      \                           nextgroup=ldapconfTLSCertCheck
      \                           skipwhite

syn keyword ldapconfOption        contained
      \                           TLS_CRLCHECK
      \                           nextgroup=ldapconfTLSCRLCheck
      \                           skipwhite

syn case    match

syn match   ldapconfURI           contained display
      \                           'ldaps\=://[^[:space:]:]\+\%(:\d\+\)\='
      \                           nextgroup=ldapconfURI
      \                           skipwhite

" LDAP Distinguished Names are defined in Section 3 of RFC 2253:
" http://www.ietf.org/rfc/rfc2253.txt.
syn match   ldapconfDNAttrType    contained display
      \                           '\a[a-zA-Z0-9-]\+\|\d\+\%(\.\d\+\)*'
      \                           nextgroup=ldapconfDNAttrTypeEq

syn match   ldapconfDNAttrTypeEq  contained display
      \                           '='
      \                           nextgroup=ldapconfDNAttrValue

syn match   ldapconfDNAttrValue   contained display
      \                           '\%([^,=+<>#;\\"]\|\\\%([,=+<>#;\\"]\|\x\x\)\)*\|#\%(\x\x\)\+\|"\%([^\\"]\|\\\%([,=+<>#;\\"]\|\x\x\)\)*"'
      \                           nextgroup=ldapconfDNSeparator

syn match   ldapconfDNSeparator   contained display
      \                           '[+,]'
      \                           nextgroup=ldapconfDNAttrType

syn match   ldapconfHost          contained display
      \                           '[^[:space:]:]\+\%(:\d\+\)\='
      \                           nextgroup=ldapconfHost
      \                           skipwhite

syn match   ldapconfPort          contained display
      \                           '\d\+'

syn keyword ldapconfBoolean       contained
      \                           on
      \                           true
      \                           yes
      \                           off
      \                           false
      \                           no

syn match   ldapconfInteger       contained display
      \                           '\d\+'

syn keyword ldapconfDerefWhen     contained
      \                           never
      \                           searching
      \                           finding
      \                           always

" Taken from http://www.iana.org/assignments/sasl-mechanisms.
syn keyword ldapconfSASLMechanism contained
      \                           KERBEROS_V4
      \                           GSSAPI
      \                           SKEY
      \                           EXTERNAL
      \                           ANONYMOUS
      \                           OTP
      \                           PLAIN
      \                           SECURID
      \                           NTLM
      \                           NMAS_LOGIN
      \                           NMAS_AUTHEN
      \                           KERBEROS_V5

syn match   ldapconfSASLMechanism contained display
      \                           'CRAM-MD5\|GSS-SPNEGO\|DIGEST-MD5\|9798-[UM]-\%(RSA-SHA1-ENC\|\%(EC\)\=DSA-SHA1\)\|NMAS-SAMBA-AUTH'

" TODO: I have been unable to find a definition for a SASL realm,
" authentication identity, and proxy authorization identity.
syn match   ldapconfSASLRealm     contained display
      \                           '\S\+'

syn match   ldapconfSASLAuthID    contained display
      \                           '\S\+'

syn keyword ldapconfSASLSecProps  contained
      \                           none
      \                           noplain
      \                           noactive
      \                           nodict
      \                           noanonymous
      \                           forwardsec
      \                           passcred
      \                           nextgroup=ldapconfSASLSecPSep

syn keyword ldapconfSASLSecProps  contained
      \                           minssf
      \                           maxssf
      \                           maxbufsize
      \                           nextgroup=ldapconfSASLSecPEq

syn match   ldapconfSASLSecPEq    contained display
      \                           '='
      \                           nextgroup=ldapconfSASLSecFactor

syn match   ldapconfSASLSecFactor contained display
      \                           '\d\+'
      \                           nextgroup=ldapconfSASLSecPSep

syn match   ldapconfSASLSecPSep   contained display
      \                           ','
      \                           nextgroup=ldapconfSASLSecProps

syn match   ldapconfFilename      contained display
      \                           '.\+'

syn match   ldapconfPath          contained display
      \                           '.\+'

" Defined in openssl-ciphers(1).
" TODO: Should we include the stuff under CIPHER SUITE NAMES?
syn cluster ldapconfTLSCipher     contains=ldapconfTLSCipherOp,
      \                                    ldapconfTLSCipherName,
      \                                    ldapconfTLSCipherSort

syn match   ldapconfTLSCipherOp   contained display
      \                           '[+!-]'
      \                           nextgroup=ldapconfTLSCipherName

syn keyword ldapconfTLSCipherName contained
      \                           DEFAULT
      \                           COMPLEMENTOFDEFAULT
      \                           ALL
      \                           COMPLEMENTOFALL
      \                           HIGH
      \                           MEDIUM
      \                           LOW
      \                           EXP
      \                           EXPORT
      \                           EXPORT40
      \                           EXPORT56
      \                           eNULL
      \                           NULL
      \                           aNULL
      \                           kRSA
      \                           RSA
      \                           kEDH
      \                           kDHr
      \                           kDHd
      \                           aRSA
      \                           aDSS
      \                           DSS
      \                           aDH
      \                           kFZA
      \                           aFZA
      \                           eFZA
      \                           FZA
      \                           TLSv1
      \                           SSLv3
      \                           SSLv2
      \                           DH
      \                           ADH
      \                           AES
      \                           3DES
      \                           DES
      \                           RC4
      \                           RC2
      \                           IDEA
      \                           MD5
      \                           SHA1
      \                           SHA
      \                           Camellia
      \                           nextgroup=ldapconfTLSCipherSep

syn match   ldapconfTLSCipherSort contained display
      \                           '@STRENGTH'
      \                           nextgroup=ldapconfTLSCipherSep

syn match   ldapconfTLSCipherSep  contained display
      \                           '[:, ]'
      \                           nextgroup=@ldapconfTLSCipher

syn keyword ldapconfTLSCertCheck  contained
      \                           never
      \                           allow
      \                           try
      \                           demand
      \                           hard

syn keyword ldapconfTLSCRLCheck   contained
      \                           none
      \                           peer
      \                           all

hi def link ldapconfTodo          Todo
hi def link ldapconfComment       Comment
hi def link ldapconfOption        Keyword
hi def link ldapconfDeprOption    Error
hi def link ldapconfString        String
hi def link ldapconfURI           ldapconfString
hi def link ldapconfDNAttrType    Identifier
hi def link ldapconfOperator      Operator
hi def link ldapconfEq            ldapconfOperator
hi def link ldapconfDNAttrTypeEq  ldapconfEq
hi def link ldapconfValue         ldapconfString
hi def link ldapconfDNAttrValue   ldapconfValue
hi def link ldapconfSeparator     ldapconfOperator
hi def link ldapconfDNSeparator   ldapconfSeparator
hi def link ldapconfHost          ldapconfURI
hi def link ldapconfNumber        Number
hi def link ldapconfPort          ldapconfNumber
hi def link ldapconfBoolean       Boolean
hi def link­‰                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ldapconfInteger       ldapconfNumber
hi def link ldapconfType          Type
hi def link ldapconfDerefWhen     ldapconfType
hi def link ldapconfDefine        Define
hi def link ldapconfSASLMechanism ldapconfDefine
hi def link ldapconfSASLRealm     ldapconfURI
hi def link ldapconfSASLAuthID    ldapconfValue
hi def link ldapconfSASLSecProps  ldapconfType
hi def link ldapconfSASLSecPEq    ldapconfEq
hi def link ldapconfSASLSecFactor ldapconfNumber
hi def link ldapconfSASLSecPSep   ldapconfSeparator
hi def link ldapconfFilename      ldapconfString
hi def link ldapconfPath          ldapconfFilename
hi def link ldapconfTLSCipherOp   ldapconfOperator
hi def link ldapconfTLSCipherName ldapconfDefine
hi def link ldapconfSpecial       Special
hi def link ldapconfTLSCipherSort ldapconfSpecial
hi def link ldapconfTLSCipherSep  ldapconfSeparator
hi def link ldapconfTLSCertCheck  ldapconfType
hi def link ldapconfTLSCRLCheck   ldapconfType

let b:current_syntax = "ldapconf"

let &cpo = s:cpo_save
unlet s:cpo_save
          " Vim syntax file
" Language:	LDAP LDIF
" Maintainer:	Zak Johnson <zakj@nox.cx>
" Last Change:	2003-12-30

" quit when a syntax file was already loaded
if exists("b:current_syntax")
  finish
endif

syn sync minlines=10 linebreaks=1

syn match ldifAttribute /^[^ #][^:]*/ contains=ldifOption display
syn match ldifOption /;[^:]\+/ contained contains=ldifPunctuation display
syn match ldifPunctuation /;/ contained display

syn region ldifStringValue matchgroup=ldifPunctuation start=/: /  end=/\_$/ skip=/\n /
syn region ldifBase64Value matchgroup=ldifPunctuation start=/:: / end=/\_$/ skip=/\n /
syn region ldifFileValue   matchgroup=ldifPunctuation start=/:< / end=/\_$/ skip=/\n /

syn region ldifComment start=/^#/ end=/\_$/ skip=/\n /


hi def link ldifAttribute		Type
hi def link ldifOption		Identifier
hi def link ldifPunctuation	Normal
hi def link ldifStringValue	String
hi def link ldifBase64Value	Special
hi def link ldifFileValue		Special
hi def link ldifComment		Comment


let b:current_syntax = "ldif"
          " Vim syntax file
" Language:	less
" Maintainer:	Alessandro Vioni <jenoma@gmail.com>
" URL: https://github.com/genoma/vim-less
" Last Change:	2020 Sep 29

if exists("b:current_syntax")
  finish
endif

runtime! syntax/css.vim

syn case ignore

syn cluster lessCssProperties contains=cssFontProp,cssFontDescriptorProp,cssColorProp,cssTextProp,cssBoxProp,cssGeneratedContentProp,cssPagingProp,cssUIProp,cssRenderProp,cssAuralProp,cssTableProp
syn cluster lessCssAttributes contains=css.*Attr,lessEndOfLineComment,lessComment,cssValue.*,cssColor,cssURL,lessDefault,cssImportant,cssError,cssStringQ,cssStringQQ,cssFunction,cssUnicodeEscape,cssRenderProp

syn region lessDefinition matchgroup=cssBraces start="{" end="}" contains=TOP

syn match lessProperty "\%([{};]\s*\|^\)\@<=\%([[:alnum:]-]\|#{[^{}]*}\)\+\s*:" contains=css.*Prop skipwhite nextgroup=lessCssAttribute contained containedin=lessDefinition
syn match lessProperty "^\s*\zs\s\%(\%([[:alnum:]-]\|#{[^{}]*}\)\+\s*:\|:[[:alnum:]-]\+\)"hs=s+1 contains=css.*Prop skipwhite nextgroup=lessCssAttribute
syn match lessProperty "^\s*\zs\s\%(:\=[[:alnum:]-]\+\s*=\)"hs=s+1 contains=css.*Prop skipwhite nextgroup=lessCssAttribute
syn match lessCssAttribute +\%("\%([^"]\|\\"\)*"\|'\%([^']\|\\'\)*'\|#{[^{}]*}\|[^{};]\)*+ contained contains=@lessCssAttributes,lessVariable,lessFunction,lessInterpolation
syn match lessDefault "!default\>" contained

" less variables and media queries
syn match lessVariable "@[[:alnum:]_-]\+" nextgroup=lessCssAttribute skipwhite
syn match lessMedia "@media" nextgroup=lessCssAttribute skipwhite

" Less functions
syn match lessFunction "\<\%(escape\|e\|unit\)\>(\@=" contained
syn match lessFunction "\<\%(ceil\|floor\|percentage\|round\|sqrt\|abs\|sin\|asin\|cos\|acos\|tan\|atan\|pi\|pow\|min\|max\)\>(\@=" contained
syn match lessFunction "\<\%(rgb\|rgba\|argb\|argb\|hsl\|hsla\|hsv\|hsva\)\>(\@=" contained
syn match lessFunction "\<\%(hue\|saturation\|lightness\|red\|green\|blue\|alpha\|luma\)\>(\@=" contained
syn match lessFunction "\<\%(saturate\|desaturate\|lighten\|darken\|fadein\|fadeout\|fade\|spin\|mix\|greyscale\|contrast\)\>(\@=" contained
syn match lessFunction "\<\%(multiply\|screen\|overlay\|softlight\|hardlight\|difference\|exclusion\|average\|negation\)\>(\@=" contained

" Less id class visualization
syn match lessIdChar     "#[[:alnum:]_-]\@=" nextgroup=lessId,lessClassIdCall
syn match lessId         "[[:alnum:]_-]\+" contained
syn match lessClassIdCall  "[[:alnum:]_-]\+()" contained

syn match lessClassChar  "\.[[:alnum:]_-]\@=" nextgroup=lessClass,lessClassCall
syn match lessClass      "[[:alnum:]_-]\+" contained
syn match lessClassCall  "[[:alnum:]_-]\+()" contained

syn match lessAmpersand  "&" contains=lessIdChar,lessClassChar

syn region lessInclude start="@import" end=";\|$" contains=lessComment,cssURL,cssUnicodeEscape,cssMediaType,cssStringQ,cssStringQQ

syn keyword lessTodo        FIXME NOTE TODO OPTIMIZE XXX contained
syn region  lessComment     start="^\z(\s*\)//"  end="^\%(\z1 \)\@!" contains=lessTodo,@Spell
syn region  lessCssComment  start="^\z(\s*\)/\*" end="^\%(\z1 \)\@!" contains=lessTodo,@Spell
syn match   lessEndOfLineComment "//.*" contains=lessComment,lessTodo,@Spell

hi def link lessEndOfLineComment        lessComment
hi def link lessCssComment              lessComment
hi def link lessComment                 Comment
hi def link lessDefault                 cssImportant
hi def link lessVariable                Identifier
hi def link lessFunction                PreProc
hi def link lessTodo                    Todo
hi def link lessInclude                 Include
hi def link lessIdChar                  Special
hi def link lessClassChar               Special
hi def link lessAmpersand               Character
hi def link lessId                      Identifier
hi def link lessClass                   Type
hi def link lessCssAttribute            PreProc
hi def link lessClassCall               Type
hi def link lessClassIdCall             Type
hi def link lessTagName                 cssTagName
hi def link lessDeprecated              cssDeprecated
hi def link lessMedia                   cssMedia

let b:current_syntax = "less"

" vim:set sw=2:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             " Vim syntax file
" Language:	Lex and Flex
" Maintainer:	Charles E. Campbell <NcampObell@SdrPchip.AorgM-NOSPAM>
" Contributor:	Robert A. van Engelen <engelen@acm.org>
" Last Change:	Apr 24, 2020
" Version:	18

" quit when a syntax file was already loaded
if exists("b:current_syntax")
  finish
endif

" Read the C++ syntax to start with
let s:Cpath= fnameescape(expand("<sfile>:p:h")."/cpp.vim")
if !filereadable(s:Cpath)
 for s:Cpath in split(globpath(&rtp,"syntax/cpp.vim"),"\n")
  if filereadable(fnameescape(s:Cpath))
   let s:Cpath= fnameescape(s:Cpath)
   break
  endif
 endfor
endif
exe "syn include @lexCcode ".s:Cpath

" --- ========= ---
" --- Lex stuff ---
" --- ========= ---

" Definitions
" %%
" Rules
" %%
" User Code
"
" --- ======= ---
" --- Example ---
" --- ======= ---
"
"   // this is a valid lex file
"   // indented initial code block
"   #include <stdlib.h>
" %{
" // initial code block
" #include <stdio.h>
" const char *sep = "";
" %}
" %option outfile="scanner.c" noyywrap nodefault
" %x COMMENT
" id      [A-Za-z_][A-Za-z0-9_]*
" %%
"   // indented initial action code block
"   printf("BEGIN");
" {id}    printf("%s%s", sep, yytext); sep = "";
" .       |
" \n      { sep = "\n"; }
" "/*"    { BEGIN COMMENT; }
" "//".*  { }
" <COMMENT>{
" "*/"    { BEGIN INITIAL; }
" .|\n    
" }
" <*><<EOF>> { // end of file
"              printf("\nEND\n");
"              yyterminate();
"            }
" %%
" void scan()
" {
"   while (yylex())
"     continue;
" }
" /* main program */
" int main()
" { 
"   scan();
" }   

" Definitions Section with initial code blocks, abbreviations, options, states
if has("folding")
 syn region lexAbbrvBlock	fold	start="^\S"	end="^\ze%%"	skipnl	nextgroup=lexPatBlock	contains=lexOptions,lexAbbrv,lexInitialCodeBlock,lexInclude,lexAbbrvComment,lexStartState
else
 syn region lexAbbrvBlock		start="^\S"	end="^\ze%%"	skipnl	nextgroup=lexPatBlock	contains=lexOptions,lexAbbrv,lexInitialCodeBlock,lexInclude,lexAbbrvComment,lexStartState
endif
syn match  lexOptions		"^%\a\+\(\s.*\|[^{]*\)$"				contains=lexOptionsEq,lexPatString,lexSlashQuote,lexBrace,lexSlashBrace
syn match  lexOptionsEq		"="					skipwhite	contained
syn match  lexAbbrv		"^\I\i*\s"me=e-1			skipwhite	contained	nextgroup=lexAbbrvPat
syn match  lexAbbrvPat		"\s\S.*$"lc=1						contained	contains=lexPatAbbrv,lexPatString,lexSlashQuote,lexBrace,lexSlashBrace	nextgroup=lexAbbrv,lexInclude
syn match  lexStartState	"^%\(xs\?\|s\)\(t\(a\(t\(e\?\)\?\)\?\)\?\)\?\(\s\+\I\i*\)\+\s*$"	contained	contains=lexStartStateCmd
syn match  lexStartStateCmd	'^%\(xs\?\|s\)\(t\(a\(t\(e\?\)\?\)\?\)\?\)\?'	contained
if has("folding")
 syn region lexInitialCodeBlock	fold				start="^\s\+"	end="^\S"me=e-1			contains=@lexCcode
 syn region lexInclude		fold	matchgroup=lexSep	start="^%\a*{"	end="^%\?}"	contained	contains=@lexCcode,lexCFunctions
 syn region lexAbbrvComment	fold				start="^\s*//"	end="$"		contains=@Spell
 syn region lexAbbrvComment	fold				start="^\s*/\*"	end="\*/"	contains=@Spell
else
 syn region lexInitialCodeBlock					start="^\s\+"	end="^\S"me=e-1			contains=@lexCcode
 syn region lexInclude			matchgroup=lexSep	start="^%\a*{"	end="^%\?}"	contained	contains=@lexCcode,lexCFunctions
 syn region lexAbbrvComment					start="^\s*//"	end="$"		contains=@Spell
 syn region lexAbbrvComment					start="^\s*/\*"	end="\*/"	contains=@Spell
endif

" Rules Section with patterns and actions
if has("folding")
 syn region lexPatBlock		fold	matchgroup=Todo		start="^%%"	matchgroup=Todo		end="^\ze%%"	skipnl	skipwhite	nextgroup=lexFinalCodeBlock	contains=lexPatTag,lexPatTagZone,lexPatComment,lexPat,lexPatSep,lexPatInclude
 syn region lexPat		fold				start="\S"	skip="\\\\\|\\\s"	end="\ze\(\s*$\|\s\+\(\h\|{\W\|{$\|[-+*]\|//\|/\*\)\)"	skipwhite	contained nextgroup=lexMorePat,lexPatSep,lexPatEnd	contains=lexPatTag,lexPatString,lexSlashQuote,lexPatAbbrv,lexBrace,lexSlashBrace
 syn region lexPatInclude	fold	matchgroup=lexSep	start="^%{"	end="^%}"	contained	contains=@lexCcode
 syn region lexBrace		fold	matchgroup=Character	start="\["	skip="\\.\|\[:\a\+:\]\|\[\.\a\+\.\]\|\[=.=\]"	end="\]"	contained
 syn region lexPatString	fold	matchgroup=String	start=+"+	skip=+\\\\\|\\"+	matchgroup=String	end=+"+	contained
else
 syn region lexPatBlock			matchgroup=Todo		start="^%%"	matchgroup=Todo		end="^\ze%%"	skipnl	skipwhite	nextgroup=lexFinalCodeBlock	contains=lexPatTag,lexPatTagZone,lexPatComment,lexPat,lexPatSep,lexPatInclude
 syn region lexPat						start="\S"	skip="\\\\\|\\\s"	end="\ze\(\s*$\|\s\+\(\h\|{\W\|{$\|[-+*]\|//\|/\*\)\)"	skipwhite	contained nextgroup=lexMorePat,lexPatSep,lexPatEnd	contains=lexPatTag,lexPatString,lexSlashQuote,lexPatAbbrv,lexBrace,lexSlashBrace
 syn region lexPatInclude		matchgroup=lexSep	start="^%{"	end="^%}"	contained	contains=@lexCcode
 syn region lexBrace			matchgroup=Character	start="\["	skip="\\.\|\[:\a\+:\]\|\[\.\a\+\.\]\|\[=.=\]"	end="\]"	contained
 syn region lexPatString		matchgroup=String	start=+"+	skip=+\\\\\|\\"+	matchgroup=String	end=+"+	contained
endif
syn match  lexPatAbbrv		"{\I\i*}"hs=s+1,he=e-1					contained
syn match  lexPatTag		"^<\^\?\(\I\i*\|\*\)\(,\^\?\(\I\i*\|\*\)\)*>"		contained	nextgroup=lexPat,lexMorePat,lexPatSep,lexPatEnd
syn match  lexPatTagZone	"^<\^\?\(\I\i*\|\*\)\(,\^\?\(\I\i*\|\*\)\)*>\s*{$"me=e-1	contained	nextgroup=lexPatTagZoneStart

if has("folding")
 syn region lexPatTagZoneStart	fold	matchgroup=lexPatTag	start='{$'	end='^}'	skipnl	skipwhite	contained	contains=lexPatTag,lexPatTagZone,lexPatComment,lexPat,lexPatSep,lexPatInclude
 syn region lexPatComment	fold	start="//"	end="$"		skipnl	contained	contains=cTodo	skipwhite	nextgroup=lexPatComment,lexPat,@Spell
 syn region lexPatComment	fold	start="/\*"	end="\*/"	skipnl	contained	contains=cTodo	skipwhite	nextgroup=lexPatComment,lexPat,@Spell
else
 syn region lexPatTagZoneStart		matchgroup=lexPatTag		start='{'	end='^}'	skipnl	skipwhite	contained	contains=lexPatTag,lexPatTagZone,lexPatComment,lexPat,lexPatSep,lexPatInclude
 syn region lexPatComment		start="//"	end="$"		skipnl	contained	contains=cTodo	skipwhite	nextgroup=lexPatComment,lexPat,@Spell
 syn region lexPatComment		start="/\*"	end="\*/"	skipnl	contained	contains=cTodo	skipwhite	nextgroup=lexPatComment,lexPat,@Spell
endif
syn match  lexPatEnd		"\s*$"				skipnl	contained
syn match  lexPatCodeLine	"[^{\[].*"				contained	contains=@lexCcode,lexCFunctions
syn match  lexMorePat		"\s*|\s*$"			skipnl	contained	nextgroup=lexPat,lexPatTag,lexPatComment
syn match  lexPatSep		"\s\+"					contained	nextgroup=lexMorePat,lexPatCode,lexPatCodeLine
syn match  lexSlashQuote	+\(\\\\\)*\\"+				contained
syn match  lexSlashBrace	+\(\\\\\)*\\\[+				contained
if has("folding")
 syn region lexPatCode		fold	matchgroup=Delimiter	start="{"	end="}"	skipnl	contained	contains=@lexCcode,lexCFunctions
else
 syn region lexPatCode			matchgroup=Delimiter	start="{"	end="}"	skipnl	contained	contains=@lexCcode,lexCFunctions
endif

" User Code Section with final code block
syn region lexFinalCodeBlock	matchgroup=Todo	start="^%%"	end="\%$"	contained	contains=@lexCcode

" Lex macros which may appear in C/C++ code blocks
syn keyword lexCFunctions	BEGIN	ECHO	REJECT	yytext	YYText	yyleng	YYLeng	yymore	yyless	yywrap	yylook
syn keyword lexCFunctions	yyrestart	yyterminate	yylineno	yycolumno	yyin	yyout
syn keyword lexCFunctions	input	unput	output		winput		wunput		woutput
syn keyword lexCFunctions	yyinput	yyunput	yyoutput	yywinput	yywunput	yywoutput

" <c.vim> includes several ALLBUTs; these have to be treated so as to exclude lex* groups
syn cluster cParenGroup		add=lex.*
syn cluster cDefineGroup	add=lex.*
syn cluster cPreProcGroup	add=lex.*
syn cluster cMultiGroup		add=lex.*

" Synchronization
syn sync clear
syn sync minlines=500
syn sync match lexSyncPat	grouphere  lexPatBlock	"^%[a-zA-Z]"
syn sync match lexSyncPat	groupthere lexPatBlock	"^<$"
syn sync match lexSyncPat	groupthere lexPatBlock	"^%%"

" The default highlighting.
if !exists("skip_lex_syntax_inits")
 hi def link lexAbbrvComment	lexPatComment
 hi def link lexAbbrvPat	lexPat
 hi def link lexAbbrv		Special
 hi def link lexBrace		lexPat
 hi def link lexCFunctions	PreProc
 hi def link lexMorePat		Special
 hi def link lexOptions		PreProc
 hi def link lexOptionsEq	Operator
 hi def link lexPatComment	Comment
 hi def link lexPat		Function
 hi def link lexPatString	lexPat
 hi def link lexPatAbbrv	Special
 hi def link lexPatTag		Statement
 hi def link lexPatTagZone	lexPatTag
 hi def link lexSep		Delimiter
 hi def link lexSlashQuote	lexPat
 hi def link lexSlashBrace	lexPat
 hi def link lexStartState	lexPatTag
 hi def link lexStartStateCmd	Special
endif

let b:current_syntax = "lex"

" vim:ts=8
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     " Vim syntax file
" Language:             lftp(1) configuration file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2007-06-17

if exists("b:current_syntax")
  finish
endif

let s:cpo_save = &cpo
set cpo&vim

setlocal iskeyword+=-

syn region  lftpComment         display oneline start='#' end='$'
                                \ contains=lftpTodo,@Spell

syn keyword lftpTodo            contained TODO FIXME XXX NOTE

syn region  lftpString          contained display
                                \ start=+"+ skip=+\\$\|\\"+ end=+"+ end=+$+

syn match   lftpNumber          contained display '\<\d\+\(\.\d\+\)\=\>'

syn keyword lftpBoolean         contained yes no on off true false

syn keyword lftpInterval        contained infinity inf never forever
syn match   lftpInterval        contained '\<\(\d\+\(\.\d\+\)\=[dhms]\)\+\>'

syn keyword lftpKeywords        alias anon at bookmark cache cat cd chmod close
                                \ cls command debug du echo exit fg find get
                                \ get1 glob help history jobs kill lcd lftp
                                \ lpwd ls mget mirror mkdir module more mput
                                \ mrm mv nlist open pget put pwd queue quote
                                \ reget recls rels renlist repeat reput rm
                                \ rmdir scache site source suspend user version
                                \ wait zcat zmore

syn region  lftpSet             matchgroup=lftpKeywords
                                \ start="set" end=";" end="$"
                                \ contains=lftpString,lftpNumber,lftpBoolean,
                                \ lftpInterval,lftpSettingsPrefix,lftpSettings
syn match   lftpSettingsPrefix  contained '\<\%(bmk\|cache\|cmd\|color\|dns\):'
syn match   lftpSettingsPrefix  contained '\<\%(file\|fish\|ftp\|hftp\):'
syn match   lftpSettingsPrefix  contained '\<\%(http\|https\|mirror\|module\):'
syn match   lftpSettingsPrefix  contained '\<\%(net\|sftp\|ssl\|xfer\):'
" bmk:
syn keyword lftpSettings        contained save-p[asswords]
" cache:
syn keyword lftpSettings        contained cache-em[pty-listings] en[able]
                                \ exp[ire] siz[e]
" cmd:
syn keyword lftpSettings        contained at[-exit] cls-c[ompletion-default]
                                \ cls-d[efault] cs[h-history]
                                \ default-p[rotocol] default-t[itle]
syn keyword lftpSettings        contained fai[l-exit] in[teractive]
                                \ lo[ng-running] ls[-default] mo[ve-background]
                                \ prom[pt]
                                \ rem[ote-completion]
                                \ save-c[wd-history] save-r[l-history]
                                \ set-t[erm-status] statu[s-interval]
                                \ te[rm-status] verb[ose] verify-h[ost]
                                \ verify-path verify-path[-cached]
" color:
syn keyword lftpSettings        contained dir[-colors] use-c[olor]
" dns:
syn keyword lftpSettings        contained S[RV-query] cache-en[able]
                                \ cache-ex[pire] cache-s[ize]
                                \ fat[al-timeout] o[rder] use-fo[rk]
" file:
syn keyword lftpSettings        contained ch[arset]
" fish:
syn keyword lftpSettings        contained connect[-program] sh[ell]
" ftp:
syn keyword lftpSettings        contained acct anon-p[ass] anon-u[ser]
                                \ au[to-sync-mode] b[ind-data-socket]
                                \ ch[arset] cli[ent] dev[ice-prefix]
                                \ fi[x-pasv-address] fxp-f[orce]
                                \ fxp-p[assive-source] h[ome] la[ng]
                                \ list-e[mpty-ok] list-o[ptions]
                                \ nop[-interval] pas[sive-mode]
                                \ port-i[pv4] port-r[ange] prox[y]
                                \ rest-l[ist] rest-s[tor]
                                \ retry-530 retry-530[-anonymous]
                                \ sit[e-group] skey-a[llow]
                                \ skey-f[orce] ssl-allow
                                \ ssl-allow[-anonymous] ssl-au[th]
                                \ ssl-f[orce] ssl-protect-d[ata]
                                \ ssl-protect-l[ist] stat-[interval]
                                \ sy[nc-mode] timez[one] use-a[bor]
                                \ use-fe[at] use-fx[p] use-hf[tp]
                                \ use-mdtm use-mdtm[-overloaded]
                                \ use-ml[sd] use-p[ret] use-q[uit]
                                \ use-site-c[hmod] use-site-i[dle]
                                \ use-site-u[time] use-siz[e]
                                \ use-st[at] use-te[lnet-iac]
                                \ verify-a[ddress] verify-p[ort]
                                \ w[eb-mode]
" hftp:
syn keyword lftpSettings        contained w[eb-mode] cache prox[y]
                                \ use-au[thorization] use-he[ad] use-ty[pe]
" http:
syn keyword lftpSettings        contained accept accept-c[harset]
                                \ accept-l[anguage] cache coo[kie]
                                \ pos[t-content-type] prox[y]
                                \ put-c[ontent-type] put-m[ethod] ref[erer]
                                \ set-c[ookies] user[-agent]
" https:
syn keyword lftpSettings        contained prox[y]
" mirror:
syn keyword lftpSettings        contained exc[lude-regex] o[rder]
                                \ parallel-d[irectories]
                                \ parallel-t[ransfer-count] use-p[get-n]
" module:
syn keyword lftpSettings        contained pat[h]
" net:
syn keyword lftpSettings        contained connection-l[imit]
                                \ connection-t[akeover] id[le] limit-m[ax]
                                \ limit-r[ate] limit-total-m[ax]
                                \ limit-total-r[ate] max-ret[ries] no-[proxy]
                                \ pe[rsist-retries] reconnect-interval-b[ase]
                                \ reconnect-interval-ma[x]
                                \ reconnect-interval-mu[ltiplier]
                                \ socket-bind-ipv4 socket-bind-ipv6
                                \ socket-bu[ffer] socket-m[axseg] timeo[ut]
" sftp:
syn keyword lftpSettings        contained connect[-program]
                                \ max-p[ackets-in-flight] prot[ocol-version]
                                \ ser[ver-program] size-r[ead] size-w[rite]
" ssl:
syn keyword lftpSettings        contained ca-f[ile] ca-p[ath] ce[rt-file]
                                \ crl-f[ile] crl-p[ath] k[ey-file]
                                \ verify-c[ertificate]
" xfer:
syn keyword lftpSettings        contained clo[bber] dis[k-full-fatal]
                                \ eta-p[eriod] eta-t[erse] mak[e-backup]
                                \ max-red[irections] ra[te-period]

hi def link lftpComment         Comment
hi def link lftpTodo            Todo
hi def link lftpString          String
hi def link lftpNumber          Number
hi def link lftpBoolean         Boolean
hi def link lftpInterval        Number
hi def link lftpKeywords        Keyword
hi def link lftpSettingsPrefix  PreProc
hi def link lftpSettings        Type

let b:current_syntax = "lftp"

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 " Vim syntax file
" Language:		Haskell with literate comments, Bird style,
"			Markdown style, TeX style and plain text surrounding
"			\begin{code} \end{code} blocks
" Maintainer:		Haskell Cafe mailinglist <haskell-cafe@haskell.org>
" Original Author:	Arthur van Leeuwen <arthurvl@cs.uu.nl>
" Last Change:		2020 Feb 25
" Version:		1.05
"
" Thanks to Ian Lynagh for thoughtful comments on initial versions and
" for the inspiration for writing this in the first place.
"
" This style guesses as to the type of markup used in a literate haskell
" file and will highlight (La)TeX markup if it finds any
" This behaviour can be overridden, both glabally and locally using
" the lhs_markup variable or b:lhs_markup variable respectively.
"
" lhs_markup	    must be set to either  tex	or  none  to indicate that
"		    you always want (La)TeX highlighting or no highlighting
"		    must not be set to let the highlighting be guessed
" b:lhs_markup	    must be set to eiterh  tex	or  none  to indicate that
"		    you want (La)TeX highlighting or no highlighting for
"		    this particular buffer
"		    must not be set to let the highlighting be guessed
"
"
" 2004 February 18: New version, based on Ian Lynagh's TeX guessing
"		    lhaskell.vim, cweb.vim, tex.vim, sh.vim and fortran.vim
" 2004 February 20: Cleaned up the guessing and overriding a bit
" 2004 February 23: Cleaned up syntax highlighting for \begin{code} and
"		    \end{code}, added some clarification to the attributions
" 2008 July 1:      Removed % from guess list, as it totally breaks plain
"                   text markup guessing
" 2009 April 29:    Fixed highlighting breakage in TeX mode, 
"                   thanks to Kalman Noel
"


" quit when a syntax file was already loaded
if exists("b:current_syntax")
  finish
endif

" First off, see if we can inherit a user preference for lhs_markup
if !exists("b:lhs_markup")
    if exists("lhs_markup")
	if lhs_markup =~ '\<\%(tex\|md\|none\)\>'
	    let b:lhs_markup = matchstr(lhs_markup,'\<\%(tex\|md\|none\)\>')
	else
	    echohl WarningMsg | echo "Unknown value of lhs_markup" | echohl None
	    let b:lhs_markup = "unknown"
	endif
    else
	let b:lhs_markup = "unknown"
    endif
else
    if b:lhs_markup !~ '\<\%(tex\|md\|none\)\>'
	let b:lhs_markup = "unknown"
    endif
endif

" Remember where the cursor is, and go to upperleft
let s:oldline=line(".")
let s:oldcolumn=col(".")
call cursor(1,1)

" If no user preference, scan buffer for our guess of the markup to
" highlight. We only differentiate between TeX and plain markup, where
" plain is not highlighted. The heuristic for finding TeX markup is if
" one of the following occurs anywhere in the file:
"   - \documentclass
"   - \begin{env}       (for env != code)
"   - \part, \chapter, \section, \subsection, \subsubsection, etc
if b:lhs_markup == "unknown"
    if search('\\documentclass\|\\begin{\(code}\)\@!\|\\\(sub\)*section\|\\chapter|\\part','W') != 0
	let b:lhs_markup = "tex"
    elseif search('```haskell','W') != 0
        let b:lhs_markup = "md"
    else
	let b:lhs_markup = "plain"
    endif
endif

" If user wants us to highlight TeX syntax or guess thinks it's TeX, read it.
if b:lhs_markup == "tex"
    runtime! syntax/tex.vim
    unlet b:current_syntax
    " Tex.vim removes "_" from 'iskeyword', but we need it for Haskell.
    setlocal isk+=_
    syntax cluster lhsTeXContainer contains=tex.*Zone,texAbstract
elseif b:lhs_markup == "md"
    runtime! syntax/markdown.vim
    unlet b:current_syntax
    syntax cluster lhsTeXContainer contains=markdown.*
else
    syntax cluster lhsTeXContainer contains=.*
endif

" Literate Haskell is Haskell in between text, so at least read Haskell
" highlighting
syntax include @haskellTop syntax/haskell.vim

syntax region lhsHaskellBirdTrack start="^>" end="\%(^[^>]\)\@=" contains=@haskellTop,lhsBirdTrack containedin=@lhsTeXContainer
syntax region lhsHaskellBeginEndBlock start="^\\begin{code}\s*$" matchgroup=NONE end="\%(^\\end{code}.*$\)\@=" contains=@haskellTop,beginCodeBegin containedin=@lhsTeXContainer
syntax region lhsHaskellMDBlock start="^```haskell$" matchgroup=NONE end="^```$" keepend contains=@haskellTop,lhsMarkdownCode containedin=@lhsTeXContainer

syntax match lhsBirdTrack "^>" contained

syntax match lhsMarkdownCode "^\(```haskell\|^```\)$" contained

syntax match beginCodeBegin "^\\begin" nextgroup=beginCodeCode contained
syntax region beginCodeCode  matchgroup=texDelimiter start="{" end="}"

" Define the default highlighting.
" Only when an item doesn't have highlighting yet

hi def link lhsBirdTrack Comment

hi def link lhsMarkdownCode Comment

hi def link beginCodeBegin	      texCmdName
hi def link beginCodeCode	      texSection


" Restore cursor to original position, as it may have been disturbed
" by the searches in our guessing code
call cursor (s:oldline, s:oldcolumn)

unlet s:oldline
unlet s:oldcolumn

let b:current_syntax = "lhaskell"

" vim: ts=8
                                                                                                                                                                                        " Vim syntax file
" Language:             libao.conf(5) configuration file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2006-04-19

if exists("b:current_syntax")
  finish
endif

let s:cpo_save = &cpo
set cpo&vim

syn keyword libaoTodo     contained TODO FIXME XXX NOTE

syn region  libaoComment  display oneline start='^\s*#' end='$'
                          \ contains=libaoTodo,@Spell

syn keyword libaoKeyword  default_driver

hi def link libaoTodo     Todo
hi def link libaoComment  Comment
hi def link libaoKeyword  Keyword

let b:current_syntax = "libao"

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                    " Vim syntax file
" Language:	LifeLines (v 3.0.62) <http://lifelines.sourceforge.net>
" Maintainer:	Patrick Texier <p.texier@orsennes.com>
" Location:	<http://patrick.texier.free.fr/vim/syntax/lifelines.vim>
" Last Change:	2010 May 7

" option to highlight error obsolete statements
" add the following line to your .vimrc file :
" let lifelines_deprecated = 1

" For version 5.x: Clear all syntax items
" For version 6.x: Quit when a syntax file was already loaded

" quit when a syntax file was already loaded
if exists("b:current_syntax")
  finish
endif

" A bunch of useful LifeLines keywords 3.0.62

syn keyword	lifelinesDecl		char_encoding require option include
syn keyword	lifelinesStatement	set
syn keyword	lifelinesUser		getindi geindiset getfam getint getstr choosechild
syn keyword	lifelinesUser		chooseindi choosespouse choosesubset menuchoose
syn keyword	lifelinesUser		choosefam 
syn keyword	lifelinesProc		proc func return call
syn keyword	lifelinesInclude	include
syn keyword	lifelinesDef		global
syn keyword	lifelinesConditional	if else elsif switch
syn keyword	lifelinesRepeat		continue break while
syn keyword	lifelinesLogical	and or not eq ne lt gt le ge strcmp eqstr nestr
syn keyword	lifelinesArithm		add sub mul div mod exp neg incr decr
syn keyword	lifelinesArithm		cos sin tan arccos arcsin arctan
syn keyword	lifelinesArithm		deg2dms dms2deg spdist
syn keyword	lifelinesIndi		name fullname surname givens trimname birth
syn keyword	lifelinesIndi		death burial baptism
syn keyword	lifelinesIndi		father mother nextsib prevsib sex male female
syn keyword	lifelinesIndi		pn nspouses nfamilies parents title key
syn keyword	lifelinesIndi		soundex inode root indi firstindi nextindi
syn keyword	lifelinesIndi		previndi spouses families forindi indiset
syn keyword	lifelinesIndi		addtoset deletefromset  union intersect
syn keyword	lifelinesIndi		difference parentset childset spouseset siblingset
syn keyword	lifelinesIndi		ancestorset descendentset descendantset uniqueset
syn keyword	lifelinesIndi		namesort keysort valuesort genindiset getindiset
syn keyword	lifelinesIndi		forindiset lastindi writeindi
syn keyword	lifelinesIndi		inset
syn keyword	lifelinesFam		marriage husband wife nchildren firstchild
syn keyword	lifelinesFam		lastchild fnode fam firstfam nextfam lastfam
syn keyword	lifelinesFam		prevfam children forfam writefam
syn keyword	lifelinesFam		fathers mothers Parents
syn keyword	lifelinesList		list empty length enqueue dequeue requeue
syn keyword	lifelinesList		push pop setel getel forlist inlist dup clear
syn keyword	lifelinesTable		table insert lookup
syn keyword	lifelinesGedcom		xref tag value parent child sibling savenode
syn keyword	lifelinesGedcom		fornodes traverse createnode addnode 
syn keyword	lifelinesGedcom		detachnode foreven fornotes forothr forsour
syn keyword	lifelinesGedcom		reference dereference getrecord
syn keyword	lifelinesGedcom		gengedcomstrong 
syn keyword	lifelinesFunct		date place year long short gettoday dayformat
syn keyword	lifelinesFunct		monthformat dateformat extractdate eraformat
syn keyword	lifelinesFunct		complexdate complexformat complexpic datepic
syn keyword	lifelinesFunct		extractnames extractplaces extracttokens lower
syn keyword	lifelinesFunct		yearformat
syn keyword	lifelinesFunct		upper capitalize trim rjustify 
syn keyword 	lifelinesFunct		concat strconcat strlen substring index
syn keyword	lifelinesFunct		titlecase gettext
syn keyword	lifelinesFunct		d card ord alpha roman strsoundex strtoint
syn keyword	lifelinesFunct		atoi linemode pagemod col row pos pageout nl
syn keyword	lifelinesFunct		sp qt newfile outfile copyfile print lock unlock test
syn keyword	lifelinesFunct		database version system stddate program
syn keyword	lifelinesFunct		pvalue pagemode level extractdatestr debug
syn keyword	lifelinesFunct		f float int free getcol getproperty heapused
syn keyword 	lifelinesFunct		sort rsort
syn keyword	lifelinesFunct		deleteel
syn keyword	lifelinesFunct		bytecode convertcode setlocale
" New dates functions (since 3.0.51)
syn keyword	lifelinesFunct		jd2date date2jd dayofweek setdate

" options to highlight as error obsolete statements
" please read ll-reportmanual.

if exists("lifelines_deprecated")
	syn keyword lifelinesError	getintmsg getindimsg getstrmsg
	syn keyword lifelinesError	gengedcom gengedcomweak deletenode
	syn keyword lifelinesError	save strsave
	syn keyword lifelinesError	lengthset
	if version >= 700
		let g:omni_syntax_group_exclude_lifelines = 'lifelinesError'
	endif
else
	syn keyword lifelinesUser	getintmsg getindimsg getstrmsg
	syn keyword lifelinesGedcom	gengedcom gengedcomweak deletenode
	syn keyword lifelinesFunct	save strsave
	syn keyword lifelinesIndi	lengthset
endif

syn region	lifelinesString	start=+L\="+ skip=+\\\\\|\\"+ end=+"+ contains=lifelinesSpecial

syn match	lifelinesSpecial	"\\\(\\\|\(n\|t\)\)" contained

syn keyword	lifelinesTodo		contained TODO FIXME XXX
syn region	lifelinesComment	start="/\*"  end="\*/" contains=lifelinesTodo

" integers
syn match	lifelinesNumber	"-\=\<\d\+\>"
"floats, with dot
syn match	lifelinesNumber	"-\=\<\d\+\.\d*\>"
"floats, starting with a dot
syn match	lifelinesNumber	"-\=\.\d\+\>"

" folding using {}
syn region lifelinesFoldBlock	start="{" end="}" transparent fold

"catch errors caused by wrong parenthesis
"adapted from original c.vim written by Bram Moolenaar

syn cluster	lifelinesParenGroup	contains=lifelinesParenError
syn region	lifelinesParen		transparent start='(' end=')' contains=ALLBUT,@lifelinesParenGroup
syn match	lifelinesParenError	")"
syn match	lifelinesErrInParen	contained "[{}]"

" Define the default highlighting.
" Only when an item doesn't have highlighting yet


hi def link lifelinesConditional	Conditional
hi def link lifelinesArithm	Operator
hi def link lifelinesLogical	Conditional
hi def link lifelinesInclude	Include
hi def link lifelinesComment	Comment
hi def link lifelinesStatement	Statement
hi def link lifelinesUser		Statement
hi def link lifelinesFunct		Statement
hi def link lifelinesTable		Statement
hi def link lifelinesGedcom	Statement
hi def link lifelinesList		Statement
hi def link lifelinesRepeat	Repeat
hi def link lifelinesFam		Statement
hi def link lifelinesIndi		Statement
hi def link lifelinesProc		Statement
hi def link lifelinesDef		Statement
hi def link lifelinesString	String
hi def link lifelinesSpecial	Special
hi def link lifelinesNumber	Number
hi def link lifelinesParenError	Error
hi def link lifelinesErrInParen	Error
hi def link lifelinesError		Error
hi def link lifelinesTodo		Todo
hi def link lifelinesDecl		PreProc


let b:current_syntax = "lifelines"

" vim: ts=8 sw=4
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                " Vim syntax file
" Language: lilo configuration (lilo.conf)
" Maintainer: Niels Horn <niels.horn@gmail.com>
" Previous Maintainer: David Necas (Yeti) <yeti@physics.muni.cz>
" Last Change: 2010-02-03

" Setup
" quit when a syntax file was already loaded
if exists("b:current_syntax")
  finish
endif

setlocal iskeyword=@,48-57,.,-,_

syn case ignore

" Base constructs
syn match liloError "\S\+"
syn match liloComment "#.*$"
syn match liloEnviron "\$\w\+" contained
syn match liloEnviron "\${[^}]\+}" contained
syn match liloDecNumber "\d\+" contained
syn match liloHexNumber "0[xX]\x\+" contained
syn match liloDecNumberP "\d\+p\=" contained
syn match liloSpecial contained "\\\(\"\|\\\|$\)"
syn region liloString start=+"+ skip=+\\\\\|\\"+ end=+"+ contained contains=liloSpecial,liloEnviron
syn match liloLabel :[^ "]\+: contained contains=liloSpecial,liloEnviron
syn region liloPath start=+[$/]+ skip=+\\\\\|\\ \|\\$"+ end=+ \|$+ contained contains=liloSpecial,liloEnviron
syn match liloDecNumberList "\(\d\|,\)\+" contained contains=liloDecNumber
syn match liloDecNumberPList "\(\d\|[,p]\)\+" contained contains=liloDecNumberP,liloDecNumber
syn region liloAnything start=+[^[:space:]#]+ skip=+\\\\\|\\ \|\\$+ end=+ \|$+ contained contains=liloSpecial,liloEnviron,liloString

" Path
syn keyword liloOption backup bitmap boot disktab force-backup keytable map message nextgroup=liloEqPath,liloEqPathComment,liloError skipwhite skipempty
syn keyword liloKernelOpt initrd root nextgroup=liloEqPath,liloEqPathComment,liloError skipwhite skipempty
syn keyword liloImageOpt path loader table nextgroup=liloEqPath,liloEqPathComment,liloError skipwhite skipempty
syn keyword liloDiskOpt partition nextgroup=liloEqPath,liloEqPathComment,liloError skipwhite skipempty

" Other
syn keyword liloOption menu-scheme raid-extra-boot serial install nextgroup=liloEqAnything,liloEqAnythingComment,liloError skipwhite skipempty
syn keyword liloOption bios-passes-dl nextgroup=liloEqAnything,liloEqAnythingComment,liloError skipwhite skipempty
syn keyword liloOption default label alias wmdefault nextgroup=liloEqLabelString,liloEqLabelStringComment,liloError skipwhite skipempty
syn keyword liloKernelOpt ramdisk nextgroup=liloEqAnything,liloEqAnythingComment,liloError skipwhite skipempty
syn keyword liloImageOpt password range nextgroup=liloEqAnything,liloEqAnythingComment,liloError skipwhite skipempty
syn keyword liloDiskOpt set type nextgroup=liloEqAnything,liloEqAnythingComment,liloError skipwhite skipempty

" Symbolic
syn keyword liloKernelOpt vga nextgroup=liloEqVga,liloEqVgaComment,liloError skipwhite skipempty

" Number
syn keyword liloOption delay timeout verbose nextgroup=liloEqDecNumber,liloEqDecNumberComment,liloError skipwhite skipempty
syn keyword liloDiskOpt sectors heads cylinders start nextgroup=liloEqDecNumber,liloEqDecNumberComment,liloError skipwhite skipempty

" String
syn keyword liloOption menu-title nextgroup=liloEqString,liloEqStringComment,liloError skipwhite skipempty
syn keyword liloKernelOpt append addappend nextgroup=liloEqString,liloEqStringComment,liloError skipwhite skipempty
syn keyword liloImageOpt fallback literal nextgroup=liloEqString,liloEqStringComment,liloError skipwhite skipempty

" Hex number
syn keyword liloImageOpt map-drive to boot-as nextgroup=liloEqHexNumber,liloEqHexNumberComment,liloError skipwhite skipempty
syn keyword liloDiskOpt bios normal hidden nextgroup=liloEqNumber,liloEqNumberComment,liloError skipwhite skipempty

" Number list
syn keyword liloOption bmp-colors nextgroup=liloEqNumberList,liloEqNumberListComment,liloError skipwhite skipempty

" Number list, some of the numbers followed by p
syn keyword liloOption bmp-table bmp-timer nextgroup=liloEqDecNumberPList,liloEqDecNumberPListComment,liloError skipwhite skipempty

" Flag
syn keyword liloOption compact fix-table geometric ignore-table lba32 linear mandatory nowarn prompt
syn keyword liloOption bmp-retain el-torito-bootable-CD large-memory suppress-boot-time-BIOS-data
syn keyword liloKernelOpt read-only read-write
syn keyword liloImageOpt bypass lock mandatory optional restricted single-key unsafe
syn keyword liloImageOpt master-boot wmwarn wmdisable
syn keyword liloDiskOpt change activate deactivate inaccessible reset

" Image
syn keyword liloImage image other nextgroup=liloEqPath,liloEqPathComment,liloError skipwhite skipempty
syn keyword liloDisk disk nextgroup=liloEqPath,liloEqPathComment,liloError skipwhite skipempty
syn keyword liloChRules change-rules

" Vga keywords
syn keyword liloVgaKeyword ask ext extended normal contained

" Comment followed by equal sign and ...
syn match liloEqPathComment "#.*$" contained nextgroup=liloEqPath,liloEqPathComment,liloError skipwhite skipempty
syn match liloEqVgaComment "#.*$" contained nextgroup=liloEqVga,liloEqVgaComment,liloError skipwhite skipempty
syn match liloEqNumberComment "#.*$" contained nextgroup=liloEqNumber,liloEqNumberComment,liloError skipwhite skipempty
syn match liloEqDecNumberComment "#.*$" contained nextgroup=liloEqDecNumber,liloEqDecNumberComment,liloError skipwhite skipempty
syn match liloEqHexNumberComment "#.*$" contained nextgroup=liloEqHexNumber,liloEqHexNumberComment,liloError skipwhite skipempty
syn match liloEqStringComment "#.*$" contained nextgroup=liloEqString,liloEqStringComment,liloError skipwhite skipempty
syn match liloEqLabelStringComment "#.*$" contained nextgroup=liloEqLabelString,liloEqLabelStringComment,liloError skipwhite skipempty
syn match liloEqNumberListComment "#.*$" contained nextgroup=liloEqNumberList,liloEqNumberListComment,liloError skipwhite skipempty
syn match liloEqDecNumberPListComment "#.*$" contained nextgroup=liloEqDecNumberPList,liloEqDecNumberPListComment,liloError skipwhite skipempty
syn match liloEqAnythingComment "#.*$" contained nextgroup=liloEqAnything,liloEqAnythingComment,liloError skipwhite skipempty

" Equal sign followed by ...
syn match liloEqPath "=" contained nextgroup=liloPath,liloPathComment,liloError skipwhite skipempty
syn match liloEqVga "=" contained nextgroup=liloVgaKeyword,liloHexNumber,liloDecNumber,liloVgaComment,liloError skipwhite skipempty
syn match liloEqNumber "=" contained nextgroup=liloDecNumber,liloHexNumber,liloNumberComment,liloError skipwhite skipempty
syn match liloEqDecNumber "=" contained nextgroup=liloDecNumber,liloDecNumberComment,liloError skipwhite skipempty
syn match liloEqHexNumber "=" contained nextgroup=liloHexNumber,liloHexNumberComment,liloError skipwhite skipempty
syn match liloEqString "=" contained nextgroup=liloString,liloStringComment,liloError skipwhite skipempty
syn match liloEqLabelString "=" contained nextgroup=liloString,liloLabel,liloLabelStringComment,liloError skipwhite skipempty
syn match liloEqNumberList "=" contained nextgroup=liloDecNumberList,liloDecNumberListComment,liloError skipwhite skipempty
syn match liloEqDecNumberPList "=" contained nextgroup=liloDecNumberPList,liloDecNumberPListComment,liloError skipwhite skipempty
syn match liloEqAnything "=" contained nextgroup=liloAnything,liloAnythingComment,liloError skipwhite skipempty

" Comment followed by ...
syn match liloPathComment "#.*$" contained nextgroup=liloPath,liloPathComment,liloError skipwhite skipempty
syn match liloVgaComment "#.*$" contained nextgroup=liloVgaKeyword,liloHexNumber,liloVgaComment,liloError skipwhite skipempty
syn match liloNumberComment "#.*$" contained nextgroup=liloDecNumber,liloHexNumber,liloNumberComment,liloError skipwhite skipempty
syn match liloDecNumberComment "#.*$" contained nextgroup=liloDecNumber,liloDecNumberComment,liloError skipwhite skipempty
syn match liloHexNumberComment "#.*$" contained nextgroup=liloHexNumber,liloHexNumberComment,liloError skipwhite skipempty
syn match liloStringComment "#.*$" contained nextgroup=liloString,liloStringComment,liloError skipwhite skipempty
syn match liloLabelStringComment "#.*$" contained nextgroup=liloString,liloLabel,liloLabelStringComment,liloError skipwhite skipempty
syn match liloDecNumberListComment "#.*$" contained nextgroup=liloDecNumberList,liloDecNumberListComment,liloError skipwhite skipempty
syn match liloDecNumberPListComment "#.*$" contained nextgroup=liloDecNumberPList,liloDecNumberPListComment,liloError skipwhite skipempty
syn match liloAnythingComment "#.*$" contained nextgroup=liloAnything,liloAnythingComment,liloError skipwhite skipempty

" Define the default highlighting

hi def link liloEqPath             liloEquals
hi def link liloEqWord             liloEquals
hi def link liloEqVga              liloEquals
hi def link liloEqDecNumber        liloEquals
hi def link liloEqHexNumber        liloEquals
hi def link liloEqNumber           liloEquals
hi def link liloEqString           liloEquals
hi def link liloEqAnything         liloEquals
hi def link liloEquals             Special

hi def link liloError              Error

hi def link liloEqPathComment      liloComment
hi def link liloEqVgaComment       liloComment
hi def link liloEqDecNumberComment liloComment
hi def link liloEqHexNumberComment liloComment
hi def link liloEqStringComment    liloComment
hi def link liloEqAnythingComment  liloComment
hi def link liloPathComment        liloComment
hi def link liloVgaComment         liloComment
hi def link liloDecNumberComment   liloComment
hi def link liloHexNumberComment   liloComment
hi def link liloNumberComment      liloComment
hi def link liloStringComment      liloComment
hi def link liloAnythingComment    liloComment
hi def link liloComment            Comment

hi def link liloDiskOpt            liloOption
hi def link liloKernelOpt          liloOption
hi def link liloImageOpt           liloOption
hi def link liloOption             Keyword

hi def link liloDecNumber          liloNumber
hi def link liloHexNumber          liloNumber
hi def link liloDecNumberP         liloNumber
hi def link liloNumber             Number
hi def link liloString             String
hi def link liloPath               Constant

hi def link liloSpecial            Special
hi def link liloLabel              Title
hi def link liloDecNumberList      Special
hi def link liloDecNumberPList     Special
hi def link liloAnything           Normal
hi def link liloEnviron            Identifier
hi def link liloVgaKeyword         Identifier
hi def link liloImage              Type
hi def link liloChRules            Preproc
hi def link liloDisk               Preproc


let b:current_syntax = "lilo"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     " Vim syntax file
" Language:             limits(5) configuration file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2006-04-19

if exists("b:current_syntax")
  finish
endif

let s:cpo_save = &cpo
set cpo&vim

syn keyword limitsTodo    contained TODO FIXME XXX NOTE

syn region  limitsComment display oneline start='^\s*#' end='$'
                          \ contains=limitsTodo,@Spell

syn match   limitsBegin   display '^'
                          \ nextgroup=limitsUser,limitsDefault,limitsComment
                          \ skipwhite

syn match   limitsUser    contained '[^ \t#*]\+'
                          \ nextgroup=limitsLimit,limitsDeLimit skipwhite

syn match   limitsDefault contained '*'
                          \ nextgroup=limitsLimit,limitsDeLimit skipwhite

syn match   limitsLimit   contained '[ACDFMNRSTUKLP]' nextgroup=limitsNumber
syn match   limitsDeLimit contained '-'

syn match   limitsNumber  contained '\d\+\>' nextgroup=limitsLimit skipwhite

hi def link limitsTodo    Todo
hi def link limitsComment Comment
hi def link limitsUser    Keyword
hi def link limitsDefault Macro
hi def link limitsLimit   Identifier
hi def link limitsDeLimit Special
hi def link limitsNumber  Number

let b:current_syntax = "limits"

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           " Vim syntax file
" Language:     Liquid
" Maintainer:   Tim Pope <vimNOSPAM@tpope.org>
" Filenames:    *.liquid
" Last Change:	2013 May 30

if exists('b:current_syntax')
  finish
endif

if !exists('main_syntax')
  let main_syntax = 'liquid'
endif

if !exists('g:liquid_default_subtype')
  let g:liquid_default_subtype = 'html'
endif

if !exists('b:liquid_subtype') && main_syntax == 'liquid'
  let s:lines = getline(1)."\n".getline(2)."\n".getline(3)."\n".getline(4)."\n".getline(5)."\n".getline("$")
  let b:liquid_subtype = matchstr(s:lines,'liquid_subtype=\zs\w\+')
  if b:liquid_subtype == ''
    let b:liquid_subtype = matchstr(&filetype,'^liquid\.\zs\w\+')
  endif
  if b:liquid_subtype == ''
    let b:liquid_subtype = matchstr(substitute(expand('%:t'),'\c\%(\.liquid\)\+$','',''),'\.\zs\w\+$')
  endif
  if b:liquid_subtype == ''
    let b:liquid_subtype = g:liquid_default_subtype
  endif
endif

if exists('b:liquid_subtype') && b:liquid_subtype != ''
  exe 'runtime! syntax/'.b:liquid_subtype.'.vim'
  unlet! b:current_syntax
endif

syn case match

if exists('b:liquid_subtype') && b:liquid_subtype != 'yaml'
  " YAML Front Matter
  syn include @liquidYamlTop syntax/yaml.vim
  unlet! b:current_syntax
  syn region liquidYamlHead start="\%^---$" end="^---\s*$" keepend contains=@liquidYamlTop,@Spell
endif

if !exists('g:liquid_highlight_types')
  let g:liquid_highlight_types = []
endif

if !exists('s:subtype')
  let s:subtype = exists('b:liquid_subtype') ? b:liquid_subtype : ''

  for s:type in map(copy(g:liquid_highlight_types),'matchstr(v:val,"[^=]*$")')
    if s:type =~ '\.'
      let b:{matchstr(s:type,'[^.]*')}_subtype = matchstr(s:type,'\.\zs.*')
    endif
    exe 'syn include @liquidHighlight'.substitute(s:type,'\.','','g').' syntax/'.matchstr(s:type,'[^.]*').'.vim'
    unlet! b:current_syntax
  endfor
  unlet! s:type

  if s:subtype == ''
    unlet! b:liquid_subtype
  else
    let b:liquid_subtype = s:subtype
  endif
  unlet s:subtype
endif

syn region  liquidStatement  matchgroup=liquidDelimiter start="{%" end="%}" contains=@liquidStatement containedin=ALLBUT,@liquidExempt keepend
syn region  liquidExpression matchgroup=liquidDelimiter start="{{" end="}}" contains=@liquidExpression  containedin=ALLBUT,@liquidExempt keepend
syn region  liquidComment    matchgroup=liquidDelimiter start="{%\s*comment\s*%}" end="{%\s*endcomment\s*%}" contains=liquidTodo,@Spell containedin=ALLBUT,@liquidExempt keepend
syn region  liquidRaw        matchgroup=liquidDelimiter start="{%\s*raw\s*%}" end="{%\s*endraw\s*%}" contains=TOP,@liquidExempt containedin=ALLBUT,@liquidExempt keepend

syn cluster liquidExempt contains=liquidStatement,liquidExpression,liquidComment,liquidRaw,@liquidStatement,liquidYamlHead
syn cluster liquidStatement contains=liquidConditional,liquidRepeat,liquidKeyword,@liquidExpression
syn cluster liquidExpression contains=liquidOperator,liquidString,liquidNumber,liquidFloat,liquidBoolean,liquidNull,liquidEmpty,liquidPipe,liquidForloop

syn keyword liquidKeyword highlight nextgroup=liquidTypeHighlight skipwhite contained
syn keyword liquidKeyword endhighlight contained
syn region liquidHighlight start="{%\s*highlight\s\+\w\+\s*%}" end="{% endhighlight %}" keepend

for s:type in g:liquid_highlight_types
  exe 'syn match liquidTypeHighlight "\<'.matchstr(s:type,'[^=]*').'\>" contained'
  exe 'syn region liquidHighlight'.substitute(matchstr(s:type,'[^=]*$'),'\..*','','').' start="{%\s*highlight\s\+'.matchstr(s:type,'[^=]*').'\s*%}" end="{% endhighlight %}" keepend contains=@liquidHighlight'.substitute(matchstr(s:type,'[^=]*$'),'\.','','g')
endfor
unlet! s:type

syn region liquidString matchgroup=liquidQuote start=+"+ end=+"+ contained
syn region liquidString matchgroup=liquidQuote start=+'+ end=+'+ contained
syn match liquidNumber "-\=\<\d\+\>" contained
syn match liquidFloat "-\=\<\d\+\>\.\.\@!\%(\d\+\>\)\=" contained
syn keyword liquidBoolean true false contained
syn keyword liquidNull null nil contained
syn match liquidEmpty "\<empty\>" contained

syn keyword liquidOperator and or not contained
syn match liquidPipe '|' contained skipwhite nextgroup=liquidFilter

syn keyword liquidFilter date capitalize downcase upcase first last join sort size strip_html strip_newlines newline_to_br replace replace_first remove remove_first truncate truncatewords prepend append minus plus times divided_by contained

syn keyword liquidConditional if elsif else endif unless endunless case when endcase ifchanged endifchanged contained
syn keyword liquidRepeat      for endfor tablerow endtablerow in contained
syn match   liquidRepeat      "\%({%\s*\)\@<=empty\>" contained
syn keyword liquidKeyword     assign cycle include with contained

syn keyword liquidForloop forloop nextgroup=liquidForloopDot contained
syn match liquidForloopDot "\." nextgroup=liquidForloopAttribute contained
syn keyword liquidForloopAttribute length index index0 rindex rindex0 first last contained

syn keyword liquidTablerowloop tablerowloop nextgroup=liquidTablerowloopDot contained
syn match liquidTablerowloopDot "\." nextgroup=liquidTableForloopAttribute contained
syn keyword liquidTablerowloopAttribute length index index0 col col0 index0 rindex rindex0 first last col_first col_last contained

hi def link liquidDelimiter             PreProc
hi def link liquidComment               Comment
hi def link liquidTypeHighlight         Type
hi def link liquidConditional           Conditional
hi def link liquidRepeat                Repeat
hi def link liquidKeyword               Keyword
hi def link liquidOperator              Operator
hi def link liquidString                String
hi def link liquidQuote                 Delimiter
hi def link liquidNumber                Number
hi def link liquidFloat                 Float
hi def link liquidEmpty                 liquidNull
hi def link liquidNull                  liquidBoolean
hi def link liquidBoolean               Boolean
hi def link liquidFilter                Function
hi def link liquidForloop               Identifier
hi def link liquidForloopAttribute      Identifier

let b:current_syntax = 'liquid'

if exists('main_syntax') && main_syntax == 'liquid'
  unlet main_syntax
endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        " Vim syntax file
" Language:    Lisp
" Maintainer:  Charles E. Campbell <NcampObell@SdrPchip.AorgM-NOSPAM>
" Last Change: Jul 11, 2019
" Version:     30
" URL:	http://www.drchip.org/astronaut/vim/index.html#SYNTAX_LISP
"
"  Thanks to F Xavier Noria for a list of 978 Common Lisp symbols taken from HyperSpec
"  Clisp additions courtesy of http://clisp.cvs.sourceforge.net/*checkout*/clisp/clisp/emacs/lisp.vim

" ---------------------------------------------------------------------
"  Load Once: {{{1
if exists("b:current_syntax")
 finish
endif

if exists("g:lisp_isk")
 exe "setl isk=".g:lisp_isk
elseif (v:version == 704 && has("patch-7.4.1142")) || v:version > 704
 syn iskeyword 38,42,43,45,47-58,60-62,64-90,97-122,_
else
 setl isk=38,42,43,45,47-58,60-62,64-90,97-122,_
endif

if exists("g:lispsyntax_ignorecase") || exists("g:lispsyntax_clisp")
 set ignorecase
endif

" ---------------------------------------------------------------------
" Clusters: {{{1
syn cluster			lispAtomCluster		contains=lispAtomBarSymbol,lispAtomList,lispAtomNmbr0,lispComment,lispDecl,lispFunc,lispLeadWhite
syn cluster			lispBaseListCluster	contains=lispAtom,lispAtomBarSymbol,lispAtomMark,lispBQList,lispBarSymbol,lispComment,lispConcat,lispDecl,lispFunc,lispKey,lispList,lispNumber,lispEscapeSpecial,lispSymbol,lispVar,lispLeadWhite
if exists("g:lisp_instring")
 syn cluster			lispListCluster		contains=@lispBaseListCluster,lispString,lispInString,lispInStringString
else
 syn cluster			lispListCluster		contains=@lispBaseListCluster,lispString
endif

syn case ignore

" ---------------------------------------------------------------------
" Lists: {{{1
syn match lispSymbol	contained	![^()'`,"; \t]\+!
syn match lispBarSymbol	contained	!|..\{-}|!
if exists("g:lisp_rainbow") && g:lisp_rainbow != 0
 syn region lispParen0           matchgroup=hlLevel0 start="`\=(" end=")" skip="|.\{-}|" contains=@lispListCluster,lispParen1
 syn region lispParen1 contained matchgroup=hlLevel1 start="`\=(" end=")" skip="|.\{-}|" contains=@lispListCluster,lispParen2
 syn region lispParen2 contained matchgroup=hlLevel2 start="`\=(" end=")" skip="|.\{-}|" contains=@lispListCluster,lispParen3
 syn region lispParen3 contained matchgroup=hlLevel3 start="`\=(" end=")" skip="|.\{-}|" contains=@lispListCluster,lispParen4
 syn region lispParen4 contained matchgroup=hlLevel4 start="`\=(" end=")" skip="|.\{-}|" contains=@lispListCluster,lispParen5
 syn region lispParen5 contained matchgroup=hlLevel5 start="`\=(" end=")" skip="|.\{-}|" contains=@lispListCluster,lispParen6
 syn region lispParen6 contained matchgroup=hlLevel6 start="`\=(" end=")" skip="|.\{-}|" contains=@lispListCluster,lispParen7
 syn region lispParen7 contained matchgroup=hlLevel7 start="`\=(" end=")" skip="|.\{-}|" contains=@lispListCluster,lispParen8
 syn region lispParen8 contained matchgroup=hlLevel8 start="`\=(" end=")" skip="|.\{-}|" contains=@lispListCluster,lispParen9
 syn region lispParen9 contained matchgroup=hlLevel9 start="`\=(" end=")" skip="|.\{-}|" contains=@lispListCluster,lispParen0
else
 syn region lispList			matchgroup=lispParen start="("   skip="|.\{-}|"			matchgroup=lispParen end=")"	contains=@lispListCluster
 syn region lispBQList			matchgroup=PreProc   start="`("  skip="|.\{-}|"			matchgroup=PreProc   end=")"		contains=@lispListCluster
endif

" ---------------------------------------------------------------------
" Atoms: {{{1
syn match lispAtomMark			"'"
syn match lispAtom			"'("me=e-1			contains=lispAtomMark	nextgroup=lispAtomList
syn match lispAtom			"'[^ \t()]\+"			contains=lispAtomMark
syn match lispAtomBarSymbol		!'|..\{-}|!			contains=lispAtomMark
syn region lispAtom			start=+'"+			skip=+\\"+ end=+"+
syn region lispAtomList			contained			matchgroup=Special start="("	skip="|.\{-}|" matchgroup=Special end=")"	contains=@lispAtomCluster,lispString,lispEscapeSpecial
syn match lispAtomNmbr			contained			"\<\d\+"
syn match lispLeadWhite			contained			"^\s\+"

" ---------------------------------------------------------------------
" Standard Lisp Functions and Macros: {{{1
syn keyword lispFunc		<				find-method				pprint-indent
syn keyword lispFunc		<=				find-package				pprint-linear
syn keyword lispFunc		=				find-restart				pprint-logical-block
syn keyword lispFunc		>				find-symbol				pprint-newline
syn keyword lispFunc		>=				finish-output				pprint-pop
syn keyword lispFunc		-				first					pprint-tab
syn keyword lispFunc		/				fixnum					pprint-tabular
syn keyword lispFunc		/=				flet					prin1
syn keyword lispFunc		//				float					prin1-to-string
syn keyword lispFunc		///				float-digits				princ
syn keyword lispFunc		*				floating-point-inexact			princ-to-string
syn keyword lispFunc		**				floating-point-invalid-operation	print
syn keyword lispFunc		***				floating-point-overflow			print-not-readable
syn keyword lispFunc		+				floating-point-underflow		print-not-readable-object
syn keyword lispFunc		++				floatp					print-object
syn keyword lispFunc		+++				float-precision				print-unreadable-object
syn keyword lispFunc		1-				float-radix				probe-file
syn keyword lispFunc		1+				float-sign				proclaim
syn keyword lispFunc		abort				floor					prog
syn keyword lispFunc		abs				fmakunbound				prog*
syn keyword lispFunc		access				force-output				prog1
syn keyword lispFunc		acons				format					prog2
syn keyword lispFunc		acos				formatter				progn
syn keyword lispFunc		acosh				fourth					program-error
syn keyword lispFunc		add-method			fresh-line				progv
syn keyword lispFunc		adjoin				fround					provide
syn keyword lispFunc		adjustable-array-p		ftruncate				psetf
syn keyword lispFunc		adjust-array			ftype					psetq
syn keyword lispFunc		allocate-instance		funcall					push
syn keyword lispFunc		alpha-char-p			function				pushnew
syn keyword lispFunc		alphanumericp			function-keywords			putprop
syn keyword lispFunc		and				function-lambda-expression		quote
syn keyword lispFunc		append				functionp				random
syn keyword lispFunc		apply				gbitp					random-state
syn keyword lispFunc		applyhook			gcd					random-state-p
syn keyword lispFunc		apropos				generic-function			rassoc
syn keyword lispFunc		apropos-list			gensym					rassoc-if
syn keyword lispFunc		aref				gentemp					rassoc-if-not
syn keyword lispFunc		arithmetic-error		get					ratio
syn keyword lispFunc		arithmetic-error-operands	get-decoded-time			rational
syn keyword lispFunc		arithmetic-error-operation	get-dispatch-macro-character		rationalize
syn keyword lispFunc		array				getf					rationalp
syn keyword lispFunc		array-dimension			gethash					read
syn keyword lispFunc		array-dimension-limit		get-internal-real-time			read-byte
syn keyword lispFunc		array-dimensions		get-internal-run-time			read-char
syn keyword lispFunc		array-displacement		get-macro-character			read-char-no-hang
syn keyword lispFunc		array-element-type		get-output-stream-string		read-delimited-list
syn keyword lispFunc		array-has-fill-pointer-p	get-properties				reader-error
syn keyword lispFunc		array-in-bounds-p		get-setf-expansion			read-eval-print
syn keyword lispFunc		arrayp				get-setf-method				read-from-string
syn keyword lispFunc		array-rank			get-universal-time			read-line
syn keyword lispFunc		array-rank-limit		go					read-preserving-whitespace
syn keyword lispFunc		array-row-major-index		graphic-char-p				read-sequence
syn keyword lispFunc		array-total-size		handler-bind				readtable
syn keyword lispFunc		array-total-size-limit		handler-case				readtable-case
syn keyword lispFunc		ash				hash-table				readtablep
syn keyword lispFunc		asin				hash-table-count			real
syn keyword lispFunc		asinh				hash-table-p				realp
syn keyword lispFunc		assert				hash-table-rehash-size			realpart
syn keyword lispFunc		assoc				hash-table-rehash-threshold		reduce
syn keyword lispFunc		assoc-if			hash-table-size				reinitialize-instance
syn keyword lispFunc		assoc-if-not			hash-table-test				rem
syn keyword lispFunc		atan				host-namestring				remf
syn keyword lispFunc		atanh				identity				remhash
syn keyword lispFunc		atom				if					remove
syn keyword lispFunc		base-char			if-exists				remove-duplicates
syn keyword lispFunc		base-string			ignorable				remove-if
syn keyword lispFunc		bignum				ignore					remove-if-not
syn keyword lispFunc		bit				ignore-errors				remove-method
syn keyword lispFunc		bit-and				imagpart				remprop
syn keyword lispFunc		bit-andc1			import					rename-file
syn keyword lispFunc		bit-andc2			incf					rename-package
syn keyword lispFunc		bit-eqv				initialize-instance			replace
syn keyword lispFunc		bit-ior				inline					require
syn keyword lispFunc		bit-nand			in-package				rest
syn keyword lispFunc		bit-nor				in-package				restart
syn keyword lispFunc		bit-not				input-stream-p				restart-bind
syn keyword lispFunc		bit-orc1			inspect					restart-case
syn keyword lispFunc		bit-orc2			int-char				restart-name
syn keyword lispFunc		bit-vector			integer					return
syn keyword lispFunc		bit-vector-p			integer-decode-float			return-from
syn keyword lispFunc		bit-xor				integer-length				revappend
syn keyword lispFunc		block				integerp				reverse
syn keyword lispFunc		boole				interactive-stream-p			room
syn keyword lispFunc		boole-1				intern					rotatef
syn keyword lispFunc		boole-2				internal-time-units-per-second		round
syn keyword lispFunc		boolean				intersection				row-major-aref
syn keyword lispFunc		boole-and			invalid-method-error			rplaca
syn keyword lispFunc		boole-andc1			invoke-debugger				rplacd
syn keyword lispFunc		boole-andc2			invoke-restart				safety
syn keyword lispFunc		boole-c1			invoke-restart-interactively		satisfies
syn keyword lispFunc		boole-c2			isqrt					sbit
syn keyword lispFunc		boole-clr			keyword					scale-float
syn keyword lispFunc		boole-eqv			keywordp				schar
syn keyword lispFunc		boole-ior			labels					search
syn keyword lispFunc		boole-nand			lambda					second
syn keyword lispFunc		boole-nor			lambda-list-keywords			sequence
syn keyword lispFunc		boole-orc1			lambda-parameters-limit			serious-condition
syn keyword lispFunc		boole-orc2			last					set
syn keyword lispFunc		boole-set			lcm					set-char-bit
syn keyword lispFunc		boole-xor			ldb					set-difference
syn keyword lispFunc		both-case-p			ldb-test				set-dispatch-macro-character
syn keyword lispFunc		boundp				ldiff					set-exclusive-or
syn keyword lispFunc		break				least-negative-double-float		setf
syn keyword lispFunc		broadcast-stream		least-negative-long-float		set-macro-character
syn keyword lispFunc		broadcast-stream-streams	least-negative-normalized-double-float	set-pprint-dispatch
syn keyword lispFunc		built-in-class			least-negative-normalized-long-float	setq
syn keyword lispFunc		butlast				least-negative-normalized-short-float	set-syntax-from-char
syn keyword lispFunc		byte				least-negative-normalized-single-float	seventh
syn keyword lispFunc		byte-position			least-negative-short-float		shadow
syn keyword lispFunc		byte-size			least-negative-single-float		shadowing-import
syn keyword lispFunc		call-arguments-limit		least-positive-double-float		shared-initialize
syn keyword lispFunc		call-method			least-positive-long-float		shiftf
syn keyword lispFunc		call-next-method		least-positive-normalized-double-float	short-float
syn keyword lispFunc		capitalize			least-positive-normalized-long-float	short-float-epsilon
syn keyword lispFunc		car				least-positive-normalized-short-float	short-float-negative-epsilon
syn keyword lispFunc		case				least-positive-normalized-single-float	short-site-name
syn keyword lispFunc		catch				least-positive-short-float		signal
syn keyword lispFunc		ccase				least-positive-single-float		signed-byte
syn keyword lispFunc		cdr				length					signum
syn keyword lispFunc		ceiling				let					simple-array
syn keyword lispFunc		cell-error			let*					simple-base-string
syn keyword lispFunc		cell-error-name			lisp					simple-bit-vector
syn keyword lispFunc		cerror				lisp-implementation-type		simple-bit-vector-p
syn keyword lispFunc		change-class			lisp-implementation-version		simple-condition
syn keyword lispFunc		char				list					simple-condition-format-arguments
syn keyword lispFunc		char<				list*					simple-condition-format-control
syn keyword lispFunc		char<=				list-all-packages			simple-error
syn keyword lispFunc		char=				listen					simple-string
syn keywó‰  ô‰  õ‰  ö‰  ÷‰  ø‰  ù‰  ú‰  û‰  ü‰  ý‰  þ‰  ÿ‰   Š  Š  Š  Š  Š  Š  Š  Š  Š  	Š  
Š                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ord lispFunc		char>				list-length				simple-string-p
syn keyword lispFunc		char>=				listp					simple-type-error
syn keyword lispFunc		char/=				load					simple-vector
syn keyword lispFunc		character			load-logical-pathname-translations	simple-vector-p
syn keyword lispFunc		characterp			load-time-value				simple-warning
syn keyword lispFunc		char-bit			locally					sin
syn keyword lispFunc		char-bits			log					single-flaot-epsilon
syn keyword lispFunc		char-bits-limit			logand					single-float
syn keyword lispFunc		char-code			logandc1				single-float-epsilon
syn keyword lispFunc		char-code-limit			logandc2				single-float-negative-epsilon
syn keyword lispFunc		char-control-bit		logbitp					sinh
syn keyword lispFunc		char-downcase			logcount				sixth
syn keyword lispFunc		char-equal			logeqv					sleep
syn keyword lispFunc		char-font			logical-pathname			slot-boundp
syn keyword lispFunc		char-font-limit			logical-pathname-translations		slot-exists-p
syn keyword lispFunc		char-greaterp			logior					slot-makunbound
syn keyword lispFunc		char-hyper-bit			lognand					slot-missing
syn keyword lispFunc		char-int			lognor					slot-unbound
syn keyword lispFunc		char-lessp			lognot					slot-value
syn keyword lispFunc		char-meta-bit			logorc1					software-type
syn keyword lispFunc		char-name			logorc2					software-version
syn keyword lispFunc		char-not-equal			logtest					some
syn keyword lispFunc		char-not-greaterp		logxor					sort
syn keyword lispFunc		char-not-lessp			long-float				space
syn keyword lispFunc		char-super-bit			long-float-epsilon			special
syn keyword lispFunc		char-upcase			long-float-negative-epsilon		special-form-p
syn keyword lispFunc		check-type			long-site-name				special-operator-p
syn keyword lispFunc		cis				loop					speed
syn keyword lispFunc		class				loop-finish				sqrt
syn keyword lispFunc		class-name			lower-case-p				stable-sort
syn keyword lispFunc		class-of			machine-instance			standard
syn keyword lispFunc		clear-input			machine-type				standard-char
syn keyword lispFunc		clear-output			machine-version				standard-char-p
syn keyword lispFunc		close				macroexpand				standard-class
syn keyword lispFunc		clrhash				macroexpand-1				standard-generic-function
syn keyword lispFunc		code-char			macroexpand-l				standard-method
syn keyword lispFunc		coerce				macro-function				standard-object
syn keyword lispFunc		commonp				macrolet				step
syn keyword lispFunc		compilation-speed		make-array				storage-condition
syn keyword lispFunc		compile				make-array				store-value
syn keyword lispFunc		compiled-function		make-broadcast-stream			stream
syn keyword lispFunc		compiled-function-p		make-char				stream-element-type
syn keyword lispFunc		compile-file			make-concatenated-stream		stream-error
syn keyword lispFunc		compile-file-pathname		make-condition				stream-error-stream
syn keyword lispFunc		compiler-let			make-dispatch-macro-character		stream-external-format
syn keyword lispFunc		compiler-macro			make-echo-stream			streamp
syn keyword lispFunc		compiler-macro-function		make-hash-table				streamup
syn keyword lispFunc		complement			make-instance				string
syn keyword lispFunc		complex				make-instances-obsolete			string<
syn keyword lispFunc		complexp			make-list				string<=
syn keyword lispFunc		compute-applicable-methods	make-load-form				string=
syn keyword lispFunc		compute-restarts		make-load-form-saving-slots		string>
syn keyword lispFunc		concatenate			make-method				string>=
syn keyword lispFunc		concatenated-stream		make-package				string/=
syn keyword lispFunc		concatenated-stream-streams	make-pathname				string-capitalize
syn keyword lispFunc		cond				make-random-state			string-char
syn keyword lispFunc		condition			make-sequence				string-char-p
syn keyword lispFunc		conjugate			make-string				string-downcase
syn keyword lispFunc		cons				make-string-input-stream		string-equal
syn keyword lispFunc		consp				make-string-output-stream		string-greaterp
syn keyword lispFunc		constantly			make-symbol				string-left-trim
syn keyword lispFunc		constantp			make-synonym-stream			string-lessp
syn keyword lispFunc		continue			make-two-way-stream			string-not-equal
syn keyword lispFunc		control-error			makunbound				string-not-greaterp
syn keyword lispFunc		copy-alist			map					string-not-lessp
syn keyword lispFunc		copy-list			mapc					stringp
syn keyword lispFunc		copy-pprint-dispatch		mapcan					string-right-strim
syn keyword lispFunc		copy-readtable			mapcar					string-right-trim
syn keyword lispFunc		copy-seq			mapcon					string-stream
syn keyword lispFunc		copy-structure			maphash					string-trim
syn keyword lispFunc		copy-symbol			map-into				string-upcase
syn keyword lispFunc		copy-tree			mapl					structure
syn keyword lispFunc		cos				maplist					structure-class
syn keyword lispFunc		cosh				mask-field				structure-object
syn keyword lispFunc		count				max					style-warning
syn keyword lispFunc		count-if			member					sublim
syn keyword lispFunc		count-if-not			member-if				sublis
syn keyword lispFunc		ctypecase			member-if-not				subseq
syn keyword lispFunc		debug				merge					subsetp
syn keyword lispFunc		decf				merge-pathname				subst
syn keyword lispFunc		declaim				merge-pathnames				subst-if
syn keyword lispFunc		declaration			method					subst-if-not
syn keyword lispFunc		declare				method-combination			substitute
syn keyword lispFunc		decode-float			method-combination-error		substitute-if
syn keyword lispFunc		decode-universal-time		method-qualifiers			substitute-if-not
syn keyword lispFunc		defclass			min					subtypep
syn keyword lispFunc		defconstant			minusp					svref
syn keyword lispFunc		defgeneric			mismatch				sxhash
syn keyword lispFunc		define-compiler-macro		mod					symbol
syn keyword lispFunc		define-condition		most-negative-double-float		symbol-function
syn keyword lispFunc		define-method-combination	most-negative-fixnum			symbol-macrolet
syn keyword lispFunc		define-modify-macro		most-negative-long-float		symbol-name
syn keyword lispFunc		define-setf-expander		most-negative-short-float		symbolp
syn keyword lispFunc		define-setf-method		most-negative-single-float		symbol-package
syn keyword lispFunc		define-symbol-macro		most-positive-double-float		symbol-plist
syn keyword lispFunc		defmacro			most-positive-fixnum			symbol-value
syn keyword lispFunc		defmethod			most-positive-long-float		synonym-stream
syn keyword lispFunc		defpackage			most-positive-short-float		synonym-stream-symbol
syn keyword lispFunc		defparameter			most-positive-single-float		sys
syn keyword lispFunc		defsetf				muffle-warning				system
syn keyword lispFunc		defstruct			multiple-value-bind			t
syn keyword lispFunc		deftype				multiple-value-call			tagbody
syn keyword lispFunc		defun				multiple-value-list			tailp
syn keyword lispFunc		defvar				multiple-value-prog1			tan
syn keyword lispFunc		delete				multiple-value-seteq			tanh
syn keyword lispFunc		delete-duplicates		multiple-value-setq			tenth
syn keyword lispFunc		delete-file			multiple-values-limit			terpri
syn keyword lispFunc		delete-if			name-char				the
syn keyword lispFunc		delete-if-not			namestring				third
syn keyword lispFunc		delete-package			nbutlast				throw
syn keyword lispFunc		denominator			nconc					time
syn keyword lispFunc		deposit-field			next-method-p				trace
syn keyword lispFunc		describe			nil					translate-logical-pathname
syn keyword lispFunc		describe-object			nintersection				translate-pathname
syn keyword lispFunc		destructuring-bind		ninth					tree-equal
syn keyword lispFunc		digit-char			no-applicable-method			truename
syn keyword lispFunc		digit-char-p			no-next-method				truncase
syn keyword lispFunc		directory			not					truncate
syn keyword lispFunc		directory-namestring		notany					two-way-stream
syn keyword lispFunc		disassemble			notevery				two-way-stream-input-stream
syn keyword lispFunc		division-by-zero		notinline				two-way-stream-output-stream
syn keyword lispFunc		do				nreconc					type
syn keyword lispFunc		do*				nreverse				typecase
syn keyword lispFunc		do-all-symbols			nset-difference				type-error
syn keyword lispFunc		documentation			nset-exclusive-or			type-error-datum
syn keyword lispFunc		do-exeternal-symbols		nstring					type-error-expected-type
syn keyword lispFunc		do-external-symbols		nstring-capitalize			type-of
syn keyword lispFunc		dolist				nstring-downcase			typep
syn keyword lispFunc		do-symbols			nstring-upcase				unbound-slot
syn keyword lispFunc		dotimes				nsublis					unbound-slot-instance
syn keyword lispFunc		double-float			nsubst					unbound-variable
syn keyword lispFunc		double-float-epsilon		nsubst-if				undefined-function
syn keyword lispFunc		double-float-negative-epsilon	nsubst-if-not				unexport
syn keyword lispFunc		dpb				nsubstitute				unintern
syn keyword lispFunc		dribble				nsubstitute-if				union
syn keyword lispFunc		dynamic-extent			nsubstitute-if-not			unless
syn keyword lispFunc		ecase				nth					unread
syn keyword lispFunc		echo-stream			nthcdr					unread-char
syn keyword lispFunc		echo-stream-input-stream	nth-value				unsigned-byte
syn keyword lispFunc		echo-stream-output-stream	null					untrace
syn keyword lispFunc		ed				number					unuse-package
syn keyword lispFunc		eighth				numberp					unwind-protect
syn keyword lispFunc		elt				numerator				update-instance-for-different-class
syn keyword lispFunc		encode-universal-time		nunion					update-instance-for-redefined-class
syn keyword lispFunc		end-of-file			oddp					upgraded-array-element-type
syn keyword lispFunc		endp				open					upgraded-complex-part-type
syn keyword lispFunc		enough-namestring		open-stream-p				upper-case-p
syn keyword lispFunc		ensure-directories-exist	optimize				use-package
syn keyword lispFunc		ensure-generic-function		or					user
syn keyword lispFunc		eq				otherwise				user-homedir-pathname
syn keyword lispFunc		eql				output-stream-p				use-value
syn keyword lispFunc		equal				package					values
syn keyword lispFunc		equalp				package-error				values-list
syn keyword lispFunc		error				package-error-package			variable
syn keyword lispFunc		etypecase			package-name				vector
syn keyword lispFunc		eval				package-nicknames			vectorp
syn keyword lispFunc		evalhook			packagep				vector-pop
syn keyword lispFunc		eval-when			package-shadowing-symbols		vector-push
syn keyword lispFunc		evenp				package-used-by-list			vector-push-extend
syn keyword lispFunc		every				package-use-list			warn
syn keyword lispFunc		exp				pairlis					warning
syn keyword lispFunc		export				parse-error				when
syn keyword lispFunc		expt				parse-integer				wild-pathname-p
syn keyword lispFunc		extended-char			parse-namestring			with-accessors
syn keyword lispFunc		fboundp				pathname				with-compilation-unit
syn keyword lispFunc		fceiling			pathname-device				with-condition-restarts
syn keyword lispFunc		fdefinition			pathname-directory			with-hash-table-iterator
syn keyword lispFunc		ffloor				pathname-host				with-input-from-string
syn keyword lispFunc		fifth				pathname-match-p			with-open-file
syn keyword lispFunc		file-author			pathname-name				with-open-stream
syn keyword lispFunc		file-error			pathnamep				with-output-to-string
syn keyword lispFunc		file-error-pathname		pathname-type				with-package-iterator
syn keyword lispFunc		file-length			pathname-version			with-simple-restart
syn keyword lispFunc		file-namestring			peek-char				with-slots
syn keyword lispFunc		file-position			phase					with-standard-io-syntax
syn keyword lispFunc		file-stream			pi					write
syn keyword lispFunc		file-string-length		plusp					write-byte
syn keyword lispFunc		file-write-date			pop					write-char
syn keyword lispFunc		fill				position				write-line
syn keyword lispFunc		fill-pointer			position-if				write-sequence
syn keyword lispFunc		find				position-if-not				write-string
syn keyword lispFunc		find-all-symbols		pprint					write-to-string
syn keyword lispFunc		find-class			pprint-dispatch				yes-or-no-p
syn keyword lispFunc		find-if				pprint-exit-if-list-exhausted		y-or-n-p
syn keyword lispFunc		find-if-not			pprint-fill				zerop

syn match   lispFunc		"\<c[ad]\+r\>"
if exists("g:lispsyntax_clisp")
  " CLISP FFI:
  syn match lispFunc	"\<\(ffi:\)\?with-c-\(place\|var\)\>"
  syn match lispFunc	"\<\(ffi:\)\?with-foreign-\(object\|string\)\>"
  syn match lispFunc	"\<\(ffi:\)\?default-foreign-\(language\|library\)\>"
  syn match lispFunc	"\<\([us]_\?\)\?\(element\|deref\|cast\|slot\|validp\)\>"
  syn match lispFunc	"\<\(ffi:\)\?set-foreign-pointer\>"
  syn match lispFunc	"\<\(ffi:\)\?allocate-\(deep\|shallow\)\>"
  syn match lispFunc	"\<\(ffi:\)\?c-lines\>"
  syn match lispFunc	"\<\(ffi:\)\?foreign-\(value\|free\|variable\|function\|object\)\>"
  syn match lispFunc	"\<\(ffi:\)\?foreign-address\(-null\|unsigned\)\?\>"
  syn match lispFunc	"\<\(ffi:\)\?undigned-foreign-address\>"
  syn match lispFunc	"\<\(ffi:\)\?c-var-\(address\|object\)\>"
  syn match lispFunc	"\<\(ffi:\)\?typeof\>"
  syn match lispFunc	"\<\(ffi:\)\?\(bit\)\?sizeof\>"
" CLISP Macros, functions et al:
  syn match lispFunc	"\<\(ext:\)\?with-collect\>"
  syn match lispFunc	"\<\(ext:\)\?letf\*\?\>"
  syn match lispFunc	"\<\(ext:\)\?finalize\>\>"
  syn match lispFunc	"\<\(ext:\)\?memoized\>"
  syn match lispFunc	"\<\(ext:\)\?getenv\>"
  syn match lispFunc	"\<\(ext:\)\?convert-string-\(to\|fr